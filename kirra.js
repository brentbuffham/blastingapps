// Description: This file contains the main functions for the Kirra App
// Author: Brent Buffham
// Last Modified: "20250816.0140AWST"
const buildVersion = "20250816.0140AWST"; //Backwards Compatible Date Format AWST = Australian Western Standard Time
//-----------------------------------------
// Using SweetAlert Library Create a popup that gets input from the user.
function updatePopup() {
	console.log("function updatePopup()");
	Swal.fire({
		showCancelButton: false,
		confirmButtonText: "Ok",
		html: `
		<svg version="1.1" baseProfile="basic" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="70" height="70" viewBox="-40 0 200 200" stroke-width="3" stroke="white" fill="none" stroke-linecap="round" stroke-linejoin="round">
		<path
			d="M7.53,64.77c-0.36-1.36-0.38-3.99,0.08-5.34c-0.98-2.51-2.88-8.13-2.22-10.9c1.77-5.81-0.07-16.1-0.95-24.92C3.55,18.78,6.31,4.11,7.61,2.26c6.24-5.37,24.76,22.67,29.81,29.81c1.57-0.17,1.91,1.72,1.78,2.93c1.87,2.82,3.54,4.3,7.03,4.17c2.71,0.61,9.25,1.73,11.56,3.31c3.57-1.82,10.55,1.6,12.57-3.03c1.23-0.82,4.4-3.07,3.94-4.96c2.19-1.04,4.21-5.39,5.03-7.5c1.7-4.14,5.96-7.51,8.29-11.14c5.21-6.14,15.78-27.02,20.71-8.09c2.32,9.62,3.98,22.54,1.38,32.15c0.51,1.33,0.58,4.5,0.59,5.92c0.89,1.69,0.82,4.84,0.2,6.61c0.38,2.52-0.66,5.62-2.47,7.4c0.17,1.03,0.2,2.67-0.49,3.55c0,0,3.21,2.42,4.04,4.54c0.84,2.12-0.59,9.51-1.18,12.53c1.32,1.57,2.75,4.67,2.17,6.81c3.3,5.31-0.68,4.27,1.38,8.48c0.69,2.34-0.51,4.65,1.09,6.71c-0.28,1.05-1.39,3.81-1.58,4.93c0.84,2.71-1.41,6.85-2.96,8.97c0,0,0.39,3.85,0.39,3.85c-4.86,1.62-1.02,2.56-4.83,5.13c-3.52,19.49-28.37,34.55-46.94,37.28c-9.52,0.18-23.4-3.44-29-11.64c-3.47-1.2-9.42-2.81-11.05-6.51c-0.68-1.05-4.4-2.51-3.75-4.24c-1.39,0.33-2.04-1.83-2.47-2.76c-3.42,0.24-3.99-8.32-3.55-10.75c0,0-1.68-3.16-1.68-3.16c0.5-1.06,0.12-1.99-0.69-2.66c0.66-1.83,0.58-1.44-1.18-1.87c-0.19-1.23,0.33-2.6-0.69-3.45c0.13-1.01-0.33-2.69-0.8-3.55c-1.65-1.36-1.5-5.44-2.56-7.3c-3.32-1.31-2.49-3.65,0.2-5.23c0.49-1.42-0.47-3.32-1.38-4.34c2.56-1.71-0.74-3.32,1.48-6.41c0.99-2.71,2.11-0.41-0.3-3.85c0.28-2.86,2.84-3.43,3.06-6.9c0.46-1.74-0.61-4.26-1.78-5.52c3.46-0.9,1.88-1.16,1.28-3.65l2.81-3" />
		<path d="M60.64,124.58c1.69,0.63,4,0.19,5.21-1.41c-1.74,0.78-4.01,1.14-4.83-0.99c3.43-2.98-6.5-3.52,1.55,1.73" />
		<path d="M51.44,124.77c-1.56,0.79-4.74,0.05-5.89-2.37c1.6,1.38,3.9,2.71,4.71-0.18c-3.32-3.58,5.44-3.26,2.3,1.74" />
		<path d="M42.74,86.54c-3.68-8.21-9.86-10.1-12.32-6.32c-1.16,1.72-1.56,3.14-2.92,3.74" />
		<path d="M41.19,87.3c0,0-1.04,0.11-2.33,0.63c-1.29,0.52-5.01,0.78-6.4-0.06c-1.39-0.83-2.55-3.2-2.55-3.2" />
		<path d="M72.65,83.88c0,0,0.7-1.47,0.93-2.36c0.22-0.89,0.9-4.5,4.52-4.59c3.62-0.09,5.07,2.18,5.95,3.48s3.41,2.52,3.41,2.52" />
		<path d="M74.1,84.9c2.28,3.42,7.74,2.49,9.25-1.12" />
		<path
			d="M34.46,114.13c1.38,2.59,0.42,5.7,0.55,9.02s6.39,9.58,11.88,10.5c15.33-0.88,26.05,3.26,34.02-13.86c1.31-4.15,4.28-5.58,7.4-7.96c-0.51,2.55-4.26,8.65-5.62,10.91c-1.51,5.29-4.92,13.59-8.8,17.57c-1.11,7.93-2.1,17.62-11.76,19.38c-12.37,1.23-15.89-4.36-15.83-16.05c-2.76-2.08-5.87-7.81-6.95-11.02" />
		<path d="M68.11,149.19c-2.23,4.57-6.63,5.95-11.39,5.32c-3.31-0.23-5.85-2.22-6.95-5.32" />
		<path
			d="M40.3,41.79l0.25,2.02c0.1,0.81-0.53,1.53-1.35,1.53h-1.72l0.71,1.99c0.21,0.58,0.2,1.21-0.03,1.77l-0.25,0.63c-0.25,0.62-0.91,0.97-1.56,0.84c-1.28-0.27-3.16-0.65-3.01-0.5c0.14,0.14,0.77,1.41,1.25,2.38c0.33,0.67,0.27,1.47-0.16,2.09l0,0c-0.31,0.45-0.81,0.74-1.35,0.79L29.2,55.7l0,0c0.57,0.8,0.27,1.93-0.63,2.34l-1.37,0.62l0,0c1.07,0.44,1.13,1.92,0.11,2.46l-0.11,0.06l0,0c1.01,0.72,0.8,2.28-0.37,2.71l-0.08,0.03h0c0.76,0.63,0.57,1.85-0.35,2.21l-1.35,0.53h0c0.93,0.97,1.12,2.43,0.48,3.61l-0.24,0.44c-0.46,0.85-0.86,1.74-1.19,2.65l-1.34,3.7c-0.45,1.24-1.14,2.38-2.04,3.35l-3.23,3.49l-3.33,3.99" />
		<path
			d="M9.75,67.53l4.97-1.74c0.73-0.25,1.29-0.85,1.49-1.6l0.24-0.87c0.25-0.91,0.84-1.69,1.64-2.18l1.78-1.1c1.17-0.72,2.16-1.7,2.88-2.87l1.62-2.6c0.45-0.73,0.99-1.4,1.59-2.01l1.39-1.39c0.33-0.33,0.59-0.73,0.75-1.17l0.79-2.14c0.28-0.76,0.87-1.35,1.63-1.64l0.55-0.21c1.57-0.59,2.65-2.03,2.8-3.7l0.42-4.67" />
		<path
			d="M70.4,44.82l0.99,2.07c0.39,0.81,0.87,1.58,1.43,2.28c0.33,0.42,0.74,0.88,1.06,1.23c0.3,0.33,0.72,0.5,1.16,0.5c0.82-0.01,2.16,0.22,2.46,1.68l0,0l6.54,1.31c0.53,0.11,0.97,0.48,1.16,0.99v0c0.13,0.36,0.45,0.63,0.83,0.69l1.12,0.19c1.15,0.19,2.17,0.86,2.8,1.84l0.64,0.99c0.24,0.38,0.55,0.71,0.91,0.98l1.58,1.18c0.55,0.41,0.99,0.95,1.29,1.57l0.73,1.55c0.3,0.63,0.7,1.2,1.18,1.7c0.77,0.79,2.03,2.05,2.74,2.76c0.34,0.34,0.78,0.58,1.26,0.67c0.42,0.08,0.97,0.19,1.49,0.27c1.24,0.2,2.47-0.38,3.11-1.47l0.87-1.47" />
		<path d="M78.02,45.64c2.43,2.96,7.99,2.96,7.99,2.96s-2.66-2.88-2.07-5.7c0.59-2.81-2-2.29-3.4-3.77c-1.41-1.48,1.11-10.65,1.11-10.65s-5.55,7.4-5.87,9.54" />
		<path
			d="M96.96,28.48c0.83,1.43,1.78,2.22,1.48,5.25s-2.74,5.4-2.74,5.4s-1.04,1.18-1.63,2.66c-0.59,1.48-0.15,5.4-0.67,6.44c-0.52,1.04-1.18,1.41-2.29,1.41c-1.11,0-4.22,0-5.1-1.04c-0.89-1.04-2.07-4.59-2.07-5.7c0-1.11,1.63-1.85,1.63-1.85s-0.74-1.29-0.59-2.51c0.15-1.22,1.09-2.72,2.49-3.25c1.4-0.53,3.65-1.18,4.61-2.59s-0.81-2.74-0.67-4.22C91.56,27,94.44,25,94.44,25" />
		<path d="M14.88,39.54c0.15-0.56,0.71-0.9,1.28-0.76l2.7,0.64c0.54,0.13,1.08-0.18,1.26-0.7l0.76-2.27c0.03-0.09,0.05-0.17,0.05-0.26l0.29-4.23" />
		<path
			d="M18.24,26.66c0.73-0.95,2.05-1.23,3.09-0.64l2.92,1.63c0.29,0.16,0.56,0.35,0.82,0.55l2.55,2.05c1.65,1.32,2.43,3.45,2.02,5.53l-0.59,2.96c-0.05,0.27-0.12,0.52-0.22,0.78c-0.47,1.28-1.94,5.31-2.01,5.31c-0.03,0-0.44,0.92-0.87,1.92c-0.38,0.88-1.64,0.85-1.98-0.05l0,0c-0.34-0.93-2.13-0.98-2,0c0.73,5.26-1.19,4.42-1.44,3.98c-0.25-0.44-0.36-1.56-0.86-3.16c-0.33-1.08-2.04-1.75-2.22-0.64l0.14,0.86c0.5,2.45-1.01,1.49-1.74,0.15c0,0-0.61-4.26-2.02-3.44" />
		<path d="M48.95,81.34c0.27-8.42-0.2-14.05-10.13-14.1c4.07,2.81,4.72,2.2-0.96,2.55c3.59,2.44,5.86,3.03,0,3c0,0,4.88,3.48,4.88,3.48" />
		<path d="M66.51,81.81c-1.86-6.59-4.51-15.84,4.95-15.53c0,0-2.46,3.33-2.46,3.33c4.6-1.37,6.17-4.41,3.86,2.48c3.07-2.83,3.5-3.2,2.27,1.22c-0.8,1.5-3.99,2.59-3.99,2.59" />
		<path d="M56.2,113.69c-10.45-1.63-14.35,2.61-9.02,13.24c1.03,1.95,6.8,4.29,9.02,4.29c2.22,0,9.97-4.36,11.09-10.8c0.49-2.79-1.41-7.53-4.59-7.17c-3.18,0.36-5.19,0.59-5.19,0.59" />
		<path d="M46.88,133.66c0,0,1.11,3.25,1.11,3.25c1.59,4.52,4.14,12.99,10.28,12.28c5.26,0.91,7.22-1.96,8.58-6.51c0.93-2.57,3.04-8.51,3.57-11.14" />
		<path d="M14.63,91.57l-2,3.48c2.78-0.79,3.25-1.37,1.55,1.63c0,0,3.55-2,3.55-2s-4.07,10.36-3.55,9.84c0.52-0.52,3.25-3.92,3.25-3.92l-0.37,8.88l3.99-5.4c-0.06,2.42-6.63,14.46,0,7.47c0.1,1.2-2.39,6.04,0.52,5.84c0.44-0.15-0.37,6.21,0,5.84c5.11-8.5,2.1-0.16,7.91-3.43" />
		<path
			d="M92.23,66.42l2.81,6.88c-1.71,2.48,0.02,3.07,1.63,4.51c-2.6,4.51,2.76,3.87-1.48,7.84c1.93,3.51,6.42,7.84,10.21,9.25c-4.4,2.3-2.16,2.64,0,5.55c0,0-2.81,4.29-2.81,4.29c0.84,2.23,1.99,3.22-1.11,3.99c0,0,2.07,2,1.85,2s-6.21,0-6.21,0l1.33,3.25c-2.8,1.8-4.5,1.5-1.48,4.66c-2.16-0.37-4.47-2.5-1.48,1.16" />
		<path d="M42.74,90.17c0,0-1.63,3.66-2.51,4.96c-0.89,1.29-3.95,3.37-5.77,4.22c-1.82,0.84-3.6,1.58-4.96,2.29s-3.77,2.24-4.51,1.04c-0.74-1.21-1.48-9.69-0.74-11.1c0.74-1.41,1.92,4.62,4.14,4.84c0.59,0.08,0.81,0.82,1.52,0.85s1.74,0.07,1.74,0.07" />
		<path d="M74.92,91.57c0,0,1.8,4.66,3.18,6.73c1.38,2.07,3.25,4.04,4.29,4.81s3.06,1.7,4.07,1.7c1.01,0,0.91-1.58,1.63-2.15c0.72-0.57,2.22-2.74,2.22-3.77c0-1.04-1.23-2.01-0.89-3.03c0.35-1.02,1.85-1.87,0.89-2.62c-0.96-0.76-4.29,2.18-4.29,2.18" />
		<path d="M38.02,82.31c0,1.37-1.11,2.48-2.48,2.48c-1.37,0-2.48-1.11-2.48-2.48c0-1.37,1.11-2.48,2.48-2.48" />
		<path d="M77.98,78.29c1.37,0,2.48,1.11,2.48,2.48c0,1.37-1.11,2.48-2.48,2.48s-2.48-1.11-2.48-2.48" />
		<path d="M39.21,82.75c0,2.21-1.79,4.01-4.01,4.01c-2.21,0-4.01-1.79-4.01-4.01c0-2.21,1.79-4.01,4.01-4.01" />
		<path d="M78.23,77.22c2.21,0,4.01,1.79,4.01,4.01c0,2.21-1.79,4.01-4.01,4.01c-2.21,0-4.01-1.79-4.01-4.01" />
		<path d="M65.76,119.94c0,0-0.8-2.02-2.61-2.63c-1.81-0.61-4.99-0.91-6.88-0.92s-3.11,0.63-4.16,0c-1.05-0.63-1.66-1.39-1.66-1.39" />
		</svg>
			<br>
				    <label class="labelWhite18">Update - NEW FEATURES:                           </label>
					<hr>
				<div style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;">
					<label     class="labelWhite12c">⭐ ⭐ August 2025 ⭐ ⭐                                            </label>
					<br><label class="labelWhite12c">✅ Delaunay Triangulation with Constrainautor - Surfaces/shells </label>
					<br><label class="labelWhite12c">✅ Hillshade Lighting improvement - Better lighting and shadows </label>
					<br><label class="labelWhite12c">✅ Three gradient style improvemts - Linear, Radial, Barycentric </label>
					<br><label class="labelWhite12c">✅ Custom CSV importer improved and redesigned                  </label>
					<br><label class="labelWhite12c">✅ Holes or KAD selection options                               </label>
					<br><label class="labelWhite12c">---- Move tool moves holes no snap when "Holes" option true     </label>
					<br><label class="labelWhite12c">---- Move tool moves KAD with snapping when "KAD" option true   </label>
					<br><label class="labelWhite12c">✅ Curved Timing Arrows can be created for better visibilty     </label>
					<br><label class="labelWhite12c">✅ Blast stats on print page including delay count              </label>
					<br><label class="labelWhite12c">✅ QR code to App website on print page                         </label>
					<br><label class="labelWhite12c">✅ Timing contour time labels are shown - Only in App not print </label>
					<br><label class="labelWhite12c">✅ Contours are now processed in a separate thread/webworker    </label>
					<br><label class="labelWhite12c">✅ Connect Distance now Base 5 Log for added granularity        </label>
					<br><label class="labelWhite12c">✅ Play/Animate blast Time Speed slider is now Base 10 Log      </label>
					<br><label class="labelWhite12c">⭐ July 2025 ⭐                                                 </label>
					<br><label class="labelWhite12c">✅ IREDES Tested and confirmed working on Epiroc RCS 6.28.1     </label>
					<br><label class="labelWhite12c">---- 6.22.1 returns a checksum error on both HEX and DEC        </label>
					<br><label class="labelWhite12c">✅ UI Floating Dialog replacement to SWAL 2 Modal popups.       </label>
					<br><label class="labelWhite12c">✅ KAD Entity visibility improvement and Hole Visibility        </label>
					<br><label class="labelWhite12c">✅ Drawing tools on Floating Toolbar - details in the Left Nav  </label>
					<br><label class="labelWhite12c">✅ Ruler Improved to 3D-Snap Dip, DeltaZ, Plan, Total Length    </label>
					<br><label class="labelWhite12c">✅ Additional Hole properties on right click of selected holes  </label>
					<br><label class="labelWhite12c">✅ Z Interpolation Snap for Drawing - snap to segment           </label>
					<br><label class="labelWhite12c">✅ Backspace or Delete when drawing to remove the last point    </label>
					<br><label class="labelWhite12c">✅ Offset Line and Projection added to Floating Toolbar         </label>
					<br><label class="labelWhite12c">✅ Radiate Holes or KADs added to Floating Toolbar              </label>
					<br><label class="labelWhite12c">✅ DXF 3DFace and Hillshade Gradient added                      </label>
					<br><label class="labelWhite12c">✅ Selection and manipulation disabled on hidden entities       </label>
					<br><label class="labelWhite12c">✅ Children Nodes inherit group node visibility                 </label>
					<br><label class="labelWhite12c">✅ Export and Save only includes Visible holes all Entities     </label>
					<br><label class="labelWhite12c">✅ Row and Position for holes added assists renaming            </label>
					<br><label class="labelWhite12c">✅ Row detection for imported holes without row ids             </label>
					<br><label class="labelWhite12c">✅ Holes along Lines/Polylines uses more reliable selection     </label>
					<br><label class="labelWhite12c">✅ Implemented Show/Hide for Blasts, Blast holes, KAD Drawings  </label>
					<br><label class="labelWhite12c">✅ Clear Database correctly and reordered the Popups            </label>
					<br><label class="labelWhite12c">✅ Increased Colour Swatches in the jsColor picker              </label>
					<br><label class="labelWhite12c">⭐ May, June and July 2025 ⭐                                   </label>
					<br><label class="labelWhite12c">✅ Pattern bug fixes, duplicate hole search, polygon selection  </label>
					<br><label class="labelWhite12c">✅ Added a radiate warning dialog                               </label>
					<br><label class="labelWhite12c">✅ Move and Z Leveling for KAD Drawings in Edit Popup           </label>
					<br><label class="labelWhite12c">✅ Distance indicator between added to drawing tools            </label>
					<br><label class="labelWhite12c">✅ Improved user interaction for drawing tools                  </label>
					<br><label class="labelWhite12c">✅ Added support for OBJ and other surface formats              </label>
					<br><label class="labelWhite12c">✅ Critical bug fix to restore loading from local files         </label>
					<br><label class="labelWhite12c">✅ Proximity Duplicate hole check and resolve                   </label>
					<br><label class="labelWhite12c">✅ Tree View - Color Change                                     </label>
					<br><label class="labelWhite12c">✅ Tree View - Context Menu - Delete & Properties               </label>
					<br><label class="labelWhite12c">✅ Fixed State UI/UX issues                                     </label>
					<br><label class="labelWhite12c">✅ Delete All Images/Surfaces to cleanup DB                     </label>
					<br><label class="labelWhite12c">✅ Image Show/Hide/Remove/Transparency                          </label>
					<br><label class="labelWhite12c">✅ Drawing Optimised - Pixel Distance culling                   </label>
					<br><label class="labelWhite12c">✅ Improved Decimation of Surfaces                              </label>
					<br><label class="labelWhite12c">✅ Fixed the Collar and Grade multiple Surfaces Bug             </label>
					<br><label class="labelWhite12c">✅ Load multiple Surfaces and change colors                     </label>
					<br><label class="labelWhite12c">✅ Drawings to IndexDB for large files                          </label>
					<br><label class="labelWhite12c">✅ Load Multiple GeoTIFFs and convert from WGS                  </label>
					<hr>
					<br><label  class="labelWhite15">New & Existing Issues & Resolved                               </label>
					<br><label class="labelWhite12c">🐞 Voronoi Display Lag with large blasts      ❌ unresolved ❌  </label>
					<br><label class="labelWhite12c">🐞 Surface Display                            ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 DXF Lines Z level to 'next.pointZLocation' ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 KAD Lines Import auto closing              ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 EventListener collision hopefully resolved ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 Pattern AlphNumeric clipping improved.     ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 Allow for "_", "-", "@" in names in tree   ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 KAD TXT import, deleting sequential fix    ✅  resolved  ✅  </label>
					<br><label class="labelWhite12c">🐞 Volume for blasts not working in treeView  ❌ unresolved ❌  </label>
				</div>
				<br><br>
				<a href="https://www.buymeacoffee.com/BrentBuffham">
	          <img src="https://img.buymeacoffee.com/button-api/?text=Buy Brent a coffee&emoji=&slug=BrentBuffham&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff" alt="Buy me a coffee" />
	        </a>
	        <br>
	        <a href="mailto:blastingapps.xyz@gmail.com?subject=Bug%20Report%20or%20Feature%20request&body=
	          Application%20the%20issue%20or%20request%20is%20about:%0D%0A%0D%0A
	          Description%20of%20the%20bug%20or%20feature:%0D%0A%0D%0A
	          Steps%20to%20reproduce%20the%20bug%20or%20create%20the%20feature:%0D%0A%0D%0A
	          Expected%20result:%0D%0A%0D%0A
	          Actual%20result:%0D%0A%0D%0A
	        ">
	          <button class="button-bug">Report Bug / Request Feature</button>
	        </a>
	        <br>
	        <i><label class="labelWhite15">Version: Build ${buildVersion}</i></label>
		  `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		}
	}).then((result) => {
		if (result.isConfirmed) {
			checkAndPromptForStoredData();
		}
	});
}

// Separate function for Voronoi initialization
function initializeVoronoiControls() {
	const voronoiBoundarySwitch = document.getElementById("voronoiBoundarySwitch");
	if (voronoiBoundarySwitch) {
		voronoiBoundarySwitch.addEventListener("change", function () {
			useToeLocation = voronoiBoundarySwitch.checked;
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiMetricDropdown = document.getElementById("voronoiSelect");
	if (voronoiMetricDropdown) {
		voronoiMetricDropdown.addEventListener("change", function () {
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiLegendDropdown = document.getElementById("voronoiLegendSelect");
	if (voronoiLegendDropdown) {
		voronoiLegendDropdown.addEventListener("change", function () {
			isVoronoiLegendFixed = voronoiLegendDropdown.value === "fixed";
			drawData(allBlastHoles, selectedHole);
		});
	}
}

// Separate function for preferences initialization
function initializePreferences() {
	try {
		loadViewControlsSliderValues();
		fontSlider.value = 14; // force the font size.
		setupAutoSavePreferences();
		console.log("✅ Preferences loaded successfully");
		debugPreferences();
	} catch (error) {
		console.error("❌ Error loading preferences:", error);
	}
}
// Add this temporarily to debug
function debugPreferences() {
	console.log("Checking preference controls:");
	console.log("fontSlider:", document.getElementById("fontSlider"));
	console.log("snapToleranceSlider:", document.getElementById("snapToleranceSlider"));
	console.log("elevation:", document.getElementById("elevation"));

	// Test localStorage
	console.log("LocalStorage test:", localStorage.getItem("fontSize"));
}

// Call this in your consolidated DOMContentLoaded
//------------------------------------------
const canvas = document.getElementById("canvas");
const padding = 10; // add 10 pixels of padding

const uiVersionElement = document.getElementById("htmlUIVersion");
const htmlUIVersion = uiVersionElement ? uiVersionElement.value : "1"; // Default to "1" if not found

//get the menu bar --var from the css
const menubarSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--menubar-size"));
const canvasBorderWidth2X = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-border")) * 2;
const canvasContainerMargin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-container-margin"));

// Existing canvas setup logic that you want to make conditional
if (htmlUIVersion === "1") {
	// Get the screen size and calculate the dimensions based on the desired ratio
	const screenWidth = window.innerWidth;
	const screenHeight = window.innerHeight;
	const canvasWidth = Math.round(screenWidth);
	const canvasHeight = Math.round(screenHeight);

	const canvasAdjustWidth = 40; //was 40 for kirra.html and styles.css;
	const canvasAdjustHeight = 0.12; //was 0.12 for kirra.html and styles.css;
	// Set the dimensions of the canvas and its container
	canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
	canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
} else {
	//Do nothing
}

const timeChartObject = document.getElementById("timeChart");
let statusMessage = "";
const resizeRight = document.getElementById("resizeHandleRight");
let isResizingRight = false;
const resizeLeft = document.getElementById("resizeHandleLeft");
let isResizingLeft = false;

const ctx = canvas.getContext("2d");
let scale = 5; // adjust the scale to fit the allBlastHoles in the canvas
let fontSize = document.getElementById("fontSlider").value;
//TODO Eventually use this class for all holes.
class BlastHole {
	constructor(data = {}) {
		this.entityName = data.entityName || "";
		this.entityType = data.entityType || "hole";
		this.holeID = data.holeID || null;
		this.startXLocation = data.startXLocation || 0;
		this.startYLocation = data.startYLocation || 0;
		this.startZLocation = data.startZLocation || 0;
		this.endXLocation = data.endXLocation || 0;
		this.endYLocation = data.endYLocation || 0;
		this.endZLocation = data.endZLocation || 0;
		this.gradeXLocation = data.gradeXLocation || 0;
		this.gradeYLocation = data.gradeYLocation || 0;
		this.gradeZLocation = data.gradeZLocation || 0;
		this.subdrillAmount = data.subdrillAmount || 0;
		this.subdrillLength = data.subdrillLength || 0;
		this.benchHeight = data.benchHeight || 0;
		this.holeDiameter = data.holeDiameter || 115;
		this.holeType = data.holeType || "Undefined";
		this.fromHoleID = data.fromHoleID || "";
		this.timingDelayMilliseconds = data.timingDelayMilliseconds || 0;
		this.colorHexDecimal = data.colorHexDecimal || "red";
		this.holeLengthCalculated = data.holeLengthCalculated || 0;
		this.holeAngle = data.holeAngle || 0;
		this.holeBearing = data.holeBearing || 0;
		this.measuredLength = data.measuredLength || 0;
		this.measuredLengthTimeStamp = data.measuredLengthTimeStamp || "09/05/1975 00:00:00";
		this.measuredMass = data.measuredMass || 0;
		this.measuredMassTimeStamp = data.measuredMassTimeStamp || "09/05/1975 00:00:00";
		this.measuredComment = data.measuredComment || "None";
		this.measuredCommentTimeStamp = data.measuredCommentTimeStamp || "09/05/1975 00:00:00";
		this.rowID = data.rowID || null;
		this.posID = data.posID || null;
		this.visible = data.visible !== false;
		this.burden = data.burden || 1;
		this.spacing = data.spacing || 1;
		this.connectorCurve = data.connectorCurve || 0;
	}
}

let allBlastHoles = [];
let dxfEntities = [];
let countAllBlastHoles = allBlastHoles.length;
let sumMeters = 0;
let currentScale = scale; // declare a variable to store the current scale
let currentFontSize = fontSize; // declare a variable to store the current font size
let toeScale = document.getElementById("toeSlider").value;
let holeScale = document.getElementById("holeSlider").value;
let deltaX = 0;
let deltaY = 0;
let centroidX = 0;
let centroidY = 0;
let centroidZ = 0;
let firstPointInLine = null;
// Group visibility flags
let blastGroupVisible = true;
let drawingsGroupVisible = true;
let surfacesGroupVisible = true;
let imagesGroupVisible = true;
// Drawing sub-group visibility flags
let pointsGroupVisible = true;
let linesGroupVisible = true;
let polygonsGroupVisible = true;
let circlesGroupVisible = true;
let textsGroupVisible = true;
// Variable to store the "fromHole" ID during connector mode
let fromHoleStore = null;
let isAddingConnector = false;
let isAddingMultiConnector = false;
let isAddingHole = false;
let isAddingPattern = false;
let isDeletingHole = false;
let isMovingCanvas = false;
let isDragging = false;
let isModifyingKAD = false;
let entityName; // Define entityName outside the function to persist between calls
let createNewEntity = true; // Flag to create a new entity
// Variables to store the initial mouse position during canvas movement
let initialMouseX = 0;
let initialMouseY = 0;
// Add current mouse tracking for interactive previews
let currentMouseCanvasX = 0;
let currentMouseCanvasY = 0;
let currentMouseCanvasZ = document.getElementById("drawingElevation").value;
let currentMouseWorldX = 0;
let currentMouseWorldY = 0;
let currentMouseWorldZ = document.getElementById("drawingElevation").value;
// Surfaces
let allAvailableSurfaces = [];
let intervalAmount = document.getElementById("intervalSlider").value;
let firstMovementSize = document.getElementById("firstMovementSlider").value;
let connectAmount = document.getElementById("connectSlider").value;
let contourLevel = 0;
let contourUpdatePending = false;
let minX;
let minY;
let worldX = null;
let worldY = null;
let contourLines = [];
let contourLinesArray = [];
let directionArrows = [];
let epsilon = 1;
let holeTimes = {};
let deleteRenumberStart = document.getElementById("deleteRenumberStart").value;
let firstSelectedHole = null;
let secondSelectedHole = null;
let selectedHole = null;
let isBlastNameEditing = false;
let isHoleEditing = false;
let isSelectionPointerActive = false;
let polyPointsX = [];
let polyPointsY = [];
let isPolygonSelectionActive = false;
let useToeLocation = false;
let selectedVoronoiMetric = "powderFactor"; // default
// Add these variables near the top (around line 190)
let lastKADDrawPoint = null; // Store the last drawn point from any KAD tool
let isVoronoiLegendFixed = false;
let isBearingToolActive = false;

// Add this declaration around line 99 (after bearingToolSelectedHole declaration)
let bearingToolSelectedHole = null;
let moveToolSelectedHole = null; // Add this declaration
let bearingToolStartAngle = 0;
let bearingToolStartMouseAngle = 0;
let isDraggingBearing = false;
let rulerStartPoint = null;
let rulerEndPoint = null;
let rulerProtractorPoints = []; // For 3-point bearing measurement
let isRulerActive = false;
let isRulerProtractorActive = false;
let isLengthPopupEditing = false;
let isDisplayingContours = false;
let isDisplayingSlopeTriangles = false;
let isDisplayingReliefTriangles = false;
let isDisplayingDirectionArrows = false;
let isTypeEditing = false;
let fixToeLocation = false;
// Add these missing global variable declarations
let imageVisible = false;
let surfaceVisible = false;
//drawing tool booleans
let isDrawingPoint = false;
let isDrawingLine = false;
let isDrawingCircle = false;
let isDrawingPoly = false;
let isDrawingText = false;
//delete tool booleans
let isDeletingKAD = false;
//modify tool booleans
let isModifyingPoint = false;
//offset tool booleans
let isOffsetLinePoly = false;
//offset kad tool booleans
let isOffsetKAD = false;
//radii holes or kads tool booleans
let isRadiiHolesOrKADs = false;
//Record Measurements booleans
let isMeasureRecording = false;
// PolyLine select for use in tools
let selectedVertices = [];
let isSelectingPolyline = false;
//has selected multiple holes
let hasSelectedMultipleHoles = false;
let isMultiHoleSelectionEnabled = false; // Selection mode is false if single ONLY hole selection on each click and true when each click adds a hole to the selection.  It does not indicate that selection is active or inactive.
let isMoveToolActive = false;
let isMovingHole = false;
let holeToMove = null;

let maxEdgeLength = 15;
let clickedHole; // Declare clickedHole outside the event listener
let timingWindowHolesSelected = [];
let selectedMultipleHoles = [];
let selectedPoint = null; // Global selectedPoint declaration
let selectedMultiplePoints = [];
let selectedMultipleKADObjects = []; // Array to store multiple selected KAD objects
let isMultiKADSelectionEnabled = false; // Flag for multi-KAD selection mode
// Step 4) Move tool state for KAD vertices
let moveToolSelectedKAD = null;
let moveToolKADOriginalZ = 0;

let isPlaying = false; // To track whether the animation is playing
let animationInterval; // To store the interval ID for the animation
let playSpeed = 1; // Default play speed
//COLOURS
let noneColor = "rgba(0, 0, 0, 0)";
let darkModeEnabled = document.body.classList.contains("dark-mode");
let transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
let fillColor = darkModeEnabled ? "lightgrey" : "darkgrey";
let strokeColor = darkModeEnabled ? "white" : "black";
let textFillColor = darkModeEnabled ? "white" : "black";
let depthColor = darkModeEnabled ? "blue" : "cyan";
let angleDipColor = darkModeEnabled ? "darkcyan" : "orange";
// Add this global flag at the top of your file (near other globals like snapEnabled)
let isSelfSnapEnabled = false; // Tracks if 'S' is held down
///////////////////////////
//DEVELOPER MODE BUTTON
const developerModeCheckbox = document.getElementById("developerMode");
let developerModeEnabled = false;
developerModeCheckbox.addEventListener("change", function () {
	developerModeEnabled = developerModeCheckbox.checked;
	console.log("Developer mode enabled:", developerModeEnabled);
});
///////////////////////////

//Switches
const addConnectorButton = document.getElementById("addConnectorButton");
const addMultiConnectorButton = document.getElementById("addMultiConnectorButton");
const addPatternSwitch = document.getElementById("addPatternSwitch");
const addHoleSwitch = document.getElementById("addHoleSwitch");

const editLengthPopupSwitch = document.getElementById("editLengthPopupButton");
const editHoleTypePopupSwitch = document.getElementById("editHoleTypePopupButton");

const editBlastNameSwitch = document.getElementById("editBlastNameButton");
// const editDiameterSwitch = document.getElementById("editDiameterButton");
const deleteHoleSwitch = document.getElementById("deleteHoleSwitch");
const modifyKADSwitch = document.getElementById("modifyKADDraw");
const offsetKADButton = document.getElementById("offsetKADTool");
const radiiHolesOrKADsButton = document.getElementById("radiiHolesOrKADsTool");
const selectionModeButton = document.getElementById("selectionModeButton");
const editHolesToggle = document.getElementById("editHolesToggle"); //required to be true if holes are to be fine tuned

// Drawing Switch Event Listeners
const addPointDraw = document.getElementById("addPointDraw");
const addLineDraw = document.getElementById("addLineDraw");
const addCircleDraw = document.getElementById("addCircleDraw");
const addPolyDraw = document.getElementById("addPolyDraw");
const addTextDraw = document.getElementById("addTextDraw");
// Delete Drawing Switch Event Listeners
const deleteKADDraw = document.getElementById("deleteKADDraw");
//Record Measurements Switch Event Listeners
const measuredLengthSwitch = document.getElementById("measuredLengthSwitch");
const measuredMassSwitch = document.getElementById("measuredMassSwitch");
const measuredCommentSwitch = document.getElementById("measuredCommentSwitch");

//switch Options - Do not include in switches array
const renumberStartListener = document.getElementById("deleteRenumberStart");
const renumberHoles = document.getElementById("renumberHoles");
let isRenumberingHoles = false;

const switches = [addConnectorButton, addMultiConnectorButton, addPatternSwitch, addHoleSwitch, editLengthPopupSwitch, editBlastNameSwitch, deleteHoleSwitch, modifyKADSwitch, editHoleTypePopupSwitch, addPointDraw, addLineDraw, addCircleDraw, addPolyDraw, addTextDraw, deleteKADDraw, measuredLengthSwitch, measuredMassSwitch, measuredCommentSwitch, selectionModeButton, editHolesToggle];

const booleans = [
	isAddingConnector,
	isAddingMultiConnector,
	isAddingHole,
	isAddingPattern,
	isDeletingHole,
	isMovingCanvas,
	isDragging,
	isBlastNameEditing,
	isHoleEditing,
	isLengthPopupEditing,
	isDisplayingContours,
	isDisplayingSlopeTriangles,
	isDisplayingReliefTriangles,
	isDisplayingDirectionArrows,
	isTypeEditing,
	isDrawingPoint,
	isDrawingLine,
	isDrawingCircle,
	isDrawingPoly,
	isDrawingText,
	isDeletingKAD,
	isPlaying,
	isModifyingPoint,
	isOffsetLinePoly,
	isMeasureRecording,
	isMultiHoleSelectionEnabled //check this
];

// Boolean set to False
function setAllBoolsToFalse() {
	isAddingConnector = false;
	isAddingMultiConnector = false;
	isAddingHole = false;
	isAddingPattern = false;
	isDeletingHole = false;
	isMovingCanvas = false;
	isDragging = false;
	isBlastNameEditing = false;
	isHoleEditing = false;
	isLengthPopupEditing = false;
	isDisplayingContours = false;
	isDisplayingSlopeTriangles = false;
	isDisplayingReliefTriangles = false;
	isDisplayingDirectionArrows = false;
	isTypeEditing = false;
	isDrawingPoint = false;
	isDrawingLine = false;
	isDrawingCircle = false;
	isDrawingPoly = false;
	isDrawingText = false;
	isDeletingKAD = false;
	isPlaying = false;
	isModifyingPoint = false;
	isOffsetLinePoly = false;
	isMeasureRecording = false;
	isMultiHoleSelectionEnabled = false;
	isMoveToolActive = false;
	isMovingHole = false;

	// CRITICAL FIX: Remove move tool event listeners when deactivating
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Also clear move tool state variables
	moveToolSelectedHole = null;
	isDraggingHole = false;

	// Remove bearing tool listeners too
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);

	// Clear bearing tool state
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
}

// Function 2: Reset all switches and toggles
function resetSwitchesTogglesOptionalDisplay(resetDisplayOptions) {
	// Reset all switches
	const allSwitches = [
		"addConnectorSwitch",
		"addMultiConnectorSwitch",
		"addHoleSwitch",
		"addPatternSwitch",
		"deleteHoleSwitch",
		"renumberHoles",
		"editBlastNameSwitch",
		"editHoleSwitch",
		"editLengthPopupSwitch",
		"editTypePopupSwitch",
		"selectionModeSwitch",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"addPointDraw",
		"addLineDraw",
		"addCircleDraw",
		"addPolyDraw",
		"addTextDraw",
		"deleteKADDraw",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"selectionModeButton",
		"editHolesToggle"
	];

	allSwitches.forEach((switchId) => {
		const switchElement = document.getElementById(switchId);
		if (switchElement) {
			switchElement.checked = false;
		}
	});

	if (resetDisplayOptions) {
		// Reset display options toggles
		allToggles.forEach((toggle) => {
			if (toggle) {
				toggle.checked = false;
			}
		});
	}
}

// Function 3: Reset all selected stores and state variables
function resetAllSelectedStores() {
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	firstSelectedHole = null;
	secondSelectedHole = null;
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	clickedHole = null;
	timingWindowHolesSelected = [];

	// Reset pattern tool variables
	selectedPolygon = null;
	selectedPolyline = null;
	patternStartPoint = null;
	patternEndPoint = null;
	patternReferencePoint = null;

	// Reset line tool variables
	lineStartPoint = null;
	lineEndPoint = null;

	// Reset poly line tool variables
	polylineStartPoint = null;
	polylineEndPoint = null;

	// Reset any other state variables
	blastNameValue = "";
	currentEntityName = "";

	console.log("🧹 All selected stores and pattern states reset");
}

/**
 * Removes event listeners for various tools, with option to exclude specific tools
 *
 * @param {string|string[]} [excluding=[]] - Tool(s) to exclude from listener removal
 * Possible exclusion values include:
 * - "moveToTool", "bearingTool", "tieConnectTool", "tieConnectMultiTool", "lineDrawing", "polygonDrawing", "pointDrawing", "textDrawing", "circleDrawing", "rulerTool", "rulerProtractorTool", "selectPointerTool", "selectByPolygonTool", "addingHoleSwitch", "addingPatternSwitch", "patternInPolygonTool", "holesAlongLineTool", "holesAlongPolyLineTool", "measuredLengthClick", "measuredMassClick", "measuredCommentClick", "editBlastNameClick", "editLengthWithPopupClick", "editHoleTypeClick", "defaultListeners"
 */
function removeEventListenersExcluding(excluding = []) {
	console.log("Removing event listeners excluding: ", excluding);
	// Convert single string to array for consistency
	if (typeof excluding === "string") {
		excluding = [excluding];
	}

	// Remove move tool listeners
	if (!excluding.includes("moveToTool")) {
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		document.removeEventListener("mousemove", handleMoveToolMouseMove);
		document.removeEventListener("touchmove", handleMoveToolMouseMove);
		moveToolSelectedHole = null;
		isDraggingHole = false;
	}

	// Remove bearing tool listeners
	if (!excluding.includes("bearingTool")) {
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		document.removeEventListener("mousemove", handleBearingToolMouseMove);
		document.removeEventListener("touchmove", handleBearingToolMouseMove);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}

	// Remove connector tool listeners
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Remove drawing tool listeners
	if (!excluding.includes("lineDrawing")) {
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		isDrawingLine = false;
		createNewEntity = true;
	}

	// Remove polygon drawing listeners
	if (!excluding.includes("polygonDrawing")) {
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		isDrawingPoly = false;
		createNewEntity = true;
	}

	// Remove point drawing listeners
	if (!excluding.includes("pointDrawing")) {
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		isDrawingPoint = false;
		createNewEntity = true;
	}

	// Remove text drawing listeners
	if (!excluding.includes("textDrawing")) {
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		isDrawingText = false;
		createNewEntity = true;
	}

	// Remove circle drawing listeners
	if (!excluding.includes("circleDrawing")) {
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		isDrawingCircle = false;
		createNewEntity = true;
	}

	// Remove ruler tool listeners
	if (!excluding.includes("rulerTool")) {
		canvas.removeEventListener("click", handleRulerClick);
		canvas.removeEventListener("touchstart", handleRulerClick);
		rulerStartPoint = null;
		rulerEndPoint = null;
	}

	// Remove ruler protractor listeners
	if (!excluding.includes("rulerProtractorTool")) {
		canvas.removeEventListener("click", handleRulerProtractorClick);
		canvas.removeEventListener("touchstart", handleRulerProtractorClick);
		rulerProtractorPoints = [];
	}

	// Remove selection tool listeners
	if (!excluding.includes("selectPointerTool")) {
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		isSelectionPointerActive = false;
	}

	// Remove polygon selection listeners
	if (!excluding.includes("selectByPolygonTool")) {
		// Remove polygon listeners
		canvas.removeEventListener("click", selectInsidePolygon);
		canvas.removeEventListener("dblclick", completePolygonSelection);
		canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
		canvas.removeEventListener("mousemove", handlePolygonMouseMove);
		document.removeEventListener("mousemove", handlePolygonMouseMove);
		isPolygonSelectionActive = false;
	}

	// Remove the adding Pattern Listener
	if (!excluding.includes("addingPatternSwitch")) {
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		isAddingPattern = false;
	}

	// Remove the adding hole listener
	if (!excluding.includes("addingHoleSwitch")) {
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		isAddingHole = false;
	}

	// Remove pattern in polygon listeners
	if (!excluding.includes("patternInPolygonTool")) {
		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);
		isPatternInPolygonActive = false;
	}

	// Remove holes along line listeners
	if (!excluding.includes("holesAlongLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);
		isHolesAlongLineActive = false;
	}

	// Remove holes along poly line listeners
	if (!excluding.includes("holesAlongPolyLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);
		isHolesAlongPolyLineActive = false;
	}

	// Remove measured length click listeners
	if (!excluding.includes("measuredLengthClick")) {
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
	}

	// Remove measured mass click listeners
	if (!excluding.includes("measuredMassClick")) {
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
	}

	// Remove measured comment click listeners
	if (!excluding.includes("measuredCommentClick")) {
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
	}

	// Remove edit blast name click listeners
	if (!excluding.includes("editBlastNameClick")) {
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
	}

	// Remove edit length with popup click listeners
	if (!excluding.includes("editLengthWithPopupClick")) {
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
	}

	// Remove edit hole type click listeners
	if (!excluding.includes("editHoleTypeClick")) {
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
	}

	// ⭐ IMPORTANT: NEVER remove handleMouseMove or handleTouchMove here
	// These are intended to be persistent for basic mouse/touch tracking.
	if (!excluding.includes("defaultListeners")) {
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Do NOT remove handleMouseMove or handleTouchMove here!
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// document.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		// document.removeEventListener("touchmove", handleTouchMove);
	}

	// Reset tool-specific state variables that aren't excluded
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		isAddingConnector = false;
		isAddingMultiConnector = false;
		firstSelectedHole = null;
		secondSelectedHole = null;
	}

	// Reset drawing states if not excluded
	if (!excluding.includes("lineDrawing") && !excluding.includes("polygonDrawing") && !excluding.includes("pointDrawing") && !excluding.includes("textDrawing") && !excluding.includes("circleDrawing")) {
		createNewEntity = true;
	}
}

// Add a centralized function to clear all selection state
function clearAllSelectionState() {
	// Clear individual selections
	selectedPoint = null;
	selectedHole = null;
	selectedKADObject = null;
	selectedKADPolygon = null;
	selectedMultipleKADObjects = []; // Add this line
	// Clear multiple selections (with null safety)
	if (selectedMultipleHoles) {
		selectedMultipleHoles.length = 0; // Clear array but keep referenceß
	} else {
		selectedMultipleHoles = [];
	}

	// Clear selected multiple KAD objects
	if (selectedMultipleKADObjects) {
		selectedMultipleKADObjects.length = 0;
	} else {
		selectedMultipleKADObjects = [];
	}

	// Clear timing window holes selected
	if (timingWindowHolesSelected) {
		timingWindowHolesSelected.length = 0;
	} else {
		timingWindowHolesSelected = [];
	}

	console.log("🧹 All selection state cleared");
}

// Update resetFloatingToolbarButtons to only clear floating toolbar related booleans
function resetFloatingToolbarButtons(excluding) {
	// Clear only floating toolbar tool states
	isSelectionPointerActive = false;
	isPolygonSelectionActive = false;
	isHolesAlongPolyLineActive = false;
	isHolesAlongLineActive = false;
	isMoveToolActive = false;
	isBearingToolActive = false;
	isRulerActive = false;
	isRulerProtractorActive = false;

	// ALSO clear connector tool states when switching floating toolbar tools
	isAddingConnector = false;
	isAddingMultiConnector = false;

	// CRITICAL: Remove move and bearing tool listeners when switching away
	if (excluding !== "moveToTool") {
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		moveToolSelectedHole = null;
		isDraggingHole = false;
	}

	if (excluding !== "bearingTool") {
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}
	// Set all tool checkboxes to false except the excluded one
	selectPointerTool.checked = excluding === "selectPointerTool";
	selectByPolygonTool.checked = excluding === "selectByPolygonTool";
	moveToTool.checked = excluding === "moveToTool";
	tieConnectTool.checked = excluding === "tieConnectTool";
	tieConnectMultiTool.checked = excluding === "tieConnectMultiTool";
	addKADPointsTool.checked = excluding === "addKADPointsTool";
	addKADLineTool.checked = excluding === "addKADLineTool";
	addKADPolygonTool.checked = excluding === "addKADPolygonTool";
	addKADCircleTool.checked = excluding === "addKADCircleTool";
	addKADTextTool.checked = excluding === "addKADTextTool";
	triangulateTool.checked = excluding === "triangulateTool";
	bearingTool.checked = excluding === "bearingTool";
	rulerTool.checked = excluding === "rulerTool";
	rulerProtractorTool.checked = excluding === "rulerProtractorTool";
	patternInPolygonTool.checked = excluding === "patternInPolygonTool";
	holesAlongLineTool.checked = excluding === "holesAlongLineTool";
	holesAlongPolyLineTool.checked = excluding === "holesAlongPolyLineTool";

	// ALSO uncheck connector buttons when switching floating toolbar tools
	if (excluding !== "tieConnectTool") {
		addConnectorButton.checked = false;
	}
	if (excluding !== "tieConnectMultiTool") {
		addMultiConnectorButton.checked = false;
	}

	// Set only the excluded tool's active state to true
	isSelectionPointerActive = excluding === "selectPointerTool";
	isPolygonSelectionActive = excluding === "selectByPolygonTool";
	isPatternInPolygonActive = excluding === "patternInPolygonTool";
	isHolesAlongLineActive = excluding === "holesAlongLineTool";
	isHolesAlongPolyLineActive = excluding === "holesAlongPolyLineTool";
	isMoveToolActive = excluding === "moveToTool";
	isBearingToolActive = excluding === "bearingTool";
	isRulerActive = excluding === "rulerTool";
	isRulerProtractorActive = excluding === "rulerProtractorTool";
	isAddKADPointsToolActive = excluding === "addKADPointsTool";
	isAddKADLineToolActive = excluding === "addKADLineTool";
	isAddKADPolygonToolActive = excluding === "addKADPolygonTool";
	isAddKADCircleToolActive = excluding === "addKADCircleTool";
	isAddKADTextToolActive = excluding === "addKADTextTool";
	isTriangulateToolActive = excluding === "triangulateTool";

	// Reset floating toolbar tool-specific state variables
	rulerStartPoint = null;
	rulerEndPoint = null;
	rulerProtractorPoints = [];
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
	isDraggingHole = false;

	// Reset selection-related variables for floating toolbar tools
	firstSelectedHole = null;
	secondSelectedHole = null;

	// Remove connector event listeners when switching away from connector tools
	if (excluding !== "tieConnectTool" && excluding !== "tieConnectMultiTool") {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Force redraw to update button states
	drawData(allBlastHoles, selectedHole);
}

// Master function to reset everything
function resetAppToDefaults() {
	setAllBoolsToFalse();
	resetSwitchesTogglesOptionalDisplay(true);
	resetAllSelectedStores();
	resetFloatingToolbarButtons("none");
	console.log("App reset to defaults: booleans, switches, toggles, and stores cleared");
}

// Buttons
document.getElementById("deletePointButton").addEventListener("click", deleteSelectedPoint);
document.getElementById("deleteObjectButton").addEventListener("click", deleteSelectedObject);
document.getElementById("deleteAllButton").addEventListener("click", deleteSelectedAll);
document.getElementById("fileInput").addEventListener("change", handleFileUpload);
document.getElementById("fileInputDXF").addEventListener("change", handleDXFUpload);
document.getElementById("fileInputMeasured").addEventListener("change", handleMeasuredUpload);
document.getElementById("fileInputSurface").addEventListener("change", handleSurfaceUpload);
document.getElementById("fileInputGeotiff").addEventListener("change", handleGeotiffUpload);
document.getElementById("helpButton").addEventListener("click", openHelp);
document.getElementById("zoomInButton").addEventListener("click", zoomIn);
document.getElementById("zoomOutButton").addEventListener("click", zoomOut);
// document.getElementById("resetZoomButton").addEventListener("click", resetZoom);
document.getElementById("deleteHoleButton").addEventListener("click", deleteSelectedHoles);
document.getElementById("deletePatternButton").addEventListener("click", deleteSelectedPattern);
document.getElementById("deleteAllPatternsButton").addEventListener("click", deleteSelectedAllPatterns);

const displayHoleId = document.getElementById("display1"); //holeID
const displayHoleLength = document.getElementById("display2"); //holeLength
const displayHoleDiameter = document.getElementById("display2A"); //holeDiameter
const displayHoleAngle = document.getElementById("display3"); //holeAngle
const displayHoleDip = document.getElementById("display4"); //holeDip
const displayHoleBearing = document.getElementById("display5"); //holeBearing
const displayHoleSubdrill = document.getElementById("display5B"); //subdrill
const displayConnectors = document.getElementById("display5A"); //connectors
const displayDelays = document.getElementById("display6"); //delays
const displayTimes = document.getElementById("display6A"); //times only
const displayContours = document.getElementById("display8"); //contours
const displaySlope = document.getElementById("display8A"); //slope
const displayRelief = document.getElementById("display8B"); //relief
const displayFirstMovements = document.getElementById("display8C"); //direction
const displayXLocation = document.getElementById("display9"); //xlocation
const displayYLocation = document.getElementById("display10"); //ylocation
const displayElevation = document.getElementById("display11"); //zlocation
const displayHoleType = document.getElementById("display12"); //holeType
const displayMLength = document.getElementById("display13"); //holeLength
const displayMMass = document.getElementById("display14"); //holeMass
const displayMComment = document.getElementById("display15"); //holeComment
const displayVoronoiCells = document.getElementById("display16"); //voronoi
const displayRowAndPosId = document.getElementById("rowAndPosDisplay"); //Developer mode Row and Position Display

// after const option16 = …
const allToggles = [displayHoleId, displayHoleLength, displayHoleDiameter, displayHoleAngle, displayHoleDip, displayHoleBearing, displayHoleSubdrill, displayConnectors, displayDelays, displayTimes, displayContours, displaySlope, displayRelief, displayFirstMovements, displayXLocation, displayYLocation, displayElevation, displayHoleType, displayMLength, displayMMass, displayMComment, displayVoronoiCells, displayRowAndPosId];

allToggles.forEach((opt) => {
	if (opt)
		opt.addEventListener("change", () => {
			// assuming drawData is your main render function
			drawData(allBlastHoles, selectedHole);
		});
});

const holeCountRadio = document.getElementById("holeCountRadio");
const measuredMassRadio = document.getElementById("measuredMassRadio");

//create holeCountRadio and measureMassRadio Listener
document.getElementById("measuredMassRadio")?.addEventListener("change", timeChart);
document.getElementById("holeCountRadio")?.addEventListener("change", timeChart);

// Add event listeners for mouse down, move, and up events
canvas.addEventListener("mousedown", handleMouseDown);
// canvas.addEventListener("mousemove", handleMouseMove);
canvas.addEventListener("mouseup", handleMouseUp);
// Add event listeners for touch start, move, and end events
canvas.addEventListener("touchstart", handleTouchStart, {
	passive: false
});
// canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd, {
	passive: false
});

// Event listener for the language dropdown
document.getElementById("languageSelect").addEventListener("change", function () {
	const selectedLanguage = this.value;
	updateTranslations(selectedLanguage);
});

// Function to update translations
function updateTranslations(language) {
	// Use the inline translations object
	const langTranslations = translations[language]?.translation;

	if (langTranslations) {
		// Update the text content of elements in the DOM with null checks
		const titleElement = document.querySelector("title");
		if (titleElement) titleElement.textContent = langTranslations.title;

		const helpButton = document.querySelector("#helpButton");
		if (helpButton) helpButton.title = langTranslations.help_button;

		const zoomInButton = document.querySelector("#zoomInButton");
		if (zoomInButton) zoomInButton.title = langTranslations.zoom_in_button;

		const zoomOutButton = document.querySelector("#zoomOutButton");
		if (zoomOutButton) zoomOutButton.title = langTranslations.zoom_out_button;

		const buttonGoBack = document.querySelector("#buttonGoBack");
		if (buttonGoBack) buttonGoBack.title = langTranslations.go_back_button;

		const languageSelect = document.querySelector("#languageSelect");
		if (languageSelect) languageSelect.title = langTranslations.select_language;

		const darkModeToggle = document.querySelector("#dark-mode-toggle");
		if (darkModeToggle) darkModeToggle.placeholder = langTranslations.dark_mode;

		// Display option tooltips
		const display1Label = document.querySelector("label[for='display1']");
		if (display1Label) display1Label.title = langTranslations.display_hole_id_title;

		const display2Label = document.querySelector("label[for='display2']");
		if (display2Label) display2Label.title = langTranslations.display_hole_length_title;

		const display2ALabel = document.querySelector("label[for='display2A']");
		if (display2ALabel) display2ALabel.title = langTranslations.display_hole_diameter_title;

		const display3Label = document.querySelector("label[for='display3']");
		if (display3Label) display3Label.title = langTranslations.display_angle_title;

		const display4Label = document.querySelector("label[for='display4']");
		if (display4Label) display4Label.title = langTranslations.display_dip_title;

		const display5Label = document.querySelector("label[for='display5']");
		if (display5Label) display5Label.title = langTranslations.display_bearing_title;

		const display5BLabel = document.querySelector("label[for='display5B']");
		if (display5BLabel) display5BLabel.title = langTranslations.display_subdrill_title;

		const display5ALabel = document.querySelector("label[for='display5A']");
		if (display5ALabel) display5ALabel.title = langTranslations.display_ties_title;

		const display6Label = document.querySelector("label[for='display6']");
		if (display6Label) display6Label.title = langTranslations.display_connectors_title;

		const display6ALabel = document.querySelector("label[for='display6A']");
		if (display6ALabel) display6ALabel.title = langTranslations.display_times_only_title;

		const display8Label = document.querySelector("label[for='display8']");
		if (display8Label) display8Label.title = langTranslations.display_contours_title;

		const display8ALabel = document.querySelector("label[for='display8A']");
		if (display8ALabel) display8ALabel.title = langTranslations.display_slope_title;

		const display8BLabel = document.querySelector("label[for='display8B']");
		if (display8BLabel) display8BLabel.title = langTranslations.display_relief_title;

		const display8CLabel = document.querySelector("label[for='display8C']");
		if (display8CLabel) display8CLabel.title = langTranslations.display_direction_title;

		const display9Label = document.querySelector("label[for='display9']");
		if (display9Label) display9Label.title = langTranslations.display_xlocation_title;

		const display10Label = document.querySelector("label[for='display10']");
		if (display10Label) display10Label.title = langTranslations.display_ylocation_title;

		const display11Label = document.querySelector("label[for='display11']");
		if (display11Label) display11Label.title = langTranslations.display_zlocation_title;

		const display12Label = document.querySelector("label[for='display12']");
		if (display12Label) display12Label.title = langTranslations.display_hole_type_title;

		const display13Label = document.querySelector("label[for='display13']");
		if (display13Label) display13Label.title = langTranslations.display_measure_title;

		const display14Label = document.querySelector("label[for='display14']");
		if (display14Label) display14Label.title = langTranslations.display_mass_title;

		const display15Label = document.querySelector("label[for='display15']");
		if (display15Label) display15Label.title = langTranslations.display_comment_title;

		const display16Label = document.querySelector("label[for='display16']");
		if (display16Label) display16Label.title = langTranslations.display_voronoi_title;

		// Left panel sections
		const openOrImportAcc = document.querySelector("#openOrImportAcc span");
		if (openOrImportAcc) openOrImportAcc.textContent = langTranslations.open_import;

		// File input icon button titles
		const fileInputBtns = document.querySelectorAll(".file-import-btn");
		fileInputBtns.forEach((btn) => {
			const target = btn.getAttribute("data-target");
			if (target === "fileInput") btn.title = langTranslations.file_holes_kad_title;
			if (target === "fileInputCustomCSV") btn.title = langTranslations.custom_csv_title;
			if (target === "fileInputDXF") btn.title = langTranslations.file_dxf_title;
			if (target === "fileInputMeasured") btn.title = langTranslations.measured_values_title;
			if (target === "fileInputSurface") btn.title = langTranslations.file_surface_title;
			if (target === "fileInputGeotiff") btn.title = langTranslations.file_geotiff_title;
		});

		// File input alt text
		const fileInputImgs = document.querySelectorAll(".file-import-btn img");
		fileInputImgs.forEach((img) => {
			const alt = img.getAttribute("alt");
			if (alt === "Load Holes & KAD") img.alt = langTranslations.load_holes_kad_alt;
			if (alt === "Load CSV") img.alt = langTranslations.load_csv_alt;
			if (alt === "Load DXF") img.alt = langTranslations.load_dxf_alt;
			if (alt === "Load Measured Values") img.alt = langTranslations.load_measured_alt;
			if (alt === "Load Surface") img.alt = langTranslations.load_surface_alt;
			if (alt === "Load Geotiff") img.alt = langTranslations.load_geotiff_alt;
		});

		const plusorminusHolesAcc = document.querySelector("#plusorminusHolesAcc span");
		if (plusorminusHolesAcc) plusorminusHolesAcc.textContent = langTranslations.plus_minus_holes;

		const addPatternLabel = document.querySelector("#addPatternLabel");
		if (addPatternLabel) addPatternLabel.textContent = langTranslations.add_pattern_label;

		const addHoleLabel = document.querySelector("#addHoleLabel");
		if (addHoleLabel) addHoleLabel.textContent = langTranslations.add_hole_label;

		const deleteHoleLabel = document.querySelector("#deleteHoleLabel");
		if (deleteHoleLabel) deleteHoleLabel.textContent = langTranslations.delete_label;

		const deleteHoleButton = document.querySelector("#deleteHoleButton");
		if (deleteHoleButton) deleteHoleButton.textContent = langTranslations.delete_hole_button;

		const deletePatternButton = document.querySelector("#deletePatternButton");
		if (deletePatternButton) deletePatternButton.textContent = langTranslations.delete_pattern_button;

		const deleteAllPatternsButton = document.querySelector("#deleteAllPatternsButton");
		if (deleteAllPatternsButton) deleteAllPatternsButton.textContent = langTranslations.delete_all_patterns_button;

		const renumberHolesLabel = document.querySelector("label[for='renumberHoles']");
		if (renumberHolesLabel) renumberHolesLabel.textContent = langTranslations.renumber_holes_label;

		const deleteRenumberStartLabel = document.querySelector("label[for='deleteRenumberStart']");
		if (deleteRenumberStartLabel) deleteRenumberStartLabel.textContent = langTranslations.delete_renumber_start_label;

		const editHolesAcc = document.querySelector("#editHolesAcc span");
		if (editHolesAcc) editHolesAcc.textContent = langTranslations.edit_holes;

		const editBlastNameLabel = document.querySelector("#editBlastNameLabel");
		if (editBlastNameLabel) editBlastNameLabel.textContent = langTranslations.edit_blast_name_label;

		const editLengthPopupLabel = document.querySelector("#editLengthPopupLabel");
		if (editLengthPopupLabel) editLengthPopupLabel.textContent = langTranslations.edit_length_popup_label;

		const editHoleTypePopupLabel = document.querySelector("#editHoleTypePopupLabel");
		if (editHoleTypePopupLabel) editHoleTypePopupLabel.textContent = langTranslations.edit_hole_type_popup_label;

		const selectionModeLabels = document.querySelectorAll("#selectionModeLabel");
		selectionModeLabels.forEach((label, index) => {
			if (index === 0) label.textContent = langTranslations.allow_holes_edited;
			if (index === 1) label.textContent = langTranslations.selection_mode_label;
		});

		const holeEastingLabel = document.querySelector("#holeEastingLabel");
		if (holeEastingLabel) holeEastingLabel.textContent = langTranslations.hole_easting_label;

		const holeNorthingLabel = document.querySelector("#holeNorthingLabel");
		if (holeNorthingLabel) holeNorthingLabel.textContent = langTranslations.hole_northing_label;

		const holeElevationLabel = document.querySelector("#holeElevationLabel");
		if (holeElevationLabel) holeElevationLabel.textContent = langTranslations.hole_elevation_label;

		const holeDiameterLabel = document.querySelector("#holeDiameterLabel");
		if (holeDiameterLabel) holeDiameterLabel.textContent = langTranslations.hole_diameter_label;

		const holeLengthLabel = document.querySelector("#holeLengthLabel");
		if (holeLengthLabel) holeLengthLabel.textContent = langTranslations.hole_length_label;

		const holeAngleLabel = document.querySelector("#holeAngleLabel");
		if (holeAngleLabel) holeAngleLabel.textContent = langTranslations.hole_angle_label;

		const holeBearingLabel = document.querySelector("#holeBearingLabel");
		if (holeBearingLabel) holeBearingLabel.textContent = langTranslations.hole_bearing_label;

		const holeSubdrillLabel = document.querySelector("#holeSubdrillLabel");
		if (holeSubdrillLabel) holeSubdrillLabel.textContent = langTranslations.hole_subdrill_label;

		const recordActualsAcc = document.querySelector("#recordActualsAcc span");
		if (recordActualsAcc) recordActualsAcc.textContent = langTranslations.record_actuals;

		const recordLengthPopupLabel = document.querySelector("#recordLengthPopupLabel");
		if (recordLengthPopupLabel) recordLengthPopupLabel.textContent = langTranslations.record_length_popup_label;

		const editMassPopupLabel = document.querySelector("#editMassPopupLabel");
		if (editMassPopupLabel) editMassPopupLabel.textContent = langTranslations.record_mass_popup_label;

		const recordCommentPopupLabel = document.querySelector("#recordCommentPopupLabel");
		if (recordCommentPopupLabel) recordCommentPopupLabel.textContent = langTranslations.record_comment_popup_label;

		const viewControlsAcc = document.querySelector("#viewControlsAcc span");
		if (viewControlsAcc) viewControlsAcc.textContent = langTranslations.view_controls;

		const fontLabel = document.querySelector("#fontLabel");
		if (fontLabel) fontLabel.textContent = langTranslations.font_size_label;

		const connLabel = document.querySelector("#connLabel");
		if (connLabel) connLabel.textContent = langTranslations.tie_size_label;

		const toeLabel = document.querySelector("#toeLabel");
		if (toeLabel) toeLabel.textContent = langTranslations.toe_size_label;

		const holeLabel = document.querySelector("#holeLabel");
		if (holeLabel) holeLabel.textContent = langTranslations.hole_adjust_label;

		const intervalLabel = document.querySelector("#intervalLabel");
		if (intervalLabel) intervalLabel.textContent = langTranslations.interval_label;

		const firstMovementLabel = document.querySelector("#firstMovementLabel");
		if (firstMovementLabel) firstMovementLabel.textContent = langTranslations.first_movement_label;

		const snapToleranceLabel = document.querySelector("#snapToleranceLabel");
		if (snapToleranceLabel) snapToleranceLabel.textContent = langTranslations.snap_tolerance_label;

		const outputfilesAcc = document.querySelector("#outputfilesAcc span");
		if (outputfilesAcc) outputfilesAcc.textContent = langTranslations.output_files;

		const label_saveHoles = document.querySelector("#label_saveHoles");
		if (label_saveHoles) label_saveHoles.textContent = langTranslations.save_holes_label;

		const saveHoles = document.querySelector("#saveHoles");
		if (saveHoles) saveHoles.textContent = langTranslations.save_holes_button;

		const label_saveKAD = document.querySelector("#label_saveKAD");
		if (label_saveKAD) label_saveKAD.textContent = langTranslations.save_kad_label;

		const saveKAD = document.querySelector("#saveKAD");
		if (saveKAD) saveKAD.textContent = langTranslations.save_kad_button;

		const label_saveAll = document.querySelector("#label_saveAll");
		if (label_saveAll) label_saveAll.textContent = langTranslations.save_all_label;

		const saveAll = document.querySelector("#saveAll");
		if (saveAll) saveAll.textContent = langTranslations.save_all_button;

		const label_saveMeasures = document.querySelector("#label_saveMeasures");
		if (label_saveMeasures) label_saveMeasures.textContent = langTranslations.save_measures_label;

		const saveMeasures = document.querySelector("#saveMeasures");
		if (saveMeasures) saveMeasures.textContent = langTranslations.save_measures_button;

		const label_exportHolesDXF = document.querySelector("#label_exportHolesDXF");
		if (label_exportHolesDXF) label_exportHolesDXF.textContent = langTranslations.export_holes_dxf_label;

		const exportHolesDXF = document.querySelector("#exportHolesDXF");
		if (exportHolesDXF) exportHolesDXF.textContent = langTranslations.export_holes_dxf_button;

		const label_exportDrawingDXF = document.querySelector("#label_exportDrawingDXF");
		if (label_exportDrawingDXF) label_exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_label;

		const exportDrawingDXF = document.querySelector("#exportDrawingDXF");
		if (exportDrawingDXF) exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_button;

		const label_saveIREDES = document.querySelector("#label_saveIREDES");
		if (label_saveIREDES) label_saveIREDES.textContent = langTranslations.export_epiroc_label;

		const saveIREDES = document.querySelector("#saveIREDES");
		if (saveIREDES) saveIREDES.textContent = langTranslations.export_epiroc_button;

		const label_saveAQM = document.querySelector("#label_saveAQM");
		if (label_saveAQM) label_saveAQM.textContent = langTranslations.export_minestar_label;

		const saveAQM = document.querySelector("#saveAQM");
		if (saveAQM) saveAQM.textContent = langTranslations.export_minestar_button;

		const aboutAcc = document.querySelector("#aboutAcc span");
		if (aboutAcc) aboutAcc.textContent = langTranslations.about_title;

		const developerModeLabel = document.querySelector("label[for='developerMode']");
		if (developerModeLabel) developerModeLabel.textContent = langTranslations.developer_mode;

		const connectorsAcc = document.querySelector("#connectorsAcc span");
		if (connectorsAcc) connectorsAcc.textContent = langTranslations.connectors;

		const singleTie = document.querySelector("#singleTie");
		if (singleTie) singleTie.textContent = langTranslations.single_tie_label;

		const multiTie = document.querySelector("#multiTie");
		if (multiTie) multiTie.textContent = langTranslations.multi_tie_label;

		const delayLabel = document.querySelector("#delayLabel");
		if (delayLabel) delayLabel.textContent = langTranslations.delay_label;

		const connectorColor = document.querySelector("#connectorColor");
		if (connectorColor) connectorColor.textContent = langTranslations.color_label;

		const connectLabel = document.querySelector("#connectLabel");
		if (connectLabel) connectLabel.textContent = langTranslations.connect_distance_label;

		const animateAcc = document.querySelector("#animateAcc span");
		if (animateAcc) animateAcc.textContent = langTranslations.animate_firing;

		const play = document.querySelector("#play");
		if (play) play.textContent = langTranslations.play_button;

		const stop = document.querySelector("#stop");
		if (stop) stop.textContent = langTranslations.stop_button;

		const timeWindowAcc = document.querySelector("#timeWindowAcc span");
		if (timeWindowAcc) timeWindowAcc.textContent = langTranslations.time_window;

		const timeRangeLabel = document.querySelector("#timeRangeLabel");
		if (timeRangeLabel) timeRangeLabel.textContent = langTranslations.time_range_label;

		const timeOffsetLabel = document.querySelector("#timeOffsetLabel");
		if (timeOffsetLabel) timeOffsetLabel.textContent = langTranslations.time_offset_label;

		const holeCountLabel = document.querySelector("#holeCountLabel");
		if (holeCountLabel) holeCountLabel.textContent = langTranslations.hole_count_label;

		const measuredMassLabel = document.querySelector("#measuredMassLabel");
		if (measuredMassLabel) measuredMassLabel.textContent = langTranslations.measured_mass_label;

		const drawingTools = document.querySelector("#drawingTools span");
		if (drawingTools) drawingTools.textContent = langTranslations.drawing_tools;

		const elevationName = document.querySelector("#elevationName");
		if (elevationName) elevationName.textContent = langTranslations.elevation_label;

		const colorLabel = document.querySelector("#colorLabel");
		if (colorLabel) colorLabel.textContent = langTranslations.drawing_color_label;

		const lineWidthLabel = document.querySelector("#lineWidthLabel");
		if (lineWidthLabel) lineWidthLabel.textContent = langTranslations.line_width_label;

		const pointDraw = document.querySelector("#pointDraw");
		if (pointDraw) pointDraw.textContent = langTranslations.point_draw_label;

		const lineDraw = document.querySelector("#lineDraw");
		if (lineDraw) lineDraw.textContent = langTranslations.line_draw_label;

		const polyDraw = document.querySelector("#polyDraw");
		if (polyDraw) polyDraw.textContent = langTranslations.poly_draw_label;

		const circleDraw = document.querySelector("#circleDraw");
		if (circleDraw) circleDraw.textContent = langTranslations.circle_draw_label;

		const drawingRadiusLabel = document.querySelector("#drawingRadiusLabel");
		if (drawingRadiusLabel) drawingRadiusLabel.textContent = langTranslations.drawing_radius_label;

		const textDraw = document.querySelector("#textDraw");
		if (textDraw) textDraw.textContent = langTranslations.text_draw_label;

		const textLabel = document.querySelector("#textLabel");
		if (textLabel) textLabel.textContent = langTranslations.text_label;

		const commonMath1 = document.querySelector("#commonMath1");
		if (commonMath1) commonMath1.textContent = langTranslations.common_math_label;

		const commonMath2 = document.querySelector("#commonMath2");
		if (commonMath2) commonMath2.innerHTML = langTranslations.common_math_examples;

		const createRadiiFromBlastHoles = document.querySelector("#createRadiiFromBlastHoles");
		if (createRadiiFromBlastHoles) createRadiiFromBlastHoles.textContent = langTranslations.create_radii_button;

		const radiiStepsLabel = document.querySelector("#radiiStepsLabel");
		if (radiiStepsLabel) radiiStepsLabel.textContent = langTranslations.radii_steps_label;

		const drawingPolygonRadiusLabel = document.querySelector("#drawingPolygonRadiusLabel");
		if (drawingPolygonRadiusLabel) drawingPolygonRadiusLabel.textContent = langTranslations.drawing_polygon_radius_label;

		const drawingRemovalAcc = document.querySelector("#drawingRemovalAcc span");
		if (drawingRemovalAcc) drawingRemovalAcc.textContent = langTranslations.drawing_removal;

		const pointDeleteLabel = document.querySelector("#pointDeleteLabel");
		if (pointDeleteLabel) pointDeleteLabel.textContent = langTranslations.drawing_delete_label;

		const deletePointButton = document.querySelector("#deletePointButton");
		if (deletePointButton) deletePointButton.textContent = langTranslations.delete_point_button;

		const deleteObjectButton = document.querySelector("#deleteObjectButton");
		if (deleteObjectButton) deleteObjectButton.textContent = langTranslations.delete_object_button;

		const deleteAllButton = document.querySelector("#deleteAllButton");
		if (deleteAllButton) deleteAllButton.textContent = langTranslations.delete_all_button;

		const voronoiOptionsAcc = document.querySelector("#voronoiOptionsAcc span");
		if (voronoiOptionsAcc) voronoiOptionsAcc.textContent = langTranslations.voronoi_options;

		const voronoiLabel = document.querySelector("#voronoiLabel");
		if (voronoiLabel) voronoiLabel.textContent = langTranslations.voronoi_display_label;

		const voronoiLegendLabel = document.querySelector("#voronoiLegendLabel");
		if (voronoiLegendLabel) voronoiLegendLabel.textContent = langTranslations.voronoi_legend_label;

		const voronoiBoundaryLabel = document.querySelector("#voronoiBoundaryLabel");
		if (voronoiBoundaryLabel) voronoiBoundaryLabel.textContent = langTranslations.voronoi_boundary_label;

		// Update select options
		const voronoiSelect = document.querySelector("#voronoiSelect");
		if (voronoiSelect) {
			const options = voronoiSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "powderFactor":
						option.textContent = langTranslations.powder_factor;
						break;
					case "mass":
						option.textContent = langTranslations.mass;
						break;
					case "volume":
						option.textContent = langTranslations.volume;
						break;
					case "area":
						option.textContent = langTranslations.area;
						break;
					case "measuredLength":
						option.textContent = langTranslations.measured_length;
						break;
					case "designedLength":
						option.textContent = langTranslations.designed_length;
						break;
					case "holeFiringTime":
						option.textContent = langTranslations.hole_firing_time;
						break;
					case "heelanVibration":
						option.textContent = langTranslations.heelan_vibration;
						break;
					case "unknown":
						option.textContent = langTranslations.unknown;
						break;
				}
			});
		}

		// Update legend select options
		const voronoiLegendSelect = document.querySelector("#voronoiLegendSelect");
		if (voronoiLegendSelect) {
			const options = voronoiLegendSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "minmax":
						option.textContent = langTranslations.min_max;
						break;
					case "fixed":
						option.textContent = langTranslations.fixed;
						break;
				}
			});
		}

		const buymeaCoffeeLabel = document.querySelector("#buymeacoffeelabel");
		if (buymeaCoffeeLabel) buymeaCoffeeLabel.textContent = langTranslations.buy_coffee_alt;

		const bugButton = document.querySelector("#bugButton");
		if (bugButton) bugButton.textContent = langTranslations.report_bug_button;

		// Floating toolbar
		const dragLabel = document.querySelector("#dragLabel");
		if (dragLabel) dragLabel.textContent = langTranslations.drag_label;

		const selectLabel = document.querySelector("#selectLabel");
		if (selectLabel) selectLabel.textContent = langTranslations.select_label;

		const selectPointerLabel = document.querySelector("label[for='selectPointer']");
		if (selectPointerLabel) selectPointerLabel.title = langTranslations.select_pointer;

		const selectByPolygonLabel = document.querySelector("label[for='selectByPolygon']");
		if (selectByPolygonLabel) selectByPolygonLabel.title = langTranslations.select_by_polygon;

		const createLabel = document.querySelector("#createLabel");
		if (createLabel) createLabel.textContent = langTranslations.create_label;

		const patternInPolygonLabel = document.querySelector("label[for='patternInPolygonTool']");
		if (patternInPolygonLabel) patternInPolygonLabel.title = langTranslations.pattern_in_polygon;

		const holesAlongLineLabel = document.querySelector("label[for='holesAlongLineTool']");
		if (holesAlongLineLabel) holesAlongLineLabel.title = langTranslations.holes_along_line;

		const holesAlongPolyLineLabel = document.querySelector("label[for='holesAlongPolyLineTool']");
		if (holesAlongPolyLineLabel) holesAlongPolyLineLabel.title = langTranslations.holes_along_polyline;

		// Triangulation tool translations
		const triangulateLabel = document.querySelector("#triangulateLabel");
		if (triangulateLabel) triangulateLabel.textContent = langTranslations.triangulate_label;

		const triangulateTool = document.querySelector("label[for='triangulateTool']");
		if (triangulateTool) triangulateTool.title = langTranslations.triangulate_tooltip;

		// drawing tool translations
		const drawLabel = document.querySelector("#addKADLabel");
		if (drawLabel) drawLabel.textContent = langTranslations.draw_label;

		const addKADPointsTool = document.querySelector("label[for='addKADPointsTool']");
		if (addKADPointsTool) addKADPointsTool.title = langTranslations.add_kad_points_tooltip;

		const addKADLineTool = document.querySelector("label[for='addKADLineTool']");
		if (addKADLineTool) addKADLineTool.title = langTranslations.add_kad_line_tooltip;

		const addKADPolygonTool = document.querySelector("label[for='addKADPolygonTool']");
		if (addKADPolygonTool) addKADPolygonTool.title = langTranslations.add_kad_polygon_tooltip;

		const addKADCircleTool = document.querySelector("label[for='addKADCircleTool']");
		if (addKADCircleTool) addKADCircleTool.title = langTranslations.add_kad_circle_tooltip;

		const addKADTextTool = document.querySelector("label[for='addKADTextTool']");
		if (addKADTextTool) addKADTextTool.title = langTranslations.add_kad_text_tooltip;

		// Modify Section
		const modifyLabel = document.querySelector("#modifyLabel");
		if (modifyLabel) modifyLabel.textContent = langTranslations.modify_label;

		const moveToLabel = document.querySelector("label[for='moveToTool']");
		if (moveToLabel) moveToLabel.title = langTranslations.move_to;

		const bearingToolLabel = document.querySelector("label[for='bearingTool']");
		if (bearingToolLabel) bearingToolLabel.title = langTranslations.hole_bearing;

		const assignSurfaceLabel = document.querySelector("label[for='assignSurfaceTool']");
		if (assignSurfaceLabel) assignSurfaceLabel.title = langTranslations.assign_surface;

		const assignGradeLabel = document.querySelector("label[for='assignGradeTool']");
		if (assignGradeLabel) assignGradeLabel.title = langTranslations.assign_grade;

		const offsetKADTool = document.querySelector("label[for='offsetKADTool']");
		if (offsetKADTool) offsetKADTool.title = langTranslations.offset_kad_tooltip;

		const radiiHolesOrKADTool = document.querySelector("label[for='radiiHolesOrKADTool']");
		if (radiiHolesOrKADTool) radiiHolesOrKADTool.title = langTranslations.radii_holes_or_kad_tooltip;

		// Connectors Section
		const connectLabelFloating = document.querySelector("#toolbarPanel #connectLabel");
		if (connectLabelFloating) connectLabelFloating.textContent = langTranslations.connect_label;

		const tieConnectLabel = document.querySelector("label[for='tieConnectTool']");
		if (tieConnectLabel) tieConnectLabel.title = langTranslations.tie_connect;

		const tieConnectMultiLabel = document.querySelector("label[for='tieConnectMultiTool']");
		if (tieConnectMultiLabel) tieConnectMultiLabel.title = langTranslations.tie_connect_multi;

		const floatingConnectorColor = document.querySelector("#floatingConnectorColor");
		if (floatingConnectorColor) floatingConnectorColor.title = langTranslations.connector_color;

		// Measure Section
		const measureLabel = document.querySelector("#measureLabel");
		if (measureLabel) measureLabel.textContent = langTranslations.measure_label;

		const rulerLabel = document.querySelector("label[for='rulerTool']");
		if (rulerLabel) rulerLabel.title = langTranslations.ruler;

		const rulerProtractorLabel = document.querySelector("label[for='rulerProtractorTool']");
		if (rulerProtractorLabel) rulerProtractorLabel.title = langTranslations.ruler_protractor;

		const viewLabel = document.querySelector("#viewLabel");
		if (viewLabel) viewLabel.textContent = langTranslations.view_label;

		const resetViewLabel = document.querySelector("label[for='resetViewTool']");
		if (resetViewLabel) resetViewLabel.title = langTranslations.reset_view;
	} else {
		console.error("Translations for language ", language, " not found.");
	}
}

function getDarkModeSettings() {
	// Add safety checks for all elements
	const darkModeToggle = document.getElementById("darkModeToggle");
	const body = document.body;
	const sidenavLeft = document.getElementById("sidenavLeft");
	const canvas = document.getElementById("canvas");

	// Check if all required elements exist
	if (!darkModeToggle || !body || !sidenavLeft || !canvas) {
		console.warn("⚠️ Dark mode elements not ready yet, skipping...");
		return;
	}

	darkModeEnabled = localStorage.getItem("darkMode") === "true";

	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}
	// Update color variables based on dark mode
	updateColorsForDarkMode();
}

document.getElementById("buttonGoBack").addEventListener("click", function () {
	// Step 1) Create detailed message content
	const message = "You might lose unsaved data." + "<br><br>Make sure to save any important work before leaving." + '<br><br><div class="labelWhite15" style="text-align: left;">' + "<strong>Consider saving your work first:</strong>" + '<ul style="margin: 20px 0; padding-left: 20px;">' + "<li>Save holes to CSV file</li>" + "<li>Save drawing to KAD file</li>" + "<li>Export your current work</li>" + "</ul></div>";

	// Step 2) Show confirmation dialog
	showConfirmationDialog(
		"Leave Kirra 2D?",
		message,
		"Leave",
		"Stay",
		() => {
			// Step 3) Handle leave confirmation
			window.location.href = "index.html";
		},
		() => {
			// Step 4) Handle stay (cancel) - nothing needed
			console.log("User chose to stay in Kirra 2D");
		}
	);
});

// Tie Connect Tool event listener
const tieConnectTool = document.getElementById("tieConnectTool");
tieConnectTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		// Activate the right side nav "tie in one by one" switch
		addConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

// Tie Connect Multi Tool event listener
const tieConnectMultiTool = document.getElementById("tieConnectMultiTool");
tieConnectMultiTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addMultiConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addMultiConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

const addKADPointsTool = document.getElementById("addKADPointsTool");
addKADPointsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPointsTool");
		addPointDraw.checked = true;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPointDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPointDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADLineTool = document.getElementById("addKADLineTool");
addKADLineTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADLineTool");
		addPointDraw.checked = false;
		addLineDraw.checked = true;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addLineDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addLineDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADPolygonTool = document.getElementById("addKADPolygonTool");
addKADPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPolygonTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = true;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPolyDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPolyDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADCircleTool = document.getElementById("addKADCircleTool");
addKADCircleTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADCircleTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = true;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addCircleDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addCircleDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADTextTool = document.getElementById("addKADTextTool");
addKADTextTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADTextTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = true;
		// Trigger the change event to activate the functionality
		addTextDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addTextDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

//Selection Mode
selectionModeButton.addEventListener("change", function () {
	if (this.checked) {
		//set all the other switches to false
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== editHolesToggle) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning on: " + switchElement.id);
			}
		});
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		selectionModeButton.checked = true;
		isMultiHoleSelectionEnabled = true;

		if (selectedHole && !selectedMultipleHoles.includes(selectedHole)) {
			selectedMultipleHoles.push(selectedHole);
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		console.log("selectionModeButton.addEventListener checked");
	} else {
		console.log("selectionModeButton.addEventListener unchecked");
		isMultiHoleSelectionEnabled = false;
		selectionModeButton.checked = false;
		selectedMultipleHoles = [];
		switches.forEach((switchElement) => {
			if (switchElement) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning off: " + switchElement.id);
			}
		});

		drawData(allBlastHoles, selectedHole);
	}
});

function setMultipleSelectionModeToFalse() {
	// resetFloatingToolbarButtons("none");
	isMultiHoleSelectionEnabled = false;
	selectedMultipleHoles = [];
	timingWindowHolesSelected = [];
	console.log("selectionModeSettings set to false");
}

//Resizing the Navbar on the right
resizeRight.addEventListener("mousedown", function () {
	isResizingRight = true;

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", handleMouseUp);
});
//Resizing the Navbar on the left
resizeLeft.addEventListener("mousedown", function () {
	isResizingLeft = true;

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", handleMouseUp);
});
renumberHoles.addEventListener("click", function () {
	isRenumberingHoles = this.checked;
});
renumberStartListener.addEventListener("change", function () {
	//Allow Alpha numeric values
	deleteRenumberStart = this.value;
});

measuredLengthSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		// Remove all listeners except move tool
		isMeasureRecording = true;
		measuredLengthSwitch.checked = true;
		displayHoleId.checked = true;
		displayMLength.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredLengthClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredLengthClick);
		canvas.addEventListener("touchstart", handleMeasuredLengthClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
		measuredMassSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredMassSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredMassSwitch.checked = true;
		displayHoleId.checked = true;
		displayMMass.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredMassClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredMassClick);
		canvas.addEventListener("touchstart", handleMeasuredMassClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
		measuredLengthSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredCommentSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredCommentSwitch.checked = true;
		displayHoleId.checked = true; // Set display mode to hole Id
		displayMComment.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredCommentClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredCommentClick);
		canvas.addEventListener("touchstart", handleMeasuredCommentClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
		measuredMassSwitch.checked = false;
		measuredLengthSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

addPointDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPointsTool");
		isDrawingPoint = true;
		addPointDraw.checked = true;
		createNewEntity = true; // ← ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["pointDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		//Add event listeners
		canvas.addEventListener("click", handleKADPointClick);
		canvas.addEventListener("touchstart", handleKADPointClick);
	} else {
		isDrawingPoint = false;
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		createNewEntity = true;
		drawData(allBlastHoles, selectedHole);
	}
});
addLineDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADLineTool");
		isDrawingLine = true;
		addLineDraw.checked = true;
		createNewEntity = true; // ← ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["lineDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADLineClick);
		canvas.addEventListener("touchstart", handleKADLineClick);
	} else {
		isDrawingLine = false;
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		createNewEntity = true;
		drawData(allBlastHoles, selectedHole);
	}
});
addPolyDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPolygonTool");
		isDrawingPoly = true;
		addPolyDraw.checked = true;
		createNewEntity = true; // ← ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["polygonDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADPolyClick);
		canvas.addEventListener("touchstart", handleKADPolyClick);
	} else {
		isDrawingPoly = false;
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		createNewEntity = true;
		drawData(allBlastHoles, selectedHole);
	}
});
addCircleDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADCircleTool");
		isDrawingCircle = true;
		addCircleDraw.checked = true;
		createNewEntity = true; // ← ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["circleDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADCircleClick);
		canvas.addEventListener("touchstart", handleKADCircleClick);
	} else {
		isDrawingCircle = false;
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		createNewEntity = true;
		drawData(allBlastHoles, selectedHole);
	}
});
addTextDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADTextTool");
		//If font is less than 20pt set the Font size slider to 20pt and and update
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		isDrawingText = true;
		addTextDraw.checked = true;
		createNewEntity = true; // ← ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["textDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADTextClick);
		canvas.addEventListener("touchstart", handleKADTextClick);
	} else {
		isDrawingText = false;
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		createNewEntity = true;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteKADDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("selectPointer", "selectByPolyhon");
		isDeletingKAD = true;
		deleteKADDraw.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", getClickedPoint);
		canvas.addEventListener("touchstart", getClickedPoint);
	} else {
		isDeletingKAD = false;
		canvas.removeEventListener("click", getClickedPoint);
		canvas.removeEventListener("touchstart", getClickedPoint);
		drawData(allBlastHoles, selectedHole);
	}
});

addConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectTool");
		isAddingConnector = true;
		addConnectorButton.checked = true;
		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;

		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
addMultiConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		isAddingMultiConnector = true;

		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;
		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConectMultiTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingMultiConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		deleteHoleSwitch.checked = true;
		isDeletingHole = true;
		isAddingPattern = false;
		isAddingHole = false;
		displayHoleId.checked = true;
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		canvas.addEventListener("click", handleHoleDeletingClick);
		canvas.addEventListener("touchstart", handleHoleDeletingClick);
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isDeletingHole = false;
		canvas.removeEventListener("click", handleHoleDeletingClick);
		canvas.removeEventListener("touchstart", handleHoleDeletingClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}

		addHoleSwitch.checked = true;
		isAddingHole = true;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handleHoleAddingClick);
		canvas.addEventListener("touchstart", handleHoleAddingClick);
		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingHole = false;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY); //TODO: check if this is correct
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addPatternSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		addPatternSwitch.checked = true;
		isAddingPattern = true;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handlePatternAddingClick);
		canvas.addEventListener("touchstart", handlePatternAddingClick);
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingPattern = false;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		// ensure the Adding Pattern and adding a hole are off and their switches are off
		addHoleSwitch.checked = false;
		addPatternSwitch.checked = false;
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});

editHoleTypePopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		//setSelectionModeToFalse();
		isTypeEditing = true;
		editHoleTypePopupSwitch.checked = true;
		displayHoleId.checked = true;
		displayHoleType.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editHoleTypeSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleTypeEditClick);
		canvas.addEventListener("touchstart", handleHoleTypeEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isTypeEditing = false;
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editBlastNameSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		editBlastNameSwitch.checked = true;
		isBlastNameEditing = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editBlastNameSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleBlastNameClick);
		canvas.addEventListener("touchstart", handleBlastNameClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isBlastNameEditing = false;
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editLengthPopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//setSelectionModeToFalse();
		editLengthPopupSwitch.checked = true;
		isLengthPopupEditing = true;
		displayHoleLength.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editLengthPopupSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleLengthEditClick);
		canvas.addEventListener("touchstart", handleHoleLengthEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isLengthPopupEditing = false;
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

/// Event listener for the edit hole Easting switch
// All previous slider enabling toggles/switches will be grouped into one switch
// isHoleEditing will be used to determine if the hole is being edited
editHolesToggle.addEventListener("change", function () {
	if (this.checked) {
		console.log("editHolesToggle checked");
		isHoleEditing = true;
		//use the set all switches to false function
		booleans.forEach((bool) => {
			if (bool !== isHoleEditing || bool != isMultiHoleSelectionEnabled) bool = false;
		});
		//turn all the switches off
		switches.forEach((switchElement) => {
			if (switchElement && (switchElement !== selectionModeButton || switchElement !== editHolesToggle)) switchElement.checked = false;
		});
		//turn on the edit holes toggle
		editHolesToggle.checked = true;
		//attach all the event listeners to the canvas
		canvas.addEventListener("click", handleHoleEditingSelection);
		canvas.addEventListener("touchstart", handleHoleEditingSelection);

		//draw the canvas
		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("editHolesToggle unchecked");
		isHoleEditing = false;
		//remove all the event listeners from the canvas
		canvas.removeEventListener("click", handleHoleEditingSelection);
		canvas.removeEventListener("touchstart", handleHoleEditingSelection);
		//turn off the edit holes toggle
		editHolesToggle.checked = false;
		//reset the selected hole
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
		drawData(allBlastHoles, selectedHole);
	}
});

const holeEastingSlider = document.getElementById("holeEastingSlider");
holeEastingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleEasting = parseFloat(holeEastingSlider.value);
		holeEastingLabel.textContent = "Hole Easting (X): " + newHoleEasting.toFixed(2) + "mE";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 4 (easting)
				calculateHoleGeometry(clickedHole, newHoleEasting, 4);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average easting of all selected holes
			let sumEasting = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startXLocation, 0);
			let averageEasting = sumEasting / selectedMultipleHoles.length;
			let eastingDelta = newHoleEasting - averageEasting;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleX = hole.startXLocation + eastingDelta;
				calculateHoleGeometry(hole, newHoleX, 4);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

const holeNorthingSlider = document.getElementById("holeNorthingSlider");
holeNorthingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleNorthing = parseFloat(holeNorthingSlider.value);
		holeNorthingLabel.textContent = "Hole Northing (Y): " + newHoleNorthing.toFixed(2) + "mN";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 5 (northing)
				calculateHoleGeometry(clickedHole, newHoleNorthing, 5);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average northing of all selected holes
			let sumNorthing = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startYLocation, 0);
			let averageNorthing = sumNorthing / selectedMultipleHoles.length;
			let northingDelta = newHoleNorthing - averageNorthing;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleY = hole.startYLocation + northingDelta;
				calculateHoleGeometry(hole, newHoleY, 5);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

// Access the slider element and add an event listener to track changes
const holeElevationSlider = document.getElementById("holeElevationSlider");
holeElevationSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleElevation = parseFloat(holeElevationSlider.value);
		holeElevationLabel.textContent = "Hole Elevation (Z): " + newHoleElevation.toFixed(2) + "m";

		if (selectedHole) {
			// Update the easting of the individual selected hole
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (fixToeLocation == true) {
				if (index !== -1) {
					allBlastHoles[index].startZLocation = newHoleElevation;
					// Assuming endZLocation should also be updated based on the new easting
					allBlastHoles[index].endZLocation += newHoleElevation - allBlastHoles[index].startZLocation;
					calculateHoleGeometry(allBlastHoles[index], allBlastHoles[index].length, 1);
					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			} else {
				if (index !== -1) {
					// Calculate the original delta between startZLocation and endZLocation
					let originalDeltaZ = allBlastHoles[index].endZLocation - allBlastHoles[index].startZLocation;

					// Update startZLocation
					allBlastHoles[index].startZLocation = newHoleElevation;

					// Update endZLocation based on the new startZLocation and original delta
					allBlastHoles[index].endZLocation = newHoleElevation + originalDeltaZ;

					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			}
		} else if (selectedMultipleHoles) {
			// Update the elevation of multiple selected holes
			let sumElevation = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startZLocation, 0);
			let averageElevation = sumElevation / selectedMultipleHoles.length;
			let elevationDelta = newHoleElevation - averageElevation;

			selectedMultipleHoles.forEach((hole) => {
				hole.startZLocation += elevationDelta;
				// Assuming endZLocation should also be updated based on the new elevation
				hole.endZLocation += elevationDelta;
			});

			// Redraw the updated data for multiple holes
			drawData(allBlastHoles, null); // Pass null as the selected hole might not be relevant
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
	}
});

const holeLengthSlider = document.getElementById("holeLengthSlider");
holeLengthSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleLength = parseFloat(holeLengthSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeAngleSlider = document.getElementById("holeAngleSlider");
holeAngleSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleAngle = parseFloat(holeAngleSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(clickedHole, newHoleAngle, 2);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(hole, newHoleAngle, 2);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
		}
	}
});

const holeDiameterSlider = document.getElementById("holeDiameterSlider");
holeDiameterSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleDiameter = parseFloat(holeDiameterSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(clickedHole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(hole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeBearingSlider = document.getElementById("holeBearingSlider");
holeBearingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleBearing = parseFloat(holeBearingSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(clickedHole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(hole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeSubdrillSlider = document.getElementById("holeSubdrillSlider");
holeSubdrillSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleSubdrill = parseFloat(holeSubdrillSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleSubdrill, 8);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleSubdrill, 8);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
		}
	}
});

function resizeChart() {
	if (Array.isArray(holeTimes) && timeChartObject) {
		// Check if the chart has been created by Plotly
		const chart = document.getElementById("timeChart");
		if (chart && chart._fullLayout) {
			const newWidth = document.documentElement.clientWidth;
			// Use the string ID instead of the DOM element
			Plotly.relayout("timeChart", {
				width: newWidth
			});
		} else {
			console.warn("resizeChart skipped: timeChart not yet initialized by Plotly");
		}
	} else {
		console.warn("resizeChart skipped: invalid holeTimes or timeChartObject");
	}
}

// Add event listener for window resize
window.addEventListener("resize", resizeChart);
var acc = document.getElementsByClassName("accordion");
var i;
for (i = 0; i < acc.length; i++) {
	acc[i].addEventListener("click", function () {
		/* Toggle between adding and removing the "active" class,
    to highlight the button that controls the panel */
		this.classList.toggle("active");
		/* Toggle between hiding and showing the active panel */
		var panel = this.nextElementSibling;
		if (panel.style.display === "block") {
			panel.style.display = "none";
		} else {
			panel.style.display = "block";
			resizeChart(); // Call the resizeChart function to adjust the chart layout
			timeChart();
			//Plotly.relayout("timeChart", {
			//	width: newWidthRight - 50
			//});
		}
	});
}

const voronoiMetricDropdown = document.getElementById("voronoiSelect");
if (voronoiMetricDropdown) {
	voronoiMetricDropdown.addEventListener("change", function (e) {
		selectedVoronoiMetric = e.target.value;
		drawData(allBlastHoles, selectedHole); // Redraw with the new metric
	});
}

function isIOS() {
	const userAgent = navigator.userAgent.toLowerCase();
	return /iphone|ipad|ipod/.test(userAgent);
}
document.getElementById("saveKAD").addEventListener("click", function () {
	exportKADFile(mapData);
});
document.getElementById("saveHoles").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsTo14ColumnCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8"
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	} else {
		const csv = convertPointsTo14ColumnCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});

document.getElementById("saveAll").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToAllDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8"
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	} else {
		const csv = convertPointsToAllDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
document.getElementById("saveIREDES").addEventListener("click", function () {
	saveIREDESPopup();
});
document.getElementById("saveAQM").addEventListener("click", function () {
	saveAQMPopup();
});
document.getElementById("saveMeasures").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToActualDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8"
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	} else {
		const csv = convertPointsToActualDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
// Update the event listener to filter visible holes first
document.getElementById("exportHolesDXF").addEventListener("click", function () {
	// ✅ Filter allBlastHoles to only include visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

	if (visibleBlastHoles.length === 0) {
		alert("No visible holes to export.");
		return;
	}

	console.log(`Exporting ${visibleBlastHoles.length} visible holes out of ${allBlastHoles.length} total holes`);

	const dxf = exportHolesDXF(visibleBlastHoles);
	const filename = "KIRRA_HOLES_DXF_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_") + ".dxf";
	downloadDXF(dxf, filename);
});

document.getElementById("exportDrawingDXF").addEventListener("click", function () {
	const dxf = exportKADDXF();
	const filename = "KIRRA_DRAWING_DXF_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_") + ".dxf";
	downloadDXF(dxf, filename);
});

function downloadDXF(content, filename) {
	if (isIOS()) {
		const blob = new Blob([content], {
			type: "text/dxf;charset=utf-8"
		});
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	} else {
		const link = document.createElement("a");
		link.style.display = "none";
		link.href = "data:text/dxf;charset=utf-8," + encodeURIComponent(content);
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

// Function to check if the mouse is inside the canvas
function isMouseInside(mouseX, mouseY, canvas) {
	const rect = canvas.getBoundingClientRect(); // Get the bounding rectangle of the canvas
	return mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom;
}
const canvasContainer = document.querySelector(".canvas-container");

canvasContainer.addEventListener(
	"wheel",
	function (event) {
		const mouseX = event.clientX;
		const mouseY = event.clientY;
		const isMouseInsideCanvas = isMouseInside(mouseX, mouseY, canvas);

		if (isMouseInsideCanvas) {
			event.preventDefault();
			const wheelDelta = event.deltaY;

			const zoomFactor = wheelDelta > 0 ? 0.95 : 1.05;

			// Calculate the mouse position in canvas coordinates
			const canvasRect = canvas.getBoundingClientRect();
			const canvasX = mouseX - canvasRect.left;
			const canvasY = mouseY - canvasRect.top;

			// Calculate the center of the canvas
			const centerX = canvasRect.width / 2;
			const centerY = canvasRect.height / 2;
			//make the canvas center the value of 0,0
			//const canvasCenterX = centerX - canvasX;
			//const canvasCenterY = centerY - canvasY;

			// Calculate the delta between the mouse position and the canvas center
			const deltaX = canvasX - centerX;
			const deltaY = canvasY - centerY;
			// Calculate the delta between the mouse position and the canvas center in negative on the left and positive on the right
			// and negative on the top and positive on the bottom
			//const deltaX = canvasCenterX - centerX;
			//const deltaY = canvasCenterY - centerY;

			// Calculate the position offsets from the center of the canvas
			const offsetX = canvasX - canvasRect.width / 2;
			const offsetY = canvasY - canvasRect.height / 2;

			// Calculate the new scale
			// Calculate the new scale
			// Calculate the new scale
			currentScale *= zoomFactor;

			// Step #) Only adjust font size if font lock is not checked
			const fontLock = document.getElementById("fontLock");
			if (!fontLock.checked) {
				currentFontSize = Math.min(Math.max(currentFontSize * zoomFactor, 0), 100);
			}

			// Adjust the centroid position based on the offsets and zoom direction
			if (deltaX < 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Left Quadrant: Mouse is above and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX < 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Left Quadrant: Mouse is below and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Right Quadrant: Mouse is above and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Right Quadrant: Mouse is below and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Center: Mouse is in the center region of the canvas");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY -= (offsetY / currentScale) * (1 - zoomFactor);
			}

			// Ensure the currentScale does not go below a minimum value
			currentScale = Math.max(currentScale, 0.000001);

			drawData(allBlastHoles, selectedHole);
		}
	},
	{
		passive: false
	}
);

document.addEventListener("DOMContentLoaded", function () {
	// Access the slider element and add an event listener to track changes
	const toeSlider = document.getElementById("toeSlider");
	toeSlider.addEventListener("input", function () {
		// Calculate the toe size in meters by using the slider value directly
		const toeSizeInMeters = parseFloat(this.value);

		// Update the label with the calculated toe size
		toeLabel.textContent = "Toe Size: " + toeSizeInMeters.toFixed(2) + "m";

		// Call the drawData function with the updated toe size in meters
		drawData(allBlastHoles, selectedHole, toeSizeInMeters);
	});
	const holeSlider = document.getElementById("holeSlider");
	holeSlider.addEventListener("input", function () {
		////console.log('Slider value:', this.value);
		holeScale = document.getElementById("holeSlider").value;
		holeLabel.textContent = "Hole Adjust : " + parseFloat(holeScale).toFixed(1);
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const connSlider = document.getElementById("connSlider");
	connSlider.addEventListener("input", function () {
		////console.log('Connector value:', this.value);
		connScale = document.getElementById("connSlider").value;
		connLabel.textContent = "Tie Size : " + parseFloat(connScale).toFixed(1);
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	// Step #) Font lock checkbox event listener
	const fontLock = document.getElementById("fontLock");
	const fontSlider = document.getElementById("fontSlider");

	fontLock.addEventListener("change", function () {
		// Step #) Enable/disable slider based on checkbox state
		fontSlider.disabled = this.checked;
	});

	fontSlider.min = "0";
	fontSlider.max = "100";
	fontSlider.addEventListener("input", function () {
		currentFontSize = this.value;
		currentFontSize = document.getElementById("fontSlider").value;
		fontLabel.textContent = "Font Size : " + currentFontSize + "px";
		drawData(allBlastHoles, selectedHole);
	});

	// Access the slider element and add an event listener to track changes
	const intervalSlider = document.getElementById("intervalSlider");
	intervalSlider.addEventListener("input", function () {
		intervalAmount = document.getElementById("intervalSlider").value;
		intervalLabel.textContent = "Interval : " + intervalAmount + "ms";
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const firstMovementSlider = document.getElementById("firstMovementSlider");
	firstMovementSlider.addEventListener("input", function () {
		firstMovementSize = document.getElementById("firstMovementSlider").value;
		firstMovementLabel.textContent = "First Movement Size : " + firstMovementSize;
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		drawData(allBlastHoles, selectedHole);
	});
	//snap tolerance - UPDATED TO USE PIXELS
	const snapToleranceSlider = document.getElementById("snapToleranceSlider");
	snapToleranceSlider.addEventListener("input", function () {
		snapRadiusPixels = parseFloat(this.value);
		document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

		// Save to localStorage
		localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
	});

	// Access the slider element and add an event listener to track changes
	const connectSlider = document.getElementById("connectSlider");
	connectSlider.addEventListener("input", function () {
		updateConnectDistance(); // Step 7) Use the new logarithmic update function
	});
});

// Connector Distance Log Helper Functions (Base 5)
function connectDistanceLogScale(sliderValue) {
	if (sliderValue <= 33.33) {
		// First third: 0.2m to 1.0m (5^0.43 to 5^0.86 approximately)
		const normalizedValue = sliderValue / 33.33;
		const minLog = Math.log(0.2) / Math.log(5); // log₅(0.2)
		const maxLog = Math.log(1.0) / Math.log(5); // log₅(1.0)
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else if (sliderValue <= 66.66) {
		// Second third: 1.0m to 5.0m (5^0 to 5^1)
		const normalizedValue = (sliderValue - 33.33) / 33.33;
		const minLog = Math.log(1.0) / Math.log(5); // log₅(1.0) = 0
		const maxLog = Math.log(5.0) / Math.log(5); // log₅(5.0) = 1
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else {
		// Last third: 5.0m to 25.0m (5^1 to 5^2)
		const normalizedValue = (sliderValue - 66.66) / 33.34;
		const minLog = Math.log(5.0) / Math.log(5); // log₅(5.0) = 1
		const maxLog = Math.log(25.0) / Math.log(5); // log₅(25.0) = 2
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	}
}

function updateConnectDistance() {
	const connectSlider = document.getElementById("connectSlider");
	const sliderValue = parseFloat(connectSlider.value);

	// Step 4) Use logarithmic scaling instead of direct value
	connectAmount = connectDistanceLogScale(sliderValue);

	// Step 5) Snap to 0.1m increments
	connectAmount = Math.round(connectAmount * 10) / 10;

	// Step 6) Update label with actual distance
	const connectLabel = document.getElementById("connectLabel");
	connectLabel.textContent = "Connect Distance : " + connectAmount.toFixed(1) + "m";
}

// Step 6) Optional: Add visual markers to show the scale divisions
function addConnectDistanceMarkers() {
	const slider = document.getElementById("connectSlider");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.2m</span><span>1m</span><span>5m</span><span>25m</span>";
	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}
const timeSlider = document.getElementById("timeRange");
timeSlider.addEventListener("input", function () {
	timeRange = document.getElementById("timeRange").value;
	timeRangeLabel.textContent = "Time window :" + timeRange + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true // Adjust the y-axis range to fit the data
		}
	});
});

// Access the slider element and add an event listener to track changes
const timeOffsetSlider = document.getElementById("timeOffset");
timeOffsetSlider.addEventListener("input", function () {
	timeOffset = document.getElementById("timeOffset").value;
	timeOffsetLabel.textContent = "Time Offset : " + timeOffset + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true // Adjust the y-axis range to fit the data
		}
	});
});

//floating connector color
const floatingConnectorColor = document.getElementById("floatingConnectorColor");
floatingConnectorColor.addEventListener("change", function () {
	floatingConnectorColor.jscolor.fromString(floatingConnectorColor.value);
});
//Color Wells not sliders but JScolor buttons
const connectorColor = document.getElementById("connectorColor");
connectorColor.addEventListener("change", function () {
	connectorColor.jscolor.fromString(connectorColor.value);
});
const drawingColor = document.getElementById("drawingColor");
drawingColor.addEventListener("change", function () {
	drawingColor.jscolor.fromString(drawingColor.value);
});

const connectorDelay = document.getElementById("delay");
connectorDelay.addEventListener("change", function () {
	connectorDelay.value = parseFloat(connectorDelay.value);
});
const floatingDelay = document.getElementById("floatingDelay");
floatingDelay.addEventListener("change", function () {
	floatingDelay.value = parseFloat(floatingDelay.value);
});

let drawingZValue = 0.0;
//Numbers like elevation and circle radius and polygon radius
const drawingElevation = document.getElementById("drawingElevation");
// Step #) Initialize drawingZValue to match the HTML input's initial value
drawingZValue = parseFloat(drawingElevation.value) || 0.0;
drawingElevation.addEventListener("change", function () {
	drawingZValue = parseFloat(drawingElevation.value);
});

const lineThickness = document.getElementById("drawingLineWidth");
lineThickness.addEventListener("change", function () {
	lineThickness.value = parseFloat(lineThickness.value);
});
const circleRadius = document.getElementById("drawingRadius");
circleRadius.addEventListener("change", function () {
	circleRadius.value = parseFloat(circleRadius.value);
});
const polygonRadius = document.getElementById("drawingPolygonRadius");
polygonRadius.addEventListener("change", function () {
	polygonRadius.value = parseFloat(polygonRadius.value);
});
const radiiSteps = document.getElementById("radiiSteps");
radiiSteps.addEventListener("change", function () {
	radiiSteps.value = parseInt(radiiSteps.value);
});
const drawingText = document.getElementById("drawingText");
drawingText.addEventListener("change", function () {
	drawingText.value = String(drawingText.value);
});

// Create array of options and their corresponding flags
const optionConfigs = [
	{
		option: displayHoleId
	},
	{
		option: displayHoleLength
	},
	{
		option: displayHoleDiameter
	},
	{
		option: displayHoleAngle
	},
	{
		option: displayHoleDip
	},
	{
		option: displayHoleBearing
	},
	{
		option: displayHoleSubdrill
	},
	{
		option: displayConnectors
	},
	{
		option: displayDelays
	},
	{
		option: displayTimes
	},
	{
		option: displayContours,
		flag: "isDisplayingContours"
	},
	{
		option: displaySlope,
		flag: "isDisplayingSlopeTriangles"
	},
	{
		option: displayRelief,
		flag: "isDisplayingReliefTriangles"
	},
	{
		option: displayFirstMovements,
		flag: "isDisplayingDirectionArrows"
	},
	{
		option: displayXLocation
	},
	{
		option: displayYLocation
	},
	{
		option: displayElevation
	},
	{
		option: displayHoleType
	},
	{
		option: displayMLength
	},
	{
		option: displayMMass
	},
	{
		option: displayMComment
	},
	{
		option: displayVoronoiCells
	},
	{
		option: displayRowAndPosId
	}
];

// Step 1: Add throttling variables at the top of your file (near other global variables)
//let contourUpdatePending = false;

// Step 2: Create throttled function
function throttledRecalculateContours() {
	if (contourUpdatePending) return;
	contourUpdatePending = true;

	requestAnimationFrame(() => {
		if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
			contourUpdatePending = false;
			return;
		}

		const result = recalculateContours(allBlastHoles, 0, 0);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
		updateOverlayColorsForTheme();
		contourUpdatePending = false;
	});
}

// Step 3: Replace the calculation in your existing event listener
optionConfigs.forEach((config) => {
	if (config.option) {
		config.option.addEventListener("change", function () {
			if (config.flag) {
				window[config.flag] = true;
			}

			// REPLACE THIS SECTION:
			/*
            // Calculate contours when any of these displays are turned on
            if ((config.option === displayContours && displayContours.checked) || 
                (config.option === displayFirstMovements && displayFirstMovements.checked) || 
                (config.option === displayRelief && displayRelief.checked)) {
                const result = recalculateContours(allBlastHoles, 0, 0);
                contourLinesArray = result.contourLinesArray;
                directionArrows = result.directionArrows;
            }
            */

			// WITH THIS THROTTLED VERSION:
			if ((config.option === displayContours && displayContours.checked) || (config.option === displayFirstMovements && displayFirstMovements.checked) || (config.option === displayRelief && displayRelief.checked)) {
				throttledRecalculateContours(); // Use throttled version
			}

			// Your existing overlay integration code...
			if (config.option === displayContours) {
				if (displayContours.checked) {
					if (!useContourOverlay) {
						toggleContourOverlayFixed();
					} else {
						updateOverlayColorsForTheme();
					}
				} else {
					if (contourOverlayCanvas) {
						contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
					}
				}
			}

			drawData(allBlastHoles, selectedHole);
		});
	}
});

let touchStartTime;
let touchDuration;
const longPressDuration = 200; // Adjust this duration as needed
let isTouchDragging = false;
let longPressTimeout;
let isUpdatingSelectionFromMove = false;
let newWidthRight = 350;
let newWidthLeft = 350;

function handleMouseDown(event) {
	// Ignore right-clicks - they're handled by context menu event
	// BUT preserve move tool functionality completely
	if (event.button === 2) {
		// Only ignore if not in move tool mode
		if (!isMoveToolActive) return;
	}

	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	longPressTimeout = setTimeout(() => {
		isDragging = true; // Set isDragging to true after 500ms
	}, longPressDuration);

	// Convert to canvas coordinates (consistent with handleMouseMove)
	const rect = canvas.getBoundingClientRect();
	lastMouseX = event.clientX - rect.left;
	lastMouseY = event.clientY - rect.top;
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
}

function handleMouseMove(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Update global mouse tracking for interactive previews
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;
	// Convert to world coordinates
	currentMouseWorldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
	currentMouseWorldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	if (isResizingRight) {
		newWidthRight = window.innerWidth - event.clientX;
		Plotly.relayout("timeChart", {
			width: newWidthRight - 50
		});
		document.getElementById("sidenavRight").style.width = newWidthRight + "px";
	}
	if (isResizingLeft) {
		newWidthLeft = event.clientX;
		document.getElementById("sidenavLeft").style.width = newWidthLeft + "px";
	}

	// If in selection mode and there's a selection, prevent getMultipleClickedHoles from re-evaluating during this move
	if (isMultiHoleSelectionEnabled && selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		isUpdatingSelectionFromMove = true; // Flag to prevent re-evaluating selection during mouse move
	}

	// ⭐ IMPORTANT: Ensure this line is REMOVED or COMMENTED OUT if it's still present!
	drawData(allBlastHoles, selectedHole); // THIS LINE IS THE MAJOR PERFORMANCE HIT IF UNCONDITIONAL
	//drawMouseCrossHairs(lastMouseX, lastMouseY, snapRadiusPixels, true, true);

	isUpdatingSelectionFromMove = false; // Reset the flag after drawData
}

function handleMouseUp(event) {
	isDragging = false;
	clearTimeout(longPressTimeout); // Clear the long press timeout
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
	//touchDuration = Date.now() - touchStartTime;

	if (isAddingHole && touchDuration <= longPressDuration) {
		// Short click behavior
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		addHolePopup();
	}
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	drawData(allBlastHoles, selectedHole);
	// Remove the Side Nav Accorian resize Listeners.
	isResizingRight = false;
	document.removeEventListener("mousemove", handleMouseMove);
	document.removeEventListener("mouseup", handleMouseUp);
	isResizingLeft = false;
	document.removeEventListener("mousemove", handleMouseMove);
	document.removeEventListener("mouseup", handleMouseUp);
}

// Rest of the code for touch events is unchanged

function handleTouchStart(event) {
	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	longPressTimeout = setTimeout(() => {
		isTouchDragging = true; // Set isTouchDragging to true after 500ms
	}, longPressDuration);

	// Continue handling the touch start event as before
	if (event.touches.length === 1) {
		if (!isDraggingBearing && !isDraggingHole) {
			isTouchDragging = true;
		}
		touchStartX = event.touches[0].clientX;
		touchStartY = event.touches[0].clientY;
	} else if (event.touches.length === 2) {
		// Pinch
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
}

function handleTouchEnd(event) {
	// Clear the long press timeout
	clearTimeout(longPressTimeout);

	// Only set isTouchDragging to false on touch end
	isTouchDragging = false;

	touchDuration = Date.now() - touchStartTime;
	// Block tool-specific behaviors if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;

	if (isAddingHole && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
		addHolePopup();
	}
	if (event.touches.length === 1) {
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
}

function handleTouchMove(event) {
	if (event.touches.length === 1 && isTouchDragging && !isDraggingBearing && !isDraggingHole) {
		// Only do canvas panning if tools aren't dragging
		event.preventDefault();
		let touchX = event.touches[0].clientX;
		let touchY = event.touches[0].clientY;
		deltaX = touchX - touchStartX;
		deltaY = touchY - touchStartY;
		touchStartX = touchX;
		touchStartY = touchY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		drawData(allBlastHoles, selectedHole);
	} else if (event.touches.length === 2) {
		event.preventDefault();

		deltaX = event.touches[0].clientX - event.touches[1].clientX;
		deltaY = event.touches[0].clientY - event.touches[1].clientY;
		const currentPinchDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

		if (initialPinchDistance === null) {
			initialPinchDistance = currentPinchDistance;
		} else {
			const pinchDelta = currentPinchDistance - initialPinchDistance;
			currentScale = initialScale + pinchDelta * 0.05;
			currentScale = Math.max(currentScale, 0.000001);
			currentFontSize = initialFontSize * (currentScale / initialScale);

			drawData(allBlastHoles, selectedHole);
		}
	}
}

async function handleFileUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();

	reader.onload = async function (event) {
		const data = event.target.result;

		if (file.name.endsWith(".kad") || file.name.endsWith(".KAD") || file.name.endsWith(".txt") || file.name.endsWith(".TXT")) {
			parseKADFile(data);
			drawData(allBlastHoles, selectedHole);
		} else if (file.name.endsWith(".csv") || file.name.endsWith(".CSV")) {
			try {
				allBlastHoles = parseK2Dcsv(data);

				// Calculate centroid
				let sumX = 0;
				let sumY = 0;
				for (let i = 0; i < allBlastHoles.length; i++) {
					sumX += allBlastHoles[i].startXLocation;
					sumY += allBlastHoles[i].startYLocation;
				}
				centroidX = sumX / allBlastHoles.length;
				centroidY = sumY / allBlastHoles.length;

				// Recalculate contours and triangles
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
				drawData(allBlastHoles, selectedHole);
				countAllBlastHoles = allBlastHoles.length;
			} catch (error) {
				console.error("Error during CSV handling:", error);
				fileFormatPopup(error);
			}
		}
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

let randomHex = Math.floor(Math.random() * 16777215).toString(16);

// DUPLICATE ID DETECTION AND RESOLUTION SYSTEM
// Enhanced duplicate checking that handles all ID formats
async function checkAndResolveDuplicateHoleIDs(allBlastHoles, actionType = "import") {
	const duplicateReport = {
		hasDuplicates: false,
		duplicates: [],
		resolved: [],
		errors: []
	};

	// Group holes by entity name
	const entitiesMap = new Map();

	allBlastHoles.forEach((hole, index) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, []);
		}
		entitiesMap.get(hole.entityName).push({
			hole,
			originalIndex: index
		});
	});

	// Check each entity for duplicate IDs
	entitiesMap.forEach((holes, entityName) => {
		const idMap = new Map();

		holes.forEach(({ hole, originalIndex }) => {
			const holeID = hole.holeID.toString(); // Convert to string for comparison

			if (idMap.has(holeID)) {
				// Duplicate found!
				duplicateReport.hasDuplicates = true;

				const existingHole = idMap.get(holeID);
				const duplicateInfo = {
					entityName,
					holeID,
					existing: {
						hole: existingHole.hole,
						index: existingHole.originalIndex
					},
					duplicate: {
						hole,
						index: originalIndex
					}
				};

				duplicateReport.duplicates.push(duplicateInfo);
			} else {
				idMap.set(holeID, {
					hole,
					originalIndex
				});
			}
		});
	});

	// If duplicates found, resolve them
	if (duplicateReport.hasDuplicates) {
		console.warn("🚨 DUPLICATE HOLE IDs DETECTED:", duplicateReport.duplicates.length, "conflicts found");

		// Show user dialog for resolution strategy
		const resolution = await showDuplicateResolutionDialog(duplicateReport, actionType);

		switch (resolution.strategy) {
			case "auto-renumber":
				resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport);
				break;
			case "keep-first":
				resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport);
				break;
			case "keep-last":
				resolveDuplicatesKeepLast(allBlastHoles, duplicateReport);
				break;
			case "manual":
				// Let user manually resolve - return for manual handling
				return duplicateReport;
			case "abort":
				// Return special value indicating user cancelled
				console.log("✅ User cancelled duplicate resolution");
				return { cancelled: true };
		}
	}

	return duplicateReport;
}

function showDuplicateResolutionDialog(duplicateReport, actionType) {
	const duplicateCount = duplicateReport.duplicates.length;
	const entitiesAffected = [...new Set(duplicateReport.duplicates.map((d) => d.entityName))];

	// Build content using CSS classes that handle dark/light mode automatically
	const contentDiv = document.createElement("div");
	contentDiv.className = "button-container-2col";
	contentDiv.style.padding = "10px";
	contentDiv.style.minHeight = "200px";

	// Warning header - uses labelWhite18 class
	const warningHeader = document.createElement("label");
	warningHeader.className = "labelWhite15"; // Using existing CSS class
	warningHeader.style.gridColumn = "1 / -1";
	warningHeader.style.textAlign = "center";
	warningHeader.style.marginBottom = "10px";
	warningHeader.style.fontSize = "14px";
	warningHeader.style.fontWeight = "bold";
	warningHeader.textContent = "⚠️ Duplicate Hole IDs Detected";
	contentDiv.appendChild(warningHeader);

	// Conflict count - uses labelWhite15 class
	const conflictLabel = document.createElement("label");
	conflictLabel.className = "labelWhite15";
	conflictLabel.style.gridColumn = "1 / -1";
	conflictLabel.style.marginBottom = "5px";
	conflictLabel.textContent = "Found: " + duplicateCount + " conflicts";
	contentDiv.appendChild(conflictLabel);

	// Affected blasts - uses labelWhite15 class
	const blastsLabel = document.createElement("label");
	blastsLabel.className = "labelWhite15";
	blastsLabel.style.gridColumn = "1 / -1";
	blastsLabel.style.marginBottom = "10px";
	blastsLabel.textContent = "Blasts: " + entitiesAffected.join(", ");
	contentDiv.appendChild(blastsLabel);

	// Examples header - uses labelWhite12 class
	const examplesHeader = document.createElement("label");
	examplesHeader.className = "labelWhite12";
	examplesHeader.style.gridColumn = "1 / -1";
	examplesHeader.style.marginTop = "10px";
	examplesHeader.style.marginBottom = "5px";
	examplesHeader.textContent = "Examples:";
	contentDiv.appendChild(examplesHeader);

	// Example entries - uses labelWhite12 class
	duplicateReport.duplicates.slice(0, 3).forEach((dup) => {
		const exampleLabel = document.createElement("label");
		exampleLabel.className = "labelWhite12";
		exampleLabel.style.gridColumn = "1 / -1";
		exampleLabel.style.marginBottom = "2px";
		exampleLabel.textContent = "• " + dup.entityName + " - ID: " + dup.holeID;
		contentDiv.appendChild(exampleLabel);
	});

	// More indicator - uses labelWhite12 class
	if (duplicateReport.duplicates.length > 3) {
		const moreLabel = document.createElement("label");
		moreLabel.className = "labelWhite12";
		moreLabel.style.gridColumn = "1 / -1";
		moreLabel.textContent = "... and " + (duplicateReport.duplicates.length - 3) + " more";
		contentDiv.appendChild(moreLabel);
	}

	// Return promise exactly like original Swal2 version
	return new Promise((resolve) => {
		const dialog = new FloatingDialog({
			title: "Duplicate Resolution",
			content: contentDiv,
			width: 450,
			height: 350,
			layoutType: "default",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false,
			showConfirm: true,
			showCancel: true,
			showOption1: true,
			showOption2: true,
			confirmText: "Renumber",
			option1Text: "Keep First",
			option2Text: "Keep Last",
			cancelText: "Cancel",
			onConfirm: () => {
				resolve({
					strategy: "auto-renumber"
				});
			},
			onOption1: () => {
				resolve({
					strategy: "keep-first"
				});
			},
			onOption2: () => {
				resolve({
					strategy: "keep-last"
				});
			},
			onCancel: () => {
				resolve({
					strategy: "abort"
				});
			}
		});

		dialog.show();
	});
}

// Enhanced auto-renumbering that handles all ID formats
function resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport) {
	// For each entity, analyze existing ID patterns and generate appropriate new IDs
	const entitiesMap = new Map();

	// Group allBlastHoles by entity and analyze ID patterns
	allBlastHoles.forEach((hole) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, {
				holes: [],
				numericIDs: [],
				alphaIDs: [],
				maxNumeric: 0,
				maxAlphaRow: "A",
				maxAlphaNum: 0
			});
		}
		const entity = entitiesMap.get(hole.entityName);
		entity.holes.push(hole);

		const holeID = hole.holeID.toString();

		// Check if it's purely numeric
		const numericMatch = holeID.match(/^(\d+)$/);
		if (numericMatch) {
			const num = parseInt(numericMatch[1]);
			entity.numericIDs.push(num);
			entity.maxNumeric = Math.max(entity.maxNumeric, num);
		}
		// Check if it's alphanumeric (like A1, B2, AA1, etc.)
		else {
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);
				entity.alphaIDs.push({
					letters,
					number,
					full: holeID
				});

				// Track highest letter combination and number
				if (letters.localeCompare(entity.maxAlphaRow) > 0) {
					entity.maxAlphaRow = letters;
					entity.maxAlphaNum = number;
				} else if (letters === entity.maxAlphaRow) {
					entity.maxAlphaNum = Math.max(entity.maxAlphaNum, number);
				}
			}
		}
	});

	// Renumber duplicates using appropriate format
	duplicateReport.duplicates.forEach((duplicate) => {
		const entity = entitiesMap.get(duplicate.entityName);
		const oldID = duplicate.duplicate.hole.holeID.toString();
		let newID;

		// Determine what format to use for the new ID
		const numericMatch = oldID.match(/^(\d+)$/);
		const alphaMatch = oldID.match(/^([A-Z]+)(\d+)$/);

		if (numericMatch) {
			// Generate new numeric ID
			newID = (++entity.maxNumeric).toString();
		} else if (alphaMatch) {
			// For true alphanumeric (A1, B2 style), maintain the letter prefix
			const letters = alphaMatch[1];

			// Find max number for this specific letter prefix
			let maxNumForPrefix = 0;
			entity.holes.forEach((h) => {
				const match = h.holeID.toString().match(/^([A-Z]+)(\d+)$/);
				if (match && match[1] === letters) {
					maxNumForPrefix = Math.max(maxNumForPrefix, parseInt(match[2]));
				}
			});

			newID = letters + (maxNumForPrefix + 1);
		} else {
			// Fallback: use numeric
			newID = (++entity.maxNumeric).toString();
		}

		// Update the hole ID
		duplicate.duplicate.hole.holeID = newID;

		// Update fromHoleID references if they point to this hole
		allBlastHoles.forEach((hole) => {
			if (hole.fromHoleID === duplicate.entityName + ":::" + oldID) {
				hole.fromHoleID = duplicate.entityName + ":::" + newID;
			}
		});

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			oldID: oldID,
			newID: newID,
			action: "renumbered"
		});

		console.log("🔧 Renumbered duplicate hole:", duplicate.entityName + ":" + oldID, "→", newID);
	});
}

function resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport) {
	// Remove duplicate holes (keep the first occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.duplicate.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-duplicate"
		});

		console.log("🗑️ Removed duplicate hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

function resolveDuplicatesKeepLast(allBlastHoles, duplicateReport) {
	// Remove original holes (keep the duplicate/last occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.existing.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-original"
		});

		console.log("🗑️ Removed original hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

// Enhanced unique ID validation for any format
function validateUniqueHoleID(entityName, holeID, excludeHole = null) {
	const holeIDStr = holeID.toString();

	const existing = allBlastHoles.find((hole) => hole.entityName === entityName && hole.holeID.toString() === holeIDStr && hole !== excludeHole);

	if (existing) {
		const newID = generateUniqueHoleID(entityName, holeIDStr);
		console.warn("🚨 Duplicate hole ID detected:", entityName + ":" + holeIDStr, "→ Auto-assigned:", newID);
		return newID;
	}

	return holeIDStr;
}
// Enhanced unique ID generation for any format
function generateUniqueHoleID(entityName, baseID) {
	const baseIDStr = baseID.toString();

	// Analyze existing IDs in this entity
	const existingIDs = new Set();
	let maxNumeric = 0;
	let maxAlphaRow = "A";
	let maxAlphaNum = 0;

	allBlastHoles.forEach((hole) => {
		if (hole.entityName === entityName) {
			const holeID = hole.holeID.toString();
			existingIDs.add(holeID);

			// Track numeric IDs
			const numericMatch = holeID.match(/^(\d+)$/);
			if (numericMatch) {
				maxNumeric = Math.max(maxNumeric, parseInt(numericMatch[1]));
			}

			// Track alphanumeric IDs
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);

				if (letters.localeCompare(maxAlphaRow) > 0) {
					maxAlphaRow = letters;
					maxAlphaNum = number;
				} else if (letters === maxAlphaRow) {
					maxAlphaNum = Math.max(maxAlphaNum, number);
				}
			}
		}
	});

	// Determine format of base ID and generate appropriate new ID
	const numericMatch = baseIDStr.match(/^(\d+)$/);
	const alphaMatch = baseIDStr.match(/^([A-Z]+)(\d+)$/);

	if (numericMatch) {
		// Generate next numeric ID
		return (maxNumeric + 1).toString();
	} else if (alphaMatch) {
		// Generate next alphanumeric ID in same pattern
		const letters = alphaMatch[1];
		let newID;

		// Try incrementing the number first
		for (let num = 1; num <= maxAlphaNum + 10; num++) {
			newID = letters + num;
			if (!existingIDs.has(newID)) {
				return newID;
			}
		}

		// If that fails, increment the letter
		const nextLetter = incrementLetter(letters);
		return nextLetter + "1";
	} else {
		// Fallback: generate numeric ID
		return (maxNumeric + 1).toString();
	}
}

// ===================================================================
// MISSING HDBSCAN FUNCTIONS - DROP-IN CODE
// ===================================================================
// Add these functions to kirra.js to complete the sequence-weighted HDBSCAN implementation

/**
 * SIMPLIFIED HDBSCAN WITH PRE-CALCULATED DISTANCE MATRIX
 * 
 * Step 1) This function implements HDBSCAN clustering using a pre-calculated distance matrix,
 * which is needed for sequence-weighted row detection.
 * 
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n×n distance matrix
 * @param {number} minClusterSize - Minimum number of points required to form a cluster
 * @returns {Array<Array<number>>} Array of clusters, where each cluster is an array of point indices
 */
function simplifiedHDBSCANWithDistanceMatrix(distanceMatrix, minClusterSize) {
    // Step 2) Validate input parameters
    if (!distanceMatrix || !Array.isArray(distanceMatrix) || distanceMatrix.length === 0) {
        console.warn("Invalid distance matrix provided to simplifiedHDBSCANWithDistanceMatrix");
        return [];
    }
    
    const n = distanceMatrix.length;
    
    // Step 3) Validate that distance matrix is square
    if (distanceMatrix.some(row => !Array.isArray(row) || row.length !== n)) {
        console.warn("Distance matrix is not square or properly formatted");
        return [];
    }
    
    console.log("Running HDBSCAN with pre-calculated " + n + "×" + n + " distance matrix");
    
    // Step 4) Build minimum spanning tree using the provided distance matrix
    const mst = buildMinimumSpanningTreeFromMatrix(distanceMatrix, minClusterSize);
    
    // Step 5) Build cluster hierarchy using existing function
    const hierarchy = buildClusterHierarchy(mst);
    
    // Step 6) Extract stable clusters using existing function
    const clusters = extractStableClusters(hierarchy, minClusterSize);
    
    console.log("HDBSCAN with distance matrix detected " + clusters.length + " clusters");
    return clusters;
}

/**
 * BUILD MINIMUM SPANNING TREE FROM DISTANCE MATRIX
 * 
 * Step 1) This is a variant of the existing buildMinimumSpanningTree function
 * that works with a pre-calculated distance matrix instead of calculating distances.
 * 
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n×n distance matrix
 * @param {number} minPts - Minimum points parameter for core distance calculation
 * @returns {Array<Object>} Minimum spanning tree edges with {from, to, weight} structure
 */
function buildMinimumSpanningTreeFromMatrix(distanceMatrix, minPts) {
    const n = distanceMatrix.length;
    const edges = [];
    
    // Step 2) Calculate core distances (distance to k-th nearest neighbor)
    const coreDistances = [];
    for (let i = 0; i < n; i++) {
        // Step 3) Get all distances for point i and sort them
        const dists = distanceMatrix[i].slice(); // Copy the row
        dists.sort((a, b) => a - b);
        
        // Step 4) Use k-th nearest neighbor distance as core distance
        // Ensure we don't exceed array bounds
        const kIndex = Math.min(minPts, dists.length - 1);
        coreDistances[i] = dists[kIndex];
    }
    
    // Step 5) Calculate mutual reachability distances and create edges
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            // Step 6) Mutual reachability is the maximum of:
            // - Core distance of point i
            // - Core distance of point j  
            // - Direct distance between points i and j
            const mutualReachability = Math.max(
                coreDistances[i], 
                coreDistances[j], 
                distanceMatrix[i][j]
            );
            
            edges.push({ 
                from: i, 
                to: j, 
                weight: mutualReachability 
            });
        }
    }
    
    // Step 7) Sort edges by weight (Kruskal's algorithm)
    edges.sort((a, b) => a.weight - b.weight);
    
    // Step 8) Build MST using Union-Find algorithm
    const parent = Array(n).fill().map((_, i) => i);
    const mst = [];
    
    // Step 9) Union-Find helper functions
    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    function union(x, y) {
        const px = find(x);
        const py = find(y);
        if (px !== py) {
            parent[px] = py;
            return true;
        }
        return false;
    }
    
    // Step 10) Build MST by adding edges that don't create cycles
    for (const edge of edges) {
        if (union(edge.from, edge.to)) {
            mst.push(edge);
            // Step 11) Stop when we have n-1 edges (complete spanning tree)
            if (mst.length === n - 1) break;
        }
    }
    
    console.log("Built MST from distance matrix with " + mst.length + " edges");
    return mst;
}

/**
 * CALCULATE SEQUENCE-WEIGHTED DISTANCES
 *
 * Step 1) Modifies spatial distances to give preference to holes that are close
 * in the numbering sequence, making them more likely to cluster together
 * 
 * @param {Array<Object>} holesData - Array of hole objects with startXLocation, startYLocation, holeID
 * @param {Object} sequenceInfo - Object containing sequenceMap and hasValidSequence
 * @returns {Array<Array<number>>} Weighted distance matrix
 */
function calculateSequenceWeightedDistances(holesData, sequenceInfo) {
    const n = holesData.length;
    const distances = Array(n).fill().map(() => Array(n).fill(0));
    
    // Step 2) Get sequence numbers for all holes
    const sequences = holesData.map((hole) => sequenceInfo.sequenceMap.get(hole.holeID) || 0);
    const maxSequenceDiff = Math.max(...sequences) - Math.min(...sequences);
    
    // Step 3) Prevent division by zero
    const normalizedMaxDiff = maxSequenceDiff > 0 ? maxSequenceDiff : 1;
    
    console.log("Calculating sequence-weighted distances for " + n + " holes");
    console.log("Sequence range: " + Math.min(...sequences) + " to " + Math.max(...sequences));
    
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            // Step 4) Calculate spatial distance
            const dx = holesData[i].startXLocation - holesData[j].startXLocation;
            const dy = holesData[i].startYLocation - holesData[j].startYLocation;
            const spatialDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Step 5) Calculate sequence distance (normalized)
            const sequenceDiff = Math.abs(sequences[i] - sequences[j]);
            const normalizedSequenceDiff = sequenceDiff / normalizedMaxDiff;
            
            // Step 6) SEQUENCE WEIGHTING FORMULA:
            // - If holes are close in sequence (low sequenceDiff), reduce distance
            // - If holes are far in sequence (high sequenceDiff), increase distance
            // - Weight factor controls how much sequence matters vs spatial distance
            const sequenceWeight = 0.3; // 30% influence from sequence
            const sequencePenalty = 1 + sequenceWeight * normalizedSequenceDiff;
            const sequenceBonus = Math.max(0.5, 1 - sequenceWeight * Math.exp(-sequenceDiff / 5));
            
            // Step 7) Apply sequence weighting
            let weightedDistance;
            if (sequenceDiff <= 3) {
                // Step 8) Holes very close in sequence get a distance bonus
                weightedDistance = spatialDistance * sequenceBonus;
            } else {
                // Step 9) Holes far in sequence get a distance penalty
                weightedDistance = spatialDistance * sequencePenalty;
            }
            
            distances[i][j] = distances[j][i] = weightedDistance;
        }
    }
    
    console.log("Applied sequence weighting with max penalty factor: " + (1 + 0.3));
    return distances;
}

/**
 * ORDER CLUSTERS BY SEQUENCE
 *
 * Step 1) After clustering, ensure holes within each cluster are ordered by sequence
 * 
 * @param {Array<Array<number>>} clusters - Array of clusters, each containing point indices
 * @param {Array<Object>} holesData - Array of hole objects
 * @param {Object} sequenceInfo - Object containing sequenceMap
 * @returns {Array<Array<number>>} Clusters with holes ordered by sequence within each cluster
 */
function orderClustersbySequence(clusters, holesData, sequenceInfo) {
    console.log("Ordering " + clusters.length + " clusters by sequence");
    
    return clusters.map((cluster, clusterIndex) => {
        // Step 2) Get holes in this cluster with their sequence information
        const clusterHoles = cluster.map((index) => ({
            hole: holesData[index],
            index: index,
            sequence: sequenceInfo.sequenceMap.get(holesData[index].holeID) || 0
        }));
        
        // Step 3) Sort by sequence number
        clusterHoles.sort((a, b) => a.sequence - b.sequence);
        
        console.log("Cluster " + clusterIndex + ": ordered " + clusterHoles.length + " holes by sequence (" + 
                   clusterHoles[0].sequence + " to " + clusterHoles[clusterHoles.length - 1].sequence + ")");
        
        // Step 4) Return just the indices in sequence order
        return clusterHoles.map((item) => item.index);
    });
}

/**
 * ASSIGN ORDERED CLUSTERS TO ROWS
 *
 * Step 1) Assigns cluster results to rows while preserving sequence order
 * 
 * @param {Array<Object>} holesData - Array of hole objects to assign row/position IDs
 * @param {Array<Array<number>>} orderedClusters - Clusters with holes ordered by sequence
 * @param {string} entityName - Entity name for generating row IDs
 */
function assignOrderedClustersToRows(holesData, orderedClusters, entityName) {
    const startingRowID = getNextRowID(entityName);
    
    console.log("Assigning " + orderedClusters.length + " ordered clusters to rows starting from ID " + startingRowID);
    
    orderedClusters.forEach((cluster, clusterIndex) => {
        const rowID = startingRowID + clusterIndex;
        
        // Step 2) Assign row and position IDs in sequence order
        cluster.forEach((holeIndex, positionInRow) => {
            const hole = holesData[holeIndex];
            hole.rowID = rowID;
            hole.posID = positionInRow + 1; // Position respects sequence order
        });
        
        console.log("Row " + rowID + " assigned " + cluster.length + " holes in sequence order");
    });
    
    console.log("Completed sequence-ordered row assignment for entity: " + entityName);
}



function parseK2Dcsv(data) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles)) allBlastHoles = [];
	randomHex = Math.floor(Math.random() * 16777215).toString(16);

	const lines = data.split("\n");
	let minX = Infinity;
	let minY = Infinity;

	const supportedLengths = [4, 7, 9, 12, 14, 20, 25, 30, 32, 35];
	const warnings = [];
	const newHolesForRowDetection = []; // Track holes that need row detection

	let blastNameValue = "BLAST_" + randomHex;

	for (let i = 0; i < lines.length; i++) {
		const rawLine = lines[i].trim();
		if (rawLine === "") continue;

		const values = rawLine.split(",");
		const len = values.length;

		if (values.every((v) => v.trim() === "")) continue;
		if (!supportedLengths.includes(len)) {
			warnings.push("Line " + (i + 1) + " skipped: unsupported column count (" + len + ")");
			continue;
		}

		let entityName = blastNameValue;
		let holeID, startX, startY, startZ, endX, endY, endZ;
		let holeDiameter = 0,
			holeType = "Undefined",
			fromHoleID = "",
			delay = 0,
			color = "red";
		let measuredLength = 0,
			measuredLengthTimeStamp = "09/05/1975 00:00:00";
		let measuredMass = 0,
			measuredMassTimeStamp = "09/05/1975 00:00:00";
		let measuredComment = "None",
			measuredCommentTimeStamp = "09/05/1975 00:00:00";
		let subdrill = 0;
		let rowID = 0;
		let posID = 0;
		let burden = 0;
		let spacing = 0;
		let connectorCurve = 0;

		if (len === 35) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
			rowID = values[30] && values[30].trim() !== "" ? parseInt(values[30]) : null;
			posID = values[31] && values[31].trim() !== "" ? parseInt(values[31]) : null;
			burden = parseFloat(values[32]);
			spacing = parseFloat(values[33]);
			connectorCurve = parseInt(values[34]);
		} else if (len === 32) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
			rowID = values[30] && values[30].trim() !== "" ? parseInt(values[30]) : null;
			posID = values[31] && values[31].trim() !== "" ? parseInt(values[31]) : null;
		} else if (len === 30) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
		} else if (len === 14) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			holeDiameter = parseFloat(values[9]);
			holeType = values[10];
			fromHoleID = values[11];
			delay = parseInt(values[12]);
			color = values[13].replace(/\r$/, "");
		} else if (len === 12) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			holeDiameter = parseFloat(values[7]);
			holeType = values[8];
			fromHoleID = values[9].includes(":::") ? values[9] : blastNameValue + ":::" + values[9];
			delay = parseInt(values[10]);
			color = values[11].replace(/\r$/, "");
		} else if (len === 9) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			holeDiameter = parseFloat(values[7]);
			holeType = values[8];
			fromHoleID = blastNameValue + ":::" + holeID;
		} else if (len === 7) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			fromHoleID = blastNameValue + ":::" + holeID;
		} else if (len === 4) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = startX;
			endY = startY;
			endZ = startZ;
			fromHoleID = blastNameValue + ":::" + holeID;
		}

		// Calculate basic hole properties using the same logic as calculateHoleGeometry
		const dx = endX - startX;
		const dy = endY - startY;
		const dz = endZ - startZ;
		const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

		const epsilon = 1e-10;
		const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
		const dotProduct = dz;
		const normalizedDotProduct = magnitude < epsilon ? 0 : dotProduct / magnitude;

		const angle = 180 - Math.acos(normalizedDotProduct) * (180 / Math.PI);
		const bearing = (450 - Math.atan2(dy, dx) * (180 / Math.PI)) % 360;

		if (!isNaN(startX) && !isNaN(startY) && !isNaN(startZ) && !isNaN(endX) && !isNaN(endY) && !isNaN(endZ)) {
			// Create the hole object with initial values
			const hole = {
				entityName,
				entityType: "hole",
				holeID,
				startXLocation: startX,
				startYLocation: startY,
				startZLocation: startZ,
				endXLocation: endX,
				endYLocation: endY,
				endZLocation: endZ,
				gradeXLocation: endX, // Will be recalculated
				gradeYLocation: endY, // Will be recalculated
				gradeZLocation: endZ, // Will be recalculated
				subdrillAmount: subdrill,
				subdrillLength: 0, // Will be recalculated
				benchHeight: 0, // Will be recalculated
				holeDiameter,
				holeType,
				fromHoleID,
				timingDelayMilliseconds: delay,
				colorHexDecimal: color,
				holeLengthCalculated: length,
				holeAngle: angle,
				holeBearing: bearing,
				measuredLength,
				measuredLengthTimeStamp,
				measuredMass,
				measuredMassTimeStamp,
				measuredComment,
				measuredCommentTimeStamp,
				rowID,
				posID,
				visible: true,
				burden: burden || 0,
				spacing: spacing || 0,
				connectorCurve: connectorCurve || 0
			};

			// Add to allBlastHoles array first
			allBlastHoles.push(hole);
			// If this hole needs row detection, add to list
			if (rowID === null || rowID === 0 || posID === null || posID === 0) {
				newHolesForRowDetection.push(hole);
			}

			// Calculate proper benchHeight and grade positions for ALL holes (not just when subdrill !== 0)
			if (len !== 4) {
				// Only skip for 4-point holes (which are just collar coordinates)
				const cosAngle = Math.cos(angle * (Math.PI / 180));
				if (Math.abs(cosAngle) > 1e-9) {
					// Calculate benchHeight from the Z difference minus subdrill
					hole.benchHeight = Math.abs(startZ - endZ) - subdrill;

					// Use calculateHoleGeometry to recalculate all derived positions
					// First recalculate based on the existing length to set up grade positions
					calculateHoleGeometry(hole, length, 1); // Mode 1 = length recalculation

					// If there's subdrill, also update that
					if (subdrill !== 0) {
						calculateHoleGeometry(hole, subdrill, 8); // Mode 8 = subdrill recalculation
					}
				} else {
					// For horizontal holes, handle specially
					hole.benchHeight = Math.abs(startZ - endZ);
					hole.gradeXLocation = endX;
					hole.gradeYLocation = endY;
					hole.gradeZLocation = endZ - subdrill;
				}
			}

			minX = Math.min(minX, startX);
			minY = Math.min(minY, startY);
		}
	}
	// Group holes by entity for row detection
	const entitiesForRowDetection = new Map();
	newHolesForRowDetection.forEach((hole) => {
		if (!entitiesForRowDetection.has(hole.entityName)) {
			entitiesForRowDetection.set(hole.entityName, []);
		}
		entitiesForRowDetection.get(hole.entityName).push(hole);
	});

	// In parseCSV and processCsvData:
	entitiesForRowDetection.forEach((holes, entityName) => {
		improvedSmartRowDetection(holes, entityName);// This should be improvedSmartRowDetection 
	});

	// Auto-assign rowID/posID for holes that still don't have them
	const unassignedHoles = allBlastHoles.filter((hole) => hole.rowID === null || hole.rowID === 0 || hole.posID === null || hole.posID === 0);
	unassignedHoles.forEach((hole) => {
		if (!hole.rowID || hole.rowID === 0) {
			hole.rowID = getNextRowID(hole.entityName);
		}
		if (!hole.posID || hole.posID === 0) {
			hole.posID = getNextPosID(hole.entityName, hole.rowID);
		}
	});

	if (warnings.length > 0) {
		console.warn("parseK2Dcsv warnings:\n" + warnings.join("\n"));
	}
	// CRITICAL: Check for duplicate hole IDs after parsing
	const duplicateCheck = checkAndResolveDuplicateHoleIDs(allBlastHoles, "CSV import");

	if (duplicateCheck.hasDuplicates) {
		console.log("Resolved", duplicateCheck.resolved.length, "duplicate hole ID conflicts");

		// Show summary to user
		let summary = "Duplicate hole IDs resolved:\n\n";
		duplicateCheck.resolved.forEach((resolution) => {
			if (resolution.action === "renumbered") {
				summary += "• " + resolution.entityName + ":" + resolution.oldID + " → " + resolution.newID + "\n";
			} else {
				summary += "• " + resolution.entityName + ":" + resolution.holeID + " (" + resolution.action + ")\n";
			}
		});

		alert(summary);
	}
	holeTimes = calculateTimes(allBlastHoles);
	drawData(allBlastHoles, selectedHole);
	return allBlastHoles;
}

async function handleDXFUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = function (e) {
		const dxfContent = e.target.result;
		try {
			const parser = new DxfParser();
			const dxf = parser.parseSync(dxfContent);
			parseDXFtoKadMaps(dxf);
		} catch (error) {
			console.error("DXF parsing failed:", error);
			alert("Error parsing DXF file.");
		}
	};
	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}
// Add this helper function to generate unique entity names
function getUniqueEntityName(baseName, entityType) {
	// If baseName doesn't exist in the map, use it as-is
	if (!allKADDrawingsMap.has(baseName)) {
		return baseName;
	}

	// Otherwise, increment until we find a unique name
	let counter = 1;
	let uniqueName = baseName + "_" + counter;

	while (allKADDrawingsMap.has(uniqueName)) {
		counter++;
		uniqueName = baseName + "_" + counter;
	}

	console.log("⚠️ Entity name collision avoided: '" + baseName + "' → '" + uniqueName + "'");
	return uniqueName;
}

function parseDXFtoKadMaps(dxf) {
	// 1) seed counters so we never collide with existing entries
	var counts = {
		point: 0,
		line: 0,
		poly: 0,
		circle: 0,
		text: 0
	};

	// 2) kirra.js centroid offsets
	var offsetX = 0; //centroidX || 0;
	var offsetY = 0; //centroidY || 0;
	// 3) Collections for surface data
	var surfacePoints = [];
	var surfaceTriangles = [];

	// 3) raw DXF color or bright-red fallback, but return as "#RRGGBB"
	function getColor(idx) {
		// pick the DXF color (decimal) or default grey
		var dec = idx != null && idx >= 0 ? idx : 0x777777;
		// convert to hex, pad to 6 digits, uppercase if you like
		var hex = dec.toString(16).padStart(6, "0").toUpperCase();
		return "#" + hex;
	}

	// 4) iterate over every entity
	dxf.entities.forEach(function (ent) {
		var t = ent.type.toUpperCase();
		var color = getColor(ent.color);

		// POINT or VERTEX
		if (t === "POINT" || t === "VERTEX") {
			var x = (ent.position && ent.position.x != null ? ent.position.x : ent.x) - offsetX;
			var y = (ent.position && ent.position.y != null ? ent.position.y : ent.y) - offsetY;
			var z = (ent.position && ent.position.z != null ? ent.position.z : ent.z) || 0;
			if (x == null || y == null) {
				console.warn("POINT/VERTEX missing coords:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseName = ent.name || "pointEntity_" + ++counts.point;
				var name = getUniqueEntityName(baseName, "point");

				allKADDrawingsMap.set(name, {
					entityName: name,
					entityType: "point",
					data: [
						{
							entityName: name,
							entityType: "point",
							pointID: 1,
							pointXLocation: x,
							pointYLocation: y,
							pointZLocation: z,
							color: color
						}
					]
				});
			}
		}
		// INSERT → single point
		else if (t === "INSERT") {
			if (!ent.position) {
				console.warn("INSERT missing position:", ent);
			} else {
				var xi = ent.position.x - offsetX;
				var yi = ent.position.y - offsetY;
				var zi = ent.position.z || 0;

				// FIXED: Use unique name generation
				var baseNameI = ent.name || "pointEntity_" + ++counts.point;
				var nameI = getUniqueEntityName(baseNameI, "point");

				allKADDrawingsMap.set(nameI, {
					entityName: nameI,
					entityType: "point",
					data: [
						{
							entityName: nameI,
							entityType: "point",
							pointID: 1,
							pointXLocation: xi,
							pointYLocation: yi,
							pointZLocation: zi,
							color: color
						}
					]
				});
			}
		} else if (t === "LINE") {
			var v = ent.vertices;
			if (!v || v.length < 2) {
				console.warn("LINE missing vertices:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameL = ent.name || "lineEntity_" + ++counts.line;
				var nameL = getUniqueEntityName(baseNameL, "line");

				allKADDrawingsMap.set(nameL, {
					entityName: nameL,
					entityType: "line",
					data: [
						{
							entityName: nameL,
							entityType: "line",
							pointID: 1,
							pointXLocation: v[0].x - offsetX,
							pointYLocation: v[0].y - offsetY,
							pointZLocation: v[0].z || 0,
							lineWidth: 1,
							color: color,
							closed: false
						},
						{
							entityName: nameL,
							entityType: "line",
							pointID: 2,
							pointXLocation: v[1].x - offsetX,
							pointYLocation: v[1].y - offsetY,
							pointZLocation: v[1].z || 0,
							lineWidth: 1,
							color: color,
							closed: false
						}
					]
				});
			}
		}
		// LWPOLYLINE or POLYLINE → poly (closed) or line (open)
		else if (t === "LWPOLYLINE" || t === "POLYLINE") {
			var verts = ent.vertices || ent.controlPoints || [];
			if (!verts.length) {
				console.warn("POLYLINE missing vertices:", ent);
			} else {
				var isClosed = !!(ent.closed || ent.shape);
				var entityType = isClosed ? "poly" : "line";
				var nameP;
				if (isClosed) {
					// FIXED: Use unique name generation
					var baseNameP = ent.name || "polyEntity_" + ++counts.poly;
					nameP = getUniqueEntityName(baseNameP, "poly");
				} else {
					// FIXED: Use unique name generation
					var baseNameP = ent.name || "lineEntity_" + ++counts.line;
					nameP = getUniqueEntityName(baseNameP, "line");
				}

				allKADDrawingsMap.set(nameP, {
					entityName: nameP,
					entityType: entityType,
					data: []
				});
				var dataP = allKADDrawingsMap.get(nameP).data;
				verts.forEach(function (v, i) {
					dataP.push({
						entityName: nameP,
						entityType: entityType,
						pointID: i + 1,
						pointXLocation: v.x - offsetX,
						pointYLocation: v.y - offsetY,
						pointZLocation: v.z || 0,
						lineWidth: 1,
						color: color,
						closed: false
					});
				});
				// close if flagged
				if (isClosed) {
					var v0p = verts[0];
					dataP.push({
						entityName: nameP,
						entityType: entityType,
						pointID: dataP.length + 1,
						pointXLocation: v0p.x - offsetX,
						pointYLocation: v0p.y - offsetY,
						pointZLocation: v0p.z || 0,
						lineWidth: 1,
						color: color,
						closed: true
					});
				}
			}
		}
		// CIRCLE
		else if (t === "CIRCLE") {
			if (!ent.center) {
				console.warn("CIRCLE missing center:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameC = ent.name || "circleEntity_" + ++counts.circle;
				var nameC = getUniqueEntityName(baseNameC, "circle");

				allKADDrawingsMap.set(nameC, {
					entityName: nameC,
					entityType: "circle",
					data: [
						{
							entityName: nameC,
							entityType: "circle",
							pointID: 1,
							pointXLocation: ent.center.x - offsetX,
							pointYLocation: ent.center.y - offsetY,
							pointZLocation: ent.center.z || 0,
							radius: ent.radius,
							lineWidth: 1,
							color: color
						}
					]
				});
			}
		}
		// ELLIPSE sampled as closed polygon
		else if (t === "ELLIPSE") {
			if (!ent.center) {
				console.warn("ELLIPSE missing center:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameE = ent.name || "polyEntity_" + ++counts.poly;
				var nameE = getUniqueEntityName(baseNameE, "poly");

				allKADDrawingsMap.set(nameE, {
					entityName: nameE,
					entityType: "poly",
					data: []
				});
				var dataE = allKADDrawingsMap.get(nameE).data;
				var segs = 64;
				for (var i = 0; i < segs; i++) {
					var angle = ent.startAngle + (ent.endAngle - ent.startAngle) * (i / (segs - 1));
					var px = ent.center.x + ent.xRadius * Math.cos(angle) - offsetX;
					var py = ent.center.y + ent.yRadius * Math.sin(angle) - offsetY;
					var closed = true;
					dataE.push({
						entityName: nameE,
						entityType: "poly",
						pointID: i + 1,
						pointXLocation: px,
						pointYLocation: py,
						pointZLocation: ent.center.z || 0,
						lineWidth: 1,
						color: color,
						closed: closed
					});
				}
				// close loop
				dataE.push(
					Object.assign({}, dataE[0], {
						pointID: dataE.length + 1
					})
				);
			}
		}
		// TEXT or MTEXT
		else if (t === "TEXT" || t === "MTEXT") {
			var pos = ent.startPoint || ent.position;
			if (!pos) {
				console.warn("TEXT missing position:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameT = ent.name || "textEntity_" + ++counts.text;
				var nameT = getUniqueEntityName(baseNameT, "text");

				allKADDrawingsMap.set(nameT, {
					entityName: nameT,
					entityType: "text",
					data: [
						{
							entityName: nameT,
							entityType: "text",
							pointID: 1,
							pointXLocation: pos.x - offsetX,
							pointYLocation: pos.y - offsetY,
							pointZLocation: pos.z || 0,
							text: ent.text,
							color: color
						}
					]
				});
			}
		} // NEW: 3DFACE handling for surfaces
		else if (t === "3DFACE") {
			// 3DFACE entities have vertices property with 4 allBlastHoles (last one often duplicates first for triangles)
			var verts = ent.vertices;
			if (!verts || verts.length < 3) {
				console.warn("3DFACE missing vertices:", ent);
			} else {
				// Extract the three unique vertices for the triangle
				var p1 = {
					x: verts[0].x - offsetX,
					y: verts[0].y - offsetY,
					z: verts[0].z || 0
				};
				var p2 = {
					x: verts[1].x - offsetX,
					y: verts[1].y - offsetY,
					z: verts[1].z || 0
				};
				var p3 = {
					x: verts[2].x - offsetX,
					y: verts[2].y - offsetY,
					z: verts[2].z || 0
				};

				// Add allBlastHoles to surface allBlastHoles collection (with deduplication)
				var p1Index = addUniquePoint(surfacePoints, p1);
				var p2Index = addUniquePoint(surfacePoints, p2);
				var p3Index = addUniquePoint(surfacePoints, p3);

				// Create triangle referencing the point indices
				surfaceTriangles.push({
					vertices: [surfacePoints[p1Index], surfacePoints[p2Index], surfacePoints[p3Index]],
					minZ: Math.min(p1.z, p2.z, p3.z),
					maxZ: Math.max(p1.z, p2.z, p3.z)
				});
			}
		}
		// anything else → skip
		else {
			console.warn("Unsupported DXF entity:", ent.type);
		}
	});
	// NEW: Create and SAVE surface from 3DFACE data if any triangles were found
	if (surfaceTriangles.length > 0) {
		var surfaceName = "DXF_Surface_" + Date.now();
		var surfaceId = getUniqueEntityName(surfaceName, "surface");

		console.log("Creating surface from DXF 3DFACE entities: " + surfaceTriangles.length + " triangles, " + surfacePoints.length + " points");

		// Add to surfaces system (same as point cloud)
		loadedSurfaces.set(surfaceId, {
			id: surfaceId,
			name: surfaceId,
			points: surfacePoints,
			triangles: surfaceTriangles,
			visible: true,
			gradient: "hillshade", // Could be "hillshade" for your lighting effect
			transparency: 1.0
		});

		// Update display
		updateCentroids();
		drawData(allBlastHoles, selectedHole);

		// CRITICAL: Save to database using async pattern like point cloud loader
		setTimeout(async () => {
			try {
				await saveSurfaceToDB(surfaceId);
				console.log("✅ DXF surface saved to database: " + surfaceId);
				debouncedUpdateTreeView();
			} catch (saveError) {
				console.error("❌ Failed to save DXF surface:", saveError);
			}
		}, 100);
	}

	console.log("Appended to KAD maps:", {
		drawings: allKADDrawingsMap
	});
	// Trigger a debounced save to persist the newly loaded data
	debouncedSaveKAD();
	// Frame the newly loaded data correctly on the canvas
	zoomToFitAll();
}

function addUniquePoint(pointsArray, newPoint, tolerance = 0.001) {
	// Check if point already exists within tolerance
	for (let i = 0; i < pointsArray.length; i++) {
		const existingPoint = pointsArray[i];
		const dx = Math.abs(existingPoint.x - newPoint.x);
		const dy = Math.abs(existingPoint.y - newPoint.y);
		const dz = Math.abs(existingPoint.z - newPoint.z);

		if (dx < tolerance && dy < tolerance && dz < tolerance) {
			return i; // Return existing point index
		}
	}

	// Point doesn't exist, add it
	pointsArray.push({
		...newPoint
	}); // Create a copy to avoid reference issues
	return pointsArray.length - 1; // Return new point index
}

function handleGeotiffUpload(event) {
	const file = event.target.files[0];
	if (file) {
		loadGeoTIFF(file);
		updateStatusMessage("Loading geotiff: " + file.name);
	}
	debouncedUpdateTreeView(); // Use debounced version
}

function handleSurfaceUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	updateStatusMessage("Loading surface: " + file.name);

	// If it's an OBJ file, check for MTL first
	if (file.name.toLowerCase().endsWith(".obj")) {
		loadOBJWithMTL(file, event.target.files);
	} else {
		loadPointCloudFile(file);
	}
	debouncedUpdateTreeView(); // Use debounced version
}

// ENHANCED: Update OBJ loading to pass texture data
async function loadOBJWithMTL(objFile, allFiles) {
	try {
		const objContent = await readFileAsText(objFile);
		const baseName = objFile.name.replace(/\.obj$/i, "");

		// Look for MTL file
		let mtlContent = null;
		for (const file of allFiles) {
			if (file.name.toLowerCase() === baseName.toLowerCase() + ".mtl") {
				mtlContent = await readFileAsText(file);
				updateStatusMessage("Found material file: " + file.name);
				break;
			}
		}

		// Parse OBJ (with or without MTL)
		const objData = parseOBJFile(objContent, mtlContent);

		// Create surface using existing method
		if (objData.points && objData.points.length > 0) {
			if (objData.points.length > 10000) {
				showDecimationWarning(objData.points, objFile.name, objData);
			} else {
				processSurfacePoints(objData.points, objFile.name, objData);
			}
		}
	} catch (error) {
		// If anything fails, use normal OBJ loading
		loadPointCloudFile(objFile);
	}
}
async function handleMeasuredUpload(event) {
	// Measured data format: EntityName,EntityType,PointID,MeasuredLength,MeasuredLengthTimeStamp,MeasuredMass,MeasuredMassTimeStamp,MeasuredComment,MeasuredCommentTimeStamp

	if (!event.target.files[0].name.endsWith(".csv")) {
		fileFormatPopup("1");
		return;
	}
	if (allBlastHoles.length === 0) {
		fileFormatPopup("2");
		return;
	}

	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = function (e) {
		const fileContent = e.target.result;
		const lines = fileContent.split("\n").filter((line) => line.trim().length > 0);

		// Skip header if present
		const header = lines[0].toLowerCase();
		const startIndex = header.includes("entityname") ? 1 : 0;

		for (let i = startIndex; i < lines.length; i++) {
			const cols = lines[i].split(",");
			if (cols.length < 9) continue; // Skip malformed lines

			const entityName = cols[0].trim();
			const holeID = cols[2].trim();

			// Find matching point
			const point = allBlastHoles.find((p) => p.entityName === entityName && p.holeID === holeID);
			if (point) {
				point.measuredLength = parseFloat(cols[3]) || 0;
				point.measuredLengthTimeStamp = cols[4].trim() || "09/05/1975 00:00:00";
				point.measuredMass = parseFloat(cols[5]) || 0;
				point.measuredMassTimeStamp = cols[6].trim() || "09/05/1975 00:00:00";
				point.measuredComment = cols[7].trim();
				point.measuredCommentTimeStamp = cols[8].trim() || "09/05/1975 00:00:00";
			}
		}

		drawData(allBlastHoles, selectedHole); // Redraw to reflect updated values
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

function fileFormatPopup(error) {
	console.log("File format error");
	showModalMessage("Error " + error, "This could be related to the data structure or file.<br><br>" + "Or there are NO blasts or Holes yet, if so ignore.<br><br>" + "Only files with 4, 7, 9, 14, 30, 32 and 35 columns are Accepted<br><br>" + "Column Order and Types are important.", "error");
}
// Create a Map for each entity type to store entities by name

let allKADDrawingsMap = new Map();

function parseKADFile(fileData) {
	let minX = Infinity;
	let minY = Infinity;
	let pointID, pointXLocation, pointYLocation, pointZLocation, text, radius, color, closed, lineWidth;

	try {
		// ✅ Use PapaParse with error handling
		const parseResult = Papa.parse(fileData, {
			delimiter: "", // Auto-detect delimiter
			skipEmptyLines: true,
			trimHeaders: true,
			transform: (value) => value.trim()
		});

		// ✅ Check for critical parsing errors
		const criticalErrors = parseResult.errors.filter((error) => error.type === "Delimiter" || error.type === "Quotes");

		if (criticalErrors.length > 0) {
			showModalMessage("File Parsing Error", "Failed to parse the file properly:<br><br>" + criticalErrors.map((error) => "<li>" + error.message + "</li>").join("") + "<br><br>" + "Common causes:<br><br>" + "<li>Mixed delimiters (commas and tabs in same file)</li>" + "<li>Unescaped quotes in text fields</li>" + "<li>Inconsistent number of columns</li>" + "<br><br>" + "Please check your file format and try again.", "error");
			return; // Exit early
		}

		// ✅ Warn about minor parsing issues but continue
		if (parseResult.errors.length > 0) {
			console.warn("CSV parsing warnings:", parseResult.errors);

			const additionalErrors = parseResult.errors.length > 5 ? "<li>... and " + (parseResult.errors.length - 5) + " more</li>" : "";
			showModalMessage(
				"File Import Warning",
				"The file was imported but there were " +
					parseResult.errors.length +
					" parsing warnings:<br><br>" +
					parseResult.errors
						.slice(0, 5)
						.map((error) => "<li>Row " + error.row + ": " + error.message + "</li>")
						.join("") +
					additionalErrors +
					"<br><br>" +
					"Some data may have been skipped. Check your results carefully.",
				"warning"
			);
		}

		const dataRows = parseResult.data;

		// ✅ Check if we got any data
		if (dataRows.length === 0) {
			showModalMessage("Empty File", "The file appears to be empty or contains no valid data.", "warning");
			return;
		}

		console.log("Parsed " + dataRows.length + " rows with delimiter: " + parseResult.meta.delimiter);

		let successCount = 0;
		let errorCount = 0;
		let errorDetails = [];

		// Parse each row with individual error handling
		for (let i = 0; i < dataRows.length; i++) {
			try {
				const row = dataRows[i];

				// Skip rows that don't have enough columns
				if (row.length < 3) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Too few columns (" + row.length + ")");
					continue;
				}

				const entityName = row[0];
				const entityType = row[1];

				// Skip if missing essential data
				if (!entityName || !entityType) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Missing entity name or type");
					continue;
				}

				// ✅ Validate entity type
				const validTypes = ["point", "line", "poly", "circle", "text"];
				if (!validTypes.includes(entityType)) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Invalid entity type '" + entityType + "'");
					continue;
				}

				// ✅ Your existing parsing logic here (same as before)
				switch (entityType) {
					case "point":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "point",
								data: []
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]) || 1;
						color = (row[7] || "#FF0000").replace(/\r$/, "");

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							connected: false,
							closed: false
						});
						break;

					case "poly":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: entityType,
								data: []
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = (row[7] || "#FF0000").replace(/\r$/, "");
						closed = String(row[8]).trim().toLowerCase() === "true";

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: closed
						});
						break;

					case "line":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "line",
								data: []
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = (row[7] || "#FF0000").replace(/\r$/, "");

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "line",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: false
						});
						break;

					case "circle":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "circle",
								data: []
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						radius = parseFloat(row[6]);
						lineWidth = parseFloat(row[7]) || 1;
						color = (row[8] || "#FF0000").replace(/\r$/, "");

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "circle",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							radius: radius,
							lineWidth: lineWidth,
							color: color
						});
						break;

					case "text":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "text",
								data: []
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						text = row[6] || "";
						color = (row[7] || "#FF0000").replace(/\r$/, "");

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "text",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							text: text,
							color: color
						});
						break;
				}

				successCount++;
			} catch (rowError) {
				errorCount++;
				errorDetails.push("Row " + (i + 1) + ": " + rowError.message);
				console.error("Error parsing row " + (i + 1) + ":", rowError);
			}
		}

		// ✅ Show import results
		if (successCount > 0) {
			let message = "Successfully imported " + successCount + " items.";

			if (errorCount > 0) {
				message += "\n" + errorCount + " items failed to import.";
			}

			const errorDetailsHtml =
				errorCount > 0
					? "<details>" +
					  "<summary>View Error Details (" +
					  errorCount +
					  " errors)</summary>" +
					  '<ul style="max-height: 200px; overflow-y: auto; text-align: left;">' +
					  errorDetails
							.slice(0, 10)
							.map((error) => "<li>" + error + "</li>")
							.join("") +
					  (errorDetails.length > 10 ? "<li>... and " + (errorDetails.length - 10) + " more errors</li>" : "") +
					  "</ul>" +
					  "</details>"
					: "";

			showModalMessage(errorCount > 0 ? "Import Completed with Errors" : "Import Successful", message + errorDetailsHtml, errorCount > 0 ? "warning" : "success");
		} else {
			// ✅ Complete failure
			const errorDetailsHtml =
				'<div style="text-align: left;">' +
				"<p><strong>No items could be imported.</strong></p>" +
				"<p><strong>Common issues:</strong></p>" +
				"<ul>" +
				"<li>Wrong file format or column order</li>" +
				"<li>Missing required columns</li>" +
				"<li>Invalid data types</li>" +
				"</ul>" +
				"<details>" +
				"<summary>View Error Details</summary>" +
				'<ul style="max-height: 200px; overflow-y: auto;">' +
				errorDetails
					.slice(0, 10)
					.map((error) => "<li>" + error + "</li>")
					.join("") +
				"</ul>" +
				"</details>" +
				"</div>";

			showModalMessage("Import Failed", errorDetailsHtml, "error");
			return;
		}

		// Calculate centroid (existing logic)
		let sumX = 0;
		let sumY = 0;
		let count = 0;

		for (let [key, value] of allKADDrawingsMap) {
			for (let i = 0; i < value.data.length; i++) {
				sumX += value.data[i].pointXLocation;
				sumY += value.data[i].pointYLocation;
				count++;
			}
		}

		if (count > 0) {
			centroidX = sumX / count;
			centroidY = sumY / count;
		}

		console.log(allKADDrawingsMap);
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	} catch (error) {
		// ✅ Catch any unexpected errors
		console.error("Unexpected error during KAD file parsing:", error);

		showModalMessage("Unexpected Error", '<div style="text-align: left;">' + "<p><strong>An unexpected error occurred while importing the file:</strong></p>" + "<p><code>" + error.message + "</code></p>" + "<p>Please check the file format and try again. If the problem persists, contact support.</p>" + "</div>", "error");
	}
}

let mapData = [allKADDrawingsMap];

function exportKADFile() {
	// First, check if we have data to export
	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		alert("No data to export. Please add some drawings first.");
		return;
	}

	console.log("Exporting KAD data, map size:", allKADDrawingsMap.size);

	// Prepare the CSV content for .kad file
	let csvContentKAD = "";
	let csvContentTXT = "";

	try {
		// Directly iterate through the allKADDrawingsMap
		for (const [entityName, entityData] of allKADDrawingsMap.entries()) {
			// ✅ ONLY ADD THIS LINE - check visibility using your existing function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity:", entityName);
				continue;
			}
			// Log each entity we're processing
			console.log(`Processing entity: ${entityName}, type: ${entityData.entityType}`);

			if (!entityData || !entityData.entityType) {
				console.warn(`Skipping invalid entity: ${entityName}`);
				continue;
			}

			if (entityData.entityType.trim() === "point") {
				for (const point of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${point.pointID},${point.pointXLocation},${point.pointYLocation},${point.pointZLocation},${point.lineWidth || 1},${point.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "poly") {
				for (let i = 0; i < entityData.data.length; i++) {
					const polygon = entityData.data[i];
					const isLast = i === entityData.data.length - 1;
					const csvLine = `${entityName},${entityData.entityType},${polygon.pointID},${polygon.pointXLocation},${polygon.pointYLocation},${polygon.pointZLocation},${polygon.lineWidth},${polygon.color},${isLast ? "1" : "0"}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "line") {
				for (const entityLine of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${entityLine.pointID},${entityLine.pointXLocation},${entityLine.pointYLocation},${entityLine.pointZLocation},${entityLine.lineWidth},${entityLine.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "circle") {
				for (const circle of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${circle.pointID},${circle.pointXLocation},${circle.pointYLocation},${circle.pointZLocation},${circle.radius},${circle.lineWidth},${circle.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "text") {
				for (const text of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${text.pointID},${text.pointXLocation},${text.pointYLocation},${text.pointZLocation},${text.text},${text.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			}
		}
	} catch (error) {
		console.error("Error generating KAD export:", error);
		alert("Error exporting KAD file: " + error.message);
		return;
	}

	// If we generated any content, create and download the files
	if (csvContentKAD) {
		// Create a Blob with the CSV content for .kad file
		const blobKAD = new Blob([csvContentKAD], {
			type: "text/csv"
		});

		// Create a Blob with the CSV content for .txt file
		const blobTXT = new Blob([csvContentTXT], {
			type: "text/plain"
		});

		// Create temporary anchor elements to trigger the download for both files
		const aKAD = document.createElement("a");
		const aTXT = document.createElement("a");

		// Set the content for the anchor elements
		aKAD.href = URL.createObjectURL(blobKAD);
		aKAD.download = "KAD_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".kad";

		aTXT.href = URL.createObjectURL(blobTXT);
		aTXT.download = "TXT_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".txt";

		// Simulate clicks on both anchor elements to trigger the downloads
		aKAD.click();
		aTXT.click();

		console.log("KAD export completed successfully");
	} else {
		alert("No data to export. Please add some drawings first.");
	}
}

function getNearestNeighborDistancesByAggregation(allBlastHoles, mode, useToeLocation) {
	// Step 1: Compute nearest neighbor distances for each point
	const nearestDistances = allBlastHoles.map((pt, idx) => {
		let minDist = Infinity;
		for (let j = 0; j < allBlastHoles.length; j++) {
			if (j === idx) continue;
			const otherPt = allBlastHoles[j];

			const dx = useToeLocation ? otherPt.endXLocation - pt.endXLocation : otherPt.startXLocation - pt.startXLocation;
			const dy = useToeLocation ? otherPt.endYLocation - pt.endYLocation : otherPt.startYLocation - pt.startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			if (dist < minDist) minDist = dist;
		}
		return minDist;
	});
	// Step 2: Determine the distance to use based on the mode
	let chosenDistance;
	if (mode === "min") {
		chosenDistance = Math.min(...nearestDistances);
	} else if (mode === "max") {
		chosenDistance = Math.max(...nearestDistances);
	} else if (mode === "average" || mode === "mean") {
		const sum = nearestDistances.reduce((a, b) => a + b, 0);
		chosenDistance = sum / nearestDistances.length;
	} else if (mode === "mode") {
		// Find the most common value (rounded to nearest cm for stability)
		const freq = {};
		let maxFreq = 0,
			modeValue = nearestDistances[0];
		nearestDistances.forEach((d) => {
			const rounded = Math.round(d * 100); // round to cm
			freq[rounded] = (freq[rounded] || 0) + 1;
			if (freq[rounded] > maxFreq) {
				maxFreq = freq[rounded];
				modeValue = rounded / 100;
			}
		});
		chosenDistance = modeValue;
	} else {
		console.warn("Unknown mode for getRadiiBlastHolesPolygon:", mode, "Defaulting to  min.");
		chosenDistance = Math.min(...nearestDistances);
	}
	return chosenDistance;
}

/**
 * Get the unioned polygon of circles around blast holes, with radius based on nearest neighbor distances.
 * @param {Array} allBlastHoles - Array of allBlastHoles, each with startXLocation, startYLocation, startZLocation, endXLocation, endYLocation, endZLocation.
 * @param {number} percentDistance - Percentage to scale the chosen distance metric.
 * @param {number} steps - Number of steps for circle polygon-isation.
 * @param {string} mode - One of "min", "max", "average", "mode" (statistical mode of distances).
 * @returns {Array} Array of {x, y, z} points representing the unioned polygon.
 */
function getRadiiBlastHolesPolygon(allBlastHoles, percentDistance, steps, mode = "min") {
	const scale = 100000; // Clipper uses integers; scale meters to avoid precision loss

	// Step 2: Use the helper function to determine distance
	const chosenDistance = getNearestNeighborDistancesByAggregation(allBlastHoles, mode);

	// Step 3: Calculate the radius to use
	const radius = chosenDistance * (percentDistance / 100);

	// Step 4: Build circle polygons for each point
	const circlePolygons = allBlastHoles.map((pt) => {
		const centerX = pt.endXLocation;
		const centerY = pt.endYLocation;
		const centerZ = pt.endZLocation;
		const path = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			const z = centerZ; // keep flat for now
			path.push({
				X: Math.round(x * scale),
				Y: Math.round(y * scale),
				Z: z
			});
		}
		return path;
	});

	// Step 5: Perform union using clipper-lib
	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(circlePolygons, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		console.warn("Clipper union failed or returned empty result.");
		return [];
	}

	// Step 6: Return the unioned polygon as an array of {x, y, z}
	return solution[0].map((pt) => {
		const realX = pt.X / scale;
		const realY = pt.Y / scale;
		// Nearest Z from original centers
		let nearestZ = 0;
		let minDist = Infinity;
		allBlastHoles.forEach((p) => {
			const dx = p.startXLocation - realX;
			const dy = p.startYLocation - realY;
			const dist = dx * dx + dy * dy;
			if (dist < minDist) {
				minDist = dist;
				nearestZ = p.startZLocation;
			}
		});
		return {
			x: realX,
			y: realY,
			z: nearestZ
		};
	});
}

document.getElementById("createRadiiFromBlastHoles").addEventListener("click", function () {
	// Get the values from the input fields
	const radius = parseFloat(document.getElementById("drawingPolygonRadius").value);
	const lineWidth = parseFloat(document.getElementById("drawingLineWidth").value);
	const color = getJSColorHexDrawing();
	const steps = parseInt(document.getElementById("radiiSteps").value);
	const union = true;
	const addToMaps = true;

	// Check if the radius is a valid number
	if (isNaN(radius) || radius <= 0) {
		alert("Please enter a valid radius.");
		return;
	}
	// Check if the line width is a valid number
	if (isNaN(lineWidth) || lineWidth <= 0) {
		alert("Please enter a valid line width.");
		return;
	}

	// Determine which holes to process
	let targetHoles = allBlastHoles;
	let datasetDescription = "all holes";

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		targetHoles = selectedMultipleHoles;
		datasetDescription = "selected holes";
	} else if (selectedHole) {
		targetHoles = [selectedHole];
		datasetDescription = "selected hole";
	}

	// Add performance warning for large number of holes
	if (targetHoles.length > 1000) {
		Swal.fire({
			title: "Performance Warning",
			html: `
				<div style="text-align: center;">
					<p><strong>⚠️ Large Dataset Detected</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p style="color: #f39c12;"><strong>Warning:</strong><br>
					This may take significant time and could cause<br>
					the browser to become unresponsive.</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Recommendations:</strong></p>
					<p style="text-align: left; margin: 0 auto; display: inline-block;">
						• Reduce steps (current: ${steps})<br>
						• Process smaller sections<br>
						• Save work before continuing
					</p>
				</div>
			`,
			icon: "warning",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container"
			}
		}).then((result) => {
			if (result.isConfirmed) {
				// Show progress message
				updateStatusMessage("Processing radii polygons for " + targetHoles.length + " " + datasetDescription + "... This may take a while.");

				// Use setTimeout to allow UI to update before processing
				setTimeout(() => {
					try {
						const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
						drawData(allBlastHoles, selectedHole);
						updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
					} catch (error) {
						console.error("Error creating radii polygons:", error);
						updateStatusMessage("Error creating radii polygons. Please try with fewer holes or reduced steps.");
						Swal.fire({
							title: "Error",
							html: `
								<div style="text-align: center;">
									<p><strong>Failed to create radii polygons.</strong></p>
									<hr style="border-color: #555; margin: 15px 0;">
									<p><strong>Try:</strong></p>
									<p style="text-align: left; margin: 0 auto; display: inline-block;">
										• Reducing steps<br>
										• Processing fewer holes<br>
										• Refreshing browser
									</p>
								</div>
							`,
							icon: "error",
							customClass: {
								container: "custom-popup-container",
								confirmButton: "confirm"
							}
						});
					}
				}, 100);
			}
		});
	} else if (targetHoles.length > 500) {
		// Medium warning for 500-1000 holes
		Swal.fire({
			title: "Performance Notice",
			html: `
				<div style="text-align: center;">
					<p><strong>Medium Dataset</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Note:</strong><br>Processing may take a few moments.</p>
				</div>
			`,
			icon: "info",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container"
			}
		}).then((result) => {
			if (result.isConfirmed) {
				processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
				debouncedUpdateTreeView(); // Use debounced version
			}
		});
	} else {
		// Process normally for smaller datasets
		processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
		debouncedUpdateTreeView(); // Use debounced version
	}
});
// Helper function to check if an entity is effectively visible (including parent groups)
function isEntityEffectivelyVisible(entityName, entityType, entityVisible = true) {
	// Check blast holes
	if (entityType === "hole") {
		return blastGroupVisible && entityVisible !== false;
	}

	// Check drawings
	if (!drawingsGroupVisible) return false;

	// Check specific drawing type groups
	if (entityType === "points") return pointsGroupVisible && entityVisible !== false;
	if (entityType === "lines") return linesGroupVisible && entityVisible !== false;
	if (entityType === "polygons") return polygonsGroupVisible && entityVisible !== false;
	if (entityType === "circles") return circlesGroupVisible && entityVisible !== false;
	if (entityType === "texts") return textsGroupVisible && entityVisible !== false;

	return entityVisible !== false;
}
// Helper function to process radii polygons
function processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription) {
	try {
		updateStatusMessage("Creating radii polygons for " + targetHoles.length + " " + datasetDescription + "...");
		const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
		// Step 1) Create success message content
		const successContent = '<div style="text-align: center;">' + "<p><strong>Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".</strong></p>" + "<p><strong>Zoom or Scroll to see the results.</strong></p>" + "<p><strong>The radii is at " + radius + "m from the hole(s).</strong></p>" + "</div>";

		// Step 2) Show success modal and handle saving
		showModalMessage("Success", successContent, "success");

		// Step 3) Save the drawing and update tree view
		debouncedSaveKAD();
		debouncedUpdateTreeView(); // Use debounced version
	} catch (error) {
		console.error("Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");
		// Step 1) Create error message content
		const errorContent = '<div style="text-align: center;">' + "<p><strong>Failed to create radii polygons.</strong></p>" + '<hr style="border-color: #555; margin: 15px 0;">' + "<p><strong>Error:</strong><br>" + (error.message || "Unknown error occurred") + "</p>" + "</div>";

		// Step 2) Show error modal using showModalMessage
		showModalMessage("Error", errorContent, "error");
	}
}

// Convert hex color (e.g., #FF0000) to a DXF color index (1-255, never 0 or 256)
function getColorInteger(hex) {
	// Remove the '#' character if present
	if (hex.startsWith("#")) {
		hex = hex.slice(1);
	}
	// Parse the hex string as an integer
	const intValue = parseInt(hex, 16);
	const r = (intValue >> 16) & 0xff;
	const g = (intValue >> 8) & 0xff;
	const b = intValue & 0xff;

	// Basic mapping for common colors
	if (r === 255 && g === 0 && b === 0) return 1; // red
	if (r === 255 && g === 255 && b === 0) return 2; // yellow
	if (r === 0 && g === 255 && b === 0) return 3; // green
	if (r === 0 && g === 255 && g === 255) return 4; // cyan
	if (r === 0 && g === 0 && b === 255) return 5; // blue
	if (r === 255 && g === 0 && b === 255) return 6; // magenta
	if (r === 255 && g === 255 && g === 255) return 7; // white

	// For other colors, approximate to 8-255 (never 0 or 256)
	const gray = Math.round((r + g + b) / 3);
	const index = Math.max(8, Math.min(255, Math.round((gray / 255) * 247) + 8));
	console.log("Color index:", index);
	return index;
}

/**
 * Exports map data to a DXF (Drawing Exchange Format) string and creates a Blob for download.
 *
 * The function iterates through the provided map data and converts supported entities
 * (point, line, poly, circle, text) into their corresponding DXF representations.
 * Each entity is added to the DXF content string, which is then used to create a Blob.
 *
 * @param {Array<Map<string, Object>>} mapData - An array of Map objects, where each Map contains
 *   entity names as keys and entity data objects as values. Each entity data object should have:
 *   - {string} entityType - The type of the entity ("point", "line", "poly", "circle", "text").
 *   - {Array<Object>} data - An array of entity⣿specific data objects.
 *
 * Entity data object structure varies by entityType:
 *   - "point": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "line": { pointXLocation, pointYLocation, pointZLocation, pointXTarget, pointYTarget, pointZTarget, color }
 *   - "poly": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "circle": { pointXLocation, pointYLocation, pointZLocation, radius, color }
 *   - "text": { pointXLocation, pointYLocation, pointZLocation, text, color }
 *
 * @returns {void}
 */
function exportKADDXF() {
	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	const allMaps = [allKADDrawingsMap];

	for (const map of allMaps) {
		for (const [entityName, entityData] of map.entries()) {
			// ✅ ADD: Check if entity is visible using existing visibility function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity for DXF export:", entityName);
				continue;
			}

			const type = entityData.entityType.trim();
			const data = entityData.data;

			data.forEach((item, index) => {
				// ✅ ADD: Check individual element visibility
				if (item.visible === false) {
					return; // Skip hidden elements
				}

				//get the first color of the first point in the item
				let color = 1;
				color = typeof item.color === "string" ? getColorInteger(item.color) : 1; // default to red if no color is provided
				if (type === "point") {
					dxf += "0\nPOINT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "line") {
					if (index === 0 && data.length > 1) {
						// ✅ ADD: Filter visible points for polyline (open)
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n0\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "poly") {
					if (index === 0 && data.length > 1) {
						// ✅ ADD: Filter visible points for polyline
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n1\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "circle") {
					dxf += "0\nCIRCLE\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n" + item.radius + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "text") {
					dxf += "0\nTEXT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n0.5\n"; // text height
					dxf += "50\n0.0\n"; // rotation
					dxf += "1\n" + item.text + "\n";
					dxf += "62\n" + color + "\n";
				}
			});
		}
	}

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

/**
 * Exports visible holes as a structured DXF file with proper layer organization
 *
 * Structure:
 * - EntityName_HoleID_Collar: Green collar circle
 * - EntityName_HoleID_Track: Grey hole track line (full length)
 * - EntityName_HoleID_Grade: Orange grade circle
 * - EntityName_HoleID_Toe: Red toe circle
 * - EntityName_HoleID_Text: Grey hole ID text
 */
function exportHolesDXF(visibleBlastHoles) {
	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	visibleBlastHoles.forEach((hole) => {
		const entityName = hole.entityName || "Unknown";
		const holeID = hole.holeID || "Unknown";
		const baseLayerName = entityName + "_" + holeID;

		// Calculate hole geometry
		const startX = hole.startXLocation || 0;
		const startY = hole.startYLocation || 0;
		const startZ = hole.startZLocation || 0;

		// Calculate end point based on hole parameters
		const length = hole.holeLengthCalculated || 0;
		const angle = (hole.holeAngle || 0) * (Math.PI / 180); // Convert to radians
		const bearing = (hole.holeBearing || 0) * (Math.PI / 180); // Convert to radians
		const subdrill = hole.subdrillAmount || 0;

		// Calculate actual hole end (planned end without subdrill)
		const plannedLength = length - subdrill;
		const endX = startX + plannedLength * Math.sin(bearing) * Math.sin(angle);
		const endY = startY + plannedLength * Math.cos(bearing) * Math.sin(angle);
		const endZ = startZ - plannedLength * Math.cos(angle);

		// Calculate toe point (actual end with subdrill)
		const toeX = startX + length * Math.sin(bearing) * Math.sin(angle);
		const toeY = startY + length * Math.cos(bearing) * Math.sin(angle);
		const toeZ = startZ - length * Math.cos(angle);

		// Circle sizes
		const collarRadius = hole.holeDiameter ? hole.holeDiameter / 1000 / 2 : 0.1; // Convert mm to meters or default 0.1m
		const gradeRadius = 0.08; // 8cm radius for grade circle
		const toeRadius = 0.06; // 6cm radius for toe circle

		// 1. COLLAR CIRCLE (Green)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Collar\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n" + collarRadius + "\n";
		dxf += "420\n65280\n"; // Green (0,255,0)

		// 2. HOLE TRACK LINE (Grey - full length from collar to toe)
		dxf += "0\nLINE\n8\n" + baseLayerName + "_Track\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n"; // Start (collar)
		dxf += "11\n" + toeX + "\n21\n" + toeY + "\n31\n" + toeZ + "\n"; // End (toe)
		dxf += "420\n9868950\n"; // Grey (150,150,150)

		// 3. GRADE CIRCLE (Orange - end of planned hole)
		if (plannedLength > 0) {
			dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Grade\n";
			dxf += "10\n" + endX + "\n20\n" + endY + "\n30\n" + endZ + "\n";
			dxf += "40\n" + gradeRadius + "\n";
			dxf += "420\n16753920\n"; // Orange (255,165,0)
		}

		// 4. TOE CIRCLE (Red)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Toe\n";
		dxf += "10\n" + toeX + "\n20\n" + toeY + "\n30\n" + toeZ + "\n";
		dxf += "40\n" + toeRadius + "\n";
		dxf += "420\n16711680\n"; // Red (255,0,0)

		// 5. HOLE ID TEXT (Grey)
		dxf += "0\nTEXT\n8\n" + baseLayerName + "_Text\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n0.5\n"; // Text height (0.5m)
		dxf += "50\n0.0\n"; // Text rotation (0°)
		dxf += "1\n" + holeID + "\n";
		dxf += "420\n9868950\n"; // Grey (150,150,150)
	});

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

function convertPointsTo14ColumnCSV() {
	// ✅ Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	// Iterate over the visible allBlastHoles array
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsTo12ColumnCSV() {
	// ✅ Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToAllDataCSV() {
	// ✅ Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	const header =
		"entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID, burden, spacing, connectorCurve";
	csv += header + "\n";
	const decimalPlaces = 4;

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation.toFixed(decimalPlaces)},${hole.startYLocation.toFixed(decimalPlaces)},${hole.startZLocation},${hole.endXLocation.toFixed(decimalPlaces)},${hole.endYLocation.toFixed(decimalPlaces)},${hole.endZLocation.toFixed(decimalPlaces)},${hole.gradeXLocation.toFixed(decimalPlaces)},${hole.gradeYLocation.toFixed(decimalPlaces)},${hole.gradeZLocation.toFixed(decimalPlaces)},${hole.subdrillAmount.toFixed(
			decimalPlaces
		)},${hole.subdrillLength.toFixed(decimalPlaces)},${hole.benchHeight.toFixed(decimalPlaces)},${hole.holeDiameter.toFixed(decimalPlaces)},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated.toFixed(decimalPlaces)},${hole.holeAngle.toFixed(decimalPlaces)},${hole.holeBearing.toFixed(decimalPlaces)},${hole.holeTime},${hole.measuredLength.toFixed(decimalPlaces)},${hole.measuredLengthTimeStamp},${hole.measuredMass.toFixed(
			decimalPlaces
		)},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToActualDataCSV() {
	// ✅ Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return;

	let csv = "";
	const header = "entityName,entityType,holeID,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp";
	csv += header + "\n";

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToAQMCSV(allBlastHoles, fileNameValue, blastName, patternName, materialType, instructionValue, useHoleTypeAsInstruction, writeIngoreColumn, columnOrderArray) {
	// ✅ Filter input allBlastHoles to only visible ones
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return;

	let aqm = "";
	let material = materialType;
	let pattern = patternName;
	let blast = blastName;
	let instruction = instructionValue;
	let fileName = fileNameValue;
	let columns = columnOrderArray; // 11 possible columns

	// Iterate over the allBlastHoles array and convert each object to an AQM row
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];

		let columnOrder = []; // Initialize the column order for each row

		let toeX = parseFloat(hole.endXLocation.toFixed(4));
		let toeY = parseFloat(hole.endYLocation.toFixed(4));
		let toeZ = parseFloat(hole.endZLocation.toFixed(4));
		// Iterate over the columns and map them to their corresponding values
		for (let j = 0; j < columns.length; j++) {
			if (columns[j] === "Pattern") {
				columnOrder.push(pattern);
			} else if (columns[j] === "Blast") {
				columnOrder.push(blast);
			} else if (columns[j] === "Name") {
				columnOrder.push(hole.holeID);
			} else if (columns[j] === "Easting") {
				columnOrder.push(toeX); // Assuming 'toeX' holds the Easting value
			} else if (columns[j] === "Northing") {
				columnOrder.push(toeY); // Assuming 'toeY' holds the Northing value
			} else if (columns[j] === "Elevation") {
				columnOrder.push(toeZ); // Assuming 'toeZ' holds the Elevation value
			} else if (columns[j] === "Angle") {
				columnOrder.push(hole.holeAngle);
			} else if (columns[j] === "Azimuth") {
				let azimuth = parseFloat(((hole.holeBearing - 180) % 360).toFixed(1));
				if (azimuth < 0) {
					azimuth += 360;
				}
				columnOrder.push(azimuth);
			} else if (columns[j] === "Diameter") {
				columnOrder.push(hole.holeDiameter);
			} else if (columns[j] === "Material Type") {
				columnOrder.push(material);
			} else if (columns[j] === "Instruction") {
				if (useHoleTypeAsInstruction) {
					columnOrder.push(hole.holeType);
				} else {
					columnOrder.push(instruction);
				}
			} else if (columns[j] === "Ignore") {
				if (writeIngoreColumn) {
					columnOrder.push("ignored");
				} else {
					//do nothing
				}

				// Default to an empty string for unknown columns
			}
		}

		// Join the column values to create a row and add it to the AQM string
		const row = columnOrder.join(",");
		aqm += row + "\n";
	}

	return aqm;
}

//-----------------------------------------------------------------------------//
// ----------------------// START IREDES EPIROC SECTION //---------------------//
//#region  --------------------------------------------------------------------//

/**
 * Using SweetAlert Library Create a popup that gets input from the user.
 * @param {object[]} allBlastHoles - The allBlastHoles to convert
 * @param {string} filename - The filename to use
 * @param {string} planID - The plan ID to use
 * @param {string} siteID - The site ID to use
 * @param {boolean} holeOptions - Whether the hole options are on
 * @param {boolean} mwd - Whether the mwd is on
 * @param {string} chksumType - The type of checksum to calculate
 * @returns {void}
 */
function saveIREDESPopup() {
	//testEpirocCRC(); // Add this line to test
	// ✅ Filter allBlastHoles first
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (visibleBlastHoles.length === 0) {
		showModalMessage("No Visible Holes", "There are no visible holes to export.", "warning");
		return;
	}

	let blastName = visibleBlastHoles[0].entityName;

	console.log("blastName: " + blastName);

	// Create form content using the enhanced helper function
	const fields = [
		{
			label: "File Name",
			name: "fileName",
			value: blastName + "_XML",
			placeholder: "File Name"
		},
		{
			label: "Drill Plan ID",
			name: "planID",
			value: blastName,
			placeholder: "Plan ID"
		},
		{
			label: "Site ID",
			name: "siteID",
			value: "SiteName",
			placeholder: "Site ID"
		},
		{
			label: "Notes (max 200 chars)",
			name: "notes",
			value: "Notes",
			placeholder: "Enter notes for the XML file"
		},
		{
			label: "Hole Options On (required for mwd)",
			name: "holeOptions",
			type: "checkbox",
			checked: true
		},
		{
			label: "Set Measure While Drilling On",
			name: "mwdOn",
			type: "checkbox",
			checked: true
		},
		{
			label: "Checksum Type",
			name: "chksumValue",
			type: "select",
			value: "CRC32-DECIMAL",
			options: [
				{
					value: "CRC32-DECIMAL",
					text: "CRC32 Decimal (Epiroc)"
				},
				{
					value: "CRC32-HEXBINARY",
					text: "HexBinary (XSD Spec)"
				},
				{
					value: "ZERO",
					text: "Zero"
				},
				{
					value: "NONE",
					text: "None"
				}
			]
		}
	];

	// Create the form content
	const formContent = createEnhancedFormContent(fields, false, false);

	// Add radio buttons for hole type handling
	const holeTypeSection = document.createElement("div");
	holeTypeSection.style.marginTop = "10px";
	holeTypeSection.style.padding = "8px";
	holeTypeSection.style.border = "1px solid #666";
	holeTypeSection.style.borderRadius = "4px";
	holeTypeSection.style.backgroundColor = "rgba(255, 255, 255, 0.05)";

	const holeTypeLabel = document.createElement("label");
	holeTypeLabel.textContent = "Hole Type Handling:";
	holeTypeLabel.className = "labelWhite12";
	holeTypeLabel.style.display = "block";
	holeTypeLabel.style.marginBottom = "8px";
	holeTypeLabel.style.fontWeight = "bold";
	holeTypeSection.appendChild(holeTypeLabel);

	const radioOptions = [
		{
			value: "Undefined",
			text: 'Set all holes to "Undefined" (Epiroc Standard)'
		},
		{
			value: "convert",
			text: "Convert hole types to integers (not recommended - Groups holes by type and assigns 1-15)"
		},
		{
			value: "current",
			text: "Use hole types currently assigned (not recommended - diameters will be unavailable on RCS)"
		}
	];

	radioOptions.forEach((option, index) => {
		const radioContainer = document.createElement("div");
		radioContainer.style.display = "flex";
		radioContainer.style.alignItems = "flex-start";
		radioContainer.style.marginBottom = "6px";
		radioContainer.style.gap = "8px";

		const radio = document.createElement("input");
		radio.type = "radio";
		radio.name = "holeTypeHandling";
		radio.value = option.value;
		radio.id = "holeTypeHandling_" + option.value;
		radio.checked = index === 0; // Default to first option

		// Apply checkbox-like styling to radio buttons
		radio.style.width = "12px";
		radio.style.height = "12px";
		radio.style.margin = "0";
		radio.style.padding = "0";
		radio.style.border = "1px solid #999";
		radio.style.borderRadius = "4px"; //
		radio.style.backgroundColor = "#fff";
		radio.style.appearance = "none";
		radio.style.webkitAppearance = "none";
		radio.style.mozAppearance = "none";
		radio.style.position = "relative";
		radio.style.cursor = "pointer";
		radio.style.marginTop = "0px";

		// Force the radio button color update
		const updateRadioColor = () => {
			if (radio.checked) {
				radio.style.backgroundColor = "var(--selected-color)";
				radio.style.borderColor = "var(--selected-color)";
				// Add a white dot in the center for selected radio
				radio.style.backgroundImage = "radial-gradient(circle, white 50%, transparent 50%)";
			} else {
				radio.style.backgroundColor = "#fff";
				radio.style.borderColor = "#999";
				radio.style.backgroundImage = "none";
			}
		};

		// Initial color
		updateRadioColor();

		// Update color on change and handle radio group behavior
		radio.addEventListener("change", () => {
			// Update all radio buttons in the group
			const allRadios = formContent.querySelectorAll('input[name="holeTypeHandling"]');
			allRadios.forEach((r) => {
				if (r !== radio) {
					r.checked = false;
					// Update the color of unchecked radios
					if (r.checked) {
						r.style.backgroundColor = "var(--selected-color)";
						r.style.borderColor = "var(--selected-color)";
						r.style.backgroundImage = "radial-gradient(circle, white 50%, transparent 50%)";
					} else {
						r.style.backgroundColor = "#fff";
						r.style.borderColor = "#999";
						r.style.backgroundImage = "none";
					}
				}
			});
			updateRadioColor();
		});

		const radioLabel = document.createElement("label");
		radioLabel.htmlFor = "holeTypeHandling_" + option.value;
		radioLabel.textContent = option.text;
		radioLabel.className = "labelWhite12";
		radioLabel.style.fontSize = "10px";
		radioLabel.style.lineHeight = "1.3";
		radioLabel.style.margin = "0";
		radioLabel.style.flex = "1";

		radioContainer.appendChild(radio);
		radioContainer.appendChild(radioLabel);
		holeTypeSection.appendChild(radioContainer);
	});
	// Add the hole type section to the form
	formContent.appendChild(holeTypeSection);

	// Add note at the bottom
	const noteDiv = document.createElement("div");
	noteDiv.style.gridColumn = "1 / -1";
	noteDiv.style.marginTop = "10px";
	noteDiv.style.fontSize = "10px";
	noteDiv.style.color = "#888";
	noteDiv.textContent = "This is an XML file in the format of an Epiroc Drill Plan Export. Warning - Using hole types already attached to the blast hole may result in the diameter of the hole being ignored at the file import. Hole type conversion takes alpha values and converts to integer values that represent IREDES hole types mostly related to underground drilling.";
	formContent.appendChild(noteDiv);

	const dialog = new FloatingDialog({
		title: "Export IREDES file?",
		content: formContent,
		layoutType: "wide",
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		width: 500,
		height: 460,
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			// Get radio button value
			const holeTypeHandling = formContent.querySelector('input[name="holeTypeHandling"]:checked').value;

			// Validate required fields
			if (!formData.fileName || formData.fileName.trim() === "") {
				const errorDialog = new FloatingDialog({
					title: "File Name is Null or Invalid",
					content: "Please enter a valid file name.",
					layoutType: "default",
					width: 300,
					height: 120,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
				return;
			}

			if (!formData.planID || formData.planID.trim() === "") {
				const errorDialog = new FloatingDialog({
					title: "Invalid Plan ID",
					content: "Please enter a Drill Plan ID.",
					layoutType: "default",
					width: 300,
					height: 120,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
				return;
			}

			if (!formData.siteID || formData.siteID.trim() === "") {
				const errorDialog = new FloatingDialog({
					title: "Invalid Site ID",
					content: "Please enter a Site ID.",
					layoutType: "default",
					width: 300,
					height: 120,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
				return;
			}

			// Process notes - limit to 200 characters and remove line breaks
			let processedNotes = formData.notes || "Notes";
			processedNotes = processedNotes.replace(/[\r\n]/g, " ").substring(0, 200);

			// Additional validation for notes length
			if (processedNotes.length > 200) {
				const errorDialog = new FloatingDialog({
					title: "Notes Too Long",
					content: "Notes must be 200 characters or less. Your notes have been truncated.",
					layoutType: "default",
					width: 300,
					height: 120,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
				return;
			}

			// Generate the XML content using the updated convertPointsToIREDESXML function
			const xmlContent = convertPointsToIREDESXML(visibleBlastHoles, formData.fileName, formData.planID, formData.siteID, formData.holeOptions === "true", formData.mwdOn === "true", formData.chksumValue, processedNotes, holeTypeHandling);

			if (isIOS()) {
				// Create a Blob with the XML data
				const blob = new Blob([xmlContent], {
					type: "text/xml;charset=utf-8"
				});

				// Create a URL for the Blob
				const url = URL.createObjectURL(blob);

				// Create an anchor element with the download link
				const link = document.createElement("a");
				link.href = url;
				link.download = formData.fileName + ".xml";
				link.textContent = "Click here to download";

				// Append the link to the document
				document.body.appendChild(link);

				// Programmatically trigger the click event on the link
				link.click();

				// Remove the link from the document
				document.body.removeChild(link);
			} else {
				// Create an invisible anchor element
				const link = document.createElement("a");
				link.style.display = "none";

				// Set the XML content as the "href" attribute
				link.href = "data:text/xml;charset=utf-8," + encodeURIComponent(xmlContent);
				link.download = formData.fileName + ".xml";

				// Append the link to the document
				document.body.appendChild(link);

				// Programmatically trigger the click event on the link
				link.click();

				// Remove the link from the document
				document.body.removeChild(link);
			}
		},
		onCancel: () => {
			// Clear any dragging states when dialog closes
			isDragging = false;
			clearTimeout(longPressTimeout);
		}
	});

	dialog.show();
}
//COMPLETED: Implement the IREDES XML file generation and checksum calculation on the Checksum CRC32 function
/*
<xsd:element name="ChkSum" type="xsd:hexBinary">
<xsd:annotation> 
<xsd:documentation>Check sum including all data Objects in the Data Set  Checksum is calculated over the ENTIRE XML file ready to send using the value string  "0" as ChkSum value. After calculating the checksum the resulting value is written into the ChkSum tag thereby replacing the "0" string. Thereafter the Data Set is issued. Interpretation is done in reverse order also using "0" as a defined value of the ChkSum tag for checksum validation. The algorithm is: CRC32</xsd:documentation>
</xsd:annotation> 
</xsd:element>
*/

/**
 * Convert the allBlastHoles to an IREDES XML file
 * @param {object[]} allBlastHoles - The allBlastHoles to convert
 * @param {string} filename - The filename to use
 * @param {string} planID - The plan ID to use
 * @param {string} siteID - The site ID to use
 */
function convertPointsToIREDESXML(allBlastHoles, filename, planID, siteID, holeOptions, mwd, chksumType, notes, holeTypeHandling) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;

	const now = new Date();
	//convert now to the computer time zone
	now.setMinutes(now.getMinutes() - now.getTimezoneOffset());

	let iredesPoints = [];

	// Process hole types based on the selected handling option
	let holeTypeMapping = {};

	if (holeTypeHandling === "convert") {
		// Group holes by type and assign integers 1-15
		const holeTypes = [...new Set(allBlastHoles.map((hole) => hole.holeType || "Production"))];
		holeTypes.forEach((type, index) => {
			if (index < 15) {
				// Limit to 15 types as per IREDES standard
				holeTypeMapping[type] = (index + 1).toString();
			}
		});
	} else if (holeTypeHandling === "Undefined") {
		// Set all hole types to "Undefined"
		allBlastHoles.forEach((hole) => {
			holeTypeMapping[hole.holeType || "Production"] = "Undefined";
		});
	}
	// For "current" option, we don't modify the hole types

	allBlastHoles.forEach((hole) => {
		let processedHoleType = hole.holeType || "Production";

		// Apply hole type processing based on the selected option
		if (holeTypeHandling === "convert" && holeTypeMapping[processedHoleType]) {
			processedHoleType = holeTypeMapping[processedHoleType];
		} else if (holeTypeHandling === "Undefined") {
			processedHoleType = "Undefined";
		}

		iredesPoints.push({
			holeID: hole.holeID,
			startXLocation: hole.startXLocation,
			startYLocation: hole.startYLocation,
			startZLocation: hole.startZLocation,
			endXLocation: hole.endXLocation,
			endYLocation: hole.endYLocation,
			endZLocation: hole.endZLocation,
			holeDiameter: hole.holeDiameter,
			holeType: processedHoleType
		});
	});

	iredesPoints.sort((a, b) => a.holeID.localeCompare(b.holeID));

	// Format the date as YYYY-MM-DDTHH:mm:ss
	const formattedDate = now.toISOString().slice(0, 19);

	// Use the provided notes or default
	const processedNotes = notes || "Notes";

	const xmlHeader = `<?xml version="1.0" encoding="UTF-8"?>\r\n<!-- Generated by Kirra - https://blastingapps.com/kirra.html -->\r\n`;
	let xml = `${xmlHeader}<DRPPlan xmlns:IR="http://www.iredes.org/xml" IRVersion="V 1.0" IRDownwCompat="V 1.0" DRPPlanDownwCompat="V 1.0" DRPPlanVersion="V 1.0" xmlns="http://www.iredes.org/xml/DrillRig">\r\n`;

	// General Header
	xml += `  <IR:GenHead>\r\n`;
	xml += `    <IR:FileCreateDate>${formattedDate}</IR:FileCreateDate>\r\n`;
	xml += `      <IR:IRversion DownwCompat="V 1.0">V 1.0</IR:IRversion>\r\n`;
	xml += `    </IR:GenHead>\r\n`;
	xml += `    <IR:PlanId>${planID}</IR:PlanId>\r\n`;
	xml += `    <IR:PlanName>${planID}</IR:PlanName>\r\n`;
	xml += `    <IR:Comment>${processedNotes}</IR:Comment>\r\n`;
	xml += `    <IR:Project>${siteID}(Site)</IR:Project>\r\n`;
	xml += `    <IR:WorkOrder>${siteID}(WorkOrder)</IR:WorkOrder>\r\n`;

	// Drill Position Plan
	xml += `  <DrillPosPlan IRVersion="V 1.0" IRDownwCompat="V 1.0">\r\n`;
	xml += `    <IR:GenHead>\r\n`;
	xml += `      <IR:FileCreateDate>${formattedDate}</IR:FileCreateDate>\r\n`;
	xml += `      <IR:IRversion DownwCompat="V 1.0">V 1.0</IR:IRversion>\r\n`;
	xml += `    </IR:GenHead>\r\n`;
	xml += `    <IR:PlanId>${planID}</IR:PlanId>\r\n`;
	xml += `    <IR:PlanName>${planID}</IR:PlanName>\r\n`;
	xml += `    <IR:Comment>${processedNotes}</IR:Comment>\r\n`;
	xml += `    <IR:Project>${siteID}(Site)</IR:Project>\r\n`;
	xml += `    <IR:WorkOrder>${siteID}(WorkOrder)</IR:WorkOrder>\r\n`;

	// Position Data
	xml += `    <PositionData>\r\n`;
	xml += `      <Coordsystem>\r\n`;
	xml += `        <IR:CoordSysName>local</IR:CoordSysName>\r\n`;
	xml += `        <IR:TMatrix>\r\n`;
	xml += `          <IR:Col>\r\n`;
	xml += `            <IR:x>1.000</IR:x>\r\n`;
	xml += `            <IR:y>0.000</IR:y>\r\n`;
	xml += `            <IR:z>0.000</IR:z>\r\n`;
	xml += `            <IR:w>0.000</IR:w>\r\n`;
	xml += `          </IR:Col>\r\n`;
	xml += `          <IR:Col>\r\n`;
	xml += `            <IR:x>0.000</IR:x>\r\n`;
	xml += `            <IR:y>1.000</IR:y>\r\n`;
	xml += `            <IR:z>0.000</IR:z>\r\n`;
	xml += `            <IR:w>0.000</IR:w>\r\n`;
	xml += `          </IR:Col>\r\n`;
	xml += `          <IR:Col>\r\n`;
	xml += `            <IR:x>0.000</IR:x>\r\n`;
	xml += `            <IR:y>0.000</IR:y>\r\n`;
	xml += `            <IR:z>1.000</IR:z>\r\n`;
	xml += `            <IR:w>0.000</IR:w>\r\n`;
	xml += `          </IR:Col>\r\n`;
	xml += `          <IR:Col>\r\n`;
	xml += `            <IR:x>0.000</IR:x>\r\n`;
	xml += `            <IR:y>0.000</IR:y>\r\n`;
	xml += `            <IR:z>0.000</IR:z>\r\n`;
	xml += `            <IR:w>1.000</IR:w>\r\n`;
	xml += `          </IR:Col>\r\n`;
	xml += `        </IR:TMatrix>\r\n`;
	xml += `        <IR:CsysType>L</IR:CsysType>\r\n`;
	xml += `      </Coordsystem>\r\n`;
	xml += `      <PlanIdRef />\r\n`;
	xml += `      <Bearing>0.000</Bearing>\r\n`;
	xml += `    </PositionData>\r\n`;
	xml += `  </DrillPosPlan>\r\n`;

	// DrillPlan
	xml += `  <DrillPlan>\r\n`;
	xml += `  <NumberOfHoles>${iredesPoints.length}</NumberOfHoles>\r\n`;

	// Holes
	for (let i = 0; i < iredesPoints.length; i++) {
		const iredesPoint = iredesPoints[i];
		xml += `    <Hole>\r\n`;
		xml += `      <HoleId>${iredesPoint.holeID.trim()}</HoleId>\r\n`;
		xml += `      <HoleName>${iredesPoint.holeID.trim()}</HoleName>\r\n`;
		xml += `      <StartPoint>\r\n`;
		xml += `        <IR:PointX>${iredesPoint.startYLocation.toFixed(3)}</IR:PointX>\r\n`;
		xml += `        <IR:PointY>${iredesPoint.startXLocation.toFixed(3)}</IR:PointY>\r\n`;
		xml += `        <IR:PointZ>${iredesPoint.startZLocation.toFixed(3)}</IR:PointZ>\r\n`;
		xml += `      </StartPoint>\r\n`;
		xml += `      <EndPoint>\r\n`;
		xml += `        <IR:PointX>${iredesPoint.endYLocation.toFixed(3)}</IR:PointX>\r\n`;
		xml += `        <IR:PointY>${iredesPoint.endXLocation.toFixed(3)}</IR:PointY>\r\n`;
		xml += `        <IR:PointZ>${iredesPoint.endZLocation.toFixed(3)}</IR:PointZ>\r\n`;
		xml += `      </EndPoint>\r\n`;
		xml += `      <TypeOfHole>${iredesPoint.holeType.trim()}</TypeOfHole>\r\n`;
		xml += `      <DrillBitDia>${iredesPoint.holeDiameter}</DrillBitDia>\r\n`;
		xml += `      <MwdOn>${mwd ? "1" : "0"}</MwdOn>\r\n`;
		xml += `      <HoleOptions xmlns:opt="opt">\r\n`;
		xml += `        <opt:HoleData>\r\n`;
		xml += `          <ExtendedHoleStatus>${iredesPoint.measuredLength ? "Drilled" : "Undrilled"}</ExtendedHoleStatus>\r\n`;
		xml += `        </opt:HoleData>\r\n`;
		xml += `      </HoleOptions>\r\n`;
		xml += `    </Hole>\r\n`;
	}

	// Placeholder for the checksum with the string "0"
	const checksumPlaceholder = "0";

	// Closing the XML
	xml += `    <EquipmentData xmlns="">\r\n`;
	xml += `      <IR:OptionData />\r\n`;
	xml += `    </EquipmentData>\r\n`;
	xml += `  </DrillPlan>\r\n`;
	xml += `  <IR:GenTrailer>\r\n`;
	xml += `    <IR:FileCloseDate>${formattedDate}</IR:FileCloseDate>\r\n`;
	xml += `    <IR:ChkSum>${checksumPlaceholder}</IR:ChkSum>\r\n`;
	xml += `  </IR:GenTrailer>\r\n`;
	xml += `</DRPPlan>`;

	// Step 1: Calculate CRC32 of the ENTIRE XML (including the "0")
	let checksum = crc32(xml, chksumType);

	// Step 2: Replace the "0" with the calculated checksum
	if (chksumType === "CRC32-DECIMAL") {
		xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, `<IR:ChkSum>${checksum}</IR:ChkSum>`);
	} else if (chksumType === "CRC32-HEXBINARY") {
		xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, `<IR:ChkSum>${checksum}</IR:ChkSum>`);
	} else if (chksumType === "NONE") {
		xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, `<IR:ChkSum> </IR:ChkSum>`);
	} else {
	}

	return xml;
}

/**
 * Calculate the CRC32 checksum of a string - CORRECTED VERSION
 * @param {string} str - The string to calculate the checksum of
 * @param {string} chksumType - The type of checksum to calculate
 * @returns {number|string} - The checksum in the specified format
 */
function crc32(str, chksumType) {
	const table = new Uint32Array(256);
	for (let i = 256; i--; ) {
		let tmp = i;
		for (let k = 8; k--; ) {
			tmp = tmp & 1 ? 3988292384 ^ (tmp >>> 1) : tmp >>> 1;
		}
		table[i] = tmp;
	}

	let crc = 0xffffffff;
	for (let i = 0, l = str.length; i < l; i++) {
		crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 255];
	}

	crc = crc >>> 0; // Ensure unsigned

	// Format depending on chksumType
	if (chksumType === "CRC32-HEXBINARY") {
		return crc.toString(16).toUpperCase();
	} else {
		return crc;
	}
}

/**
 * Validate the IREDES XML file - CORRECTED VERSION
 * @param {string} xmlContent - The XML content to validate
 * @returns {object} - An object containing the validation result
 * @returns {boolean} valid - Whether the checksum is valid
 * @returns {string} originalChecksum - The original checksum
 * @returns {string} calculatedChecksum - The calculated checksum
 * @returns {string} error - The error message if the checksum is invalid
 */
function validateIREDESXML(xmlContent) {
	// Extract the checksum from the XML
	const checksumMatch = xmlContent.match(/<IR:ChkSum>([^<]+)<\/IR:ChkSum>/);
	if (!checksumMatch) {
		return {
			valid: false,
			error: "No checksum found in XML"
		};
	}

	const originalChecksum = checksumMatch[1].trim(); // FIXED: Added trim to handle whitespace

	// Replace the checksum with "0" for validation
	const xmlForValidation = xmlContent.replace(/<IR:ChkSum>[^<]+<\/IR:ChkSum>/, "<IR:ChkSum>0</IR:ChkSum>");

	// Calculate the checksum of the modified XML
	const calculatedChecksum = crc32(xmlForValidation);

	// Compare checksums (handle both decimal and hex formats)
	let isValid = false;
	const originalTrimmed = originalChecksum.trim();
	const calculatedStr = calculatedChecksum.toString();

	if (originalTrimmed === calculatedStr) {
		isValid = true; // Decimal match
	} else if (originalTrimmed.toUpperCase() === parseInt(calculatedChecksum, 10).toString(16).toUpperCase()) {
		isValid = true; // Hex match
	} else if (parseInt(originalTrimmed, 16).toString(10) === calculatedStr) {
		isValid = true; // Original was hex, calculated is decimal
	}

	return {
		valid: isValid,
		originalChecksum: originalChecksum,
		calculatedChecksum: calculatedChecksum,
		xmlForValidation: xmlForValidation, // ADDED: For debugging
		xmlLength: xmlForValidation.length, // ADDED: For debugging
		error: isValid ? null : "Checksum validation failed"
	};
}

/**
 * Test the IREDES XML checksum validation with debug output
 * @param {string} xmlContent - The XML content to test
 * @returns {object} - Debug information and validation result
 */
function testIREDESChecksumDebug(xmlContent) {
	console.log("=== IREDES CHECKSUM DEBUG TEST ===");

	// Extract original checksum
	const checksumMatch = xmlContent.match(/<IR:ChkSum>([^<]+)<\/IR:ChkSum>/);
	if (!checksumMatch) {
		console.log("ERROR: No checksum found in XML");
		return { error: "No checksum found" };
	}

	const originalChecksum = checksumMatch[1];
	console.log("Original checksum: " + originalChecksum);

	// Create validation XML with "0" placeholder
	const xmlForValidation = xmlContent.replace(/<IR:ChkSum>[^<]+<\/IR:ChkSum>/, "<IR:ChkSum>0</IR:ChkSum>");
	console.log("XML length with '0' placeholder: " + xmlForValidation.length);

	// Calculate CRC32
	const calculatedChecksum = crc32(xmlForValidation);
	console.log("Calculated CRC32: " + calculatedChecksum);
	console.log("Calculated CRC32 (hex): " + calculatedChecksum.toString(16).toUpperCase());

	// Test matches
	const decimalMatch = originalChecksum === calculatedChecksum.toString();
	const hexToDecimalMatch = parseInt(originalChecksum, 16).toString() === calculatedChecksum.toString();
	const decimalToHexMatch = originalChecksum.toUpperCase() === calculatedChecksum.toString(16).toUpperCase();

	console.log("Decimal match: " + decimalMatch);
	console.log("Hex to decimal match: " + hexToDecimalMatch);
	console.log("Decimal to hex match: " + decimalToHexMatch);

	const isValid = decimalMatch || hexToDecimalMatch || decimalToHexMatch;
	console.log("Final validation result: " + isValid);

	return {
		originalChecksum: originalChecksum,
		calculatedChecksum: calculatedChecksum,
		xmlLength: xmlForValidation.length,
		valid: isValid,
		decimalMatch: decimalMatch,
		hexToDecimalMatch: hexToDecimalMatch,
		decimalToHexMatch: decimalToHexMatch
	};
}

// Test with the actual Epiroc XML content
function testEpirocCRC() {
	// Copy the entire Epiroc XML content and replace the checksum with "0"
	const epirocXML = `PASTE XML HERE`;

	const calculatedCRC = crc32(epirocXML, "CRC32-DECIMAL");
	console.log("Epiroc test - Expected: 1723439548, Got:", calculatedCRC);
	console.log("Match:", calculatedCRC === 1723439548);
}

//#endregion ------------------------------------------------------------------//
// ----------------------// END IREDES EPIROC SECTION //-----------------------//
//-----------------------------------------------------------------------------//

//-----------------------------------------------------------------------------//
// ----------------------// ALTERNATE CHECKSUMS //-----------------------------//
//-----------------------------------------------------------------------------//
function decimalChecksum(str) {
	let checksum = 0;
	for (let i = 0; i < str.length; i++) {
		checksum += str.charCodeAt(i);
	}
	return checksum;
}

function calculateMD5Checksum(data) {
	const hash = CryptoJS.MD5(data);
	return hash.toString();
}

function calculateSHA1Checksum(data) {
	const hash = CryptoJS.SHA1(data);
	return hash.toString();
}

function calculateSHA256Checksum(data) {
	const hash = CryptoJS.SHA256(data);
	return hash.toString();
}

//-----------------------------------------------------------------------------//
// ----------------------// END ALTERNATE CHECKSUMS //-------------------------//
//-----------------------------------------------------------------------------//

function calculateTimes(allBlastHoles) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;

	//console.log("Calculating times...");
	try {
		const surfaces = {};
		holeTimes = {};

		// Build initial structures for surfaces and hole times
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			if (hole.entityName && hole.holeID && !isNaN(hole.timingDelayMilliseconds)) {
				const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
				const combinedFromHoleID = hole.fromHoleID;
				surfaces[combinedFromHoleID + ">=|=<" + combinedHoleID] = {
					time: 0,
					delay: hole.timingDelayMilliseconds
				};

				holeTimes[combinedHoleID] = null;
			} else {
				console.log("Invalid hole data:", hole);
			}
		}

		// Calculate times for each surface
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
			const combinedFromHoleID = hole.fromHoleID;
			if (combinedFromHoleID === combinedHoleID) {
				if (holeTimes[combinedHoleID] === null || hole.timingDelayMilliseconds < holeTimes[combinedHoleID]) {
					holeTimes[combinedHoleID] = hole.timingDelayMilliseconds;
				}
				updateSurfaceTimes(combinedHoleID, hole.timingDelayMilliseconds, surfaces, holeTimes);
			}
		}

		// Log the final state of surfaces and holeTimes for debugging
		//console.log("Final Surfaces:", surfaces);
		//console.log("Final Hole Times:", holeTimes);

		// Create a result array from the holeTimes object
		const result = [];
		for (const combinedHoleID in holeTimes) {
			result.push([combinedHoleID, holeTimes[combinedHoleID]]);
		}

		// Update allBlastHoles with hole times
		for (const [combinedHoleID, time] of result) {
			const [entityName, holeID] = combinedHoleID.split(":::");
			const holeIndex = allBlastHoles.findIndex((h) => h.entityName === entityName && h.holeID === holeID);
			if (holeIndex !== -1) {
				allBlastHoles[holeIndex].holeTime = time;
			}
		}

		return result;
	} catch (err) {
		console.log("Error in calculateTimes:", err);
	}
}

function updateSurfaceTimes(combinedHoleID, time, surfaces, holeTimes, visited = new Set()) {
	visited.add(combinedHoleID);
	for (const id in surfaces) {
		const [fromHoleID, toHoleID] = id.split(">=|=<");
		if (fromHoleID === combinedHoleID) {
			const surface = surfaces[id];
			const delay = surface.delay;
			if (!isNaN(delay)) {
				const toTime = parseInt(time) + parseInt(delay);
				if (!visited.has(toHoleID) && (toTime < surface.time || surface.time === 0)) {
					surface.time = toTime;
					holeTimes[toHoleID] = toTime;
					updateSurfaceTimes(toHoleID, toTime, surfaces, holeTimes, visited);
				}
			} else {
				console.log("Invalid delay:", delay, "for surface:", id);
			}
		}
	}
	visited.delete(combinedHoleID);
}

//when we added the Webworker to stop the recursion.
function delaunayContoursSync(contourData, contourLevel, maxEdgeLength) {
	// Only do the expensive calculation if contours or direction arrows are being displayed
	if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
		return {
			contourLines: [],
			directionArrows: []
		};
	}

	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;

	const factor = 1.6;
	const minAngleThreshold = 5;
	const surfaceAreaThreshold = 0.1;

	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;
	// Filter out allBlastHoles where holeTime is null
	const filteredContourData = contourData.filter((hole) => hole.holeTime !== null);

	if (filteredContourData.length < 3) return;

	// Helper function to get average distance to N nearest neighbors for a specific point
	function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
		const distances = [];

		for (let i = 0; i < allPoints.length; i++) {
			if (allPoints[i] === targetPoint) continue; // Skip self

			const dx = targetPoint.x - allPoints[i].x;
			const dy = targetPoint.y - allPoints[i].y;
			const distance = Math.sqrt(dx * dx + dy * dy);
			distances.push(distance);
		}

		// Sort distances and take the closest N neighbors
		distances.sort((a, b) => a - b);
		const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

		// Return average of nearest neighbors
		return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
	}

	// Cache for local averages to improve performance
	const localAverageCache = new Map();

	function getCachedLocalAverage(point) {
		if (!localAverageCache.has(point)) {
			localAverageCache.set(point, getLocalAverageDistance(point, filteredContourData, 6));
		}
		return localAverageCache.get(point);
	}

	// Compute Delaunay triangulation
	const delaunay = d3.Delaunay.from(filteredContourData.map((hole) => [hole.x, hole.y]));
	const triangles = delaunay.triangles; // Access the triangles property directly

	if (!triangles || triangles.length === 0) return;

	const contourLines = [];
	directionArrows = []; // Initialize an array to store the arrows

	for (let i = 0; i < triangles.length; i += 3) {
		const contourLine = [];

		const p1 = contourData[triangles[i]];
		const p2 = contourData[triangles[i + 1]];
		const p3 = contourData[triangles[i + 2]];

		// Get cached local average distances for each vertex of the triangle
		const p1LocalAvg = getCachedLocalAverage(p1);
		const p2LocalAvg = getCachedLocalAverage(p2);
		const p3LocalAvg = getCachedLocalAverage(p3);

		// Use the average of the three vertices' local averages
		const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;

		// Create adaptive max edge length for this specific triangle
		const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

		// Calculate the centroid of the triangle (average of x, y coordinates)
		const centroidX = (p1.x + p2.x + p3.x) / 3;
		const centroidY = (p1.y + p2.y + p3.y) / 3;

		// Calculate the vector representing the slope (using Z differences)
		// We'll calculate two vectors: p1->p2 and p1->p3 to get a slope direction
		const v1X = p2.x - p1.x;
		const v1Y = p2.y - p1.y;
		const v1Z = p2.z - p1.z; // Time difference between p1 and p2

		const v2X = p3.x - p1.x;
		const v2Y = p3.y - p1.y;
		const v2Z = p3.z - p1.z; // Time difference between p1 and p3

		// Now we calculate the cross product of these two vectors to get the slope normal
		const slopeX = v1Y * v2Z - v1Z * v2Y;
		const slopeY = v1Z * v2X - v1X * v2Z;
		const slopeZ = v1X * v2Y - v1Y * v2X;

		// Normalize the slope vector (we don't care about the Z component for 2D projection)
		const slopeLength = Math.sqrt(slopeX * slopeX + slopeY * slopeY);
		const normSlopeX = slopeX / slopeLength;
		const normSlopeY = slopeY / slopeLength;

		// Calculate the end point for the arrow based on the normalized slope
		const arrowLength = 2; // Arrow length
		const arrowEndX = centroidX - normSlopeX * firstMovementSize;
		const arrowEndY = centroidY - normSlopeY * firstMovementSize;

		// Get the triangle's surface area
		const surfaceArea = Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);

		// Check if triangle passes the local adaptive filtering
		let trianglePassesFilter = true;

		// Calculate edge lengths and check against adaptive limit
		const edge1Length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
		const edge2Length = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
		const edge3Length = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));

		if (edge1Length > adaptiveMaxEdgeLength || edge2Length > adaptiveMaxEdgeLength || edge3Length > adaptiveMaxEdgeLength) {
			trianglePassesFilter = false;
		}

		// Optional: Add angle check to reject very acute triangles
		if (trianglePassesFilter) {
			// Calculate angles using law of cosines
			const edge1Squared = edge1Length * edge1Length;
			const edge2Squared = edge2Length * edge2Length;
			const edge3Squared = edge3Length * edge3Length;

			const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2Length * edge3Length)))) * (180 / Math.PI);
			const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1Length * edge3Length)))) * (180 / Math.PI);
			const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1Length * edge2Length)))) * (180 / Math.PI);

			const minAngle = Math.min(angle1, angle2, angle3);

			// Reject triangles with very acute angles (likely bridging triangles)
			if (minAngle < minAngleThreshold) {
				trianglePassesFilter = false;
			}
		}

		// Only process triangles that pass the adaptive filtering
		if (trianglePassesFilter) {
			if (surfaceArea > surfaceAreaThreshold) {
				// Store the arrow (start at the centroid, end at the calculated slope direction)
				directionArrows.push([centroidX, centroidY, arrowEndX, arrowEndY, "goldenrod", firstMovementSize]);
			}

			// Process the contour lines with adaptive edge length filtering
			for (let j = 0; j < 3; j++) {
				const p1 = contourData[triangles[i + j]];
				const p2 = contourData[triangles[i + ((j + 1) % 3)]];

				// Calculate distance between p1 and p2
				const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

				// Use adaptive edge length instead of global maxEdgeLength
				if (distance <= adaptiveMaxEdgeLength && ((p1.z < contourLevel && p2.z >= contourLevel) || (p1.z >= contourLevel && p2.z < contourLevel))) {
					const point = interpolate(p1, p2, contourLevel);
					contourLine.push(point);
				}
			}

			if (contourLine.length === 2) {
				contourLines.push(contourLine);
			}
		}
	}

	const interval = 1; // Keep every arrow
	directionArrows = directionArrows.filter((arrow, index) => index % interval === 0);

	// Optional: Log some statistics for debugging
	// console.log("Contour generation completed:");
	// console.log("- Total contour lines:", contourLines.length);
	// console.log("- Direction arrows:", directionArrows.length);
	// console.log("- Cache size:", localAverageCache.size);

	// Return both contour lines and the newly created arrows
	return {
		contourLines,
		directionArrows
	};
}

function interpolate(p1, p2, contourLevel) {
	const t = (contourLevel - p1.z) / (p2.z - p1.z);
	return {
		x: p1.x + t * (p2.x - p1.x),
		y: p1.y + t * (p2.y - p1.y)
	};
}

function simplifyLine(line, epsilon) {
	if (line.length <= 2) return line;

	const firstPoint = line[0];
	const lastPoint = line[line.length - 1];
	const lineDistSq = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

	const { maxDist, maxDistPoint } = line.slice(1, -1).reduce(
		(result, point, i) => {
			const distSq = pointToLineDistanceSq(point, firstPoint, lastPoint, lineDistSq);
			if (distSq > result.maxDist) {
				return {
					maxDist: distSq,
					maxDistPoint: {
						index: i + 1,
						point
					}
				};
			}
			return result;
		},
		{
			maxDist: 0,
			maxDistPoint: {
				index: 0,
				point: null
			}
		}
	);

	if (Math.sqrt(maxDist) > epsilon) {
		const left = simplifyLine(line.slice(0, maxDistPoint.index + 1), epsilon);
		const right = simplifyLine(line.slice(maxDistPoint.index), epsilon);

		return left.slice(0, left.length - 1).concat(right);
	} else {
		return [firstPoint, lastPoint];
	}
}
// NEW: Pixel distance simplification function
function simplifyByPxDist(points, pxThreshold = 5) {
	if (!points || points.length < 2) return points;

	const pxThresholdSq = pxThreshold * pxThreshold;
	const simplified = [points[0]]; // Always keep first point

	let lastKeptPoint = points[0];
	let [lastKeptX, lastKeptY] = worldToCanvas(lastKeptPoint.pointXLocation, lastKeptPoint.pointYLocation);

	for (let i = 1; i < points.length; i++) {
		const currentPoint = points[i];
		const [currentX, currentY] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);

		const dx = currentX - lastKeptX;
		const dy = currentY - lastKeptY;

		// Keep point if distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxThresholdSq || i === points.length - 1) {
			simplified.push(currentPoint);
			lastKeptPoint = currentPoint;
			lastKeptX = currentX;
			lastKeptY = currentY;
		}
	}

	return simplified;
}
//NEW: Add this hybrid simplification function that is WAY TOO AGGRESSIVE. - DO NOT USE.
function hybridSimplify(points, currentScale, isPolygon = false) {
	if (!points || points.length < 3) return points;

	const pxDistThresholdSq = 5 * 5; // pixel threshold squared
	const epsilon = 0.05 / currentScale; // RDP simplification tolerance

	// Convert to canvas coordinates for pixel distance calculations
	const canvasPoints = points.map((p) => {
		const [x, y] = worldToCanvas(p.pointXLocation, p.pointYLocation);
		return {
			...p,
			_cx: x,
			_cy: y
		};
	});

	// Detect closed & small polygon/shape - preserve important small features
	const isClosed = isPolygon && points.length > 2;

	if (isClosed) {
		// Calculate approximate area in world coordinates
		let area = 0;
		for (let i = 0; i < points.length - 1; i++) {
			const p1 = points[i];
			const p2 = points[i + 1];
			area += p1.pointXLocation * p2.pointYLocation - p2.pointXLocation * p1.pointYLocation;
		}
		// If area is very small, preserve the shape without simplification
		if (Math.abs(area / 2) < 5 / currentScale) {
			return points;
		}
	}

	// Step 1: Pixel distance pre-filter - but keep consecutive points
	const pxFiltered = [canvasPoints[0]];
	for (let i = 1; i < canvasPoints.length; i++) {
		const current = canvasPoints[i];
		const previous = pxFiltered[pxFiltered.length - 1];
		const dx = current._cx - previous._cx;
		const dy = current._cy - previous._cy;

		// Keep point if pixel distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxDistThresholdSq || i === canvasPoints.length - 1) {
			pxFiltered.push(current);
		}
	}

	// Step 2: Apply RDP only if we have enough points and they're not too simplified already
	if (pxFiltered.length < 3) {
		return points; // Return original if too few points
	}

	// Remove canvas coordinates before RDP
	const worldFiltered = pxFiltered.map((p) => {
		const { _cx, _cy, ...worldPoint } = p;
		return worldPoint;
	});

	const rdpSimplified = simplifyLine(worldFiltered, epsilon);
	return rdpSimplified;
}

function pointToLineDistanceSq(point, lineStart, lineEnd, lineDistSq) {
	const t = ((point.x - lineStart.x) * (lineEnd.x - lineStart.x) + (point.y - lineStart.y) * (lineEnd.y - lineStart.y)) / lineDistSq;

	if (t < 0) {
		return (lineStart.x - point.x) ** 2 + (lineStart.y - point.y) ** 2;
	} else if (t > 1) {
		return (lineEnd.x - point.x) ** 2 + (lineEnd.y - point.y) ** 2;
	} else {
		const projX = lineStart.x + t * (lineEnd.x - lineStart.x);
		const projY = lineStart.y + t * (lineEnd.y - lineStart.y);
		return (point.x - projX) ** 2 + (point.y - projY) ** 2;
	}
}

function getVisibleHolesAndKADDrawings(allBlastHoles, allKADDrawings) {
	try {
		const visibleHoles = allBlastHoles.filter((hole) => hole.visible);

		// Fix KAD drawings filtering - check if entity is visible using isEntityVisible
		const visibleKADDrawings = allKADDrawings.filter((drawing) => {
			// Check if the drawing has a visible property, or use isEntityVisible function
			if (drawing.visible !== undefined) {
				return drawing.visible;
			} else if (drawing.entityName) {
				return isEntityVisible(drawing.entityName);
			}
			// If no visibility info, assume it's visible
			return true;
		});

		console.log("�� getVisibleHolesAndKADDrawings - allBlastHoles:", allBlastHoles.length);
		console.log("�� getVisibleHolesAndKADDrawings - allKADDrawings:", allKADDrawings.length);
		console.log("�� getVisibleHolesAndKADDrawings - visibleHoles:", visibleHoles.length);
		console.log("�� getVisibleHolesAndKADDrawings - visibleKADDrawings:", visibleKADDrawings.length);

		return {
			visibleHoles,
			visibleKADDrawings
		};
	} catch (err) {
		console.log("Error in getVisibleHolesAndKADDrawings:", err);
		return {
			visibleHoles: [],
			visibleKADDrawings: []
		};
	}
}

// make a global Earcut
const useEarcut = getEarcut();

// ✅ ROBUST: Check how earcut is available
function getEarcut() {
	if (typeof earcut !== "undefined") {
		// Check if it's the direct function or has .default
		return typeof earcut === "function" ? earcut : earcut.default;
	}
	throw new Error("Earcut library not found");
}

// Unified point-in-polygon function that handles all data formats
// FIX FOR THE TRIANGULATION TOOL
function isPointInPolygonObject(x, y, polygon) {
	let inside = false;
	let vertices = [];

	// Handle different polygon formats
	if (Array.isArray(polygon)) {
		// Handle array of points (most common case)
		vertices = polygon.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y
		}));
	} else if (polygon.data) {
		// Handle KAD polygon with data property
		vertices = polygon.data.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y
		}));
	} else if (polygon.points) {
		// Handle polygon with points property
		vertices = polygon.points.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y
		}));
	}

	// Ray casting algorithm
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		const xi = vertices[i].x;
		const yi = vertices[i].y;
		const xj = vertices[j].x;
		const yj = vertices[j].y;

		if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {
			inside = !inside;
		}
	}

	return inside;
}

//===========================
//#region DELAUNAY TRIANGULATION  - SURFACE TOOL - START
//===========================

const triangulateTool = document.getElementById("triangulateTool");

// Tool event listener
triangulateTool.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("triangulateTool");

		isTriangulateTool = true;
		triangulateTool.checked = true;

		//handleContourTriangulationAction();
		handleTriangulationAction();

		isTriangulateTool = false;
		triangulateTool.checked = false;
	}
});
// Check each entity individually
if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
	allKADDrawingsMap.forEach((entity, entityName) => {
		const isVisible = isEntityVisible(entityName);
		console.log(`📋 Entity "${entityName}": type=${entity.entityType}, points=${entity.data ? entity.data.length : 0}, visible=${isVisible}`);
		if (!isVisible) {
			console.log(`❌ Why not visible: drawingsGroupVisible=${drawingsGroupVisible}, entity.visible=${entity.visible}, typeGroupVisible=${getTypeGroupVisible(entity.entityType)}`);
		}
	});
}
function getTypeGroupVisible(entityType) {
	switch (entityType) {
		case "point":
			return pointsGroupVisible;
		case "line":
			return linesGroupVisible;
		case "poly":
			return polygonsGroupVisible;
		case "circle":
			return circlesGroupVisible;
		default:
			return true;
	}
}
function handleTriangulationAction() {
	console.log("🔺 Delaunay triangulation action triggered");

	// Step 1) Debug visibility flags
	console.log("🔍 Debugging triangulation visibility:");
	console.log("📊 allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
	console.log("🌍 drawingsGroupVisible:", drawingsGroupVisible);
	console.log("�� pointsGroupVisible:", pointsGroupVisible);
	console.log("📏 linesGroupVisible:", linesGroupVisible);
	console.log("🔸 polygonsGroupVisible:", polygonsGroupVisible);
	console.log("💥 blastGroupVisible:", blastGroupVisible);

	// Check for any visible data
	let hasVisibleData = false;
	let visibleEntities = [];

	// Step 2) Check KAD drawings with detailed logging
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("🔍 Checking KAD drawings for visibility:");
		allKADDrawingsMap.forEach((entity) => {
			const isVisible = isEntityVisible(entity.entityName);
			console.log("  - " + entity.entityName + " (" + entity.entityType + "): " + (isVisible ? "✅ Visible" : "❌ Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(entity.entityName);
			}
		});
	}

	// Step 3) Check blast holes with detailed logging
	if (!hasVisibleData && allBlastHoles && allBlastHoles.length > 0) {
		console.log("🔍 Checking blast holes for visibility:");
		allBlastHoles.forEach((hole) => {
			const isVisible = isHoleVisible(hole);
			// Step 1) Fix the logging to use the correct property name
			const holeIdentifier = hole.entityName + ":" + hole.holeID || "Unknown";
			console.log("  - " + holeIdentifier + ": " + (isVisible ? "✅ Visible" : "❌ Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(holeIdentifier);
			}
		});
	}

	if (!hasVisibleData) {
		console.log("❌ No visible data found for triangulation");
		console.log("📋 Visible entities found:", visibleEntities);
		updateStatusMessage("No visible data found for triangulation");
		return;
	}

	console.log("✅ Found visible data for triangulation:", visibleEntities);
	updateStatusMessage("Ready for triangulation ✅");
	showTriangulationPopup();
}

//Take the visible veritces and filter any points the are within a 3D tolerance
function getUniqueElementVertices(xyzVertices, tolerance = 0.001) {
	let uniqueVertices = [];

	xyzVertices.forEach((vertex) => {
		let isDuplicate = false;

		// Check against all existing unique vertices
		for (let i = 0; i < uniqueVertices.length; i++) {
			const existing = uniqueVertices[i];
			const dx = vertex.x - existing.x;
			const dy = vertex.y - existing.y;
			const dz = vertex.z - existing.z;
			const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

			if (distance <= tolerance) {
				isDuplicate = true;
				break;
			}
		}

		// Only add if not within tolerance of any existing vertex
		if (!isDuplicate) {
			uniqueVertices.push(vertex);
		}
	});

	return uniqueVertices;
}

function createDelaunayTriangulation(params) {
	// Add the getX and getY functions at the top of the function
	const getX = (point) => parseFloat(point.x);
	const getY = (point) => parseFloat(point.y);

	try {
		// Fix the function call by passing the required parameters
		let visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("🔍 Debug - visibleElements:", visibleElements);
		console.log("🔍 Debug - allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
		console.log("🔍 Debug - visibleKADDrawings count:", visibleElements.visibleKADDrawings ? visibleElements.visibleKADDrawings.length : 0);

		// Extract parameters
		const minAngleTolerance = params.minAngle || 0;
		const maxEdgeLength = params.maxEdgeLength || 0;
		const tolerance = params.tolerance || 0.001;

		// Collect all vertices from visible elements
		let elementVertices = [];

		// Add blast hole vertices based on parameters
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			// Step 1) Fix property name mismatch - use visibleHoles instead of visibleBlastHoles
			const visibleHoles = visibleElements.visibleHoles || [];
			visibleHoles.forEach((hole) => {
				if (params.useCollars) {
					// Step 2) Map collar coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0
					});
				}
				if (params.useGrade && hole.gradeXLocation !== undefined) {
					// Step 3) Map grade coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0
					});
				}
				if (params.useToe && hole.endXLocation !== undefined) {
					// Step 4) Map toe coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0
					});
				}
				if (params.useMLength && hole.mLengthXLocation !== undefined) {
					// Step 5) Map measured length coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0
					});
				}
			});
		}

		// Add KAD drawing vertices
		visibleElements.visibleKADDrawings.forEach((entity) => {
			if (entity.data && Array.isArray(entity.data)) {
				entity.data.forEach((point) => {
					elementVertices.push({
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0
					});
				});
			}
		});

		// Remove duplicate vertices within tolerance
		elementVertices = getUniqueElementVertices(elementVertices, tolerance);

		console.log("🎯 Unique vertices after deduplication:", elementVertices.length);

		if (elementVertices.length < 3) {
			console.warn("❌ Insufficient vertices for triangulation. Found:", elementVertices.length);
			return {
				resultTriangles: [],
				points: []
			};
		}

		console.log("✅ Creating triangulation with", elementVertices.length, "vertices");

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(elementVertices, getX, getY);

		// Array to store valid triangles
		const resultTriangles = [];

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1.x - p2.x;
			const dy = p1.y - p2.y;
			return dx * dx + dy * dy;
		}

		// Process each triangle
		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = elementVertices[p1Index];
			const p2 = elementVertices[p2Index];
			const p3 = elementVertices[p3Index];

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared(p1, p2);
			const edge2Squared = distanceSquared(p2, p3);
			const edge3Squared = distanceSquared(p3, p1);

			// Use user-defined max edge length or skip edge culling if 0
			const maxEdgeLengthSquared = maxEdgeLength > 0 ? maxEdgeLength ** 2 : Infinity;

			// Check if all edge lengths are within the limit (or skip if maxEdgeLength is 0)
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles
				if (minAngleTolerance > 0) {
					const edge1 = Math.sqrt(edge1Squared);
					const edge2 = Math.sqrt(edge2Squared);
					const edge3 = Math.sqrt(edge3Squared);

					// Calculate angles using law of cosines
					const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
					const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
					const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

					const minAngle = Math.min(angle1, angle2, angle3);

					// Reject very acute triangles
					if (minAngle < minAngleTolerance) {
						continue; // Skip this triangle
					}
				}

				// ✅ FIX: Create triangle in the CORRECT format that matches the rest of your system
				// This should match the format used in parseDXFToKAD and other parts
				resultTriangles.push({
					vertices: [
						{
							x: parseFloat(p1.x),
							y: parseFloat(p1.y),
							z: parseFloat(p1.z)
						}, // Vertex objects, not arrays
						{
							x: parseFloat(p2.x),
							y: parseFloat(p2.y),
							z: parseFloat(p2.z)
						},
						{
							x: parseFloat(p3.x),
							y: parseFloat(p3.y),
							z: parseFloat(p3.z)
						}
					],
					minZ: Math.min(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z)),
					maxZ: Math.max(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z))
				});
			}
		}

		console.log("🎉 Generated", resultTriangles.length, "triangles");

		// ✅ FIX: Return triangles in the correct format that matches your system
		return {
			resultTriangles: resultTriangles, // Already in correct format
			points: elementVertices // Return the actual points used for triangulation
		};
	} catch (err) {
		console.error("❌ Error in createDelaunayTriangulation:", err);
		return {
			resultTriangles: [],
			points: []
		};
	}
}

// ✅ FIX: Get the complete polygon data from allKADDrawingsMap
function deleteTrianglesByClippingPolygon(surfaceId, option = "outside") {
	console.log("🔪 Clipping triangles from surface:", surfaceId, "option:", option);

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("❌ Surface not found:", surfaceId);
		return false;
	}

	// ✅ FIX: Get the complete polygon from allKADDrawingsMap using the entity name
	let selectedPolygon = null;
	if (selectedKADObject && selectedKADObject.entityType === "poly" && selectedKADObject.entityName) {
		selectedPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
		console.log("🔍 Found polygon entity:", selectedKADObject.entityName, "with data:", selectedPolygon ? selectedPolygon.data?.length : "none");
	}

	if (!selectedPolygon || !selectedPolygon.data || selectedPolygon.data.length < 3) {
		console.error("❌ No valid polygon selected for clipping. Selected:", selectedKADObject?.entityName, "Found polygon:", !!selectedPolygon, "Data points:", selectedPolygon?.data?.length);
		return false;
	}

	console.log("📐 Clipping polygon:", selectedPolygon.entityName, "with", selectedPolygon.data.length, "points");

	// Filter triangles based on the option
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		// Calculate triangle centroid
		const centroidX = (parseFloat(triangle.vertices[0].x) + parseFloat(triangle.vertices[1].x) + parseFloat(triangle.vertices[2].x)) / 3;
		const centroidY = (parseFloat(triangle.vertices[0].y) + parseFloat(triangle.vertices[1].y) + parseFloat(triangle.vertices[2].y)) / 3;

		// Use your existing isPointInPolygonObject function with the complete polygon
		const isInside = isPointInPolygonObject(centroidX, centroidY, selectedPolygon);

		// Apply the clipping logic based on option
		if (option === "outside") {
			// Keep triangles inside the polygon (delete those outside)
			return isInside;
		} else if (option === "inside") {
			// Keep triangles outside the polygon (delete those inside)
			return !isInside;
		}

		// Default: keep all triangles
		return true;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("✂️ Clipping complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.clippedTriangles = deletedCount;
		surface.metadata.clippingOption = option;
		surface.metadata.clippingPolygon = selectedPolygon.entityName;
	}

	return true;
}

// ✅ NEW: Delete triangles based on edge length criteria
function deleteTrianglesByEdgeLength(surfaceId, minEdgeLength = 0, maxEdgeLength = 0, use3DLength = false) {
	console.log("📏 Filtering triangles by edge length:", surfaceId, "min:", minEdgeLength, "max:", maxEdgeLength, "3D:", use3DLength);

	// Skip filtering if both min and max are 0
	if (minEdgeLength <= 0 && maxEdgeLength <= 0) {
		console.log("⏭️ Skipping edge length filtering (both min and max = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("❌ Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on edge lengths
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DLength) {
			// 3D edge lengths including Z
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only)
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		const edges = [edge1, edge2, edge3];
		const maxEdge = Math.max(...edges);
		const minEdge = Math.min(...edges);

		// Apply filtering criteria
		let keepTriangle = true;

		// Check minimum edge length
		if (minEdgeLength > 0 && minEdge < minEdgeLength) {
			keepTriangle = false;
		}

		// Check maximum edge length
		if (maxEdgeLength > 0 && maxEdge > maxEdgeLength) {
			keepTriangle = false;
		}

		return keepTriangle;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("📏 Edge length filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.edgeFilteredTriangles = deletedCount;
		surface.metadata.minEdgeLength = minEdgeLength;
		surface.metadata.maxEdgeLength = maxEdgeLength;
		surface.metadata.use3DLength = use3DLength;
	}

	return true;
}

// ✅ UPDATED: Delete triangles with internal angles smaller than minimum (2D or 3D)
function deleteTrianglesByInternalAngle(surfaceId, internalAngleMin = 0, use3DAngle = false) {
	console.log("📐 Filtering triangles by internal angle:", surfaceId, "min angle:", internalAngleMin + "°", "3D:", use3DAngle);

	// Skip filtering if angle is 0
	if (internalAngleMin <= 0) {
		console.log("⏭️ Skipping angle filtering (min angle = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("❌ Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on internal angles
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DAngle) {
			// 3D edge lengths including Z for accurate 3D angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only) for plan view angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		// Calculate internal angles using law of cosines
		const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2 * edge2 + edge3 * edge3 - edge1 * edge1) / (2 * edge2 * edge3)))) * (180 / Math.PI);
		const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge3 * edge3 - edge2 * edge2) / (2 * edge1 * edge3)))) * (180 / Math.PI);
		const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge2 * edge2 - edge3 * edge3) / (2 * edge1 * edge2)))) * (180 / Math.PI);

		const minAngle = Math.min(angle1, angle2, angle3);

		// Keep triangles with all angles >= minimum
		return minAngle >= internalAngleMin;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("📐 Angle filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.angleFilteredTriangles = deletedCount;
		surface.metadata.minInternalAngle = internalAngleMin;
		surface.metadata.use3DAngle = use3DAngle;
	}

	return true;
}

// ✅ NEW: Get visible KAD entities filtered by clipping polygon if needed
function getVisibleKADEntitiesForConstraints(useClippingFilter = false) {
	const visibleEntities = [];

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		return visibleEntities;
	}

	// Get clipping polygon if needed
	let clippingPolygon = null;
	if (useClippingFilter && selectedKADObject && selectedKADObject.entityType === "poly") {
		clippingPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
	}

	allKADDrawingsMap.forEach((entity, entityName) => {
		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		// Check if entity is visible
		if (!isEntityVisible(entityName)) {
			return;
		}

		// Filter by clipping polygon if specified
		if (clippingPolygon && useClippingFilter) {
			if (!entityIntersectsClippingPolygon(entity, clippingPolygon)) {
				return;
			}
		}

		// Add valid constraint entity
		visibleEntities.push({
			...entity,
			entityName: entityName,
			pointList2D: entity.data.map((p) => ({ x: parseFloat(p.pointXLocation), y: parseFloat(p.pointYLocation) })),
			pointList3D: entity.data.map((p) => ({ x: parseFloat(p.pointXLocation), y: parseFloat(p.pointYLocation), z: parseFloat(p.pointZLocation) || 0 })),
			isLineOrPoly: entity.entityType
		});
	});

	console.log("📋 Found", visibleEntities.length, "visible KAD entities for constraints");
	return visibleEntities;
}

// ✅ NEW: Check if entity intersects with clipping polygon
function entityIntersectsClippingPolygon(entity, clippingPolygon) {
	if (!entity.data || !clippingPolygon.data) return false;

	// Check if any point of the entity is inside or if any segment intersects the clipping polygon
	for (let i = 0; i < entity.data.length; i++) {
		const point = entity.data[i];
		const x = parseFloat(point.pointXLocation);
		const y = parseFloat(point.pointYLocation);

		// Check if point is inside clipping polygon
		if (isPointInPolygonObject(x, y, clippingPolygon)) {
			return true;
		}

		// Check if segment intersects clipping polygon boundary
		if (i < entity.data.length - 1) {
			const nextPoint = entity.data[i + 1];
			const x2 = parseFloat(nextPoint.pointXLocation);
			const y2 = parseFloat(nextPoint.pointYLocation);

			if (lineIntersectsPolygon(x, y, x2, y2, clippingPolygon)) {
				return true;
			}
		}
	}

	return false;
}

// ✅ NEW: Check if triangle intersects with KAD entity (line or polygon)
function checkTriangleIntersectsKADEntity(triangle, kadEntity) {
	const vertices = triangle.vertices;

	// For each segment in the KAD entity
	for (let i = 0; i < kadEntity.pointList2D.length - 1; i++) {
		const segStart = kadEntity.pointList2D[i];
		const segEnd = kadEntity.pointList2D[i + 1];

		// Check if KAD segment intersects any triangle edge
		for (let j = 0; j < 3; j++) {
			const triStart = vertices[j];
			const triEnd = vertices[(j + 1) % 3];

			if (lineSegmentsIntersect(segStart.x, segStart.y, segEnd.x, segEnd.y, triStart.x, triStart.y, triEnd.x, triEnd.y)) {
				return true;
			}
		}

		// Check if KAD segment passes through triangle interior
		if (lineIntersectsTriangle(segStart.x, segStart.y, segEnd.x, segEnd.y, vertices)) {
			return true;
		}
	}

	return false;
}

// ✅ HELPER: Check if two line segments intersect
function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	if (Math.abs(denom) < 1e-10) return false; // Lines are parallel

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// ✅ HELPER: Check if line intersects polygon
function lineIntersectsPolygon(x1, y1, x2, y2, polygon) {
	if (!polygon.data) return false;

	for (let i = 0; i < polygon.data.length - 1; i++) {
		const p1 = polygon.data[i];
		const p2 = polygon.data[i + 1];

		if (lineSegmentsIntersect(x1, y1, x2, y2, parseFloat(p1.pointXLocation), parseFloat(p1.pointYLocation), parseFloat(p2.pointXLocation), parseFloat(p2.pointYLocation))) {
			return true;
		}
	}

	return false;
}

// ===================================================================
// =============================================================================
// STEP 1: REPLACE - New Constrained Delaunay Triangulation Function
// =============================================================================

async function createConstrainedDelaunayTriangulation(params) {
	console.log("🔗 Using FIXED Constrained Delaunay Triangulation (Constrainautor)");

	try {
		// Get visible elements
		const visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("📊 Found " + (visibleElements.visibleHoles?.length || 0) + " visible holes, " + (visibleElements.visibleKADDrawings?.length || 0) + " visible KAD drawings");

		// Collect data points with source tracking
		let elementVertices = [];
		const kadSourceMap = new Map(); // Track which KAD entities contributed vertices

		// *** FIX 1: Standardized blast hole coordinate access ***
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			const visibleHoles = visibleElements.visibleHoles || [];
			console.log("🕳️ Processing " + visibleHoles.length + " blast holes");

			visibleHoles.forEach((hole, index) => {
				// Collar points (surface)
				if (params.useCollars && hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_collar",
						sourceType: "hole"
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("⚠️ Invalid collar coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Grade points (mid-hole)
				if (params.useGrade && hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_grade",
						sourceType: "hole"
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("⚠️ Invalid grade coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Toe points (bottom)
				if (params.useToe && hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_toe",
						sourceType: "hole"
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("⚠️ Invalid toe coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Measured length points
				if (params.useMLength && hole.mLengthXLocation !== undefined && hole.mLengthYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_mlength",
						sourceType: "hole"
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("⚠️ Invalid mLength coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}
			});
		}

		// *** FIX 2: KAD drawing vertices with constraint source tracking ***
		visibleElements.visibleKADDrawings.forEach((entity, entityIndex) => {
			if (entity.data && Array.isArray(entity.data)) {
				const entityName = entity.entityName || "entity_" + entityIndex;
				console.log('📐 Processing entity "' + entityName + '" (' + entity.entityType + ") with " + entity.data.length + " points");

				const entityVertices = [];

				entity.data.forEach((point, pointIndex) => {
					const coords = {
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0,
						id: "kad_" + entityName + "_" + pointIndex,
						sourceType: "kad",
						sourceEntityName: entityName,
						sourcePointIndex: pointIndex,
						originalPoint: point
					};

					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
						entityVertices.push({
							vertex: coords,
							originalIndex: pointIndex,
							originalPoint: point
						});
					} else {
						console.warn("⚠️ Invalid KAD coordinates for " + entityName + " point " + pointIndex + ":", coords);
					}
				});

				// Store for constraint extraction later
				if (entityVertices.length > 0 && (entity.entityType === "line" || entity.entityType === "poly")) {
					kadSourceMap.set(entityName, {
						entity: entity,
						vertices: entityVertices
					});
				}
			}
		});

		console.log("📊 Collected " + elementVertices.length + " vertices before deduplication");

		// *** FIX 3: Deduplicate vertices (this changes coordinates) ***
		const originalVertexCount = elementVertices.length;
		elementVertices = getUniqueElementVertices(elementVertices, params.tolerance || 0.001);

		console.log("🔄 Deduplication: " + originalVertexCount + " → " + elementVertices.length + " vertices");

		if (elementVertices.length < 3) {
			throw new Error(`Insufficient points for triangulation: ${elementVertices.length}`);
		}

		// *** FIX 4: Extract constraints AFTER deduplication using deduplicated vertices ***
		const constraintSegments = extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, params.tolerance || 0.001);

		console.log("🔗 Extracted " + constraintSegments.length + " constraints from deduplicated vertices");

		// Create the constrained triangulation
		const result = await createConstrainautorTriangulation(elementVertices, constraintSegments, {
			tolerance: params.tolerance || 1e-10
		});

		if (!result || !result.resultTriangles || result.resultTriangles.length === 0) {
			console.warn("⚠️ Constrainautor CDT failed, falling back to basic Delaunay");
			return createFallbackTriangulation(elementVertices);
		}

		console.log("✅ CDT Success: " + result.resultTriangles.length + " triangles created with " + (result.stats?.constraints || 0) + " constraints applied");

		return {
			resultTriangles: result.resultTriangles,
			points: result.points,
			constraintCount: constraintSegments.length,
			stats: result.stats
		};
	} catch (error) {
		console.error("❌ CDT Error:", error);
		console.warn("⚠️ Falling back to basic Delaunay triangulation");

		// Fallback to basic triangulation
		return createDelaunayTriangulation(params);
	}
}

// =============================================================================
// STEP 2: ADD - New constraint extraction from deduplicated vertices
// =============================================================================

function extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, tolerance) {
	console.log("🔗 Extracting constraints from deduplicated vertices...");

	const constraints = [];

	// *** FIX 5: Create spatial index for efficient vertex lookup ***
	const spatialIndex = createSpatialIndex(elementVertices, tolerance);

	// Extract constraints from each KAD entity
	kadSourceMap.forEach((entityData, entityName) => {
		const entity = entityData.entity;

		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		console.log("🔗 Processing constraints for " + entity.entityType + ' "' + entityName + '"');

		const entityConstraints = [];

		// Create segments between consecutive points
		for (let i = 0; i < entity.data.length - 1; i++) {
			const startPoint = entity.data[i];
			const endPoint = entity.data[i + 1];

			const startX = parseFloat(startPoint.pointXLocation) || parseFloat(startPoint.x);
			const startY = parseFloat(startPoint.pointYLocation) || parseFloat(startPoint.y);
			const endX = parseFloat(endPoint.pointXLocation) || parseFloat(endPoint.x);
			const endY = parseFloat(endPoint.pointYLocation) || parseFloat(endPoint.y);

			// Find corresponding deduplicated vertices
			const startIdx = findClosestVertexIndex(spatialIndex, startX, startY, tolerance);
			const endIdx = findClosestVertexIndex(spatialIndex, endX, endY, tolerance);

			if (startIdx !== null && endIdx !== null && startIdx !== endIdx) {
				const constraint = {
					start: elementVertices[startIdx],
					end: elementVertices[endIdx],
					startIndex: startIdx,
					endIndex: endIdx,
					entityName: entityName,
					segmentIndex: i
				};

				entityConstraints.push(constraint);
				constraints.push(constraint);
			} else {
				console.warn("⚠️ Could not map constraint segment " + i + " for entity " + entityName);
				console.warn("  Start: (" + startX.toFixed(3) + ", " + startY.toFixed(3) + ") → index " + startIdx);
				console.warn("  End: (" + endX.toFixed(3) + ", " + endY.toFixed(3) + ") → index " + endIdx);
			}
		}

		// Close polygon for poly entities
		if (entity.entityType === "poly" && entity.data.length > 2) {
			const firstPoint = entity.data[0];
			const lastPoint = entity.data[entity.data.length - 1];

			const firstX = parseFloat(firstPoint.pointXLocation) || parseFloat(firstPoint.x);
			const firstY = parseFloat(firstPoint.pointYLocation) || parseFloat(firstPoint.y);
			const lastX = parseFloat(lastPoint.pointXLocation) || parseFloat(lastPoint.x);
			const lastY = parseFloat(lastPoint.pointYLocation) || parseFloat(lastPoint.y);

			// Only add closing segment if points are different
			if (Math.abs(firstX - lastX) > tolerance || Math.abs(firstY - lastY) > tolerance) {
				const firstIdx = findClosestVertexIndex(spatialIndex, firstX, firstY, tolerance);
				const lastIdx = findClosestVertexIndex(spatialIndex, lastX, lastY, tolerance);

				if (firstIdx !== null && lastIdx !== null && firstIdx !== lastIdx) {
					const closingConstraint = {
						start: elementVertices[lastIdx],
						end: elementVertices[firstIdx],
						startIndex: lastIdx,
						endIndex: firstIdx,
						entityName: entityName,
						segmentIndex: "closing"
					};

					entityConstraints.push(closingConstraint);
					constraints.push(closingConstraint);
				}
			}
		}

		console.log("  ✅ Added " + entityConstraints.length + " constraints for entity " + entityName);
	});

	console.log("✅ Total constraints extracted: " + constraints.length);
	return constraints;
}

// =============================================================================
// STEP 3: ADD - Spatial indexing for vertex lookup
// =============================================================================

function createSpatialIndex(vertices, tolerance) {
	console.log("🗺️ Creating spatial index for " + vertices.length + " vertices with tolerance " + tolerance);

	const index = new Map();

	vertices.forEach((vertex, vertexIndex) => {
		// Create multiple grid keys around each vertex for tolerance-based lookup
		const baseX = Math.floor(vertex.x / tolerance) * tolerance;
		const baseY = Math.floor(vertex.y / tolerance) * tolerance;

		// Add to multiple grid cells to handle boundary cases
		for (let dx = -1; dx <= 1; dx++) {
			for (let dy = -1; dy <= 1; dy++) {
				const gridX = baseX + dx * tolerance;
				const gridY = baseY + dy * tolerance;
				const key = gridX.toFixed(10) + "_" + gridY.toFixed(10);

				if (!index.has(key)) {
					index.set(key, []);
				}
				index.get(key).push({ vertex, index: vertexIndex });
			}
		}

		// Also add exact coordinate key
		const exactKey = "exact_" + vertex.x.toFixed(10) + "_" + vertex.y.toFixed(10);
		if (!index.has(exactKey)) {
			index.set(exactKey, []);
		}
		index.get(exactKey).push({ vertex, index: vertexIndex });
	});

	console.log("🗺️ Spatial index created with " + index.size + " grid cells");
	return index;
}

function findClosestVertexIndex(spatialIndex, targetX, targetY, tolerance) {
	// Try exact match first
	const exactKey = "exact_" + targetX.toFixed(10) + "_" + targetY.toFixed(10);
	const exactCandidates = spatialIndex.get(exactKey) || [];

	if (exactCandidates.length > 0) {
		return exactCandidates[0].index;
	}

	// Try grid-based lookup
	const gridX = Math.floor(targetX / tolerance) * tolerance;
	const gridY = Math.floor(targetY / tolerance) * tolerance;
	const gridKey = gridX.toFixed(10) + "_" + gridY.toFixed(10);
	const gridCandidates = spatialIndex.get(gridKey) || [];

	// Find closest candidate within tolerance
	let bestMatch = null;
	let bestDistance = Infinity;

	for (const candidate of gridCandidates) {
		const dx = candidate.vertex.x - targetX;
		const dy = candidate.vertex.y - targetY;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance && distance < bestDistance) {
			bestMatch = candidate;
			bestDistance = distance;
		}
	}

	return bestMatch ? bestMatch.index : null;
}

// =============================================================================
// STEP 4: REPLACE - Updated Constrainautor implementation
// =============================================================================

function createConstrainautorTriangulation(points, constraintSegments, options = {}) {
	return new Promise((resolve, reject) => {
		try {
			if (!window.Constrainautor) {
				throw new Error("Constrainautor library not loaded");
			}

			console.log("🔺 Starting Constrainautor with " + points.length + " points, " + constraintSegments.length + " constraints");

			// Create basic Delaunay triangulation first
			const coords = new Float64Array(points.length * 2);
			for (let i = 0; i < points.length; i++) {
				coords[i * 2] = points[i].x;
				coords[i * 2 + 1] = points[i].y;
			}

			const delaunay = new Delaunator(coords);
			console.log("🔺 Initial Delaunay: " + delaunay.triangles.length / 3 + " triangles");

			// *** FIX 6: Use pre-calculated indices from constraint extraction ***
			const constraintEdges = [];
			const validConstraints = [];

			constraintSegments.forEach((segment, segmentIndex) => {
				const startIdx = segment.startIndex;
				const endIdx = segment.endIndex;

				// Indices should already be validated during extraction
				if (startIdx !== undefined && endIdx !== undefined && startIdx !== endIdx && startIdx >= 0 && startIdx < points.length && endIdx >= 0 && endIdx < points.length) {
					constraintEdges.push([startIdx, endIdx]);
					validConstraints.push(segment);
				} else {
					console.warn("⚠️ Invalid constraint indices: [" + startIdx + ", " + endIdx + "] for segment " + segmentIndex);
				}
			});

			console.log("🔗 Prepared " + constraintEdges.length + " valid constraint edges");

			// Create Constrainautor instance
			const constrainautor = new Constrainautor(delaunay);

			// Apply constraints one by one with error handling
			let successfulConstraints = 0;
			if (constraintEdges.length > 0) {
				console.log("🔧 Applying " + constraintEdges.length + " constraints...");

				for (let i = 0; i < constraintEdges.length; i++) {
					try {
						constrainautor.constrainOne(constraintEdges[i][0], constraintEdges[i][1]);
						successfulConstraints++;
					} catch (constraintError) {
						const constraint = validConstraints[i];
						console.warn("⚠️ Failed to apply constraint " + i + " for entity " + constraint?.entityName + ": [" + constraintEdges[i][0] + ", " + constraintEdges[i][1] + "]");
						console.warn("   Error: " + constraintError.message);
					}
				}

				console.log("✅ Successfully applied " + successfulConstraints + "/" + constraintEdges.length + " constraints");
			}

			// Convert result triangles
			const resultTriangles = [];
			const triangles = delaunay.triangles;

			for (let i = 0; i < triangles.length; i += 3) {
				const idx1 = triangles[i];
				const idx2 = triangles[i + 1];
				const idx3 = triangles[i + 2];

				const v1 = points[idx1];
				const v2 = points[idx2];
				const v3 = points[idx3];

				if (v1 && v2 && v3) {
					resultTriangles.push({
						vertices: [v1, v2, v3],
						indices: [idx1, idx2, idx3],
						minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
						maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0)
					});
				}
			}

			console.log("🎉 Constrainautor complete: " + resultTriangles.length + " triangles");

			resolve({
				resultTriangles,
				points: points,
				stats: {
					algorithm: "constrainautor",
					originalPoints: points.length,
					triangles: resultTriangles.length,
					constraints: successfulConstraints,
					constraintAttempts: constraintEdges.length
				}
			});
		} catch (error) {
			console.error("❌ Constrainautor error:", error);
			reject(error);
		}
	});
}

// =============================================================================
// STEP 5: KEEP - Fallback triangulation function (unchanged)
// =============================================================================

function createFallbackTriangulation(points) {
	if (points.length < 3) {
		return { resultTriangles: [], points: [], stats: {} };
	}

	try {
		const getX = (p) => p.x;
		const getY = (p) => p.y;

		const delaunay = Delaunator.from(points, getX, getY);
		const resultTriangles = [];

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const v1 = points[delaunay.triangles[i]];
			const v2 = points[delaunay.triangles[i + 1]];
			const v3 = points[delaunay.triangles[i + 2]];

			resultTriangles.push({
				vertices: [v1, v2, v3],
				indices: [delaunay.triangles[i], delaunay.triangles[i + 1], delaunay.triangles[i + 2]],
				minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
				maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0)
			});
		}

		return {
			resultTriangles,
			points,
			stats: {
				algorithm: "delaunator_fallback",
				triangles: resultTriangles.length,
				points: points.length
			}
		};
	} catch (error) {
		console.error("❌ Fallback triangulation failed:", error);
		return { resultTriangles: [], points: [], stats: {} };
	}
}

// Helper function to determine blast hole point type from params
function getBlastHolePointType(params) {
	if (params.useCollars) return "collar";
	if (params.useGrade) return "grade";
	if (params.useToe) return "toe";
	if (params.useMLength) return "measuredLength";
	return "collar"; // default
}

//======================================================

function showTriangulationPopup() {
	const selectedPolygon = selectedKADObject && selectedKADObject.entityType == "poly" ? selectedKADObject : null;

	const fields = [
		{
			label: "Surface Name",
			name: "surfaceName",
			value: "Surface_" + Date.now(),
			placeholder: "Surface Name"
		},
		{
			label: "Blast Hole Points",
			name: "blastHolePoints",
			type: "select",
			value: "none",
			options: [
				{
					text: "None - Exclude blast holes",
					value: "none"
				},
				{
					text: "Collar points (surface)",
					value: "collar"
				},
				{
					text: "Grade points (mid-hole)",
					value: "grade"
				},
				{
					text: "Toe points (bottom)",
					value: "toe"
				},
				{
					text: "Measured length points (along hole)",
					value: "measuredLength"
				}
			]
		},
		{
			label: "KAD Breaklines",
			name: "useBreaklines",
			type: "select",
			value: "yes",
			options: [
				{
					text: "Include as constraints",
					value: "yes"
				},
				{
					text: "Points only (no constraints)",
					value: "no"
				}
			]
		},
		{
			label: "Boundary Clipping",
			name: "clipToBoundary",
			type: "select",
			value: selectedPolygon ? "selected" : "none",
			options: [
				{
					text: "No boundary clipping",
					value: "none"
				},
				{
					text: "Delete triangles outside selected polygon",
					value: "outside"
				},
				{
					text: "Delete triangles inside selected polygon",
					value: "inside"
				}
			]
		},
		{
			label: "Search Distance (XYZ duplicates)",
			name: "xyzTolerance",
			type: "number",
			value: 0.001,
			min: 0.001,
			max: 10,
			step: 0.01
		},
		{
			label: "Minimum Internal Angle",
			name: "minInternalAngle",
			type: "number",
			value: 0, //0 = ignore culling
			min: 0,
			max: 60,
			step: 0.1
		},
		{
			label: "Consider Angle in 3D?",
			name: "consider3DAngle",
			type: "checkbox",
			value: false
		},
		{
			label: "Max Edge Length",
			name: "maxEdgeLength",
			type: "number",
			value: 0, //0 = ignore culling
			min: 0,
			max: 10000,
			step: 0.1
		},
		{
			label: "Consider 3D edge length?",
			name: "consider3DLength",
			type: "checkbox",
			value: false
		},
		{
			label: "Surface Style",
			name: "surfaceStyle",
			type: "select",
			value: "hillshade",
			options: [
				{
					text: "default",
					value: "default"
				},
				//{ text: "wireframe", value: "wireframe" },//! Never use wireframe it doesn't exist!//
				{
					text: "Hillshade",
					value: "hillshade"
				},
				{
					text: "Viridis",
					value: "viridis"
				},
				{
					text: "Turbo",
					value: "turbo"
				},
				{
					text: "Parula",
					value: "parpula"
				},
				{
					text: "Civi",
					value: "cividis"
				},
				{
					text: "terrain",
					value: "terrain"
				}
			]
		}
	];

	const formContent = createEnhancedFormContent(fields, false, true);

	// Add boundary info if polygon is selected
	if (selectedPolygon) {
		const boundaryInfo = document.createElement("div");
		boundaryInfo.style.gridColumn = "1 / -1";
		boundaryInfo.style.padding = "8px";
		boundaryInfo.style.backgroundColor = "rgba(50, 255, 100, 0.2)";
		boundaryInfo.style.border = "1px solid #4caf50";
		boundaryInfo.style.borderRadius = "4px";
		boundaryInfo.style.fontSize = "11px";
		boundaryInfo.innerHTML = "✅ Selected boundary: " + selectedPolygon.entityName;
		formContent.insertBefore(boundaryInfo, formContent.firstChild);
	}

	// HONEST notes section
	const notesDiv = document.createElement("div");
	notesDiv.style.gridColumn = "1 / -1";
	notesDiv.style.marginTop = "10px";
	notesDiv.style.fontSize = "10px";
	notesDiv.style.color = "#888";
	notesDiv.innerHTML = `
			<strong>Triangulation:</strong><br>
			✅ Handles XY duplicate points with different Z elevations<br>
			✅ Uses Constrainautor to constrain trianges to breaklines<br>
			✅ Cull triangles by internal angle, edge length, and boundary clipping<br>
			<strong>Approach:</strong><br>
			• Uses proven Delaunator + Constrainautor<br>
		`;

	formContent.appendChild(notesDiv);

	const dialog = new FloatingDialog({
		title: "Delaunay 2.5D Triangulation",
		content: formContent,
		layoutType: "wide",
		width: 520,
		height: 570,
		showConfirm: true,
		showCancel: true,
		confirmText: "Create",
		cancelText: "Cancel",
		onConfirm: async () => {
			const formData = getFormData(formContent);

			// Validate surface name
			if (!formData.surfaceName || formData.surfaceName.trim() === "") {
				showErrorDialog("Invalid Surface Name", "Please enter a valid surface name");
				return;
			}

			// Check for duplicate surface names
			const existingSurface = Array.from(loadedSurfaces.values()).find((surface) => surface.name === formData.surfaceName.trim());
			if (existingSurface) {
				showErrorDialog("Duplicate Surface Name", "A surface with this name already exists. Please choose a different name.");
				return;
			}

			// Show loading message
			updateStatusMessage("Creating delaunay triangulation...");

			try {
				// Process form data into triangulation parameters
				const params = processTriangulationFormData(formData);
				// ✅ FIX: Use surface name as the ID to maintain consistency
				const surfaceId = formData.surfaceName.trim();

				// ✅ FIX: Declare result as let instead of const for reassignment
				let result;

				// ✅ FIX: Choose triangulation method based on formData
				if (formData.useBreaklines === "yes") {
					console.log("🔗 Using constrained triangulation (poly2tri)");
					updateStatusMessage("Creating constrained triangulation...");
					result = await createConstrainedDelaunayTriangulation(params);

					// ✅ FIX: Fallback to basic triangulation if CDT fails
					if (!result || !result.resultTriangles || result.resultTriangles.length === 0) {
						console.warn("⚠️ CDT failed, falling back to basic triangulation");
						updateStatusMessage("CDT failed, using basic triangulation...");
						result = await createDelaunayTriangulation(params);
					}
				} else {
					console.log("🔺 Using basic Delaunay triangulation");
					result = await createDelaunayTriangulation(params);
				}

				if (result && result.resultTriangles && result.resultTriangles.length > 0) {
					const surface = {
						id: surfaceId,
						name: surfaceId,
						type: "delaunay",
						points: result.points || [],
						triangles: result.resultTriangles,
						created: new Date().toISOString(),
						visible: true,
						gradient: formData.surfaceStyle || "hillshade",
						transparency: 1.0,
						metadata: {
							algorithm: formData.useBreaklines === "yes" ? "constrained_delaunay" : "delaunay",
							pointCount: result.points ? result.points.length : 0,
							triangleCount: result.resultTriangles.length,
							constraintCount: result.constraintCount || 0,
							blastHolePointType: params.blastHolePoints || "none",
							cullingApplied: result.cullingStats || {}
						}
					};

					// Add to loaded surfaces
					loadedSurfaces.set(surfaceId, surface);
					console.log("✅ Surface created:", surface.name, "with", result.resultTriangles.length, "triangles");

					// ✅ Apply boundary clipping if requested
					if (formData.clipToBoundary && formData.clipToBoundary !== "none") {
						const selectedPolygon = selectedKADObject && selectedKADObject.entityType === "poly" ? selectedKADObject : null;

						if (selectedPolygon) {
							console.log("🔪 Applying boundary clipping:", formData.clipToBoundary);
							updateStatusMessage("Applying boundary clipping...");

							const clippingSuccess = deleteTrianglesByClippingPolygon(surfaceId, formData.clipToBoundary);

							if (clippingSuccess) {
								const clippedSurface = loadedSurfaces.get(surfaceId);
								const clippedCount = result.resultTriangles.length - clippedSurface.triangles.length;
								console.log("✂️ Clipping applied:", clippedCount, "triangles removed,", clippedSurface.triangles.length, "remaining");
							} else {
								console.warn("⚠️ Boundary clipping failed");
							}
						}
					}

					// ✅ Apply internal angle filtering
					if (params.minAngle > 0) {
						console.log("📐 Applying internal angle filtering:", params.minAngle + "°", "3D:", params.consider3DAngle);
						updateStatusMessage("Filtering by internal angle...");

						const angleFilterSuccess = deleteTrianglesByInternalAngle(surfaceId, params.minAngle, params.consider3DAngle);
						if (angleFilterSuccess) {
							const filteredSurface = loadedSurfaces.get(surfaceId);
							console.log("📐 Angle filtering applied:", filteredSurface.triangles.length, "triangles remaining");
						}
					}

					// ✅ Apply edge length filtering
					if (params.maxEdgeLength > 0) {
						console.log("📏 Applying edge length filtering: max =", params.maxEdgeLength, "3D:", params.consider3DLength);
						updateStatusMessage("Filtering by edge length...");

						const edgeFilterSuccess = deleteTrianglesByEdgeLength(surfaceId, 0, params.maxEdgeLength, params.consider3DLength);
						if (edgeFilterSuccess) {
							const filteredSurface = loadedSurfaces.get(surfaceId);
							console.log("📏 Edge filtering applied:", filteredSurface.triangles.length, "triangles remaining");
						}
					}

					// Final status message with all filtering applied
					const finalSurface = loadedSurfaces.get(surfaceId);
					const totalRemoved = result.resultTriangles.length - finalSurface.triangles.length;

					// Save to database
					try {
						await saveSurfaceToDB(surfaceId);
						console.log("💾 Surface saved to database successfully");
					} catch (saveError) {
						console.error("❌ Failed to save surface to database:", saveError);
					}

					// Update UI
					updateCentroids();
					drawData(allBlastHoles, selectedHole);
					debouncedUpdateTreeView();
					updateStatusMessage("Surface '" + surface.name + "' created with " + finalSurface.triangles.length + " triangles (" + totalRemoved + " filtered)");
				} else {
					updateStatusMessage("No triangles generated. Check your data and settings.");
				}
			} catch (error) {
				console.error("Error creating triangulation:", error);
				updateStatusMessage("Error creating triangulation: " + error.message);
			}

			// Clear selections
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedPoint = null;
		},
		onCancel: () => {
			updateStatusMessage("");
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedPoint = null;
		}
	});

	dialog.show();

	// Auto-focus the surface name field
	setTimeout(() => {
		const nameInput = formContent.querySelector("input[name='surfaceName']");
		if (nameInput) {
			nameInput.focus();
			nameInput.select();
		}
	}, 100);
}

// Process form data into triangulation parameters
function processTriangulationFormData(formData) {
	return {
		// Fix parameter names to match what createDelaunayTriangulation expects
		useCollars: formData.blastHolePoints === "collar",
		useGrade: formData.blastHolePoints === "grade",
		useToe: formData.blastHolePoints === "toe",
		useMLength: formData.blastHolePoints === "measuredLength",
		minAngle: parseFloat(formData.minInternalAngle) || 0,
		consider3DAngle: formData.consider3DAngle === true || formData.consider3DAngle === "true",
		maxEdgeLength: parseFloat(formData.maxEdgeLength) || 0,
		consider3DLength: formData.consider3DLength === true || formData.consider3DLength === "true",
		surfaceName: formData.surfaceName.trim(),
		blastHolePoints: formData.blastHolePoints,
		useBreaklines: formData.useBreaklines,
		clipToBoundary: formData.clipToBoundary,
		tolerance: parseFloat(formData.xyzTolerance) || 0.001, // Fixed: was xyzTolerance
		surfaceStyle: formData.surfaceStyle
	};
}

//===========================
//#endregion DELAUNAY TRIANGULATION  - SURFACE TOOL - END
//===========================

//===========================
//#region DELAUNAY TRIANGLES START
//===========================
/**
 * Function to generate a Delaunay triangulation from a set of 2D points, and
 * filter out triangles with edges that are longer than a specified maximum edge length.
 * @param {Array} points the set of 2D points to triangulate
 * @param {number} maxEdgeLength the maximum edge length to allow
 * @returns {Array} an array of triangles, where each triangle is an array of 3 points,
 * each point being an array of 3 numbers (x, y, z)
 */
function delaunayTriangles(points, maxEdgeLength) {
	// Only do the expensive calculation if slope or relief triangles are being displayed
	if (!displaySlope.checked && !displayRelief.checked) {
		return {
			resultTriangles: [],
			reliefTriangles: []
		};
	}

	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: []
		};
	}

	const factor = 1.6;
	const minAngleThreshold = 5;
	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: []
		};
	}
	let resultTriangles = [];
	let reliefTriangles = [];
	try {
		const getX = (point) => parseFloat(point.startXLocation);
		const getY = (point) => parseFloat(point.startYLocation);

		// Helper function to get average distance to N nearest neighbors for a specific point
		function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
			const distances = [];

			for (let i = 0; i < allPoints.length; i++) {
				if (allPoints[i] === targetPoint) continue; // Skip self

				const dx = getX(targetPoint) - getX(allPoints[i]);
				const dy = getY(targetPoint) - getY(allPoints[i]);
				const distance = Math.sqrt(dx * dx + dy * dy);
				distances.push(distance);
			}

			// Sort distances and take the closest N neighbors
			distances.sort((a, b) => a - b);
			const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

			// Return average of nearest neighbors
			return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
		}

		// Cache for local averages to improve performance
		const localAverageCache = new Map();

		function getCachedLocalAverage(point) {
			if (!localAverageCache.has(point)) {
				localAverageCache.set(point, getLocalAverageDistance(point, points, 6));
			}
			return localAverageCache.get(point);
		}

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(points, getX, getY);

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1[0] - p2[0];
			const dy = p1[1] - p2[1];
			return dx * dx + dy * dy;
		}

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = points[p1Index];
			const p2 = points[p2Index];
			const p3 = points[p3Index];

			// Get cached local average distances for each vertex of the triangle
			const p1LocalAvg = getCachedLocalAverage(p1);
			const p2LocalAvg = getCachedLocalAverage(p2);
			const p3LocalAvg = getCachedLocalAverage(p3);

			// Use the average of the three vertices' local averages
			const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;

			// Create adaptive max edge length for this specific triangle
			// You can adjust the 1.8 multiplier to be more or less restrictive
			const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared([getX(p1), getY(p1)], [getX(p2), getY(p2)]);
			const edge2Squared = distanceSquared([getX(p2), getY(p2)], [getX(p3), getY(p3)]);
			const edge3Squared = distanceSquared([getX(p3), getY(p3)], [getX(p1), getY(p1)]);

			// Use the adaptive max edge length for this triangle
			const maxEdgeLengthSquared = adaptiveMaxEdgeLength ** 2;

			// Check if all edge lengths are within the adaptive limit
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles (bridging triangles)
				const edge1 = Math.sqrt(edge1Squared);
				const edge2 = Math.sqrt(edge2Squared);
				const edge3 = Math.sqrt(edge3Squared);

				// Calculate angles using law of cosines
				const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
				const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
				const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

				const minAngle = Math.min(angle1, angle2, angle3);

				// Only accept triangles with reasonable angles (reject very acute triangles)
				// You can adjust the 12 degree minimum angle threshold
				if (minAngle >= minAngleThreshold) {
					// Add the triangle to the result
					resultTriangles.push([
						[getX(p1), getY(p1), p1.startZLocation], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.startZLocation], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.startZLocation] // [x, y, z] of point 3
					]);

					reliefTriangles.push([
						[getX(p1), getY(p1), p1.holeTime], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.holeTime], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.holeTime] // [x, y, z] of point 3
					]);
				}
			}
		}

		// // Optional: Log some statistics for debugging
		// console.log("Triangulation completed:");
		// console.log("- Total triangles generated:", resultTriangles.length);
		// console.log("- Cache size:", localAverageCache.size);

		return {
			resultTriangles,
			reliefTriangles
		};
	} catch (err) {
		console.log("Error in delaunayTriangles:", err);
		return {
			resultTriangles: [],
			reliefTriangles: []
		};
	}
}

//Delaunay triangulation helper function
function getDelaunayFromPoints(points, useToeLocation) {
	try {
		return d3.Delaunay.from(
			points,
			function (p) {
				return useToeLocation ? parseFloat(p.endXLocation) : parseFloat(p.startXLocation);
			},
			function (p) {
				return useToeLocation ? parseFloat(p.endYLocation) : parseFloat(p.startYLocation);
			}
		);
	} catch (err) {
		console.log("Error in getDelaunayFromPoints:", err);
	}
}

//#endregion DELAUNAY TRIANGLES END

//===========================
//#region VORONOI DIAGRAM START
//===========================

//Voronoi Diagram
function getVoronoiMetrics(allBlastHoles, useToeLocation) {
	try {
		if (!allBlastHoles || allBlastHoles.length === 0) {
			console.warn("No Blast Holes to calculate Voronoi metrics");
			return [];
		}

		const delaunay = getDelaunayFromPoints(allBlastHoles, useToeLocation);

		const margin = 10; // optional
		const xExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endXLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startXLocation)))];
		const yExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endYLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startYLocation)))];

		const voronoi = delaunay.voronoi([xExtent[0] - margin, yExtent[0] - margin, xExtent[1] + margin, yExtent[1] + margin]);

		const voronoiResults = [];

		for (let i = 0; i < allBlastHoles.length; i++) {
			const polygon = voronoi.cellPolygon(i);
			if (!polygon) continue;

			// Area using shoelace formula
			let area = 0;
			for (let j = 0; j < polygon.length; j++) {
				const [x1, y1] = polygon[j];
				const [x2, y2] = polygon[(j + 1) % polygon.length];
				area += x1 * y2 - x2 * y1;
			}
			area = Math.abs(area / 2); // in m² if coords are meters

			const h = allBlastHoles[i];
			const length = parseFloat(h.measuredLength || h.benchHeight || 1);
			const measuredLength = parseFloat(h.measuredLength || 0);
			const designedLength = parseFloat(h.holeLengthCalculated || 0);
			const holeFiringTime = parseFloat(h.holeTime || 0);
			const mass = parseFloat(h.measuredMass || 0);
			const volume = area * length;
			const powderFactor = volume > 0 ? mass / volume : null;
			//Add more metrics here

			voronoiResults.push({
				index: i,
				hole: h,
				polygon: polygon,
				area: area,
				length: length,
				measuredLength: measuredLength,
				designedLength: designedLength,
				holeFiringTime: holeFiringTime,
				volume: volume,
				mass: mass,
				powderFactor: powderFactor
				//add a scaled heelan vibration calculation here
			});
		}

		//console.log("Returning Voronoi Metrics", voronoiResults);
		return voronoiResults;
	} catch (err) {
		console.log("Error in getVoronoiMetrics:", err);
		return [];
	}
}

// All legends now use a cool-to-hot gradient: blue (cool, small) -> cyan -> green -> yellow -> red (hot, large)

function getPFColor(pf, min, max) {
	// Map PF to a visible spectrum (violet -> blue -> green -> yellow -> orange -> red)
	//console.log("Getting PF Color", pf, min, max);
	let ratio;
	let r, g, b;
	if (!isVoronoiLegendFixed) {
		const minPF = min;
		const maxPF = max;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		// Interpolate from violet (148,0,211) -> blue (0,0,255) -> cyan (0,255,255) -> green (0,255,0) -> yellow (255,255,0) -> red (255,0,0)
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	} else {
		// Fixed spectrum: min=0, max=3, 0=violet, 0.2=blue, 0.4=cyan, 0.6=green, 0.8=yellow, 1=red
		const minPF = 0.0;
		const maxPF = 3.0;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	}

	return `rgb(${r},${g},${b})`;
}

function getAreaColor(area, min, max) {
	// Map area to a cool-to-hot gradient (blue-cyan-green-yellow-red)

	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((area - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getLengthColor(length, min, max) {
	// Map length to a cool-to-hot gradient (blue-cyan-green-yellow-red)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((length - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getHoleFiringTimeColor(holeFiringTime, min, max) {
	// Color scale: lime green (min) to red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((holeFiringTime - minColor) / (maxColor - minColor), 0), 1);

	// Lime green: rgb(0, 150, 0), Red: rgb(200, 0, 0)
	const r = Math.round(50 + (255 - 50) * ratio);
	const g = Math.round(255 - 255 * ratio);
	const b = Math.round(50 - 50 * ratio);

	return `rgb(${r},${g},${b})`;
}

function getMassColor(mass, min, max) {
	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((mass - minColor) / (maxColor - minColor), 0), 1);

	// Interpolate through blue -> cyan -> green -> yellow -> red
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getVolumeColor(volume, min, max) {
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((volume - minColor) / (maxColor - minColor), 0), 1);

	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

//Draw function for Powderfactor
function drawVoronoiMetric(metrics, metricName, getColorForMetric) {
	const ctx = canvas.getContext("2d");

	for (let cell of metrics) {
		// Skip if the cell doesn't have a polygon or the metric is null/undefined
		if (!cell.polygon || cell[metricName] == null) continue;

		const color = getColorForMetric(cell[metricName]);

		ctx.beginPath();
		ctx.moveTo(cell.polygon[0][0], cell.polygon[0][1]);
		for (let j = 1; j < cell.polygon.length; j++) {
			ctx.lineTo(cell.polygon[j][0], cell.polygon[j][1]);
		}
		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}
}

//using resultTriangles from delaunayTriangles function create a bounding polygon
function createBlastBoundaryPolygon(triangles) {
	let blastBoundaryPolygon = [];

	if (triangles && triangles.length > 0) {
		// Extract all vertices from triangles
		let vertices = triangles.flat().map((point) => ({
			x: point[0],
			y: point[1]
		}));

		// Compute convex hull
		if (vertices.length > 0) {
			try {
				const hull = d3.polygonHull(vertices.map((v) => [v.x, v.y]));

				if (hull && hull.length > 0) {
					blastBoundaryPolygon = hull.map((point) => ({
						x: point[0],
						y: point[1]
					}));
				}
			} catch (error) {
				console.error("Error computing convex hull:", error);
				// Optionally, fall back to a simpler method or return an empty polygon
				blastBoundaryPolygon = [];
			}
		}
	}

	return blastBoundaryPolygon;
}
//#endregion DELAUNAY TRIANGLES END

//===========================
//#region RADII POLYGONS START
//===========================

/**
 * Generates polygons representing circles around given points, optionally performing a union of these circles.
 *
 * @param {Array<Object>} points - An array of objects, each with `startXLocation`, `startYLocation`, and `startZLocation` properties, representing the center of a circle.
 * @param {number} steps - The number of steps to use when generating the circle polygon. Higher values result in smoother circles.
 * @param {number} radius - The radius of the circles.
 * @param {boolean} union - If true, performs a union of all the circle polygons using the ClipperLib library.
 * @param {boolean} addToMaps - If true, adds the generated polygons to the `allKADDrawingsMap`.
 * @returns {Array<Array<Object>>} An array of polygons. Each polygon is an array of points, where each point is an object with `x`, `y`, and `z` properties.  Returns an empty array if the Clipper union fails.
 */
function getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation) {
	const scale = 100000;
	const rawPolygons = [];

	// Generate circle polygons
	points.forEach((pt) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		const poly = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = cx + radius * Math.cos(angle);
			const y = cy + radius * Math.sin(angle);
			poly.push({
				x: x,
				y: y,
				z: z
			});
		}

		rawPolygons.push(poly);
	});

	if (!union) {
		if (addToMaps) {
			rawPolygons.forEach((polygon) => {
				entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					data: polygon.map((pt) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: "",
						lineWidth: 5,
						color: 1,
						closed: true,
						entityType: "poly"
					}))
				});
			});
		}
		return rawPolygons; // each point includes x, y, z
	}

	// Convert for ClipperLib union
	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale)
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("Clipper union failed.");
			clipperUnionWarned = true;
		}
		return [];
	}
	// Interpolate Z using nearest original point
	const unionedPolygons = solution.map((path) =>
		path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ
			};
		})
	);

	if (addToMaps) {
		unionedPolygons.forEach((polygon) => {
			entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
			//add pointID to each point starting from 1 to nth
			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});
			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 5,
					color: color || 1,
					closed: true,
					entityType: "poly"
				}))
			});
		});
	}

	return unionedPolygons; // includes x, y, z
}

/**
 * Enhanced Radii Polygons Generator
 *
 * Creates circular or starburst polygons around blast hole points with advanced features:
 * - Rotation offset for orienting polygons
 * - Starburst effect for creating star-shaped patterns
 * - Union capability for combining overlapping circles
 * - Automatic Z-elevation inheritance from nearest points
 *
 * @param {Array} points - Array of blast hole objects with location properties
 * @param {number} steps - Number of polygon vertices (3-100, higher = smoother circles)
 * @param {number} radius - Base radius in meters for polygon generation
 * @param {boolean} union - Whether to union overlapping polygons using Clipper
 * @param {boolean} addToMaps - Whether to add results to KAD drawings map
 * @param {string} color - Hex color code for polygon display
 * @param {number} lineWidth - Line width for polygon rendering
 * @param {boolean} useToeLocation - Use end/toe location (true) or start/collar (false)
 * @param {number} rotationOffset - Rotation angle in degrees (-360 to +360)
 * @param {number} starburstOffset - Starburst ratio 0-1 (1.0=circle, 0.5=half radius on even points, 0=star)
 *
 * @returns {Array} Array of polygon objects with {x, y, z} coordinates
 *
 * Features:
 * - Rotation: 0° = no rotation, +45° = clockwise, -45° = counter-clockwise
 * - Starburst: Even-numbered vertices get reduced radius, odd vertices keep full radius
 * - Example: 5m radius + 0.5 starburst = odd points at 5m, even points at 2.5m
 * - Union: Combines overlapping circles into single complex polygons
 * - Z-elevation: Automatically finds nearest point elevation for each vertex
 *
 * Entity Naming Convention:
 * - RAD-SRT: Start/collar location polygons
 * - RAD-END: End/toe location polygons
 * - -R45: Rotation offset suffix (e.g., 45 degrees)
 * - -S50: Starburst suffix (e.g., 50% ratio)
 * - -UNION: Indicates unioned polygons
 */

// Enhanced version with rotation and starburst capabilities
// Enhanced version with rotation and starburst capabilities (with 8-step minimum)
function getRadiiPolygonsEnhanced(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation, rotationOffset, starburstOffset) {
	// Step 1: Initialize variables and convert rotation to radians
	const scale = 100000;
	const rawPolygons = [];
	const rotationRadians = (rotationOffset || 0) * (Math.PI / 180); // Convert degrees to radians

	// Step 2: Apply starburst constraint - only allow if steps >= 8
	let effectiveStarburstRatio;
	if (steps >= 8 && starburstOffset !== undefined) {
		effectiveStarburstRatio = starburstOffset;
	} else {
		effectiveStarburstRatio = 1.0; // Force normal circle for < 8 steps
	}

	console.log("🌟 Creating enhanced radii polygons:");
	console.log("   Steps: " + steps + " (starburst " + (steps >= 8 ? "enabled" : "disabled") + ")");
	console.log("   Rotation: " + (rotationOffset || 0) + "° (" + rotationRadians.toFixed(4) + " rad)");
	console.log("   Starburst ratio: " + effectiveStarburstRatio + " (" + effectiveStarburstRatio * 100 + "%)");

	// Step 3: Generate enhanced circle polygons with rotation and starburst
	points.forEach((pt, pointIndex) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		console.log("   Processing point " + (pointIndex + 1) + " at (" + cx + ", " + cy + ", " + z + ")");

		const poly = [];

		// Step 4: Create polygon points with enhanced features
		for (let i = 0; i < steps; i++) {
			// Step 5: Calculate base angle with rotation offset
			const baseAngle = (i / steps) * Math.PI * 2;
			const angle = baseAngle + rotationRadians;

			// Step 6: Apply starburst effect only if enabled (steps >= 8)
			let currentRadius = radius;
			if (steps >= 8 && i % 2 === 0) {
				// Even-numbered points (0, 2, 4, ...) get starburst reduction
				currentRadius = radius * effectiveStarburstRatio;
			}
			// Odd-numbered points (1, 3, 5, ...) always keep full radius

			// Step 7: Calculate point coordinates
			const x = cx + currentRadius * Math.cos(angle);
			const y = cy + currentRadius * Math.sin(angle);

			poly.push({
				x: x,
				y: y,
				z: z
			});

			// Debug logging for first few points
			if (pointIndex === 0 && i < 4) {
				console.log("     Point " + i + ": angle=" + ((angle * 180) / Math.PI).toFixed(1) + "°, radius=" + currentRadius.toFixed(2) + "m, coords=(" + x.toFixed(2) + "," + y.toFixed(2) + ")");
			}
		}

		rawPolygons.push(poly);
	});

	// Step 8: Handle non-union case (multiple separate polygons)
	if (!union) {
		if (addToMaps) {
			rawPolygons.forEach((polygon, index) => {
				// Step 9: Create unique entity name with enhanced indicators
				let entityName = useToeLocation ? "RAD-END" : "RAD-SRT";
				if (rotationOffset !== 0) {
					entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
				}
				if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
					entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
				}
				entityName += "-" + Math.random().toString(36).substring(2, 6);

				// Step 10: Add polygon to KAD drawings map
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					data: polygon.map((pt, pointIndex) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: pointIndex + 1,
						lineWidth: lineWidth || 2,
						color: color || "#00FF00",
						closed: true,
						entityType: "poly"
					}))
				});

				console.log("✅ Created enhanced polygon: " + entityName + " with " + polygon.length + " points");
			});
		}
		return rawPolygons;
	}

	// Continue with union logic (same as before)...
	console.log("🔗 Performing union operation on " + rawPolygons.length + " polygons...");

	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale)
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("⚠️ Clipper union failed for enhanced radii polygons.");
			clipperUnionWarned = true;
		}
		return [];
	}

	console.log("✅ Union successful, created " + solution.length + " combined polygon(s)");

	const unionedPolygons = solution.map((path, pathIndex) => {
		console.log("   Processing union polygon " + (pathIndex + 1) + " with " + path.length + " points");

		return path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ
			};
		});
	});

	if (addToMaps) {
		unionedPolygons.forEach((polygon, index) => {
			let entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + "-UNION";
			if (rotationOffset !== 0) {
				entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
			}
			if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
				entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
			}
			entityName += "-" + Math.random().toString(36).substring(2, 6);

			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});

			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 2,
					color: color || "#00FF00",
					closed: true,
					entityType: "poly"
				}))
			});

			console.log("✅ Created enhanced union polygon: " + entityName + " with " + polygon.length + " points");
		});
	}

	return unionedPolygons;
}

function clipVoronoiCells(voronoiMetrics) {
	const scale = 100000;
	const allClippedCells = []; // Changed variable name for clarity

	// --- Your existing logic to calculate contractedPolygons ---
	const nearest = getNearestNeighborDistancesByAggregation(points, "mode", useToeLocation);
	const expand = nearest * 1.5;
	const contract = expand * 0.65;
	//----------------------getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation)
	const unionedPolygons = getRadiiPolygons(points, 36, expand, true, false, "red", 1, useToeLocation);
	//----------------------
	const simplifiedPolygons = unionedPolygons.map((polygon) => simplifyPolygon(polygon, 0.1, true));
	const contractedPolygons = simplifiedPolygons.map((polygon) => offsetPolygonClipper(polygon, -contract));
	// --- End of your existing logic ---

	const clipPathPolygons = contractedPolygons; // These are the actual geometric polygons
	/*
    console.log("nearest:", nearest);
    console.log("expand:", expand);
    console.log("unionedPolygons:", unionedPolygons);
    console.log("simplifiedPolygons:", simplifiedPolygons);
    console.log("contract:", contract);
    console.log("contractedPolygons:", contractedPolygons);
    console.log("clipPathPolygons for iteration:", clipPathPolygons);
	*/

	for (let cell of voronoiMetrics) {
		if (!cell.polygon || cell.polygon.length < 3) continue;

		const subjPath = cell.polygon.map((p) => ({
			X: Math.round((p.x || p[0]) * scale),
			Y: Math.round((p.y || p[1]) * scale)
		}));

		let cellSuccessfullyClippedAndAdded = false;
		// Iterate through each of your boundary polygons
		for (const currentBoundaryPolygon of clipPathPolygons) {
			if (!currentBoundaryPolygon || currentBoundaryPolygon.length < 3) continue;

			// Convert the current boundary polygon to Clipper format
			const clipperSingleClipPath = currentBoundaryPolygon.map((p) => ({
				X: Math.round(p.x * scale),
				Y: Math.round(p.y * scale)
			}));

			const clipper = new ClipperLib.Clipper();
			clipper.AddPath(subjPath, ClipperLib.PolyType.ptSubject, true);
			clipper.AddPath(clipperSingleClipPath, ClipperLib.PolyType.ptClip, true); // Use only ONE clip path here

			const solution = new ClipperLib.Paths();
			const success = clipper.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

			if (success && solution.length > 0 && solution[0].length > 0) {
				// Check solution[0] for valid polygon
				const clippedResultPolygon = solution[0].map((pt) => ({
					x: pt.X / scale,
					y: pt.Y / scale
				}));

				const area = Math.abs(
					clippedResultPolygon.reduce((acc, curr, i, arr) => {
						const next = arr[(i + 1) % arr.length];
						return acc + curr.x * next.y - next.x * curr.y;
					}, 0) / 2
				);
				const volume = area * cell.length;
				const powderFactor = volume > 0 ? cell.mass / volume : null;

				allClippedCells.push({
					...cell,
					polygon: clippedResultPolygon,
					area,
					volume,
					powderFactor
				});
				cellSuccessfullyClippedAndAdded = true;
				break; // Important: Cell is clipped by this boundary, no need to check others
			}
		}
		// If cellSuccessfullyClippedAndAdded is false here, the cell was not inside any of the boundaries.
	}
	return allClippedCells;
}

function simplifyPolygon(polygon, tolerance, forceClose) {
	if (!polygon || polygon.length < 3) return polygon;

	const scale = 100000;
	const scaledPath = polygon.map((p) => ({
		X: Math.round((p.x || p[0]) * scale),
		Y: Math.round((p.y || p[1]) * scale)
	}));

	const c = new ClipperLib.Clipper();
	const cleaned = ClipperLib.Clipper.CleanPolygon(scaledPath, tolerance * scale);

	if (!cleaned || cleaned.length < 3) return polygon;

	const simplified = cleaned.map((p) => ({
		x: p.X / scale,
		y: p.Y / scale
	}));

	if (forceClose && simplified.length > 0) {
		simplified.push({
			...simplified[0]
		});
	}

	return simplified;
}

function offsetPolygonClipper(polygon, offsetMeters) {
	if (!polygon || polygon.length < 3) return [];

	const scale = 100000; // ClipperLib works in integers, scale up for precision

	// Convert to Clipper path format
	const path = polygon.map((p) => ({
		X: Math.round(p.x * scale),
		Y: Math.round(p.y * scale)
	}));

	// Initialize and execute offset
	const co = new ClipperLib.ClipperOffset();
	co.AddPath(path, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

	const offsetPaths = [];
	co.Execute(offsetPaths, offsetMeters * scale);

	// Convert back to float points
	if (offsetPaths.length === 0) return [];
	return offsetPaths[0].map((p) => ({
		x: p.X / scale,
		y: p.Y / scale
	}));
}

// function to offset a selected KAD object. Uses clipper library to offset.
// All KAD are allowed Points, lines, Poly, circle and text.
// Projection at 0° inherits the existing KAD object elevation
// first select the kad object to offset.
// then click the offsetKADButton.  The button cannot be on it can only be click.  There must be a selection from the selectPointer.
// then show a popup with the amount to offset Positive or Negative. will define the direction.
// the popup will allow for projection up at and angle or down at and angle.
// 0° is horizontal, -ve° is down, +ve° is Up.  The distance is the amount from the orignal line.
// the popup will allow for multiple offset. 1 - 100
// the kad object will be offset by the amount positive expands and negative compresses.
// ================================
// OFFSET KAD FUNCTIONALITY
// ================================

// Update the offset button event listener with full functionality
offsetKADButton.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools and activate offset mode
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("offsetKADTool");

		isOffsetKAD = true;
		offsetKADButton.checked = true;

		// Check if there's already a selected KAD object
		if (selectedKADObject && (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly")) {
			// Show offset popup immediately for the selected object
			showOffsetKADPopup(selectedKADObject);
		} else {
			// Add click listener for offset operations
			canvas.addEventListener("click", handleOffsetKADClick);
			canvas.addEventListener("touchstart", handleOffsetKADClick);
			updateStatusMessage("Offset Tool Activated\nClick on a KAD object (line/polygon) to offset\nThen configure offset parameters");
		}
	} else {
		isOffsetKAD = false;
		canvas.removeEventListener("click", handleOffsetKADClick);
		canvas.removeEventListener("touchstart", handleOffsetKADClick);
		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Handle clicks when offset tool is active
function handleOffsetKADClick(event) {
	if (!isOffsetKAD) return;

	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;

	if (isNaN(clickX) || isNaN(clickY)) {
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	}

	// Find clicked KAD object
	const clickedKADObject = getClickedKADObject(clickX, clickY);

	if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
		// Show offset configuration popup
		showOffsetKADPopup(clickedKADObject);
	} else {
		updateStatusMessage("Please click on a line or polygon to offset");
		setTimeout(() => updateStatusMessage("Offset Tool Active - Click on a line or polygon"), 2000);
	}
}
// Show the offset configuration popup
//! Useing the FloatingDialog class to show the popup
function showOffsetKADPopup(kadObject) {
	const entity = getEntityFromKADObject(kadObject);
	if (!entity) return;

	// Create form content using the helper function
	const fields = [
		{
			label: "Offset (m) -ve = in, +ve = out",
			name: "offsetAmount",
			type: "number",
			value: "1.0",
			step: "0.1",
			min: "-100",
			max: "100"
		},
		{
			label: "Projection (°) +ve° = up, -ve° = dn",
			name: "projectionAngle",
			type: "number",
			value: "0",
			step: "1",
			min: "-90",
			max: "90"
		},
		{
			label: "Number of Offsets",
			name: "numberOfOffsets",
			type: "number",
			value: "1",
			step: "1",
			min: "1",
			max: "10"
		},
		{
			label: "Priority Mode",
			name: "priorityMode",
			type: "select",
			value: "distance",
			options: [
				{
					value: "distance",
					text: "Distance Priority (total distance)"
				},
				{
					value: "vertical",
					text: "Vertical Priority (vertical distance)"
				}
			]
		},
		{
			label: "Offset Color",
			name: "offsetColor",
			type: "color",
			value: "#FF0000"
		},
		{
			label: "Handle Crossovers",
			name: "handleCrossovers",
			type: "checkbox",
			checked: true,
			labelInLeftColumn: false
		}
	];

	const formContent = createEnhancedFormContent(fields, false, false);

	// Add notes section
	const notesDiv = document.createElement("div");
	notesDiv.style.gridColumn = "1 / -1";
	notesDiv.style.marginTop = "10px";
	notesDiv.style.fontSize = "10px";
	notesDiv.style.color = "#888";
	notesDiv.innerHTML = `
                <strong>Notes:</strong><br>
                • Lines: Positive values offset to the right, negative to the left<br>
                • Polygons: Positive values offset outwards, negative to the left<br>
                • 0° = horizontal, +° = up slope, -° = down slope<br>
                • Distance Priority: 12m total distance from line<br>
                • Vertical Priority: 12m vertical offset (may be >12m total distance)<br>
                • Multiple offsets create lines at distance × 1, distance × 2, etc.<br>
                • Handle Crossovers creates clean connections at intersections
    `;
	formContent.appendChild(notesDiv);

	const dialog = new FloatingDialog({
		title: "Offset " + kadObject.entityType.toUpperCase() + ": " + kadObject.entityName,
		content: formContent,
		layoutType: "wide",
		width: 400,
		height: 400,
		showConfirm: true,
		showCancel: true,
		confirmText: "Offset",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			const offsetParams = {
				baseAmount: parseFloat(formData.offsetAmount),
				projectionAngle: parseFloat(formData.projectionAngle),
				numberOfOffsets: parseInt(formData.numberOfOffsets),
				priorityMode: formData.priorityMode,
				color: formData.offsetColor,
				handleCrossovers: formData.handleCrossovers === "true",
				originalEntityName: kadObject.entityName
			};

			// Perform the offset operation
			performKADOffset(entity, offsetParams);
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedPoint = null;
			offsetKADButton.checked = false;
			isOffsetKAD = false;
			canvas.removeEventListener("click", handleOffsetKADClick);
			canvas.removeEventListener("touchstart", handleOffsetKADClick);
			updateStatusMessage("");
		},
		onCancel: () => {
			// After popup closes, deactivate the offset tool
			offsetKADButton.checked = false;
			isOffsetKAD = false;
			canvas.removeEventListener("click", handleOffsetKADClick);
			canvas.removeEventListener("touchstart", handleOffsetKADClick);
			updateStatusMessage("");
			drawData(allBlastHoles, selectedHole);
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedPoint = null;
		}
	});

	dialog.show();

	// Initialize JSColor after dialog shows
	setTimeout(() => {
		jscolor.install();
		// Force z-index on any JSColor elements
		const colorInputs = formContent.querySelectorAll("[data-jscolor]");
		colorInputs.forEach((input) => {
			if (input.jscolor) {
				input.jscolor.option("zIndex", 20000);
			}
		});
	}, 100);
}
// Enhanced custom line offset function with crossover handling - COMPLETE VERSION
function createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null) {
	try {
		const originalPoints = originalEntity.data;

		// Fix Issue #2: Handle undefined entityName
		const baseEntityName = originalEntityName || originalEntity.entityName || "unnamed_entity";

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance from the line at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// Horizontal component of the offset (2D plane)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical component calculation
			// For distance priority, the vertical offset is based on the sine of the angle
			// and the ABSOLUTE value of the offset amount (distance is always positive)
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta Calculation:
			// - projectionAngle > 0: Going UP, so ADD to Z
			// - projectionAngle < 0: Going DOWN, so SUBTRACT from Z
			// - projectionAngle = 0: No vertical change
			// Note: We use the signed value of verticalOffset (which includes angle sign)
			zDelta = verticalOffset; // This already has the correct sign from sin(angle)
		} else {
			// Vertical Priority: The offset amount IS the vertical distance
			// The sign of the projection angle determines up/down direction
			// The sign of the offset amount only affects horizontal direction (left/right)

			if (projectionAngle > 0) {
				// Positive angle = going UP
				// Z increases by the absolute offset amount
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				// Z decreases by the absolute offset amount
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = pure horizontal, no Z change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset needed to achieve the vertical distance at the angle
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// Horizontal offset maintains the left/right direction from offsetAmount sign
					// but adjusts magnitude based on the angle
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount; // Fallback for very small angles
				}
			} else {
				// Pure horizontal offset when angle is 0
				horizontalOffset = offsetAmount;
			}
		}

		console.log("🔧 Offset calculation:");
		console.log("  offsetAmount:", offsetAmount, "(direction:", offsetAmount > 0 ? "right" : "left", ")");
		console.log("  projectionAngle:", projectionAngle, "°");
		console.log("  priorityMode:", priorityMode);
		console.log("  horizontalOffset:", horizontalOffset.toFixed(3));
		console.log("  verticalOffset:", verticalOffset.toFixed(3));
		console.log("  zDelta:", zDelta.toFixed(3));
		console.log("  baseEntityName:", baseEntityName); // Debug log
		console.log("  handleCrossovers", handleCrossovers);

		if (!handleCrossovers) {
			// Use the simple method without crossover handling
			return createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName);
		}

		// Create offset segments with crossover handling
		const offsetSegments = [];

		// Generate offset segments for each original segment
		for (let i = 0; i < originalPoints.length - 1; i++) {
			const p1 = originalPoints[i];
			const p2 = originalPoints[i + 1];

			// Calculate segment direction vector
			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length === 0) continue; // Skip zero-length segments

			// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
			// Negative dy and positive dx gives us the right-hand perpendicular
			const perpX = (-dy / length) * horizontalOffset;
			const perpY = (dx / length) * horizontalOffset;

			// Create offset segment with proper Z calculation
			// IMPORTANT: Ensure all values are numbers, not strings
			const offsetSeg = {
				start: {
					x: p1.pointXLocation + perpX,
					y: p1.pointYLocation + perpY,
					z: parseFloat(p1.pointZLocation) + parseFloat(zDelta) // Fix string concatenation issue
				},
				end: {
					x: p2.pointXLocation + perpX,
					y: p2.pointYLocation + perpY,
					z: parseFloat(p2.pointZLocation) + parseFloat(zDelta) // Fix string concatenation issue
				},
				index: i
			};

			offsetSegments.push(offsetSeg);
		}

		// Handle single segment lines
		if (originalPoints.length === 2 && offsetSegments.length === 0) {
			const p1 = originalPoints[0];
			const p2 = originalPoints[1];

			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length > 0) {
				const perpX = (-dy / length) * horizontalOffset;
				const perpY = (dx / length) * horizontalOffset;

				offsetSegments.push({
					start: {
						x: p1.pointXLocation + perpX,
						y: p1.pointYLocation + perpY,
						z: parseFloat(p1.pointZLocation) + parseFloat(zDelta) // Fix string concatenation
					},
					end: {
						x: p2.pointXLocation + perpX,
						y: p2.pointYLocation + perpY,
						z: parseFloat(p2.pointZLocation) + parseFloat(zDelta) // Fix string concatenation
					},
					index: 0
				});
			}
		}

		// Handle crossovers by finding intersections and trimming/extending segments
		const cleanedSegments = handleCrossovers ? handleSegmentCrossovers(offsetSegments) : offsetSegments;

		// Convert cleaned segments to point array
		const offsetPoints = [];
		cleanedSegments.forEach((seg) => {
			offsetPoints.push(
				{
					pointXLocation: seg.start.x,
					pointYLocation: seg.start.y,
					pointZLocation: seg.start.z
				},
				{
					pointXLocation: seg.end.x,
					pointYLocation: seg.end.y,
					pointZLocation: seg.end.z
				}
			);
		});

		if (offsetPoints.length === 0) {
			throw new Error("No valid segments after crossover handling");
		}

		// Create unique name with timestamp to avoid overwrites
		const timestamp = Date.now();
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + timestamp;

		const newEntityData = offsetPoints.map((pt, index) => ({
			entityName: newEntityName,
			entityType: "line",
			pointID: index + 1,
			pointXLocation: pt.pointXLocation,
			pointYLocation: pt.pointYLocation,
			pointZLocation: pt.pointZLocation,
			lineWidth: originalPoints[0].lineWidth || 1,
			color: color,
			closed: false,
			visible: true
		}));

		// Add to the map
		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: "line",
			data: newEntityData,
			visible: true
		});

		console.log("✅ Created crossover-handled line offset:", newEntityName, "with", newEntityData.length, "points");
		return newEntityName;
	} catch (error) {
		console.error("Error in createLineOffsetCustom:", error);
		throw error;
	}
}

// Simple line offset without crossover handling (updated with fixes)
function createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName) {
	const originalPoints = originalEntity.data;
	const offsetPoints = [];

	// Handle single segment and multi-segment lines
	for (let i = 0; i < originalPoints.length - 1; i++) {
		const p1 = originalPoints[i];
		const p2 = originalPoints[i + 1];

		const dx = p2.pointXLocation - p1.pointXLocation;
		const dy = p2.pointYLocation - p1.pointYLocation;
		const length = Math.sqrt(dx * dx + dy * dy);

		if (length === 0) continue;

		// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
		const perpX = (-dy / length) * horizontalOffset;
		const perpY = (dx / length) * horizontalOffset;

		// Apply the correct Z delta
		// IMPORTANT: Parse float to avoid string concatenation
		const offsetP1 = {
			pointXLocation: p1.pointXLocation + perpX,
			pointYLocation: p1.pointYLocation + perpY,
			pointZLocation: parseFloat(p1.pointZLocation) + parseFloat(zDelta) // Fix concatenation
		};

		const offsetP2 = {
			pointXLocation: p2.pointXLocation + perpX,
			pointYLocation: p2.pointYLocation + perpY,
			pointZLocation: parseFloat(p2.pointZLocation) + parseFloat(zDelta) // Fix concatenation
		};

		offsetPoints.push(offsetP1, offsetP2);
	}

	const timestamp = Date.now();
	const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + timestamp;

	const newEntityData = offsetPoints.map((pt, index) => ({
		entityName: newEntityName,
		entityType: "line",
		pointID: index + 1,
		pointXLocation: pt.pointXLocation,
		pointYLocation: pt.pointYLocation,
		pointZLocation: pt.pointZLocation,
		lineWidth: originalPoints[0].lineWidth || 1,
		color: color,
		closed: false,
		visible: true
	}));

	allKADDrawingsMap.set(newEntityName, {
		entityName: newEntityName,
		entityType: "line",
		data: newEntityData,
		visible: true
	});

	return newEntityName;
}

// Handle crossovers between offset segments
function handleSegmentCrossovers(segments) {
	if (segments.length < 2) return segments;

	const cleanedSegments = [...segments];

	// Find intersections between consecutive segments and extend/trim accordingly
	for (let i = 0; i < cleanedSegments.length - 1; i++) {
		const seg1 = cleanedSegments[i];
		const seg2 = cleanedSegments[i + 1];

		// Find intersection between the two line segments
		const intersection = findLineIntersection(seg1.start.x, seg1.start.y, seg1.end.x, seg1.end.y, seg2.start.x, seg2.start.y, seg2.end.x, seg2.end.y);

		if (intersection) {
			// Extend/trim segments to meet at intersection
			seg1.end.x = intersection.x;
			seg1.end.y = intersection.y;
			seg2.start.x = intersection.x;
			seg2.start.y = intersection.y;
		}
	}

	// Remove segments that became too short (less than 0.1m)
	return cleanedSegments.filter((seg) => {
		const length = Math.sqrt(Math.pow(seg.end.x - seg.start.x, 2) + Math.pow(seg.end.y - seg.start.y, 2));
		return length > 0.1;
	});
}

// Find intersection point between two line segments
function findLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

	if (Math.abs(denom) < 1e-10) {
		return null; // Lines are parallel
	}

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	// Check if intersection is within reasonable extension range
	if (t >= -0.5 && t <= 1.5 && u >= -0.5 && u <= 1.5) {
		return {
			x: x1 + t * (x2 - x1),
			y: y1 + t * (y2 - y1)
		};
	}

	return null; // No valid intersection
}

// Update the createOffsetEntity function for polygons
function createOffsetEntity(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null) {
	try {
		const scale = 100000;
		const originalPoints = originalEntity.data;

		if (originalPoints.length < 2) {
			throw new Error("Need at least 2 points for offset");
		}

		/// Fix Issue #2: Handle undefined entityName - use passed name or fallback
		const baseEntityName = originalEntityName || originalEntity.entityName || "undef";

		// For lines, use custom offset method
		if (originalEntity.entityType === "line") {
			return createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers, priorityMode, baseEntityName);
		}

		// For polygons, use ClipperLib
		const clipperPath = originalPoints.map((pt) => ({
			X: Math.round(pt.pointXLocation * scale),
			Y: Math.round(pt.pointYLocation * scale)
		}));

		const clipperOffset = new ClipperLib.ClipperOffset();
		clipperOffset.AddPath(clipperPath, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// For polygons: offsetAmount controls expand(+) / contract(-)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical offset uses sine of angle and absolute offset
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta: Use the signed verticalOffset (sin includes angle sign)
			zDelta = verticalOffset;
		} else {
			// Vertical Priority: Distance becomes the vertical amount
			if (projectionAngle > 0) {
				// Positive angle = going UP
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = no vertical change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset for vertical priority
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// For polygons, maintain expand/contract behavior
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount;
				}
			} else {
				horizontalOffset = offsetAmount;
			}
		}

		const offsetPaths = [];
		clipperOffset.Execute(offsetPaths, horizontalOffset * scale);

		if (offsetPaths.length === 0) {
			throw new Error("Clipper offset returned no results - try a smaller offset amount");
		}

		const offsetPath = offsetPaths[0];
		const timestamp = Date.now();
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + timestamp;

		const newEntityData = offsetPath.map((pt, index) => {
			const worldX = pt.X / scale;
			const worldY = pt.Y / scale;

			// Apply the correct Z delta
			// IMPORTANT: Use the first point's Z as reference and parse as float
			// to avoid string concatenation issues
			const worldZ = parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta);

			return {
				entityName: newEntityName,
				entityType: originalEntity.entityType,
				pointID: index + 1,
				pointXLocation: worldX,
				pointYLocation: worldY,
				pointZLocation: worldZ, // This is now correctly calculated
				lineWidth: originalPoints[0].lineWidth || 1,
				color: color,
				closed: originalEntity.entityType === "poly",
				visible: true
			};
		});

		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: originalEntity.entityType,
			data: newEntityData,
			visible: true
		});

		console.log("Created offset entity:", newEntityName, "with", newEntityData.length, "points");
		console.log("  baseEntityName:", baseEntityName); // Debug log
		console.log("  Original Z:", originalPoints[0].pointZLocation);
		console.log("  Z Delta:", zDelta);
		console.log("  New Z:", parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta));

		return newEntityName;
	} catch (error) {
		console.error("Error in createOffsetEntity:", error);
		throw error;
	}
}

// Update performKADOffset to pass the priority mode
function performKADOffset(entity, params) {
	try {
		const results = [];

		for (let i = 1; i <= params.numberOfOffsets; i++) {
			const offsetAmount = params.baseAmount * i;

			const offsetEntity = createOffsetEntity(entity, offsetAmount, params.projectionAngle, params.color, i, params.handleCrossovers, params.priorityMode, params.originalEntityName);

			if (offsetEntity) {
				results.push(offsetEntity);
			}
		}

		if (results.length > 0) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			drawData(allBlastHoles, selectedHole);

			updateStatusMessage("Created " + results.length + " offset(s) successfully");
			setTimeout(() => updateStatusMessage(""), 3000);
		} else {
			updateStatusMessage("Failed to create offsets - check parameters");
		}
	} catch (error) {
		console.error("Error in performKADOffset:", error);
		updateStatusMessage("Error creating offsets: " + error.message);
	}
}
// ================================
// OFFSET KAD FUNCTIONALITY - ENDED
// ================================

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - STARTED
// ================================

radiiHolesOrKADsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("radiiHolesOrKADsTool");

		// Get all selected entities (holes + KAD objects)
		const selectedEntities = getSelectedEntitiesForRadii();

		if (selectedEntities.length === 0) {
			// No entities selected, show message and deactivate tool
			showModalMessage("No Selection", "Please select holes or KAD entities first, then activate the Radii tool.", "info");
			this.checked = false;
			resetFloatingToolbarButtons("none");
			return;
		}

		// Show radii configuration popup
		showRadiiConfigPopup(selectedEntities);
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("");
	}
});

// Show radii configuration popup using FloatingDialog
// Show radii configuration popup using FloatingDialog
function showRadiiConfigPopup(selectedEntities) {
	// Step 1: Analyze selected entities for counts and descriptions
	const entityCount = selectedEntities.length;
	const holeCount = selectedEntities.filter((e) => e.type === "hole").length;
	const kadCount = selectedEntities.filter((e) => e.type.startsWith("kad")).length;

	let entityDescription = "";
	if (holeCount > 0 && kadCount > 0) {
		entityDescription = holeCount + " hole(s) and " + kadCount + " KAD point(s)";
	} else if (holeCount > 0) {
		entityDescription = holeCount + " hole(s)";
	} else {
		entityDescription = kadCount + " KAD point(s)";
	}

	// Step 2: Inherit properties from first selected entity
	let inheritedLineWidth = 2.0; // Default fallback
	let inheritedColor = "#00FF00"; // Default fallback

	if (selectedEntities.length > 0) {
		const firstEntity = selectedEntities[0];

		// Step 3: Check for lineWidth in entity data
		if (firstEntity.data && firstEntity.data.lineWidth !== undefined) {
			inheritedLineWidth = firstEntity.data.lineWidth;
		} else if (firstEntity.data && firstEntity.data.data && firstEntity.data.data.length > 0) {
			// Check first point in KAD data array
			const firstPoint = firstEntity.data.data[0];
			if (firstPoint && firstPoint.lineWidth !== undefined) {
				inheritedLineWidth = firstPoint.lineWidth;
			}
		}

		// Step 4: Check for color in entity data
		if (firstEntity.data && firstEntity.data.color !== undefined) {
			inheritedColor = firstEntity.data.color;
		} else if (firstEntity.data && firstEntity.data.colour !== undefined) {
			inheritedColor = firstEntity.data.colour;
		} else if (firstEntity.data && firstEntity.data.data && firstEntity.data.data.length > 0) {
			// Check first point in KAD data array
			const firstPoint = firstEntity.data.data[0];
			if (firstPoint && firstPoint.color !== undefined) {
				inheritedColor = firstPoint.color;
			} else if (firstPoint && firstPoint.colour !== undefined) {
				inheritedColor = firstPoint.colour;
			}
		}
	}

	// Step 5: Create form fields with inherited values and new rotation/starburst fields
	const fields = [
		{
			label: "Radius (m)",
			name: "radiiRadius",
			type: "number",
			value: "5.0",
			step: "0.1",
			min: "0.1",
			max: "100"
		},
		{
			label: "Circle Steps",
			name: "radiiSteps",
			type: "number",
			value: "16",
			step: "1",
			min: "3",
			max: "100"
		},
		{
			label: "Rotation Offset (°)",
			name: "rotationOffset",
			type: "number",
			value: "0.0",
			step: "1.0",
			min: "-360.0",
			max: "360.0"
		},
		{
			label: "Starburst Offset (%)",
			name: "starburstOffset",
			type: "number",
			value: "100.0",
			step: "1.0",
			min: "0.0",
			max: "100.0",
			disabled: true // Step 6: Initially disabled - will be enabled if steps >= 8
		},
		{
			label: "Point Location",
			name: "radiiLocation",
			type: "select",
			value: "start",
			options: [
				{
					value: "start",
					text: "Start/Collar Location"
				},
				{
					value: "end",
					text: "End/Toe Location"
				}
			]
		},
		{
			label: "Line Width",
			name: "lineWidth",
			type: "number",
			value: inheritedLineWidth.toString(),
			step: "0.1",
			min: "0.1",
			max: "20"
		},
		{
			label: "Polygon Color",
			name: "radiiColor",
			type: "color",
			value: inheritedColor
		},
		{
			label: "Union Circles",
			name: "unionCircles",
			type: "checkbox",
			checked: true,
			labelInLeftColumn: false
		}
	];

	// Step 7: Create enhanced form content
	const formContent = createEnhancedFormContent(fields, false, false);

	// Step 8: Add dynamic behavior for starburst field based on steps
	const stepsInput = formContent.querySelector('input[name="radiiSteps"]');
	const starburstInput = formContent.querySelector('input[name="starburstOffset"]');
	const starburstLabel = formContent.querySelector('label[for="starburstOffset"]') || Array.from(formContent.querySelectorAll("label")).find((label) => label.textContent.includes("Starburst"));

	function updateStarburstAvailability() {
		const currentSteps = parseInt(stepsInput.value) || 0;
		const isStarburstEnabled = currentSteps >= 8;

		if (starburstInput) {
			starburstInput.disabled = !isStarburstEnabled;
			starburstInput.style.opacity = isStarburstEnabled ? "1" : "0.4";
			if (!isStarburstEnabled) {
				starburstInput.value = "100.0"; // Reset to 100% when disabled
			}
		}

		if (starburstLabel) {
			starburstLabel.style.opacity = isStarburstEnabled ? "1" : "0.4";
		}
	}

	// Step 9: Add event listener for steps input
	if (stepsInput) {
		stepsInput.addEventListener("input", updateStarburstAvailability);
		stepsInput.addEventListener("change", updateStarburstAvailability);
		// Initial check
		updateStarburstAvailability();
	}

	// Step 10: Add informational notes section with starburst limitation info
	const notesDiv = document.createElement("div");
	notesDiv.style.gridColumn = "1 / -1";
	notesDiv.style.marginTop = "10px";
	notesDiv.style.fontSize = "10px";
	notesDiv.style.color = "var(--text-color)";
	notesDiv.innerHTML =
		`
        <strong>Selected:</strong> ` +
		entityDescription +
		`<br>
        • Creates circular polygons around each point<br>
        • Union option combines overlapping circles<br>
        • Higher steps create smoother circles<br>
        • Line width inherited from first selected entity<br>
        • Rotation: 0° = no rotation, +45° = clockwise, -45° = counter-clockwise<br>
        • <strong>Starburst: Requires 8+ steps minimum</strong> (disabled for < 8 steps)<br>
        • Starburst: 100% = circle, 50% = even points at half radius, 0% = star shape<br>
        • Example: 5m radius + 50% starburst = odd points at 5m, even at 2.5m
    `;
	formContent.appendChild(notesDiv);

	// Step 11: Create FloatingDialog instance
	const dialog = new FloatingDialog({
		title: "Create Radii Polygons",
		content: formContent,
		layoutType: "wide",
		width: 420,
		height: 470, // Slightly taller for the extra note
		showConfirm: true,
		showCancel: true,
		confirmText: "Create",
		cancelText: "Cancel",
		onConfirm: () => {
			// Step 12: Get form values and validate
			const formData = getFormData(formContent);

			const radius = parseFloat(formData.radiiRadius);
			const steps = parseInt(formData.radiiSteps);
			const rotationOffset = parseFloat(formData.rotationOffset);
			let starburstOffset = parseFloat(formData.starburstOffset);
			const location = formData.radiiLocation;
			const lineWidth = parseFloat(formData.lineWidth);
			const unionCircles = formData.unionCircles === "true";
			const color = formData.radiiColor;

			// Step 13: Enhanced validation with starburst step requirement
			if (isNaN(radius) || radius <= 0) {
				showErrorDialog("Invalid Radius", "Please enter a valid radius > 0");
				return;
			}

			if (isNaN(steps) || steps < 3 || steps > 100) {
				showErrorDialog("Invalid Steps", "Steps must be between 3 and 100");
				return;
			}

			if (isNaN(rotationOffset) || rotationOffset < -360.0 || rotationOffset > 360.0) {
				showErrorDialog("Invalid Rotation", "Rotation offset must be between -360° and +360°");
				return;
			}

			// Step 14: Validate starburst only if it should be enabled
			if (steps >= 8) {
				if (isNaN(starburstOffset) || starburstOffset < 0.0 || starburstOffset > 100.0) {
					showErrorDialog("Invalid Starburst", "Starburst offset must be between 0% and 100%");
					return;
				}
			} else {
				// Force starburst to 100% for steps < 8 (now this works because starburstOffset is let)
				starburstOffset = 100.0;
			}

			if (isNaN(lineWidth) || lineWidth < 0.1 || lineWidth > 20) {
				showErrorDialog("Invalid Line Width", "Line width must be between 0.1 and 20");
				return;
			}

			// Step 15: Create radii parameters object (simplified logic since we handled it above)
			const radiiParams = {
				radius: radius,
				steps: steps,
				rotationOffset: rotationOffset,
				starburstOffset: starburstOffset / 100.0, // Convert percentage to decimal ratio
				useToeLocation: location === "end",
				unionCircles: unionCircles,
				color: color,
				lineWidth: lineWidth
			};

			// Step 16: Perform radii creation
			createRadiiFromSelectedEntitiesFixed(selectedEntities, radiiParams);

			// Step 17: Clean up selection state
			// Step: Clean up selection state using centralized function
			clearAllSelectionState();
			radiiHolesOrKADsTool.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("");
		},
		onCancel: () => {
			// Step 18: Clean up on cancel
			// Step: Clean up selection state using centralized function
			clearAllSelectionState();
			radiiHolesOrKADsTool.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("");
		}
	});

	// Step 19: Show dialog and initialize color picker
	dialog.show();

	// Step 20: Initialize JSColor after dialog shows and recheck starburst availability
	setTimeout(() => {
		jscolor.install();
		// Force z-index on any JSColor elements
		const colorInputs = formContent.querySelectorAll("[data-jscolor]");
		colorInputs.forEach((input) => {
			if (input.jscolor) {
				input.jscolor.option("zIndex", 20000);
			}
		});

		// Final check of starburst availability after dialog is fully loaded
		updateStarburstAvailability();
	}, 100);
}

// Fixed version of createRadiiFromSelectedEntities with proper coordinate handling and new parameters
function createRadiiFromSelectedEntitiesFixed(selectedEntities, params) {
	try {
		// Step 1: Update status message
		updateStatusMessage("Creating radii polygons for " + selectedEntities.length + " selected entities...");

		// Step 2: Convert selectedEntities to simple point coordinates
		const pointsForRadii = [];

		selectedEntities.forEach((entity) => {
			let pointCoords;

			if (entity.type === "hole") {
				// Step 3: For holes, use start or end location based on user choice
				if (params.useToeLocation) {
					pointCoords = {
						startXLocation: entity.endXLocation,
						startYLocation: entity.endYLocation,
						startZLocation: entity.endZLocation,
						endXLocation: entity.endXLocation,
						endYLocation: entity.endYLocation,
						endZLocation: entity.endZLocation
					};
				} else {
					pointCoords = {
						startXLocation: entity.startXLocation,
						startYLocation: entity.startYLocation,
						startZLocation: entity.startZLocation,
						endXLocation: entity.startXLocation,
						endYLocation: entity.startYLocation,
						endZLocation: entity.startZLocation
					};
				}
			} else {
				// Step 4: For KAD objects, use the single point coordinate (no start/end distinction)
				pointCoords = {
					startXLocation: entity.startXLocation,
					startYLocation: entity.startYLocation,
					startZLocation: entity.startZLocation,
					endXLocation: entity.startXLocation, // Same as start for KAD objects
					endYLocation: entity.startYLocation, // Same as start for KAD objects
					endZLocation: entity.startZLocation // Same as start for KAD objects
				};
			}

			pointsForRadii.push(pointCoords);
		});

		console.log("🔥 Calling getRadiiPolygons with " + pointsForRadii.length + " points:");
		console.log("   Rotation: " + params.rotationOffset + "°, Starburst: " + params.starburstOffset * 100 + "%");
		pointsForRadii.forEach((point, index) => {
			console.log("  Point " + (index + 1) + ": (" + point.startXLocation + ", " + point.startYLocation + ", " + point.startZLocation + ")");
		});

		// Step 5: Use existing getRadiiPolygons function with new rotation and starburst parameters
		const polygons = getRadiiPolygonsEnhanced(
			pointsForRadii,
			params.steps,
			params.radius,
			params.unionCircles,
			true, // addToMaps = true
			params.color,
			params.lineWidth,
			params.useToeLocation,
			params.rotationOffset,
			params.starburstOffset
		);

		console.log("✅ getRadiiPolygonsEnhanced returned " + polygons.length + " polygon(s)");

		// Step 6: Update display and save
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedUpdateTreeView();

		// Step 7: Create success message
		const resultMessage = params.unionCircles ? "Unioned radii polygon created successfully." : polygons.length + " radii polygon(s) created successfully.";

		updateStatusMessage(resultMessage);

		// Step 8: Show success dialog using FloatingDialog
		showSuccessDialog(
			"Radii Creation Successful",
			`
            <div style="text-align: center;">
                <p><strong>` +
				resultMessage +
				`</strong></p>
                <p><strong>Input:</strong> ` +
				selectedEntities.length +
				` entities</p>
                <p><strong>Output:</strong> ` +
				polygons.length +
				` polygon(s)</p>
                <p><strong>Radius:</strong> ` +
				params.radius +
				`m</p>
                <p><strong>Rotation:</strong> ` +
				params.rotationOffset +
				`°</p>
                <p><strong>Starburst:</strong> ` +
				params.starburstOffset * 100 +
				`%</p>
                <p><strong>Line Width:</strong> ` +
				params.lineWidth +
				`</p>
                <p><strong>Location:</strong> ` +
				(params.useToeLocation ? "End/Toe" : "Start/Collar") +
				`</p>
                <p><strong>Zoom or scroll to see the results.</strong></p>
            </div>
        `
		);
	} catch (error) {
		// Step 9: Handle errors with FloatingDialog
		console.error("❌ Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");

		showErrorDialog(
			"Radii Creation Failed",
			`
            <div style="text-align: center;">
                <p><strong>Failed to create radii polygons.</strong></p>
                <hr style="border-color: #555; margin: 15px 0;">
                <p><strong>Error:</strong><br>` +
				(error.message || "Unknown error occurred") +
				`</p>
            </div>
        `
		);
	}
}

// Helper function to show success dialog using FloatingDialog
function showSuccessDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 300,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		}
	});

	dialog.show();
}

// Helper function to show error dialog using FloatingDialog
function showErrorDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;
	contentDiv.style.color = "#ff6b6b";

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 200,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		}
	});

	dialog.show();
}
// Get all selected entities for radii creation
function getSelectedEntitiesForRadii() {
	const selectedEntities = [];

	// Add selected holes (handle both single and multiple selection)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach((hole) => {
			selectedEntities.push({
				type: "hole",
				data: hole,
				startXLocation: hole.startXLocation,
				startYLocation: hole.startYLocation,
				startZLocation: hole.startZLocation,
				endXLocation: hole.endXLocation,
				endYLocation: hole.endYLocation,
				endZLocation: hole.endZLocation
			});
		});
	} else if (selectedHole) {
		// Handle single selected hole
		selectedEntities.push({
			type: "hole",
			data: selectedHole,
			startXLocation: selectedHole.startXLocation,
			startYLocation: selectedHole.startYLocation,
			startZLocation: selectedHole.startZLocation,
			endXLocation: selectedHole.endXLocation,
			endYLocation: selectedHole.endYLocation,
			endZLocation: selectedHole.endZLocation
		});
	}

	// Add selected KAD object (singular) - with comprehensive debugging
	if (selectedKADObject) {
		console.log("🔍 Processing selectedKADObject:", selectedKADObject);

		// Check if data exists and is an array
		if (selectedKADObject.data && Array.isArray(selectedKADObject.data)) {
			console.log("📊 KAD object has data array with " + selectedKADObject.data.length + " items");

			if (selectedKADObject.entityType === "point") {
				// For points, use the point location
				selectedKADObject.data.forEach((point, index) => {
					console.log("🔵 Processing point " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_point",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0
					});
				});
			} else if (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly") {
				// For lines and polygons, use each vertex
				selectedKADObject.data.forEach((point, index) => {
					console.log("📍 Processing vertex " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_vertex",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0
					});
				});
			} else if (selectedKADObject.entityType === "text") {
				// For text, use the text position
				selectedKADObject.data.forEach((textPoint, index) => {
					console.log("📝 Processing text " + (index + 1) + ":", textPoint);
					selectedEntities.push({
						type: "kad_text",
						data: selectedKADObject,
						startXLocation: textPoint.pointXLocation,
						startYLocation: textPoint.pointYLocation,
						startZLocation: textPoint.pointZLocation || 0,
						endXLocation: textPoint.pointXLocation,
						endYLocation: textPoint.pointYLocation,
						endZLocation: textPoint.pointZLocation || 0
					});
				});
			} else if (selectedKADObject.entityType === "circle") {
				// For circles, use the center point
				selectedKADObject.data.forEach((circlePoint, index) => {
					console.log("⭕ Processing circle " + (index + 1) + ":", circlePoint);
					selectedEntities.push({
						type: "kad_circle",
						data: selectedKADObject,
						startXLocation: circlePoint.pointXLocation,
						startYLocation: circlePoint.pointYLocation,
						startZLocation: circlePoint.pointZLocation || 0,
						endXLocation: circlePoint.pointXLocation,
						endYLocation: circlePoint.pointYLocation,
						endZLocation: circlePoint.pointZLocation || 0
					});
				});
			}
		} else {
			// Alternative approach - try to extract from selectedKADObject itself
			console.warn("⚠️ KAD object doesn't have proper data array, trying alternative extraction");
			console.log("KAD Object structure:", selectedKADObject);

			// Check if it's stored in allKADDrawingsMap
			if (selectedKADObject.entityName) {
				const entity = allKADDrawingsMap.get(selectedKADObject.entityName);
				if (entity && entity.data && Array.isArray(entity.data)) {
					console.log("✅ Found entity in allKADDrawingsMap with " + entity.data.length + " points");

					entity.data.forEach((point, index) => {
						console.log("🔄 Processing entity point " + (index + 1) + ":", point);
						selectedEntities.push({
							type: "kad_entity_point",
							data: entity,
							startXLocation: point.pointXLocation,
							startYLocation: point.pointYLocation,
							startZLocation: point.pointZLocation || 0,
							endXLocation: point.pointXLocation,
							endYLocation: point.pointYLocation,
							endZLocation: point.pointZLocation || 0
						});
					});
				}
			}

			// Last resort - use selectedKADObject directly if it has coordinates
			if (selectedEntities.length === 0 && selectedKADObject.pointXLocation !== undefined && selectedKADObject.pointYLocation !== undefined) {
				console.log("🆘 Using fallback direct coordinates");
				selectedEntities.push({
					type: "kad_fallback",
					data: selectedKADObject,
					startXLocation: selectedKADObject.pointXLocation,
					startYLocation: selectedKADObject.pointYLocation,
					startZLocation: selectedKADObject.pointZLocation || 0,
					endXLocation: selectedKADObject.pointXLocation,
					endYLocation: selectedKADObject.pointYLocation,
					endZLocation: selectedKADObject.pointZLocation || 0
				});
			}
		}
	}

	console.log("🎯 Final selectedEntities array has " + selectedEntities.length + " entities:");
	selectedEntities.forEach((entity, index) => {
		console.log("  " + (index + 1) + ". " + entity.type + " at (" + entity.startXLocation + ", " + entity.startYLocation + ", " + entity.startZLocation + ")");
	});

	return selectedEntities;
}

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - ENDED
// ================================

// ================================
// DRAW BLAST BOUNDARY FUNCTIONALITY - STARTED
// ================================

function drawBlastBoundary(polygon, strokeColor) {
	//convert wold coords to screen cords
	const screenCoords = polygon.map((point) => {
		const x = (point.x - centroidX) * currentScale + canvas.width / 2;
		const y = (-point.y + centroidY) * currentScale + canvas.height / 2;
		return {
			x,
			y
		};
	});

	ctx.beginPath();
	ctx.moveTo(screenCoords[0].x, screenCoords[0].y);
	for (let i = 1; i < screenCoords.length; i++) {
		ctx.lineTo(screenCoords[i].x, screenCoords[i].y);
	}
	ctx.closePath();
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 2;
	ctx.stroke();
}

function offsetPolygonMathematical(polygon, offset) {
	const result = [];
	const n = polygon.length;
	const quadrantRads = [];

	for (let i = 0; i < n; i++) {
		const dx = polygon[(i + 1) % n].x - polygon[i].x;
		const dy = polygon[(i + 1) % n].y - polygon[i].y;
		const dist = Math.sqrt(dx * dx + dy * dy);

		let angle = 0;
		if (dist > 0) {
			if (dy >= 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.asin(dx / dist);
			} else if (dy < 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.acos(dy / dist);
			} else if (dy < 0 && dx < 0) {
				angle = (3 * Math.PI) / 2 - Math.asin(-dx / dist);
			} else {
				angle = (3 * Math.PI) / 2 - Math.acos(-dy / dist);
			}
		}
		quadrantRads.push(angle);
	}

	const offsetSegments = [];
	for (let i = 0; i < n; i++) {
		const theta = quadrantRads[i];
		const dx = offset * -Math.sin(theta);
		const dy = offset * Math.cos(theta);

		const p1 = {
			x: polygon[i].x + dx,
			y: polygon[i].y + dy
		};
		const p2 = {
			x: polygon[(i + 1) % n].x + dx,
			y: polygon[(i + 1) % n].y + dy
		};
		offsetSegments.push([p1, p2]);
	}

	for (let i = 0; i < n; i++) {
		const [p1a, p1b] = offsetSegments[i];
		const [p2a, p2b] = offsetSegments[(i + 1) % n];

		const denom = -(p2b.x - p2a.x) * -Math.sin(quadrantRads[i]) - Math.cos(quadrantRads[i]) * (p2b.y - p2a.y);

		if (denom === 0) {
			result.push(p1b); // fallback
			continue;
		}

		const s = Math.cos(quadrantRads[(i + 1) % n]) * (p2b.y - p2a.y) - (p2b.x - p2a.x) * Math.sin(quadrantRads[(i + 1) % n]);
		const t = s / denom;

		const x = p1b.x + Math.cos(quadrantRads[i]) * t;
		const y = p1b.y + Math.sin(quadrantRads[i]) * t;
		result.push({
			x: x,
			y: y
		});
	}

	return result;
}

// FIXED: Much faster getAverageDistance function
function getAverageDistance(points) {
	if (!points || !Array.isArray(points) || points.length < 2) return 1;

	// For large datasets, use sampling to avoid O(n²) performance
	if (points.length > 1000) {
		// Sample every Nth point to keep it manageable
		const sampleSize = Math.min(500, Math.floor(points.length / 10));
		const step = Math.floor(points.length / sampleSize);
		const sampledPoints = [];

		for (let i = 0; i < points.length; i += step) {
			sampledPoints.push(points[i]);
		}

		// Use the sampled points for calculation
		return getAverageDistanceSmall(sampledPoints);
	}

	// For small datasets, use the original algorithm
	return getAverageDistanceSmall(points);
}

// Helper function for small datasets
function getAverageDistanceSmall(points) {
	let total = 0;
	let count = 0;

	for (let i = 0; i < points.length; i++) {
		let minDist = Infinity;

		for (let j = 0; j < points.length; j++) {
			if (i === j) continue;

			const dx = points[i].startXLocation - points[j].startXLocation;
			const dy = points[i].startYLocation - points[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);

			if (dist < minDist) {
				minDist = dist;
			}
		}

		if (minDist < Infinity) {
			total += minDist;
			count++;
		}
	}

	return count > 0 ? total / count : 1;
}

function clearCanvas() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
}
/*** CODE TO DRAW POINTS FROM KAD DATA ***/
function drawKADPoints(x, y, z, lineWidth = 1, strokeColor) {
	ctx.beginPath();
	ctx.arc(x, y, lineWidth, 0, 2 * Math.PI);
	ctx.strokeStyle = strokeColor;
	ctx.fillStyle = strokeColor;
	// Don't use line width use the line width as a proxy for diameter.
	ctx.stroke();
	ctx.fill();
}
//Draws an open poly line from the kadLinesArray
function drawKADLines(sx, sy, ex, ey, sz, ez, lineWidth, strokeColor) {
	ctx.beginPath();
	ctx.moveTo(sx, sy);
	ctx.lineTo(ex, ey);
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = lineWidth;
	ctx.stroke();
}

function drawKADPolys(sx, sy, ex, ey, sz, ez, lineWidth, strokeColor, isClosed) {
	ctx.beginPath();
	ctx.moveTo(sx, sy);
	ctx.lineTo(ex, ey);
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = lineWidth;
	ctx.stroke();
	if (isClosed) {
		ctx.closePath();
	}
}

function drawAllKADSelectionVisuals() {
	console.log("Drawing selections - single:", selectedKADObject ? 1 : 0, "multiple:", selectedMultipleKADObjects.length); // DEBUG - ADD THIS LINE
	// Handle single selection
	if (isSelectionPointerActive && selectedKADObject) {
		if (selectedKADObject.entityType === "circle") {
			// Highlight circles with a ring
			drawCircleSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "text") {
			// Highlight text with a box
			drawTextSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "point") {
			// Highlight points with a larger circle
			drawPointSelection(selectedKADObject);
		} else {
			// Use existing polygon selection for lines/polygons
			drawKADPolyUnified(selectedKADObject);
		}
	}

	// Handle multiple selections - use the same style as single selection
	if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		selectedMultipleKADObjects.forEach((kadObj) => {
			const entity = allKADDrawingsMap.get(kadObj.entityName);
			if (entity) {
				// Use the same selection functions for each selected object
				if (entity.entityType === "circle") {
					drawCircleSelection(entity);
				} else if (entity.entityType === "text") {
					drawTextSelection(entity);
				} else if (entity.entityType === "point") {
					drawPointSelection(entity);
				} else if (entity.entityType === "poly" || entity.entityType === "line") {
					// Use the same polygon/line selection drawing
					drawKADPolyUnified(entity.data);
				}
			}
		});
	}
}
// Unified drawing function for both lines and polygons
function drawKADPolyUnified(points) {
	if (points.length < 1) return;

	let currentPath = [];

	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		currentPath.push(point);

		// Check if this is the end of a path (closed or last point)
		const isLastPoint = i === points.length - 1;
		const isClosedPolygon = point.closed === true;

		if (isLastPoint || isClosedPolygon) {
			// Draw the accumulated path
			if (currentPath.length === 1) {
				// Single point - draw as dot
				const [x, y] = worldToCanvas(currentPath[0].pointXLocation, currentPath[0].pointYLocation);
				drawKADPoints(x, y, currentPath[0].pointZLocation, currentPath[0].color);
			} else if (currentPath.length >= 2) {
				// Multiple points - draw as polyline/polygon
				drawPolyPath(currentPath, isClosedPolygon);
			}

			// Reset for next path
			currentPath = [];
		}
	}
}

// Helper function to draw a path of connected points
function drawPolyPath(pathPoints, closed) {
	if (pathPoints.length < 2) return;

	const lineWidth = pathPoints[0].lineWidth || 1;
	const strokeColor = pathPoints[0].color || "#FF0000";

	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = lineWidth;
	ctx.beginPath();

	// Start at first point
	const [startX, startY] = worldToCanvas(pathPoints[0].pointXLocation, pathPoints[0].pointYLocation);
	ctx.moveTo(startX, startY);

	// Draw to subsequent points
	for (let i = 1; i < pathPoints.length; i++) {
		const [x, y] = worldToCanvas(pathPoints[i].pointXLocation, pathPoints[i].pointYLocation);
		ctx.lineTo(x, y);
	}

	// Close if it's a polygon
	if (closed) {
		ctx.closePath();
	}

	ctx.stroke();
}

// Add this to your drawData function
function drawPolygonSelection(ctx) {
	if (!isPolygonSelectionActive || polyPointsX.length < 2) return;

	ctx.beginPath();
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		if (i === 0) {
			ctx.moveTo(x, y);
		} else {
			ctx.lineTo(x, y);
		}
	}

	// Close the polygon by connecting back to first point
	if (polyPointsX.length >= 2) {
		const [firstX, firstY] = worldToCanvas(polyPointsX[0], polyPointsY[0]);
		ctx.lineTo(firstX, firstY);
	}

	ctx.strokeStyle = "rgba(200, 0, 200, 0.5)";
	ctx.lineWidth = 1;
	ctx.stroke();

	// Draw vertices
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		ctx.beginPath();
		ctx.arc(x, y, 4, 0, Math.PI * 2);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.fill();
	}
}

// Enhanced KAD preview function - FIXED VERSION
function drawKADPreviewLine(ctx) {
	// Check which tools are active
	const isPointActive = addPointDraw.checked;
	const isLineActive = addLineDraw.checked;
	const isCircleActive = addCircleDraw.checked;
	const isPolyActive = addPolyDraw.checked;
	const isTextActive = addTextDraw.checked;
	// const isPolygonSelectionActive_local = isPolyActive;

	const anyToolActive = isPointActive || isLineActive || isCircleActive || isPolyActive || isTextActive; // || isPolygonSelectionActive_local;

	if (!anyToolActive) return;

	// Skip if mouse is at origin (not moved yet)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	let previewStartX = null;
	let previewStartY = null;
	let previewColor = "rgba(255, 255, 255, 0.7)"; // Default white
	let previewStyle = [5, 5]; // Default dash pattern
	let shouldDraw = false;

	// Handle polygon selection first (it has its own tracking)
	if (isPolyActive && polyPointsX.length > 0) {
		previewStartX = polyPointsX[polyPointsX.length - 1];
		previewStartY = polyPointsY[polyPointsY.length - 1];
		previewColor = "rgba(255, 0, 255, 0.7)"; // Magenta for polygon selection
		previewStyle = [5, 5];
		shouldDraw = true;
	}
	// For other tools, use lastKADDrawPoint if available
	else if (lastKADDrawPoint) {
		previewStartX = lastKADDrawPoint.x;
		previewStartY = lastKADDrawPoint.y;
		shouldDraw = true;

		// Set colors and styles for different tools
		if (isLineActive) {
			previewColor = "rgba(0, 255, 255, 0.7)"; // Cyan for lines
			previewStyle = [8, 4];
		} else if (isCircleActive) {
			previewColor = "rgba(255, 165, 0, 0.7)"; // Orange for circles
			previewStyle = [6, 3];
		} else if (isPointActive) {
			previewColor = "rgba(209, 0, 0, 0.8)"; // Red for points
			previewStyle = [4, 2];
		} else if (isTextActive) {
			previewColor = "rgba(0, 255, 0, 0.7)"; // Green for text
			previewStyle = [10, 5];
		} else if (isPolyActive) {
			previewColor = "rgba(215, 0, 215, 0.7)"; // Purple for polygons
			previewStyle = [7, 3];
		}
	}

	// Show tool indicators for ALL active tools (even if no previous point)
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	if (isPointActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(209, 0, 0, 0.8)"; // Purple for points
		ctx.lineWidth = 2;
		if (shouldDraw) {
			const distance = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			ctx.font = "12px Arial";
			ctx.fillStyle = "rgba(209, 0, 0, 0.8)";
			ctx.fillText(distance.toFixed(2) + "m", mouseCanvasX + 10, mouseCanvasY - 10);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isCircleActive) {
		ctx.beginPath();
		ctx.lineWidth = 2;
		if (shouldDraw) {
			const distance = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			ctx.font = "12px Arial";
			ctx.fillStyle = "rgba(255, 165, 0, 0.8)"; // Orange for circles
			ctx.fillText(distance.toFixed(2) + "m", mouseCanvasX + 10, mouseCanvasY - 10);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, parseFloat(circleRadius.value) * currentScale, 0, Math.PI * 2);
		// // Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		//color of the circle to be drawn
		ctx.fillStyle = getJSColorHexDrawing() + "4D"; // Drawing color at 30% opacity
		ctx.fill();
	} else if (isTextActive) {
		// Show crosshair for Text tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 255, 0, 0.6)"; // Green for Text
		ctx.lineWidth = 2;
		if (shouldDraw) {
			const distance = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			ctx.font = "12px Arial";
			ctx.fillStyle = "rgba(0, 255, 0, 0.7)"; // Green for text
			ctx.fillText(distance.toFixed(2) + "m", mouseCanvasX + 10, mouseCanvasY - 10);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isLineActive) {
		// Show crosshair for line tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 207, 207, 0.8)"; // Cyan for lines
		ctx.lineWidth = 2;
		// Calculate and display distance for line preview
		if (shouldDraw) {
			const distance = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			ctx.font = "12px Arial";
			ctx.fillStyle = "rgba(0, 207, 207, 0.8)";
			ctx.fillText(distance.toFixed(2) + "m", mouseCanvasX + 10, mouseCanvasY - 10);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
		//ctx.setLineDash([]);
	} else if (isPolyActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(215, 0, 215, 0.6)"; // Purple for polygons
		ctx.lineWidth = 2;
		// Show for polygon tool
		// Calculate and display distance for line preview
		if (shouldDraw) {
			const distance = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			ctx.font = "12px Arial";
			ctx.fillStyle = "rgba(215, 0, 215, 0.6)";
			ctx.fillText(distance.toFixed(2) + "m", mouseCanvasX + 10, mouseCanvasY - 10);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);

		ctx.stroke();
	}

	// Draw preview line if we have a start point
	if (shouldDraw) {
		const [startCanvasX, startCanvasY] = worldToCanvas(previewStartX, previewStartY);

		// Draw the preview line
		ctx.beginPath();
		ctx.setLineDash(previewStyle);
		ctx.strokeStyle = previewColor;
		ctx.lineWidth = 2;
		ctx.moveTo(startCanvasX, startCanvasY);
		ctx.lineTo(mouseCanvasX, mouseCanvasY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Draw a small indicator at the start point
		ctx.beginPath();
		ctx.arc(startCanvasX, startCanvasY, 3, 0, Math.PI * 2);
		ctx.fillStyle = previewColor;
		ctx.fill();
	}
}
// Function to update the last KAD draw point when user draws something
function updateLastKADDrawPoint(x, y) {
	lastKADDrawPoint = {
		x: x,
		y: y
	};
}
// Simplified test version of the KAD preview function
function drawKADTESTPreviewLine(ctx) {
	// Simple test: just check if any tool is active and draw a line
	const anyToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked || isPolygonSelectionActive;

	if (!anyToolActive) return;

	// Use mouse coordinates (they're 0 by default, not null)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	// For testing, let's always use the center of the canvas as start point
	const testStartX = centroidX;
	const testStartY = centroidY;

	// Convert to canvas coordinates
	const [startCanvasX, startCanvasY] = worldToCanvas(testStartX, testStartY);
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	// Draw a bright red test line
	ctx.beginPath();
	ctx.setLineDash([10, 10]);
	ctx.strokeStyle = "rgba(255, 0, 0, 1.0)"; // Bright red
	ctx.lineWidth = 3;
	ctx.moveTo(startCanvasX, startCanvasY);
	ctx.lineTo(mouseCanvasX, mouseCanvasY);
	ctx.stroke();
	ctx.setLineDash([]);

	// Draw a circle at mouse position for debugging
	ctx.beginPath();
	ctx.arc(mouseCanvasX, mouseCanvasY, 5, 0, Math.PI * 2);
	ctx.fillStyle = "rgba(255, 0, 0, 1.0)";
	ctx.fill();
}

// Fix the drawKADCircles function around line 6450:
function drawKADCircles(x, y, z, radius, lineWidth, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	// Convert radius from world units to screen pixels
	const radiusInPixels = radius * currentScale;
	ctx.arc(x, y, radiusInPixels, 0, 2 * Math.PI);
	ctx.lineWidth = lineWidth;
	ctx.stroke();
}
// Also update the drawKADTexts function to handle multiline calculations
function drawKADTexts(x, y, z, text, color) {
	ctx.save(); // Save current context state
	ctx.font = parseInt(currentFontSize - 2) + "px Arial";
	drawMultilineText(ctx, text, x, y, currentFontSize, "left", color, color, false);
	ctx.restore(); // Restore context state
}
/*** CODE TO DRAW POINTS FROM CSV DATA ***/
function drawTrack(lineStartX, lineStartY, lineEndX, lineEndY, gradeX, gradeY, strokeColor, subdrillAmount) {
	ctx.lineWidth = 1;

	if (subdrillAmount < 0) {
		// NEGATIVE SUBDRILL: Draw only from start to toe (bypass grade)
		// Use 20% opacity for the entire line since it represents "over-drilling"
		ctx.beginPath();
		ctx.strokeStyle = strokeColor;
		ctx.moveTo(lineStartX, lineStartY);
		ctx.lineTo(lineEndX, lineEndY);
		ctx.stroke();
		// Draw from grade to toe (subdrill portion - red)
		ctx.beginPath();
		ctx.strokeStyle = "rgba(255, 0, 0, 0.2)"; // Red line (full opacity)
		ctx.moveTo(lineEndX, lineEndY);
		ctx.lineTo(gradeX, gradeY);
		ctx.stroke();
		// Draw grade marker with 20% opacity
		ctx.beginPath();
		ctx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
		ctx.fillStyle = `rgba(255, 0, 0, 0.2)`; // Red marker with 20% opacity
		ctx.fill();
	} else {
		// POSITIVE SUBDRILL: Draw from start to grade (dark), then grade to toe (red)

		// Draw from start to grade point (bench drill portion - dark)
		ctx.beginPath();
		ctx.strokeStyle = strokeColor; // Dark line (full opacity)
		ctx.moveTo(lineStartX, lineStartY);
		ctx.lineTo(gradeX, gradeY);
		ctx.stroke();

		// Draw from grade to toe (subdrill portion - red)
		ctx.beginPath();
		ctx.strokeStyle = "rgba(255, 0, 0, 1.0)"; // Red line (full opacity)
		ctx.moveTo(gradeX, gradeY);
		ctx.lineTo(lineEndX, lineEndY);
		ctx.stroke();

		// Draw grade marker (full opacity)
		ctx.beginPath();
		ctx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
		ctx.fillStyle = "rgba(255, 0, 0, 1.0)"; // Red marker (full opacity)
		ctx.fill();
	}
}

function drawHoleToe(x, y, fillColor, strokeColor, radius) {
	ctx.beginPath();
	// Use the toeSizeInMeters directly to set the radius
	ctx.lineWidth = 1;
	ctx.arc(x, y, radius, 0, 2 * Math.PI);
	ctx.fillStyle = fillColor;
	ctx.strokeStyle = strokeColor;
	ctx.stroke();
	ctx.fill();
}

function drawHole(x, y, radius, fillColor, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.fillStyle = strokeColor;
	ctx.lineWidth = 1;
	ctx.beginPath();
	const minRadius = 1.5;
	const drawRadius = radius > minRadius ? radius : minRadius;
	ctx.arc(x, y, drawRadius, 0, 2 * Math.PI);
	ctx.fill(); // fill the circle with the fill color
	ctx.stroke(); // draw the circle border with the stroke color
}

function drawDummy(x, y, radius, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 2; // Adjust the line width as needed
	ctx.beginPath();
	ctx.moveTo(x - radius, y - radius);
	ctx.lineTo(x + radius, y + radius);
	ctx.moveTo(x - radius, y + radius);
	ctx.lineTo(x + radius, y - radius);
	ctx.stroke();
}

function drawNoDiameterHole(x, y, sideLength, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 2; // Adjust the line width as needed
	const halfSide = sideLength / 2;
	ctx.beginPath();
	ctx.moveTo(x - halfSide, y - halfSide);
	ctx.lineTo(x + halfSide, y - halfSide);
	ctx.lineTo(x + halfSide, y + halfSide);
	ctx.lineTo(x - halfSide, y + halfSide);
	ctx.closePath(); // Close the path to form a square
	ctx.stroke();
}

function drawHiHole(x, y, radius, fillColor, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	ctx.arc(x, y, radius, 0, 2 * Math.PI);
	ctx.fillStyle = fillColor;
	ctx.fill(); // fill the circle with the fill color
	ctx.lineWidth = 5;
	ctx.stroke(); // draw the circle border with the stroke color
}

function drawExplosion(x, y, spikes, outerRadius, innerRadius, color1, color2) {
	let rotation = (Math.PI / 2) * 3;
	let step = Math.PI / spikes;
	let start = rotation;

	// Start the drawing path
	ctx.beginPath();
	ctx.moveTo(x, y - outerRadius);
	for (let i = 0; i < spikes; i++) {
		ctx.lineTo(x + Math.cos(start) * outerRadius, y - Math.sin(start) * outerRadius);
		start += step;

		ctx.lineTo(x + Math.cos(start) * innerRadius, y - Math.sin(start) * innerRadius);
		start += step;
	}
	ctx.lineTo(x, y - outerRadius);
	ctx.closePath();
	ctx.lineWidth = 5;
	ctx.strokeStyle = color1;
	ctx.stroke();
	ctx.fillStyle = color2;
	ctx.fill();
}

function drawHexagon(x, y, sideLength, fillColor, strokeColor) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	const rotationAngleRadians = (Math.PI / 180) * 30;
	for (let i = 0; i < 6; i++) {
		const angle = rotationAngleRadians + (Math.PI / 3) * i;
		const offsetX = sideLength * Math.cos(angle);
		const offsetY = sideLength * Math.sin(angle);

		if (i === 0) {
			ctx.moveTo(x + offsetX, y + offsetY);
		} else {
			ctx.lineTo(x + offsetX, y + offsetY);
		}
	}

	ctx.closePath();
	ctx.fillStyle = fillColor;
	ctx.fill(); // fill the hexagon with the fill color
	ctx.lineWidth = 5;
	ctx.stroke(); // draw the hexagon border with the stroke color
}

function drawText(x, y, text, color) {
	ctx.font = parseInt(currentFontSize - 2) + "px Arial";
	ctx.fillStyle = color;
	ctx.fillText(text, x, y);
}

function drawRightAlignedText(x, y, text, color) {
	ctx.font = parseInt(currentFontSize - 2) + "px Arial";
	const textWidth = ctx.measureText(text).width;
	ctx.fillStyle = color;
	// Draw the text at an x position minus the text width for right alignment
	drawText(x - textWidth, y, text, color);
}

function drawMultilineText(ctx, text, x, y, lineHeight = 16, alignment = "left", textColor, boxColor, showBox = false) {
	if (!text) return; //if no text, return
	if (!ctx) return; //if no context, return
	const lines = text.split("\n");
	//calculate the text width of the widest line NOT the the entire sting.
	let textWidth = 0;
	for (let i = 0; i < lines.length; i++) {
		const lineWidth = ctx.measureText(lines[i]).width;
		if (lineWidth > textWidth) {
			textWidth = lineWidth;
		}
	}
	//colorise the text
	ctx.fillStyle = textColor;
	for (let i = 0; i < lines.length; i++) {
		if (alignment == "left") {
			ctx.fillText(lines[i], x, y + i * lineHeight);
		} else if (alignment == "right") {
			ctx.fillText(lines[i], x - textWidth, y + i * lineHeight);
		} else if (alignment == "center") {
			// Center each line individually based on its own width
			const lineWidth = ctx.measureText(lines[i]).width;
			ctx.fillText(lines[i], x - lineWidth / 2, y + i * lineHeight);
		}
	}

	if (showBox) {
		//colorise the box
		//ctx.fillStyle = boxColor;
		ctx.strokeStyle = boxColor;
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.roundRect(x - 5 - textWidth / 2, y - 6 - lineHeight / 2, textWidth + 10, lines.length * lineHeight + 6, 4);
		ctx.stroke();
	}
}

function drawDirectionArrow(startX, startY, endX, endY, fillColor, strokeColor, connScale) {
	try {
		// Set up the arrow parameters
		var arrowWidth = (firstMovementSize / 4) * currentScale; // Width of the arrowhead
		var arrowLength = 2 * (firstMovementSize / 4) * currentScale; // Length of the arrowhead
		var tailWidth = arrowWidth * 0.7; // Width of the tail (adjust as needed)
		const angle = Math.atan2(endY - startY, endX - startX); // Angle of the arrow

		// Set the stroke and fill colors
		ctx.strokeStyle = strokeColor; // Stroke color (black outline)
		ctx.fillStyle = fillColor; // Fill color (goldenrod)

		// Begin drawing the arrow as a single path
		ctx.beginPath();

		// Move to the start point of the arrow
		ctx.moveTo(startX + (tailWidth / 2) * Math.sin(angle), startY - (tailWidth / 2) * Math.cos(angle)); // Top-left corner of the tail

		// Draw to the end point of the tail (top-right corner)
		ctx.lineTo(endX - arrowLength * Math.cos(angle) + (tailWidth / 2) * Math.sin(angle), endY - arrowLength * Math.sin(angle) - (tailWidth / 2) * Math.cos(angle));

		// Draw the right base of the arrowhead
		ctx.lineTo(endX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle), endY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle));

		// Draw the tip of the arrowhead
		ctx.lineTo(endX, endY);

		// Draw the left base of the arrowhead
		ctx.lineTo(endX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle), endY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle));

		// Draw back to the bottom-right corner of the tail
		ctx.lineTo(endX - arrowLength * Math.cos(angle) - (tailWidth / 2) * Math.sin(angle), endY - arrowLength * Math.sin(angle) + (tailWidth / 2) * Math.cos(angle));

		// Draw to the bottom-left corner of the tail
		ctx.lineTo(startX - (tailWidth / 2) * Math.sin(angle), startY + (tailWidth / 2) * Math.cos(angle));

		ctx.closePath();
		ctx.fill(); // Fill the arrow with color
		ctx.stroke(); // Outline the arrow with a stroke
	} catch (error) {
		console.error("Error while drawing arrow:", error);
	}
}

function drawArrow(startX, startY, endX, endY, color, connScale, connectorCurve = 0) {
	try {
		// Step 1) Set up the arrow parameters
		var arrowWidth = (connScale / 4) * currentScale;
		var arrowLength = 2 * (connScale / 4) * currentScale;

		ctx.strokeStyle = color;
		ctx.fillStyle = color;
		ctx.lineWidth = 2;

		// Step 2) Handle straight arrow (0 degrees)
		if (connectorCurve === 0) {
			// Draw straight line
			ctx.beginPath();
			ctx.moveTo(parseInt(startX), parseInt(startY));
			ctx.lineTo(parseInt(endX), parseInt(endY));
			ctx.stroke();

			// Calculate angle for arrowhead
			const angle = Math.atan2(startX - endX, startY - endY);
		} else {
			// Step 3) Draw curved arrow
			const midX = (startX + endX) / 2;
			const midY = (startY + endY) / 2;
			const dx = endX - startX;
			const dy = endY - startY;
			const distance = Math.sqrt(dx * dx + dy * dy);

			// Step 4) Calculate control point based on angle in degrees
			const radians = (connectorCurve * Math.PI) / 180;
			const curveFactor = (connectorCurve / 90) * distance * 0.5; // Linear scaling instead of sine

			// Perpendicular vector for curve direction
			const perpX = -dy / distance;
			const perpY = dx / distance;

			const controlX = midX + perpX * curveFactor;
			const controlY = midY + perpY * curveFactor;

			// Step 5) Draw curved line using quadratic bezier
			ctx.beginPath();
			ctx.moveTo(parseInt(startX), parseInt(startY));
			ctx.quadraticCurveTo(parseInt(controlX), parseInt(controlY), parseInt(endX), parseInt(endY));
			ctx.stroke();
		}

		// Step 6) Draw arrowhead
		if (endX == startX && endY == startY) {
			// Draw house shape for self-referencing
			var size = (connScale / 4) * currentScale;
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.moveTo(endX, endY);
			ctx.lineTo(endX - size / 2, endY + size);
			ctx.lineTo(endX - size / 2, endY + 1.5 * size);
			ctx.lineTo(endX + size / 2, endY + 1.5 * size);
			ctx.lineTo(endX + size / 2, endY + size);
			ctx.closePath();
			ctx.stroke();
		} else {
			// Step 7) Calculate arrowhead angle for curved or straight arrows
			let angle;
			if (connectorCurve !== 0) {
				// For curved arrows, calculate angle at the end point
				const dx = endX - startX;
				const dy = endY - startY;
				const distance = Math.sqrt(dx * dx + dy * dy);
				const curveFactor = (connectorCurve / 90) * distance * 0.5;
				const perpX = -dy / distance;
				const perpY = dx / distance;
				const controlX = (startX + endX) / 2 + perpX * curveFactor;
				const controlY = (startY + endY) / 2 + perpY * curveFactor;

				// Calculate tangent at end point (derivative of quadratic bezier at t=1)
				const tangentX = 2 * (endX - controlX);
				const tangentY = 2 * (endY - controlY);
				angle = Math.atan2(tangentY, tangentX);

				// Draw arrowhead for curved arrows
				ctx.beginPath();
				ctx.moveTo(parseInt(endX), parseInt(endY));
				ctx.lineTo(endX - arrowLength * Math.cos(angle - Math.PI / 6), endY - arrowLength * Math.sin(angle - Math.PI / 6));
				ctx.lineTo(endX - arrowLength * Math.cos(angle + Math.PI / 6), endY - arrowLength * Math.sin(angle + Math.PI / 6));
				ctx.closePath();
				ctx.fill();
			} else {
				// For straight arrows - use the original working calculation
				angle = Math.atan2(startX - endX, startY - endY);

				// Draw arrowhead for straight arrows (original working method)
				ctx.beginPath();
				ctx.moveTo(parseInt(endX), parseInt(endY));
				ctx.lineTo(endX - arrowLength * Math.cos((Math.PI / 2) * 3 - angle) - arrowWidth * Math.sin((Math.PI / 2) * 3 - angle), endY - arrowLength * Math.sin((Math.PI / 2) * 3 - angle) + arrowWidth * Math.cos((Math.PI / 2) * 3 - angle));
				ctx.lineTo(endX - arrowLength * Math.cos((Math.PI / 2) * 3 - angle) + arrowWidth * Math.sin((Math.PI / 2) * 3 - angle), endY - arrowLength * Math.sin((Math.PI / 2) * 3 - angle) - arrowWidth * Math.cos((Math.PI / 2) * 3 - angle));
				ctx.closePath();
				ctx.fill();
			}
		}
	} catch (error) {
		console.error("Error while drawing arrow:", error);
	}
}

function drawArrowDelayText(startX, startY, endX, endY, color, text, connectorCurve = 0) {
	// Step 1) Calculate text position and angle
	let textX, textY, textAngle;

	if (connectorCurve === 0) {
		// Straight arrow - use midpoint
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		textAngle = Math.atan2(endY - startY, endX - startX);

		// Calculate perpendicular offset to move text above the line
		const perpAngle = textAngle - Math.PI / 2; // 90 degrees counterclockwise
		const offsetDistance = (currentFontSize - 2) * 0.1; // Much smaller offset

		textX = midX + Math.cos(perpAngle) * offsetDistance;
		textY = midY + Math.sin(perpAngle) * offsetDistance;
	} else {
		// Step 2) Curved arrow - calculate actual point on curve at t=0.5
		const dx = endX - startX;
		const dy = endY - startY;
		const distance = Math.sqrt(dx * dx + dy * dy);
		const curveFactor = (connectorCurve / 90) * distance * 0.5;

		const perpX = -dy / distance;
		const perpY = dx / distance;

		// Control point
		const controlX = (startX + endX) / 2 + perpX * curveFactor;
		const controlY = (startY + endY) / 2 + perpY * curveFactor;

		// Calculate actual point on quadratic bezier curve at t=0.5 (midpoint)
		const t = 0.5;
		const oneMinusT = 1 - t;
		const curveX = oneMinusT * oneMinusT * startX + 2 * oneMinusT * t * controlX + t * t * endX;
		const curveY = oneMinusT * oneMinusT * startY + 2 * oneMinusT * t * controlY + t * t * endY;

		// Calculate tangent angle at t=0.5 for proper text rotation
		const tangentX = 2 * oneMinusT * (controlX - startX) + 2 * t * (endX - controlX);
		const tangentY = 2 * oneMinusT * (controlY - startY) + 2 * t * (endY - controlY);
		textAngle = Math.atan2(tangentY, tangentX);

		// Calculate perpendicular offset to move text above the curve
		const perpAngle = textAngle - Math.PI / 2; // 90 degrees counterclockwise from tangent
		const offsetDistance = (currentFontSize - 2) * 0.1; // Much smaller offset

		textX = curveX + Math.cos(perpAngle) * offsetDistance;
		textY = curveY + Math.sin(perpAngle) * offsetDistance;
	}

	// Step 3) Draw the text above the curve/line
	ctx.save();
	ctx.translate(textX, textY);
	ctx.rotate(textAngle);

	ctx.fillStyle = color;
	ctx.font = parseInt(currentFontSize - 2) + "px Arial";

	// Center the text horizontally and position baseline properly
	const textWidth = ctx.measureText(text).width;
	ctx.fillText(text, -textWidth / 2, 0); // y=0 puts baseline at the translated position

	ctx.restore();
}

function drawDelauanySlopeMap(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.fillStyle = fillColor;
	ctx.lineWidth = 1;
	console.log("drawDelauanySlopeMap: " + triangles.length);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		const edge1 = {
			x: tBX - tAX,
			y: tBY - tAY,
			z: tBZ - tAZ
		};
		const edge2 = {
			x: tCX - tAX,
			y: tCY - tAY,
			z: tCZ - tAZ
		};
		const edge3 = {
			x: tCX - tBX,
			y: tCY - tBY,
			z: tCZ - tBZ
		};

		// Calculate the maximum absolute slope angle for this triangle
		//const slopeAngles = [Math.abs(getEdgeSlopeAngle(triangle[0], triangle[1])), Math.abs(getEdgeSlopeAngle(triangle[1], triangle[2])), Math.abs(getEdgeSlopeAngle(triangle[2], triangle[0]))];
		//let maxSlopeAngle = Math.max(...slopeAngles);

		let maxSlopeAngle = getDipAngle(triangle);

		// Create a triangle array
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aAZ = tAZ;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aBZ = tBZ;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;
		const aCZ = tCZ;

		// Define the minimum and maximum RGB values (rgb(50, 50, 50) and rgb(200, 200, 200))
		const minRGB = [225, 225, 225];
		const maxRGB = [100, 100, 100];

		// Calculate the RGB values based on maxSlopeAngle using linear interpolation
		const r = Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const g = Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const b = Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		const ir = 255 - Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const ig = 255 - Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const ib = 255 - Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		// Define the color ranges and corresponding RGB values
		let triangleFillColor;
		if (maxSlopeAngle >= 0 && maxSlopeAngle < 5) {
			// Cornflower blue for angles in the range [0, 4)
			triangleFillColor = "rgb(51, 139, 255)";
		} else if (maxSlopeAngle >= 5 && maxSlopeAngle < 7) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 102, 204)";
		} else if (maxSlopeAngle >= 7 && maxSlopeAngle < 9) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 204, 204)";
		} else if (maxSlopeAngle >= 9 && maxSlopeAngle < 12) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(102, 204, 0)";
		} else if (maxSlopeAngle >= 12 && maxSlopeAngle < 15) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(204, 204, 0)";
		} else if (maxSlopeAngle >= 15 && maxSlopeAngle < 17) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 128, 0)";
		} else if (maxSlopeAngle >= 17 && maxSlopeAngle < 20) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 0, 0)";
		} else {
			// Default to grey for all other angles
			triangleFillColor = "rgb(153, 0, 76)";
		}

		// Combine the calculated RGB values into the final fill color
		// triangleFillColor = `rgb(${r}, ${g}, ${b})`;
		const triangleStrokeColor = `rgb(${r}, ${g}, ${b})`;
		// Invert the color by subtracting each channel value from 255
		const invertedColor = `rgb(${ir}, ${ig}, ${ib})`;

		ctx.strokeStyle = triangleStrokeColor;
		ctx.fillStyle = triangleFillColor;
		ctx.lineWidth = 1;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();

		ctx.lineWidth = 1;
	}
}

function drawDelauanyBurdenRelief(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 1;
	//console.log("drawDelauanyBurdenRelief: " + triangles.length);
	// const reliefResults = delaunayContourBurdenRelief(triangles, 20, 0);
	// console.log("Relief Results:", reliefResults);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		// Find the earliest and latest times
		const earliestTime = Math.min(tAZ, tBZ, tCZ);
		const latestTime = Math.max(tAZ, tBZ, tCZ);

		// Calculate the time difference
		const timeDifference = latestTime - earliestTime; // ms

		// Determine which points correspond to the earliest and latest times
		let p1, p2;
		if (earliestTime === tAZ) {
			p1 = {
				x: tAX,
				y: tAY
			};
		} else if (earliestTime === tBZ) {
			p1 = {
				x: tBX,
				y: tBY
			};
		} else {
			p1 = {
				x: tCX,
				y: tCY
			};
		}

		if (latestTime === tAZ) {
			p2 = {
				x: tAX,
				y: tAY
			};
		} else if (latestTime === tBZ) {
			p2 = {
				x: tBX,
				y: tBY
			};
		} else {
			p2 = {
				x: tCX,
				y: tCY
			};
		}

		// Calculate the distance between the two points (earliest and latest)
		const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

		// Calculate burden relief in ms/m
		const burdenRelief = timeDifference / distance;

		//console.log("Time Difference (ms):", timeDifference);
		//console.log("Distance (m):", distance);
		//console.log("Burden Relief (ms/m):", burdenRelief);

		// Color mapping based on timing relief (adjust values as needed)
		let triangleFillColor;
		if (burdenRelief < 4) {
			triangleFillColor = "rgb(75, 20, 20)"; // fast
		} else if (burdenRelief < 7) {
			triangleFillColor = "rgb(255, 40, 40)";
		} else if (burdenRelief < 10) {
			triangleFillColor = "rgb(255, 120, 50)"; //
		} else if (burdenRelief < 13) {
			triangleFillColor = "rgb(255, 255, 50)"; //
		} else if (burdenRelief < 16) {
			triangleFillColor = "rgb(50, 255, 70)"; //
		} else if (burdenRelief < 19) {
			triangleFillColor = "rgb(50, 255, 200)"; //
		} else if (burdenRelief < 22) {
			triangleFillColor = "rgb(50, 230, 255)"; //
		} else if (burdenRelief < 25) {
			triangleFillColor = "rgb(50, 180, 255)"; //
		} else if (burdenRelief < 30) {
			triangleFillColor = "rgb(50, 100, 255)"; //
		} else if (burdenRelief < 40) {
			triangleFillColor = "rgb(50, 0, 255)"; //
		} else {
			triangleFillColor = "rgb(75, 0, 150)"; // slow
		}

		ctx.fillStyle = triangleFillColor;

		// Draw triangle
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	}
}

function drawReliefLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function

	const legend0to4 = "rgb(75, 20, 20)"; // fast
	const legend4to7 = "rgb(255, 40, 40)";
	const legend7to10 = "rgb(255, 120, 50)"; //
	const legend10to13 = "rgb(255, 255, 50)"; //
	const legend13to16 = "rgb(50, 255, 70)"; //
	const legend16to19 = "rgb(50, 255, 200)"; //
	const legend19to22 = "rgb(50, 230, 255)"; //
	const legend22to25 = "rgb(50, 180, 255)"; //
	const legend25to30 = "rgb(50, 100, 255)"; //
	const legend30to40 = "rgb(50, 0, 255)"; //
	const legend40above = "rgb(75, 0, 150)"; // slow

	//draw the legend
	ctx.beginPath();
	ctx.fill();

	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Relief", 10, canvas.height / 2 - 70);
	ctx.fillText("0ms/m - 4ms/m", 10, canvas.height / 2 - 40);
	ctx.fillText("4ms/m - 7ms/m", 10, canvas.height / 2 - 10);
	ctx.fillText("7ms/m - 10ms/m", 10, canvas.height / 2 + 20);
	ctx.fillText("10ms/m - 13ms/m", 10, canvas.height / 2 + 50);
	ctx.fillText("13ms/m - 16ms/m", 10, canvas.height / 2 + 80);
	ctx.fillText("16ms/m - 19ms/m", 10, canvas.height / 2 + 110);
	ctx.fillText("19ms/m - 22ms/m", 10, canvas.height / 2 + 140);
	ctx.fillText("22ms/m - 25ms/m", 10, canvas.height / 2 + 170);
	ctx.fillText("25ms/m - 30ms/m", 10, canvas.height / 2 + 200);
	ctx.fillText("30ms/m - 40ms/m", 10, canvas.height / 2 + 230);
	ctx.fillText("40ms/m above", 10, canvas.height / 2 + 260);
	ctx.fillStyle = legend0to4;
	ctx.fillRect(130, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend4to7;
	ctx.fillRect(130, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to10;
	ctx.fillRect(130, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend10to13;
	ctx.fillRect(130, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend13to16;
	ctx.fillRect(130, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend16to19;
	ctx.fillRect(130, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend19to22;
	ctx.fillRect(130, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend22to25;
	ctx.fillRect(130, canvas.height / 2 + 155, 20, 20);
	ctx.fillStyle = legend25to30;
	ctx.fillRect(130, canvas.height / 2 + 185, 20, 20);
	ctx.fillStyle = legend30to40;
	ctx.fillRect(130, canvas.height / 2 + 215, 20, 20);
	ctx.fillStyle = legend40above;
	ctx.fillRect(130, canvas.height / 2 + 245, 20, 20);
	ctx.stroke();
}

function drawTriangleAngleText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let maxSlopeAngle = getDipAngle(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(maxSlopeAngle).toFixed(1), strokeColor);
}

function drawTriangleBurdenReliefText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let burdenRelief = getBurdenRelief(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(burdenRelief).toFixed(1), strokeColor);
}

function getAngleBetweenEdges(edge1, edge2) {
	const dotProduct = edge1.x * edge2.x + edge1.y * edge2.y + edge1.z * edge2.z;
	const magEdge1 = Math.sqrt(edge1.x * edge1.x + edge1.y * edge1.y + edge1.z * edge1.z);
	const magEdge2 = Math.sqrt(edge2.x * edge2.x + edge2.y * edge2.y + edge2.z * edge2.z);
	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero

	if (Math.abs(magEdge1) < epsilon || Math.abs(magEdge2) < epsilon) {
		// Handle the case where either edge is degenerate (magnitude close to zero)
		return 0;
	}

	let angle = Math.acos(dotProduct / (magEdge1 * magEdge2));
	return (angle * 180) / Math.PI;
}

function calculateTriangleCentroid(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];

	const triangleCentroid = {
		x: (tAX + tBX + tCX) / 3,
		y: (tAY + tBY + tCY) / 3,
		z: (tAZ + tBZ + tCZ) / 3
	};
	return triangleCentroid;
}

function getDipAngle(triangle) {
	const edge1 = [triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]];
	const edge2 = [triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]];

	// Calculate the normal vector of the triangle's plane
	const normalVector = [edge1[1] * edge2[2] - edge1[2] * edge2[1], edge1[2] * edge2[0] - edge1[0] * edge2[2], edge1[0] * edge2[1] - edge1[1] * edge2[0]];

	// Calculate the dot product with the vertical direction (0, 0, 1)
	const dotProduct = normalVector[0] * 0 + normalVector[1] * 0 + normalVector[2] * 1;
	const magNormal = Math.sqrt(normalVector[0] ** 2 + normalVector[1] ** 2 + normalVector[2] ** 2);

	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero
	if (Math.abs(magNormal) < epsilon) {
		// Handle degenerate case
		return 0;
	}

	const angleRadians = Math.acos(dotProduct / magNormal);
	const angleDegrees = (angleRadians * 180) / Math.PI;

	// Calculate the dip angle between the dot product and the horizontal plane (0 degrees)
	const dipAngle = 180 - angleDegrees;

	return dipAngle;
}

function getEdgeSlopeAngle(p1, p2) {
	const dx = p2[0] - p1[0];
	const dy = p2[1] - p1[1];
	const dz = p2[2] - p1[2]; // Consider the z-axis difference for vertical deviation
	const slopeAngleRadians = Math.atan2(dz, Math.sqrt(dx * dx + dy * dy));
	const slopeAngleDegrees = (slopeAngleRadians * 180) / Math.PI;
	return slopeAngleDegrees;
}

function getAngleBetweenPoints(p1, p2) {
	// Calculate the inferred point p3
	const p3 = [p1[0], p1[1], p2[2]];

	// Calculate the edges
	const edge1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
	const edge2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];

	// Calculate the angle between the edges
	const angleRadians = Math.acos((edge1[0] * edge2[0] + edge1[1] * edge2[1] + edge1[2] * edge2[2]) / (vectorMagnitude(edge1) * vectorMagnitude(edge2)));

	// Convert the angle to degrees
	const angleDegrees = (angleRadians * 180) / Math.PI;

	return angleDegrees;
}

function vectorMagnitude(vector) {
	return Math.sqrt(vector[0] ** 2 + vector[1] ** 2 + vector[2] ** 2);
}

function getBurdenRelief(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];
	// Find the earliest and latest times
	const earliestTime = Math.min(tAZ, tBZ, tCZ);
	const latestTime = Math.max(tAZ, tBZ, tCZ);

	// Calculate the time difference
	const timeDifference = latestTime - earliestTime; // ms

	// Determine which points correspond to the earliest and latest times
	let p1, p2;
	if (earliestTime === tAZ) {
		p1 = {
			x: tAX,
			y: tAY
		};
	} else if (earliestTime === tBZ) {
		p1 = {
			x: tBX,
			y: tBY
		};
	} else {
		p1 = {
			x: tCX,
			y: tCY
		};
	}

	if (latestTime === tAZ) {
		p2 = {
			x: tAX,
			y: tAY
		};
	} else if (latestTime === tBZ) {
		p2 = {
			x: tBX,
			y: tBY
		};
	} else {
		p2 = {
			x: tCX,
			y: tCY
		};
	}

	// Calculate the distance between the two points (earliest and latest)
	const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

	// Calculate burden relief in ms/m
	const burdenRelief = timeDifference / distance;

	//console.log("Time Difference (ms):", timeDifference);
	//console.log("Distance (m):", distance);
	//console.log("Burden Relief (ms/m):", burdenRelief);
	return burdenRelief;
}

function drawMousePosition(x, y) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	ctx.rect(x - 7, y - 7, 14, 14);
	ctx.lineWidth = 1;
	ctx.stroke();
}
//-------------------------SELECTION OF BLAST HOLES----------------------//
function getClickedHole(clickX, clickY) {
	// Add null check at the very beginning
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null; // No holes to check
	}

	// Adjust the click coordinates based on the current scale and centroid
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY; // Invert the Y-coordinate
	// Calculate the distance threshold based on the scale factor

	//Create a constant called thresold set it to  (10/(currentScale/2).  If the value of thresold is less than 0.1 then set it to 0.1 else if it is greater than 2 set it to 2 else set it to 10/currentScale/2
	let threshold = 10 / (currentScale / 2);
	if (threshold > 0.2 && threshold <= 1.5) {
		10 / (currentScale / 2);
	} else if (threshold > 1.5) {
		threshold = 1.5;
	} else if (threshold < 0.2) {
		threshold = 0.2;
	}

	//keep an existing selection while the Move tool is active
	if (!isMultiHoleSelectionEnabled && !isMoveToolActive) {
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}

	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ✅ CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;
		let holeX = hole.startXLocation;
		let holeY = hole.startYLocation;
		let currentEntity = hole.entity;

		let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));
		if (distance > threshold) {
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Reset the selected hole ID
		}
	}
	if (isAddingConnector || isAddingMultiConnector) {
		// Loop through the points array to find the clicked hole
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			// Calculate the distance between the clicked point and the hole
			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			// Check if the distance is within the threshold
			if (distance <= threshold) {
				//Remove this if statement if the if & if else doesn't work
				if (firstSelectedHole == null) {
					firstSelectedHole = hole;
					secondSelectedHole = null;
				} else if (secondSelectedHole == null && firstSelectedHole != hole && hole != null) {
					secondSelectedHole = hole;
					firstSelectedHole = null;
				} else {
					firstSelectedHole = null;
					secondSelectedHole = hole;
				}
				return hole; // Return the clicked hole
			}
		}
		//calculateTimes(points);
	} else if (!isMultiHoleSelectionEnabled && isMeasureRecording) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID

				//

				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
	}
	//! IMPORTANT alway check if the bool needs to be put here for drawing to work.
	else if (!isMultiHoleSelectionEnabled && (isSelectionPointerActive || isPolygonSelectionActive || isHoleEditing || isLengthPopupEditing || isDeletingHole || isTypeEditing || isBlastNameEditing || isBearingToolActive || isMoveToolActive)) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;
			let holeXEnd = hole.endXLocation;
			let holeYEnd = hole.endYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID
				// Update slider attributes here
				let holeNorthingSlider = document.getElementById("holeNorthingSlider");
				let holeEastingSlider = document.getElementById("holeEastingSlider");
				let holeElevationSlider = document.getElementById("holeElevationSlider");
				let holeLengthSlider = document.getElementById("holeLengthSlider");
				let holeDiameterSlider = document.getElementById("holeDiameterSlider");
				let holeAngleSlider = document.getElementById("holeAngleSlider");
				let holeBearingSlider = document.getElementById("holeBearingSlider");
				let holeSubdrillSlider = document.getElementById("holeSubdrillSlider");

				// Update slider attributes here

				holeEastingSlider.min = hole.startXLocation - 20;
				holeEastingSlider.max = hole.startXLocation + 20;
				holeEastingSlider.step = 0.1;

				holeNorthingSlider.min = hole.startYLocation - 20;
				holeNorthingSlider.max = hole.startYLocation + 20;
				holeNorthingSlider.step = 0.1;
				// Update slider attributes here

				holeElevationSlider.min = hole.startZLocation - 20;
				holeElevationSlider.max = hole.startZLocation + 20;
				holeElevationSlider.step = 0.1;

				//Length
				holeLengthSlider.step = 0.1;

				// Update slider attributes here
				holeAngleSlider.step = 1;

				// Update slider attributes here
				holeDiameterSlider.step = 1;

				// Update slider attributes here
				holeBearingSlider.step = 0.5;
				holeSubdrillSlider.step = 0.1;

				holeEastingSlider.value = hole.startXLocation;
				holeNorthingSlider.value = hole.startYLocation;
				holeElevationSlider.value = hole.startZLocation;
				holeLengthSlider.value = hole.holeLengthCalculated;
				holeDiameterSlider.value = hole.holeDiameter;
				holeAngleSlider.value = hole.holeAngle;
				holeBearingSlider.value = hole.holeBearing;
				holeSubdrillSlider.value = hole.subdrillAmount;

				holeEastingLabel.textContent = "Hole Easting (X) : " + parseFloat(hole.startXLocation).toFixed(2) + "mE";
				holeNorthingLabel.textContent = "Hole Northing (Y): " + parseFloat(hole.startYLocation).toFixed(2) + "mN";
				holeElevationLabel.textContent = "Hole Elevation (Z) : " + parseFloat(hole.startZLocation).toFixed(2) + "m";
				holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(hole.holeDiameter).toFixed(0) + "mm";
				holeLengthLabel.textContent = "Hole Length: " + parseFloat(hole.holeLengthCalculated).toFixed(1) + "m";
				holeAngleLabel.textContent = "Hole Angle: " + parseFloat(hole.holeAngle).toFixed(0) + "\u00B0";
				holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(hole.holeBearing).toFixed(1) + "\u00B0";
				holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(hole.subdrillAmount).toFixed(1) + "m";
				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
		if (isDisplayingContours) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}

			// directionArrows now contains the arrow data for later drawing
		}
		if (isDisplayingSlopeTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingReliefTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingDirectionArrows) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}
		}
		// If no hole is clicked or found within the threshold
		// Reset only the firstSelectedHole
		firstSelectedHole = null;
	}
	return null; // Return null if no hole is clicked
}
//------------------MULTIPLE SELECTION OF BLAST HOLES----------------------//
function getMultipleClickedHoles(clickX, clickY) {
	if (!isMultiHoleSelectionEnabled) {
		return selectedMultipleHoles || [];
	}

	// Prevent selection modification if called during a mouse move that's not intended to change selection
	if (isUpdatingSelectionFromMove) {
		return selectedMultipleHoles || [];
	}

	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = Math.max(Math.min(10 / (currentScale / 2), 1.5), 0.2);

	let holesWithinThreshold = [];
	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ✅ CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;

		let distance = Math.sqrt((hole.startXLocation - adjustedX) ** 2 + (hole.startYLocation - adjustedY) ** 2);
		if (distance < threshold) {
			holesWithinThreshold.push(hole);
		}
	}
	// Fix null reference issue - initialize selectedMultipleHoles if null
	if (!selectedMultipleHoles) {
		selectedMultipleHoles = [];
	}

	holesWithinThreshold.forEach((hole) => {
		if (!selectedMultipleHoles.includes(hole)) {
			selectedMultipleHoles.push(hole);
		} else {
			selectedMultipleHoles = selectedMultipleHoles.filter((h) => h !== hole);
			// Add UI feedback for deselection here
		}
		drawData(allBlastHoles, selectedHole);
	});

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let eastingAverage = 0;
	let northingAverage = 0;
	let elevationAverage = 0;
	let lengthAverage = 0;
	let diameterAverage = 0;
	let angleAverage = 0;
	let bearingAverage = 0;
	let subdrillSum = 0;
	let subdrillAverage = 0;

	if (isMultiHoleSelectionEnabled && (isHoleEditing || isPolygonSelectionActive || isSelectionPointerActive || isDeletingHole || isBlastNameEditing || isTypeEditing || isLengthPopupEditing)) {
		console.log("Selected Multiple Holes: ", selectedMultipleHoles);
		selectedMultipleHoles.forEach((hole) => {
			// Average the values of the selected holes in the selectedMultipleHoles array
			// Update slider attributes with the averaged values for each attribute
			// Update the UI labels with the averaged values for each attribute
			//console.log(selectedMultipleHoles);
			eastingSum += parseFloat(hole.startXLocation);
			northingSum += parseFloat(hole.startYLocation);
			elevationSum += parseFloat(hole.startZLocation);
			lengthSum += parseFloat(hole.holeLengthCalculated);
			diameterSum += parseFloat(hole.holeDiameter);
			angleSum += parseFloat(hole.holeAngle);
			bearingSum += parseFloat(hole.holeBearing);
			subdrillSum += parseFloat(hole.subdrillAmount);
			//console.log("Sums: \n   ", eastingSum, "\n   y", northingSum, "\n   z", elevationSum, "\n   l", lengthSum, "\n   d", diameterSum, "\n   a", angleSum, "\n   b", bearingSum);
			//console.log("Length: " + selectedMultipleHoles.length);

			eastingAverage = selectedMultipleHoles.length > 1 ? parseFloat(eastingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(eastingSum);
			northingAverage = selectedMultipleHoles.length > 1 ? parseFloat(northingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(northingSum);
			elevationAverage = selectedMultipleHoles.length > 1 ? parseFloat(elevationSum) / parseInt(selectedMultipleHoles.length) : parseFloat(elevationSum);
			lengthAverage = selectedMultipleHoles.length > 1 ? parseFloat(lengthSum) / parseInt(selectedMultipleHoles.length) : parseFloat(lengthSum);
			diameterAverage = selectedMultipleHoles.length > 1 ? parseFloat(diameterSum) / parseInt(selectedMultipleHoles.length) : parseFloat(diameterSum);
			angleAverage = selectedMultipleHoles.length > 1 ? parseFloat(angleSum) / parseInt(selectedMultipleHoles.length) : parseFloat(angleSum);
			bearingAverage = selectedMultipleHoles.length > 1 ? parseFloat(bearingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(bearingSum);
			subdrillAverage = selectedMultipleHoles.length > 1 ? parseFloat(subdrillSum) / parseInt(selectedMultipleHoles.length) : parseFloat(subdrillSum);

			//console.log("Averages: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);

			holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
			holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
			holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
			holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
			holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
			holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
			holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
			holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";
			//set the min max range to a value either side the average value
			holeEastingSlider.min = eastingAverage - 20;
			holeEastingSlider.max = eastingAverage + 20;
			holeNorthingSlider.min = northingAverage - 20;
			holeNorthingSlider.max = northingAverage + 20;
			holeElevationSlider.min = elevationAverage - 20;
			holeElevationSlider.max = elevationAverage + 20;
			//set the value of the slider
			holeEastingSlider.value = eastingAverage;
			holeNorthingSlider.value = northingAverage;
			holeElevationSlider.value = elevationAverage;
			holeLengthSlider.value = lengthAverage;
			holeDiameterSlider.value = diameterAverage;
			holeAngleSlider.value = angleAverage;
			holeBearingSlider.value = bearingAverage;
			holeSubdrillSlider.value = subdrillAverage;
			//console.log("Averages 2: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);
		});
	}

	return selectedMultipleHoles || [];
}

// New function to handle averaging and slider updates
function updateSelectionAveragesAndSliders(selectedHoles) {
	if (!selectedHoles || selectedHoles.length === 0) return;

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let subdrillSum = 0;

	// Calculate sums
	selectedHoles.forEach((hole) => {
		eastingSum += parseFloat(hole.startXLocation);
		northingSum += parseFloat(hole.startYLocation);
		elevationSum += parseFloat(hole.startZLocation);
		lengthSum += parseFloat(hole.holeLengthCalculated);
		diameterSum += parseFloat(hole.holeDiameter);
		angleSum += parseFloat(hole.holeAngle);
		bearingSum += parseFloat(hole.holeBearing);
		subdrillSum += parseFloat(hole.subdrillAmount);
	});

	// Calculate averages
	const count = selectedHoles.length;
	const eastingAverage = count > 1 ? eastingSum / count : eastingSum;
	const northingAverage = count > 1 ? northingSum / count : northingSum;
	const elevationAverage = count > 1 ? elevationSum / count : elevationSum;
	const lengthAverage = count > 1 ? lengthSum / count : lengthSum;
	const diameterAverage = count > 1 ? diameterSum / count : diameterSum;
	const angleAverage = count > 1 ? angleSum / count : angleSum;
	const bearingAverage = count > 1 ? bearingSum / count : bearingSum;
	const subdrillAverage = count > 1 ? subdrillSum / count : subdrillSum;

	// Update labels
	holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
	holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
	holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
	holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
	holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
	holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
	holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
	holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";

	// Update slider ranges
	holeEastingSlider.min = eastingAverage - 20;
	holeEastingSlider.max = eastingAverage + 20;
	holeNorthingSlider.min = northingAverage - 20;
	holeNorthingSlider.max = northingAverage + 20;
	holeElevationSlider.min = elevationAverage - 20;
	holeElevationSlider.max = elevationAverage + 20;

	// Update slider values
	holeEastingSlider.value = eastingAverage;
	holeNorthingSlider.value = northingAverage;
	holeElevationSlider.value = elevationAverage;
	holeLengthSlider.value = lengthAverage;
	holeDiameterSlider.value = diameterAverage;
	holeAngleSlider.value = angleAverage;
	holeBearingSlider.value = bearingAverage;
	holeSubdrillSlider.value = subdrillAverage;
}

const colorConnectorElement = document.getElementById("connectorColor");
const floatingConnectorColorElement = document.getElementById("floatingConnectorColor");
const colorDrawingElement = document.getElementById("drawingColor");

function getJSColorHexDrawing() {
	// Get the JSColor instance from the element
	const jsColorInstance = colorDrawingElement.jscolor;
	// Get the color value
	const colorHex = jsColorInstance.toHEXString(); // This will get the color in HEX format, e.g., "#FF0000"
	return colorHex;
}
// Use jscolor.ready to ensure pickers are initialized before adding event handlers
jscolor.ready(function () {
	if (colorConnectorElement && colorConnectorElement.jscolor && floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		// Sync from the main color picker to the floating one
		colorConnectorElement.jscolor.option("onInput", function () {
			// 'this' refers to the jscolor instance that triggered the event
			floatingConnectorColorElement.jscolor.fromString(this.toHEXString());
		});

		// Sync from the floating color picker to the main one
		floatingConnectorColorElement.jscolor.option("onInput", function () {
			colorConnectorElement.jscolor.fromString(this.toHEXString());
		});
	}
});

function getJSColorHex() {
	// Try floating first, then main
	if (floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		return floatingConnectorColorElement.jscolor.toHEXString();
	}
	if (colorConnectorElement && colorConnectorElement.jscolor) {
		return colorConnectorElement.jscolor.toHEXString();
	}
	return "#FF0000"; // Default fallback
}

const delayElement = document.getElementById("delay");
const floatingDelayElement = document.getElementById("floatingDelay");

delayElement.addEventListener("input", function () {
	floatingDelayElement.value = this.value;
});

floatingDelayElement.addEventListener("input", function () {
	delayElement.value = this.value;
});

function getDelayValue() {
	// Return the floating delay if it exists and has a value, otherwise use main delay
	if (floatingDelayElement && floatingDelayElement.value) {
		return parseInt(floatingDelayElement.value);
	}
	if (delayElement && delayElement.value) {
		return parseInt(delayElement.value);
	}
	return 0; // Default fallback value
}

function handleConnectorClick(event) {
	// Get the click/touch coordinates relative to the canvas
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	const clickedHole = getClickedHole(clickX, clickY);
	if (isAddingConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				selectedHole = clickedHole;
				const delay = getDelayValue();
				const clickedHoleIndex = allBlastHoles.findIndex((hole) => hole === clickedHole);

				if (clickedHoleIndex !== -1) {
					// Use the new combined format for fromHoleID
					allBlastHoles[clickedHoleIndex].fromHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;
					allBlastHoles[clickedHoleIndex].timingDelayMilliseconds = delay;
					allBlastHoles[clickedHoleIndex].colorHexDecimal = getJSColorHex();
				}
				fromHoleStore = null;
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// directionArrows now contains the arrow data for later drawing
				timeChart();
				drawData(allBlastHoles, selectedHole);
			}
		}
	} else if (isAddingMultiConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				const selectedHole = clickedHole;
				const pointsInLine = getPointsInLine(fromHoleStore, selectedHole);
				if (pointsInLine.length > 0) {
					connectHolesInLine(pointsInLine);
				}
				// Reset the fromHole and exit add connector mode
				fromHoleStore = null;
				// RECALCULATE TIMING, CONTOURS AND DIRECTION ARROWS
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Update timing chart display
				timeChart();

				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
	}
}

function getPointsInLine(startPoint, endPoint, tolerance) {
	const pointsInLine = [];
	tolerance = connectAmount;
	const dx = endPoint.startXLocation - startPoint.startXLocation;
	const dy = endPoint.startYLocation - startPoint.startYLocation;
	const length = Math.sqrt(dx * dx + dy * dy);
	const dirX = dx / length;
	const dirY = dy / length;
	const points = allBlastHoles; //Assign the point as allBlastHoles

	for (const point of points) {
		if (point !== startPoint && point !== endPoint) {
			const vecX = point.startXLocation - startPoint.startXLocation;
			const vecY = point.startYLocation - startPoint.startYLocation;
			const dotProduct = vecX * dirX + vecY * dirY;
			if (dotProduct >= 0 && dotProduct <= length) {
				const distanceToLine = Math.abs(vecX * dirY - vecY * dirX);
				if (distanceToLine <= tolerance) {
					pointsInLine.push(point);
				}
			}
		}
	}

	// Add start and end points to the array
	pointsInLine.unshift(startPoint);
	pointsInLine.push(endPoint);

	return pointsInLine;
}

function connectHolesInLine(pointsInLine) {
	// Sort points based on distance from the fromHoleStore
	pointsInLine.sort((a, b) => {
		const distanceA = calculateDistance(fromHoleStore, a);
		const distanceB = calculateDistance(fromHoleStore, b);
		return distanceA - distanceB;
	});

	let previousHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;

	// Connect each point to the previous point
	for (let i = 1; i < pointsInLine.length; i++) {
		const hole = pointsInLine[i];
		const holeIndex = allBlastHoles.findIndex((h) => h === hole);

		if (holeIndex !== -1) {
			allBlastHoles[holeIndex].fromHoleID = previousHoleID;
			allBlastHoles[holeIndex].timingDelayMilliseconds = getDelayValue();
			allBlastHoles[holeIndex].colorHexDecimal = getJSColorHex();
		}

		previousHoleID = `${hole.entityName}:::${hole.holeID}`;
	}
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, deltaX, deltaY);
	contourLinesArray = result.contourLinesArray;
	directionArrows = result.directionArrows;
	timeChart();
	drawData(allBlastHoles, selectedHole);
}

// Function to calculate the distance between two points
function calculateDistance(point1, point2) {
	const dx = point2.startXLocation - point1.startXLocation;
	const dy = point2.startYLocation - point1.startYLocation;
	return Math.sqrt(dx * dx + dy * dy);
}

//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPointInMap(map, clickX, clickY) {
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = 10 / (currentScale / 2);
	let closestPoint = null;
	let minDistance = threshold;

	// Iterate over the keys of the map
	for (const entityName of map.keys()) {
		const entity = map.get(entityName);
		for (const point of entity.data) {
			const distance = Math.sqrt(Math.pow(point.pointXLocation - adjustedX, 2) + Math.pow(point.pointYLocation - adjustedY, 2));

			if (distance <= threshold && distance < minDistance) {
				closestPoint = point;
				minDistance = distance;
			}
		}
	}
	drawData(allBlastHoles, selectedHole);
	return closestPoint;
}
//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPoint(event) {
	// get the values from clicking in the canvas
	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;
	if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
		// Handle the case when the values are NaN
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	} else {
		// Proceed with the calculation using the valid values
		clickX = event.clientX - rect.left;
		clickY = event.clientY - rect.top;
	}
	// SNAPPIN SNAP CODE:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isDeletingKAD) {
		selectedPoint = getClickedPointInMap(allKADDrawingsMap, clickX, clickY);
		drawData(allBlastHoles, selectedHole);
		return selectedPoint;
	}

	drawData(allBlastHoles, selectedHole);
	// If none of the flags match, return null
	return null;
}

/**

 * Offsets a selected object (line or polyline) by a specified amount in a given direction
 * @param {Map} map - The map containing all KAD drawings
 * @param {Object} selectedPoint - The selected point object containing entity info
 * @param {string} direction - Direction to offset ("right", "left", "up", "down")
 * @param {number} offsetAmount - Distance to offset in map units
 * @param {boolean} [checkForCrossover=false] - Whether to check and prevent line segment crossovers
 * @param {boolean} [extendIfNecessary=false] - Whether to extend line segments that get too far apart
 * @returns {Object|undefined} The newly created offset entity, or undefined if no point selected
 */
function offsetObjectWithSelectedPoint(map, selectedPoint, direction, offsetAmount, checkForCrossover = false, extendIfNecessary = false) {
	if (selectedPoint) {
		const entityName = selectedPoint.entityName;
		const entityType = selectedPoint.entityType;

		// Create a new entity for the offset polyline
		const newEntity = {
			entityName: `${entityName}_offset`, // Modify this as needed
			entityType: entityType,
			data: []
		};

		let prevPoint = null;

		// Offset and check for crossovers if needed
		for (const point of selectedPoint.data) {
			let offsetX = point.pointXLocation;
			let offsetY = point.pointYLocation;

			if (direction === "right") {
				offsetX += offsetAmount;
			} else if (direction === "left") {
				offsetX -= offsetAmount;
			} else if (direction === "up") {
				offsetY -= offsetAmount;
			} else if (direction === "down") {
				offsetY += offsetAmount;
			}

			if (checkForCrossover && prevPoint) {
				// Check for crossover and shorten the segment if needed
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					const ratio = offsetAmount / distance;
					offsetX = prevPoint.pointXLocation + (offsetX - prevPoint.pointXLocation) * ratio;
					offsetY = prevPoint.pointYLocation + (offsetY - prevPoint.pointYLocation) * ratio;
				}
			}

			// Add the offset point to the new entity
			newEntity.data.push({
				entityName: newEntity.entityName,
				entityType: newEntity.entityType,
				pointID: point.pointID, // Preserve point ID or modify as needed
				pointXLocation: offsetX,
				pointYLocation: offsetY,
				pointZLocation: point.pointZLocation,
				lineWidth: point.lineWidth,
				color: point.color
			});

			if (extendIfNecessary && prevPoint) {
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					// Extend the line segment if points get further away after offsetting
					newEntity.data.push({
						entityName: newEntity.entityName,
						entityType: newEntity.entityType,
						pointID: point.pointID, // Preserve point ID or modify as needed
						pointXLocation: offsetX,
						pointYLocation: offsetY,
						pointZLocation: point.pointZLocation,
						lineWidth: point.lineWidth,
						color: point.color
					});
				}
			}

			prevPoint = point;
		}

		// Add the new entity to the appropriate map (line or poly)
		if (entityType === "poly") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		} else if (entityType === "line") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		}

		// Redraw the canvas or perform any other necessary updates
		drawData(allBlastHoles, selectedHole);

		// Return the newly created entity if needed
		return newEntity;
	}
}

function deleteSelectedPoint() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("❌ Cannot delete point from hidden entity: " + entityName);
			return;
		}
		deletePointInMap(allKADDrawingsMap, selectedPoint);
	}
}

// Helper function to get entity name from selected point
function getEntityNameFromSelectedPoint(selectedPoint) {
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entityName;
		}
	}
	return null;
}

// Helper function to determine entity type from selected point
function getEntityTypeFromSelectedPoint(selectedPoint) {
	// Find which entity this point belongs to
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entity.entityType;
		}
	}
	return null;
}

function deleteSelectedObject() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("❌ Cannot delete object from hidden entity: " + entityName);
			return;
		}
		deleteObjectInMap(allKADDrawingsMap, selectedPoint);
		// ADD THIS: Save after delete
		debouncedSaveKAD();
	}
}

function deleteSelectedAll() {
	if (selectedPoint && isDeletingKAD) {
		// Determine entity type from the selected point
		const entityType = getEntityTypeFromSelectedPoint(selectedPoint);
		if (entityType) {
			// Only delete visible entities of this type
			const visibleEntitiesToDelete = [];
			for (const [entityName, entity] of allKADDrawingsMap.entries()) {
				if (entity.entityType === entityType && isEntityVisible(entityName)) {
					visibleEntitiesToDelete.push(entityName);
				}
			}

			if (visibleEntitiesToDelete.length === 0) {
				console.log("❌ No visible entities of type " + entityType + " to delete");
				return;
			}

			// Delete only visible entities
			visibleEntitiesToDelete.forEach((entityName) => {
				allKADDrawingsMap.delete(entityName);
			});

			console.log("🗑️ Deleted " + visibleEntitiesToDelete.length + " visible " + entityType + " entities");
			// ADD THIS: Save after delete all of type
			debouncedSaveKAD();
		}
	}
}

// Enhanced function to delete only specific entity types and clear selection
function deleteAllOfType(map, entityType) {
	const entitiesToDelete = [];
	let shouldClearSelection = false;

	// Find all entities of the specified type
	for (const [entityName, entity] of map.entries()) {
		if (entity.entityType === entityType) {
			entitiesToDelete.push(entityName);

			// Check if the selected point belongs to this entity
			if (selectedPoint && entity.data.some((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation)) {
				shouldClearSelection = true;
			}
		}
	}

	// Delete them
	entitiesToDelete.forEach((entityName) => {
		map.delete(entityName);
		console.log(`Deleted ${entityType} entity: ${entityName}`);
	});

	// Clear selection if the selected point was deleted
	if (shouldClearSelection) {
		selectedPoint = null;
		selectedKADObject = null; // Clear this too if it exists
		selectedKADPolygon = null; // And this one
	}

	updateStatusMessage(`Deleted ${entitiesToDelete.length} ${entityType} entities`);
	drawData(allBlastHoles, selectedHole);
	setTimeout(() => updateStatusMessage(""), 2000);
}

// Replace the deletePointInMap function around line 9227
function deletePointInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const dataIndex = entity.data.findIndex((point) => {
			return point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation;
		});

		if (dataIndex !== -1) {
			entity.data.splice(dataIndex, 1);
			updateStatusMessage("Deleted point " + pointToDelete.pointID + " from " + entity.entityType);

			// ✅ ADD: Renumber remaining points sequentially starting from 1
			renumberEntityPoints(entity);

			// If entity has no more points, delete the entire entity
			if (entity.data.length === 0) {
				map.delete(entityName);
				updateStatusMessage("Deleted empty " + entity.entityType + " entity: " + entityName);
			}

			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete point
			debouncedSaveKAD();
			break;
		}
	}
}

// ✅ ADD: New function to renumber points in an entity
function renumberEntityPoints(entity) {
	if (!entity || !entity.data || entity.data.length === 0) return;

	// Renumber all points sequentially starting from 1
	for (let i = 0; i < entity.data.length; i++) {
		entity.data[i].pointID = i + 1;
	}

	console.log("✅ Renumbered " + entity.data.length + " points in " + entity.entityType + " entity");
}

function deleteObjectInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const foundPoint = entity.data.find((point) => point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation);

		if (foundPoint) {
			map.delete(entityName);
			updateStatusMessage(`Deleted ${entity.entityType} entity: ${entityName}`);
			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete object
			debouncedSaveKAD();
			break;
		}
	}
}

function deleteAllInMap(map) {
	map.clear();
	selectedPoint = null;
	drawData(allBlastHoles, selectedHole);
	// ADD THIS: Save after delete all in map
	debouncedSaveKAD();
}

function deleteSelectedHoles() {
	let holesWereActuallyDeleted = false; // To track if the allBlastHoles array was modified

	if (isDeletingHole) {
		const entitiesToRenumber = new Set(); // Store unique entity names that need renumbering

		if (selectedMultipleHoles.length > 0) {
			console.log(`Processing deletion for ${selectedMultipleHoles.length} selected holes.`);
			const originalPointsLength = allBlastHoles.length;

			// Create a Set of hole references for efficient filtering
			const holesToDeleteReferences = new Set(selectedMultipleHoles);

			allBlastHoles = allBlastHoles.filter((hole) => {
				if (holesToDeleteReferences.has(hole)) {
					//console.log("Deleting Hole ID:", point.holeID, "in:", point.entityName);
					if (isRenumberingHoles) {
						entitiesToRenumber.add(hole.entityName);
					}
					return false; // Exclude this point (effectively deleting it)
				}
				return true; // Keep this point
			});

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
			}

			// Clear selections after processing
			selectedMultipleHoles = [];
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Ensure single selection is also cleared
		} else if (selectedHole !== null) {
			//console.log("Processing deletion for single Hole ID:", selectedHole.holeID, "in:", selectedHole.entityName);
			const holeToRemove = selectedHole; // Cache before selectedHole is nulled
			const originalPointsLength = allBlastHoles.length;

			allBlastHoles = allBlastHoles.filter((hole) => hole !== holeToRemove);

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
				if (isRenumberingHoles) {
					entitiesToRenumber.add(holeToRemove.entityName);
				}
			}
			// Clear selection after processing
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		if (holesWereActuallyDeleted) {
			// Perform renumbering for all affected entities if enabled
			if (isRenumberingHoles) {
				entitiesToRenumber.forEach((entityName) => {
					// deleteRenumberStart is expected to be globally available and set appropriately
					//console.log("Renumbering for Entity:", entityName, "starting at:", deleteRenumberStart);
					renumberHolesFunction(deleteRenumberStart, entityName);
				});
			}

			// Reset fromHoleStore as selections involving it are now gone
			fromHoleStore = null;

			// Note: Original intermediate recalculations and drawData(points, null) call
			// are omitted here because refreshPoints() handles these operations comprehensively.
		}
	}

	refreshPoints(); // This function will save changes, reload points, recalculate all necessary data, and redraw.
}

//function to delete holes that have the same entity name in both the points array and the map
function deleteSelectedPattern() {
	if (isDeletingHole) {
		if (selectedHole !== null) {
			// find the selected holeIDs entityName
			let entityNameToDelete = allBlastHoles.find((hole) => hole === selectedHole).entityName;

			// Remove holes with the same entityName from kadHolesMap
			// for (const [entityName, entity] of kadHolesMap) {
			// 	if (entityName === entityNameToDelete) {
			// 		kadHolesMap.delete(entityName);
			// 	}
			// }

			// Remove holes with the same entityName from the points array
			allBlastHoles = allBlastHoles.filter((hole) => hole.entityName !== entityNameToDelete);

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			drawData(allBlastHoles, selectedHole);
		} else {
			drawData(allBlastHoles, selectedHole);
		}
	}
	refreshPoints();
}

//function to delete All Entities in the kadHolesMap and all the Entityies in the points array
function deleteSelectedAllPatterns() {
	console.log("🚨 deleteSelectedAllPatterns called!");
	console.log("isDeletingHole:", isDeletingHole);
	console.log("selectedHole:", selectedHole);
	console.log("selectedMultipleHoles:", selectedMultipleHoles);
	console.log("Stack trace:", new Error().stack);
	if (isDeletingHole) {
		if (selectedHole !== null || selectedMultipleHoles.length > 0) {
			// Remove all holes from kadHolesMap
			//kadHolesMap.clear();

			// Remove all holes from the points array
			allBlastHoles = [];

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			drawData(allBlastHoles, selectedHole);
		} else {
			drawData(allBlastHoles, selectedHole);
		}
	}
}

function handleHoleDeletingClick(event) {
	if (isDeletingHole) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
		}
	}
}

// Update renumberHolesFunction to preserve rowID/posID structure
function renumberHolesFunction(startNumber, selectedEntityName) {
	console.log("Renumbering holes for Entity:", selectedEntityName, "Starting at:", startNumber);

	const oldToNewHoleIDMap = new Map();

	// Get all holes for this entity
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === selectedEntityName);

	// Sort holes by rowID first, then by posID within each row
	entityHoles.sort((a, b) => {
		// First sort by rowID
		const rowDiff = (a.rowID || 0) - (b.rowID || 0);
		if (rowDiff !== 0) return rowDiff;

		// Then sort by posID within the same row
		return (a.posID || 0) - (b.posID || 0);
	});

	const startValue = startNumber.toString();
	const alphaMatch = startValue.match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;
	const canParseAsInt = !isNaN(parseInt(startValue)) && isFinite(startValue);

	if (isAlphaNumerical) {
		// ALPHA-NUMERICAL RENUMBERING BY ROW - Use rowID/posID structure
		console.log("Using alpha-numerical renumbering with rowID/posID structure starting at:", startValue);

		const startRowLetter = alphaMatch[1];
		const startHoleNumber = parseInt(alphaMatch[2]);

		// Group holes by rowID
		const rowGroups = new Map();
		entityHoles.forEach((hole) => {
			const rowID = hole.rowID || 1;
			if (!rowGroups.has(rowID)) {
				rowGroups.set(rowID, []);
			}
			rowGroups.get(rowID).push(hole);
		});

		// Sort each row by posID
		rowGroups.forEach((holes) => {
			holes.sort((a, b) => (a.posID || 0) - (b.posID || 0));
		});

		// Get sorted rowIDs
		const sortedRowIDs = Array.from(rowGroups.keys()).sort((a, b) => a - b);

		let currentRowLetter = startRowLetter;

		// Renumber each row
		sortedRowIDs.forEach((rowID) => {
			const rowHoles = rowGroups.get(rowID);
			rowHoles.forEach((hole, posIndex) => {
				const newHoleID = currentRowLetter + (startHoleNumber + posIndex);
				oldToNewHoleIDMap.set(hole.holeID, newHoleID);
				hole.holeID = newHoleID;
			});

			// Move to next row letter
			if (currentRowLetter === "Z") {
				currentRowLetter = "AA";
			} else if (currentRowLetter === "ZZ") {
				currentRowLetter = "AAA";
			} else {
				currentRowLetter = incrementLetter(currentRowLetter);
			}
		});
	} else {
		// NUMERICAL RENUMBERING - Respect rowID/posID order
		console.log("Using numerical renumbering with rowID/posID structure starting at:", startValue);

		const startNum = canParseAsInt ? parseInt(startValue) : 1;
		let currentNumber = startNum;

		entityHoles.forEach((hole) => {
			oldToNewHoleIDMap.set(hole.holeID, currentNumber.toString());
			hole.holeID = currentNumber.toString();
			currentNumber++;
		});
	}

	// Update fromHoleID references
	allBlastHoles.forEach((hole) => {
		if (hole.fromHoleID) {
			const [entity, oldHoleID] = hole.fromHoleID.split(":::");
			if (entity === selectedEntityName && oldToNewHoleIDMap.has(oldHoleID)) {
				hole.fromHoleID = entity + ":::" + oldToNewHoleIDMap.get(oldHoleID);
			}
		}
	});

	refreshPoints();
	drawData(allBlastHoles, selectedHole);
	console.log("Renumbered", entityHoles.length, "holes respecting rowID/posID structure");
}

// Update deleteHoleAndRenumber to handle rowID/posID
function deleteHoleAndRenumber(holeToDelete) {
	const entityName = holeToDelete.entityName;
	const holeID = holeToDelete.holeID;
	const rowID = holeToDelete.rowID;
	const posID = holeToDelete.posID;

	console.log("Deleting hole", holeID, "from row", rowID, "position", posID);

	// Remove the hole from points array
	const holeIndex = allBlastHoles.indexOf(holeToDelete);
	if (holeIndex > -1) {
		allBlastHoles.splice(holeIndex, 1);
	}

	// If we have rowID/posID, renumber only the affected row
	if (rowID && posID) {
		// Get all holes in the same row that come after the deleted hole
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID && hole.posID > posID);

		// Renumber positions in this row
		sameRowHoles.forEach((hole) => {
			const oldHoleID = hole.holeID;
			hole.posID = hole.posID - 1; // Shift position down by 1

			// Update fromHoleID references if needed
			allBlastHoles.forEach((hole) => {
				if (hole.fromHoleID === entityName + ":::" + oldHoleID) {
					hole.fromHoleID = entityName + ":::" + hole.holeID;
				}
			});
		});

		console.log("Renumbered", sameRowHoles.length, "holes in row", rowID);
	}
}

function renumberPatternAfterClipping(entityName) {
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);

	if (entityHoles.length === 0) return;

	// For patterns generated in polygons, the offset-aware numbering is already applied during generation
	// This function now just ensures proper A1 start and maintains the existing numbering structure

	// Step 1: Automatically detect row orientation from the pattern
	let rowOrientation = 90; // Default to East (90°) if can't determine

	if (entityHoles.length >= 2) {
		// Sort holes by Y coordinate to find potential row mates
		const sortedByY = [...entityHoles].sort((a, b) => b.startYLocation - a.startYLocation);

		// Find the first two holes that are likely in the same row (similar Y coordinates)
		const tolerance = 2.0; // 2 meter tolerance for same row
		let firstRowHoles = [sortedByY[0]];

		for (let i = 1; i < sortedByY.length; i++) {
			if (Math.abs(sortedByY[i].startYLocation - sortedByY[0].startYLocation) <= tolerance) {
				firstRowHoles.push(sortedByY[i]);
			} else {
				break; // Found different row
			}
		}

		// If we have at least 2 holes in the same row, calculate row orientation
		if (firstRowHoles.length >= 2) {
			// Sort by X coordinate to get leftmost and rightmost holes in the row
			firstRowHoles.sort((a, b) => a.startXLocation - b.startXLocation);
			const leftHole = firstRowHoles[0];
			const rightHole = firstRowHoles[firstRowHoles.length - 1];

			// Calculate bearing from left to right hole using your protractor formula
			const deltaX = rightHole.startXLocation - leftHole.startXLocation;
			const deltaY = rightHole.startYLocation - leftHole.startYLocation;

			// Use the same bearing calculation as your protractor tool
			rowOrientation = (90 - (Math.atan2(deltaY, deltaX) * 180) / Math.PI + 360) % 360;
		}
	}

	console.log("Detected row orientation: " + rowOrientation + "° for entity: " + entityName);

	// Step 2: Convert compass bearing to math radians for projections
	const rowBearingRadians = (90 - rowOrientation) * (Math.PI / 180);
	const burdenBearingRadians = rowBearingRadians - Math.PI / 2; // Perpendicular to row direction

	// Step 3: Project each hole onto the burden axis (perpendicular to rows) and spacing axis (along rows)
	entityHoles.forEach((hole) => {
		// Project onto burden direction (perpendicular to rows) - this determines which row
		hole.burdenProjection = hole.startXLocation * Math.cos(burdenBearingRadians) + hole.startYLocation * Math.sin(burdenBearingRadians);
		// Project onto spacing direction (along rows) - this determines position within row
		hole.spacingProjection = hole.startXLocation * Math.cos(rowBearingRadians) + hole.startYLocation * Math.sin(rowBearingRadians);
	});

	// Step 4: Sort by burden projection (to group rows), then by spacing projection (within each row)
	entityHoles.sort((a, b) => {
		const burdenDiff = Math.abs(a.burdenProjection - b.burdenProjection);
		if (burdenDiff > 1.5) {
			// Tolerance for row grouping
			return b.burdenProjection - a.burdenProjection; // Sort rows (highest burden first)
		}
		return a.spacingProjection - b.spacingProjection; // Sort within row (left to right along row)
	});

	// Step 5: Group holes by rows using burden projection
	const tolerance = 2.0; // Tolerance in meters for row grouping
	const rows = [];

	if (entityHoles.length > 0) {
		let currentRow = [entityHoles[0]];
		let currentBurdenPos = entityHoles[0].burdenProjection;

		for (let i = 1; i < entityHoles.length; i++) {
			const hole = entityHoles[i];
			if (Math.abs(hole.burdenProjection - currentBurdenPos) <= tolerance) {
				currentRow.push(hole);
			} else {
				// Sort current row by spacing projection (along the row direction)
				currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
				rows.push(currentRow);
				currentRow = [hole];
				currentBurdenPos = hole.burdenProjection;
			}
		}

		// Don't forget the last row
		if (currentRow.length > 0) {
			currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
			rows.push(currentRow);
		}
	}

	// Step 6: Simple renumbering starting from A1 (offset logic already applied during generation)
	let rowLetter = "A";
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		const row = rows[rowIndex];

		// For clipped patterns, just renumber sequentially starting from 1 in each row
		for (let pos = 0; pos < row.length; pos++) {
			const hole = row[pos];
			const newHoleID = rowLetter + (pos + 1);

			// Update fromHoleID references
			allBlastHoles.forEach((hole) => {
				if (hole.fromHoleID === entityName + ":::" + hole.holeID) {
					hole.fromHoleID = entityName + ":::" + newHoleID;
				}
			});

			hole.holeID = newHoleID;
		}

		// Move to next row letter
		if (rowLetter === "Z") {
			rowLetter = "AA";
		} else if (rowLetter === "ZZ") {
			rowLetter = "AAA";
		} else {
			rowLetter = incrementLetter(rowLetter);
		}
	}

	// Step 7: Clean up temporary projection properties
	entityHoles.forEach((hole) => {
		delete hole.burdenProjection;
		delete hole.spacingProjection;
	});

	console.log("Renumbered " + entityHoles.length + " holes in " + rows.length + " rows for entity: " + entityName + " with detected row orientation: " + rowOrientation + "°");
}

function deleteHoleAndRenumber(holeToDelete) {
	const entityName = holeToDelete.entityName;
	const holeID = holeToDelete.holeID;

	// Check if this is alphanumeric naming
	const alphaMatch = holeID.toString().match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;

	// Remove the hole from points array
	const holeIndex = allBlastHoles.indexOf(holeToDelete);
	if (holeIndex > -1) {
		allBlastHoles.splice(holeIndex, 1);
	}

	if (isAlphaNumerical) {
		const deletedRowLetter = alphaMatch[1];
		const deletedHoleNumber = parseInt(alphaMatch[2]);

		// Get all holes in the same row (same letter) and entity
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.holeID.toString().startsWith(deletedRowLetter));

		// Sort by hole number within the row
		sameRowHoles.sort((a, b) => {
			const aMatch = a.holeID.toString().match(/^[A-Z]+(\d+)$/);
			const bMatch = b.holeID.toString().match(/^[A-Z]+(\d+)$/);
			if (aMatch && bMatch) {
				return parseInt(aMatch[1]) - parseInt(bMatch[1]);
			}
			return 0;
		});

		// Renumber holes in this row that come after the deleted hole
		sameRowHoles.forEach((hole) => {
			const currentMatch = hole.holeID.toString().match(/^([A-Z]+)(\d+)$/);
			if (currentMatch) {
				const currentHoleNumber = parseInt(currentMatch[2]);
				if (currentHoleNumber > deletedHoleNumber) {
					const oldHoleID = hole.holeID;
					const newHoleID = deletedRowLetter + (currentHoleNumber - 1);
					hole.holeID = newHoleID;

					// Update fromHoleID references
					allBlastHoles.forEach((hole) => {
						if (hole.fromHoleID === entityName + ":::" + oldHoleID) {
							hole.fromHoleID = entityName + ":::" + newHoleID;
						}
					});
				}
			}
		});
	}
	// For numerical holes, no automatic renumbering on delete (user can manually renumber if needed)
}

function handleHoleAddingClick(event) {
	if (isAddingHole) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
	} else {
		worldX = null;
		worldY = null;
	}
}

//================================================
//DRAWING FUNCTIONS ADD KAD DRAWING POINT - LINE - POLY - CIRCLE - TEXT
//===============================================

// Add these variables to track the current drawing state
let currentDrawingEntityName = null;
let deleteKeyPressed = false;
let deleteKeyCount = 0;

// Enhanced key listener for delete/backspace functionality
function handleDrawingKeyEvents(event) {
	// Check for Delete or Backspace keys
	if (event.key === "Delete" || event.key === "Backspace") {
		event.preventDefault(); // Prevent default browser behavior

		// Only allow deletion if we have a current drawing entity
		if (currentDrawingEntityName && allKADDrawingsMap.has(currentDrawingEntityName)) {
			const entity = allKADDrawingsMap.get(currentDrawingEntityName);

			if (entity.data.length > 0) {
				// Remove the last point
				const removedPoint = entity.data.pop();
				deleteKeyCount++;

				// Update the last draw point to the previous point (if any)
				if (entity.data.length > 0) {
					const lastPoint = entity.data[entity.data.length - 1];
					updateLastKADDrawPoint(lastPoint.pointXLocation, lastPoint.pointYLocation);
				} else {
					// If no points left, reset the last draw point
					lastKADDrawPoint = null;
				}

				// Show user feedback
				const remainingPoints = entity.data.length;
				const entityType = entity.entityType;
				let message = "";

				if (remainingPoints === 0) {
					message = "Removed last point. Entity is now empty.";
				} else {
					message = "Removed last point. " + remainingPoints + " point" + (remainingPoints > 1 ? "s" : "") + " remaining in " + entityType + ".";
				}

				updateStatusMessage(message);
				setTimeout(() => updateStatusMessage(""), 2000);

				// Redraw the canvas
				drawData(allBlastHoles, selectedHole);
				debouncedSaveKAD();

				console.log("🗑️ Removed point from " + currentDrawingEntityName + ". Points remaining: " + remainingPoints);
			} else {
				updateStatusMessage("No points to remove from current " + entity.entityType + ".");
				setTimeout(() => updateStatusMessage(""), 1500);
			}
		} else {
			updateStatusMessage("No active drawing to remove points from.");
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		return true; // Signal that we handled the key
	}
	return false; // Signal that we didn't handle the key
}
// Enhanced function to update the current drawing entity name
function setCurrentDrawingEntity(entityName) {
	currentDrawingEntityName = entityName;
	deleteKeyCount = 0; // Reset delete count when starting new entity
	console.log("🎨 Set current drawing entity: " + entityName);
}
// Function to clear current drawing entity when switching tools
function clearCurrentDrawingEntity() {
	currentDrawingEntityName = null;
	deleteKeyCount = 0;
	console.log("🧹 Cleared current drawing entity");
}

function handleKADPointClick(event) {
	if (isDrawingPoint) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADPoint();
		debouncedUpdateTreeView();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedUpdateTreeView(); // Use debounced version
		debouncedSaveKAD();
	}
}

function addKADPoint() {
	if (isDrawingPoint) {
		const color = getJSColorHexDrawing();
		const entityType = "point";

		// Use the same entity management as lines/polygons
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = "pointObject" + (allKADDrawingsMap.size + 1);
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		// In addKADPoint() function around line 9720
		const pointObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth, // This is added for inter-changable types. points > lines > polys
			color: color,
			connected: false,
			closed: false,
			visible: true
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true
			});
		}

		allKADDrawingsMap.get(entityName).data.push(pointObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedUpdateTreeView();
		console.log("Added point", pointID, "to", entityName);
	}
}

function handleKADLineClick(event) {
	if (isDrawingLine) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADLine();
		debouncedUpdateTreeView(); // Use debounced version
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADLine() {
	if (isDrawingLine) {
		const entityType = "line";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1; // Changed map
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();

		if (createNewEntity) {
			entityName = "lineObject" + (allKADDrawingsMap.size + 1); // Changed map
			createNewEntity = false;
			setCurrentDrawingEntity(entityName);
		}

		const lineObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: false, // Added: lines are open
			visible: true
		};

		// Add to allKADDrawingsMap instead
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				data: [],
				visible: true
			});
		}
		allKADDrawingsMap.get(entityName).data.push(lineObject); // Changed map
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
}

function handleKADPolyClick(event) {
	if (isDrawingPoly) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADPoly();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	}
}
// Function to add a point to the allKADDrawingsMap
function addKADPoly() {
	if (isDrawingPoly) {
		// Create a new point object or use the existing one
		const entityType = "poly";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();
		const closed = true; // Default to closed polygon

		if (createNewEntity) {
			entityName = "polyObject" + (allKADDrawingsMap.size + 1);
			createNewEntity = false; // Set the flag to false after creating a new entity
			setCurrentDrawingEntity(entityName);
		}

		const polyObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: closed, // Set to true if the polygon is closed
			visible: true
		};

		// Add the point to allKADDrawingsMap
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				data: [],
				visible: true
			});
		}
		allKADDrawingsMap.get(entityName).data.push(polyObject);
		// Add this line to update the last draw point
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
	console.log("allKADDrawingsMap: ", allKADDrawingsMap);
}

function handleKADCircleClick(event) {
	if (isDrawingCircle) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADCircle();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADCircle() {
	if (isDrawingCircle) {
		const color = getJSColorHexDrawing();
		const radius = circleRadius.value;
		const entityType = "circle";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = "circleObject" + (allKADDrawingsMap.size + 1);
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		const circleObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			radius: radius,
			lineWidth: lineWidth,
			color: color,
			connected: false,
			closed: false,
			visible: true
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true
			});
		}
		allKADDrawingsMap.get(entityName).data.push(circleObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		console.log("Added circle", pointID, "to", entityName);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
}

function handleKADTextClick(event) {
	if (isDrawingText) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADText();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

// Enhanced function to evaluate calculations with user-friendly error handling
async function processTextCalculationWithValidation(text) {
	if (text.startsWith("=")) {
		try {
			const expression = text.substring(1); // Remove '='
			const calculatedValue = eval(expression);

			// Check if result is valid
			if (isNaN(calculatedValue) || !isFinite(calculatedValue)) {
				throw new Error("Result is not a valid number");
			}

			return calculatedValue.toString(); // Return the result as a string
		} catch (error) {
			// Show user-friendly error popup
			const result = await showCalculationErrorPopup(text, error.message);
			return result; // Will be either corrected text or original
		}
	}
	return text; // Return original text if not a calculation
}
//TODO use the FloatingDialog class to create this popup
// Show calculation error popup with helpful feedback
function showCalculationErrorPopup(originalText, errorMessage) {
	return new Promise((resolve) => {
		// Generate helpful error message
		let helpfulMessage = "Unknown calculation error";
		let suggestions = "";

		if (errorMessage.includes("Unexpected token")) {
			helpfulMessage = "Invalid mathematical expression";
			suggestions = "• Check for typos in operators (+, -, *, /)<br>• Make sure parentheses are balanced<br>• Use only numbers and basic math operators";
		} else if (errorMessage.includes("not defined")) {
			helpfulMessage = "Unknown variable or function";
			suggestions = "• Only use numbers and basic math operators (+, -, *, /, ())<br>• Variables and custom functions are not supported";
		} else if (errorMessage.includes("not a valid number")) {
			helpfulMessage = "Calculation result is invalid";
			suggestions = "• Check for division by zero<br>• Ensure the result is a finite number";
		} else {
			suggestions = "• Use format: =5+3 or =10*2<br>• Only basic math operators are supported<br>• Check for syntax errors";
		}

		// Step 1) Create content with error details using inline styles for dark mode
		const textColor = darkModeEnabled ? "#ffffff" : "#000000";
		const content = `
			<div style="text-align: center;">
				<label style="color: ${textColor}; font-size: 16px; font-weight: bold;"><strong>Formula:</strong> ${originalText}</label><br><br>
				<label style="color: ${textColor}; font-size: 14px; font-weight: bold;"><strong>Error:</strong> ${helpfulMessage}</label><br><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Suggestions:</strong></label><br>
				<div style="text-align: center; margin: 10px 20px;">
					<label style="color: ${textColor}; font-size: 10px;">${suggestions}</label>
				</div><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Examples:</strong></label><br>
				<label style="color: ${textColor}; font-size: 10px;">=5+3 → 8</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=10*2.5 → 25</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=(100+50)/2 → 75</label>
			</div>
		`;

		// Step 2) Create FloatingDialog with three buttons
		const dialog = new FloatingDialog({
			title: "Calculation Error",
			content: content,
			width: 400,
			height: 300,
			showConfirm: true,
			showCancel: true,
			showDeny: false,
			showOption1: true, // Enable the third button
			showOption2: false,
			confirmText: "Fix It",
			cancelText: "Cancel",
			option1Text: "As Text", // Third button
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior
			layoutType: "default",
			onConfirm: () => {
				// Step 3) User wants to fix it - keep the text field focused for editing
				console.log("Calculation error dialog - Fix It selected");
				dialog.close();
				resolve(null); // Signal to not save and let user edit
			},
			onCancel: () => {
				// Step 4) User cancelled - don't save anything
				console.log("Calculation error dialog - Cancel selected");
				dialog.close();
				resolve(null);
			},
			onOption1: () => {
				// Step 5) User wants to use as regular text (remove the = sign)
				console.log("Calculation error dialog - As Text selected");
				dialog.close();
				resolve(originalText.substring(1)); // Remove = and store as plain text
			}
		});

		// Step 6) Show the dialog
		dialog.show();
	});
}

async function addKADText() {
	console.log("=== addKADText() called ===");
	console.log("createNewEntity:", createNewEntity);
	console.log("current entityName:", entityName);
	console.log("isDrawingText:", isDrawingText);

	if (isDrawingText) {
		// Get the text value from the input field
		let text = document.getElementById("drawingText").value.trim();

		// Check if text is blank and warn user
		if (text === "") {
			showModalMessage("No Text Entered", "Please enter text in the drawing tools text area.", "warning");
			return;
		}

		// ✅ ADD THIS: Process calculations if text starts with "="
		const processedText = await processTextCalculationWithValidation(text);

		// If processedText is null, user cancelled or wants to edit - return without saving
		if (processedText === null) {
			return;
		}

		// Use the processed text (either calculated result or original text)
		text = processedText;

		const color = getJSColorHexDrawing();
		const entityType = "text";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = drawingZValue || document.getElementById("drawingElevation").value || 0;

		console.log("Before entity creation check:");
		console.log("  createNewEntity:", createNewEntity);
		console.log("  entityName:", entityName);
		console.log("  allKADDrawingsMap.has(entityName):", allKADDrawingsMap.has(entityName));

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			console.log("Creating new entity...");
			entityName = "textObject" + (allKADDrawingsMap.size + 1);
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
			console.log("New entityName:", entityName);
		} else {
			console.log("Using existing entityName:", entityName);
		}

		const textObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			text: text, // ✅ Now using the processed text
			color: color,
			connected: false,
			closed: false,
			visible: true
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			console.log("Creating new map entry for:", entityName);
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true
			});
		} else {
			console.log("Using existing map entry for:", entityName);
			console.log("Existing entity type:", allKADDrawingsMap.get(entityName).entityType);
		}

		allKADDrawingsMap.get(entityName).data.push(textObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		drawData(allBlastHoles, selectedHole);
		debouncedUpdateTreeView();
		console.log("Added text", pointID, "to", entityName);
		console.log("Final entity type:", allKADDrawingsMap.get(entityName).entityType);
		debouncedSaveKAD();
	}
}
// Using SweetAlert Library Create a popup that gets input from the user.
//TODO use the FloatingDialog class to create this popup
//Add a column selections system to be able to select the manny attributes of the AQM file
//Ignore, Angle, Azimuth, Instruction, Diameter, Material Type, Name, Blast, Pattern, Easting, Northing, Elevation
//Eleven Possible columns
function saveAQMPopup() {
	// ✅ Filter points first
	const visibleBlastHoles = points.filter((point) => blastGroupVisible && point.visible !== false);
	if (visibleBlastHoles.length === 0) {
		showModalMessage("No Visible Holes", "There are no visible holes to export.", "warning");
		return;
	}
	const savedAQMPopupSettings = JSON.parse(localStorage.getItem("savedAQMPopupSettings")) || {};
	let blastNameFromPoints = visibleBlastHoles[0].entityName;
	console.log("blastName: " + blastNameFromPoints);
	Swal.fire({
		title: "Export AQM file?",
		showCancelButton: true,
		confirmButtonText: "Confirm",
		cancelButtonText: "Cancel",
		html: `
            <div class="button-container-2col">
                <label class="labelWhite15" for="fileName">File Name</label>
                <input type="text" id="fileName" value="${blastNameFromPoints}_AQM" placeholder="File Name"/>
				<label class="labelWhite15" for="blastName">Blast Name</label>
                <input type="text" id="blastName" value="${blastNameFromPoints}" placeholder="Blast Name"/>
				<label class="labelWhite15" for="patternName">Pattern Name</label>
                <input type="text" id="patternName" value="${blastNameFromPoints}" placeholder="Pattern Name"/>
				<label class="labelWhite15" for="materialType">Material Type</label>
				<input type="text" id="materialType" placeholder="Material Type" value="Material"/>
				<label class="labelWhite15" for="Instruction">Instruction</label>
				<input type="text" id="instruction" placeholder="Instruction" value="Instruction" />
            </div>
			<label class="labelWhite12">AQM file outputs Select the column order below:</label><br>
			<div class="button-container-2col">
				<label class="labelWhite12">Use hole type as instruction:</label>
				<input type="checkbox" id="useHoleTypeAsInstruction" name="useHoleTypeAsInstruction" value="useHoleTypeAsInstruction">
				<label class="labelWhite12">Write Ignore Columns:</label>
				<input type="checkbox" id="writeIgnoreColumn" name="writeIgnoreColumn" value="writeIgnoreColumn" checked="true">
				<label class="labelWhite12">Column 1:</label>
				<select id="column1Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast" selected>Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern" selected>Pattern</option>
				</select>
				<label class="labelWhite12">Column 2:</label>
				<select id="column2Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast" selected>Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 3:</label>
				<select id="column3Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name" selected>Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 4:</label>
				<select id="column4Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting" selected>Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 5:</label>
				<select id="column5Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing" selected>Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 6:</label>
				<select id="column6Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation" selected>Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 7:</label>
				<select id="column7Dropdown">
					<option value="Angle" selected>Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 8:</label>
				<select id="column8Dropdown">	
					<option value="Angle">Angle</option>
					<option value="Azimuth" selected>Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 9:</label>
				<select id="column9Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter" selected>Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 10:</label>
				<select id="column10Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction" selected>Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 11:</label>
				<select id="column11Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type" selected>Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
			</div>
        `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		},
		preConfirm: () => {
			// Get user input values
			const fileNameInput = document.getElementById("fileName");
			const blastNameInput = document.getElementById("blastName");
			const patternNameInput = document.getElementById("patternName");
			const materialTypeInput = document.getElementById("materialType");
			const instructionInput = document.getElementById("instruction");
			const useHoleTypeAsInstructionInput = document.getElementById("useHoleTypeAsInstruction");
			const writeIgnoreColumnInput = document.getElementById("writeIgnoreColumn");
			const column1Dropdown = document.getElementById("column1Dropdown");
			const column2Dropdown = document.getElementById("column2Dropdown");
			const column3Dropdown = document.getElementById("column3Dropdown");
			const column4Dropdown = document.getElementById("column4Dropdown");
			const column5Dropdown = document.getElementById("column5Dropdown");
			const column6Dropdown = document.getElementById("column6Dropdown");
			const column7Dropdown = document.getElementById("column7Dropdown");
			const column8Dropdown = document.getElementById("column8Dropdown");
			const column9Dropdown = document.getElementById("column9Dropdown");
			const column10Dropdown = document.getElementById("column10Dropdown");
			const column11Dropdown = document.getElementById("column11Dropdown");

			const fileNameValue = fileNameInput.value;
			const blastName = blastNameInput.value;
			const patternName = patternNameInput.value;
			const materialType = materialTypeInput.value;
			const instruction = instructionInput.value;
			const useHoleTypeAsInstruction = useHoleTypeAsInstructionInput.checked;
			const writeIgnoreColumn = writeIgnoreColumnInput.checked;

			const column1Value = column1Dropdown.value;
			const column2Value = column2Dropdown.value;
			const column3Value = column3Dropdown.value;
			const column4Value = column4Dropdown.value;
			const column5Value = column5Dropdown.value;
			const column6Value = column6Dropdown.value;
			const column7Value = column7Dropdown.value;
			const column8Value = column8Dropdown.value;
			const column9Value = column9Dropdown.value;
			const column10Value = column10Dropdown.value;
			const column11Value = column11Dropdown.value;

			// Create the column order array
			let columnOrderArray = [column1Value, column2Value, column3Value, column4Value, column5Value, column6Value, column7Value, column8Value, column9Value, column10Value, column11Value];
			// Save the selected settings to localStorage
			savedAQMPopupSettings.fileNameValue = fileNameValue;
			savedAQMPopupSettings.blastName = blastName;
			savedAQMPopupSettings.patternName = patternName;
			savedAQMPopupSettings.materialType = materialType;
			savedAQMPopupSettings.instruction = instruction;
			savedAQMPopupSettings.useHoleTypeAsInstruction = useHoleTypeAsInstruction;
			savedAQMPopupSettings.writeIgnoreColumn = writeIgnoreColumn;
			savedAQMPopupSettings.columnOrderArray = columnOrderArray;
			localStorage.setItem("savedAQMPopupSettings", JSON.stringify(savedAQMPopupSettings));
		}
	}).then((result) => {
		if (result.isConfirmed) {
			// Get user input values
			const fileNameInput = document.getElementById("fileName");
			const fileNameValue = fileNameInput.value;
			const blastNameInput = document.getElementById("blastName");
			const blastName = blastNameInput.value;
			const patternNameInput = document.getElementById("patternName");
			const patternName = patternNameInput.value;
			const materialTypeInput = document.getElementById("materialType");
			const materialType = materialTypeInput.value;
			const instructionInput = document.getElementById("instruction");
			const instruction = instructionInput.value;
			if (fileNameValue === "") {
				// Show an alert to the user with a customized error button
				Swal.fire({
					title: "File Name is Null or Invalid",
					icon: "error",
					showCancelButton: false,
					confirmButtonText: "Error",
					customClass: {
						container: "custom-popup-container",
						title: "swal2-title",
						confirmButton: "cancel",
						content: "swal2-content",
						htmlContainer: "swal2-html-container",
						icon: "swal2-icon"
					}
				});
				return; // Exit the function
			}
			let useHoleTypeAsInstruction = document.getElementById("useHoleTypeAsInstruction").checked;
			let writeIgnoreColumn = document.getElementById("writeIgnoreColumn").checked;
			// Get selected values from the dropdowns
			const column1Dropdown = document.getElementById("column1Dropdown");
			const column2Dropdown = document.getElementById("column2Dropdown");
			const column3Dropdown = document.getElementById("column3Dropdown");
			const column4Dropdown = document.getElementById("column4Dropdown");
			const column5Dropdown = document.getElementById("column5Dropdown");
			const column6Dropdown = document.getElementById("column6Dropdown");
			const column7Dropdown = document.getElementById("column7Dropdown");
			const column8Dropdown = document.getElementById("column8Dropdown");
			const column9Dropdown = document.getElementById("column9Dropdown");
			const column10Dropdown = document.getElementById("column10Dropdown");
			const column11Dropdown = document.getElementById("column11Dropdown");
			const column1Value = column1Dropdown.value;
			const column2Value = column2Dropdown.value;
			const column3Value = column3Dropdown.value;
			const column4Value = column4Dropdown.value;
			const column5Value = column5Dropdown.value;
			const column6Value = column6Dropdown.value;
			const column7Value = column7Dropdown.value;
			const column8Value = column8Dropdown.value;
			const column9Value = column9Dropdown.value;
			const column10Value = column10Dropdown.value;
			const column11Value = column11Dropdown.value;
			// Create the column order array
			let columnOrderArray = [column1Value, column2Value, column3Value, column4Value, column5Value, column6Value, column7Value, column8Value, column9Value, column10Value, column11Value];
			// Convert the points to a CSV string using the selected column orders
			let aqm = convertPointsToAQMCSV(points, fileNameValue, blastName, patternName, materialType, instruction, useHoleTypeAsInstruction, writeIgnoreColumn, columnOrderArray);
			if (isIOS()) {
				// Create a Blob with the XML data
				const blob = new Blob([aqm], {
					type: "text/csv;charset=utf-8"
				});
				// Create a URL for the Blob
				const url = URL.createObjectURL(blob);
				// Create an anchor element with the download link
				const link = document.createElement("a");
				link.href = url;
				link.download = fileNameValue + ".aqm";
				link.textContent = "Click here to download";
				// Append the link to the document
				document.body.appendChild(link);
				// Programmatically trigger the click event on the link
				link.click();
				// Remove the link from the document
				document.body.removeChild(link);
			} else {
				// Create an invisible anchor element
				const link = document.createElement("a");
				link.style.display = "none";

				// Set the XML content as the "href" attribute
				link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(aqm);
				link.download = fileNameValue + ".aqm";

				// Append the link to the document
				document.body.appendChild(link);

				// Programmatically trigger the click event on the link
				link.click();

				// Remove the link from the document
				document.body.removeChild(link);
			}
		}
	});
	// Populate form fields with saved settings
	const fileNameInput = document.getElementById("fileName");
	const blastNameInput = document.getElementById("blastName");
	const patternNameInput = document.getElementById("patternName");
	const materialTypeInput = document.getElementById("materialType");
	const instructionInput = document.getElementById("instruction");
	const useHoleTypeAsInstructionInput = document.getElementById("useHoleTypeAsInstruction");
	const writeIgnoreColumnInput = document.getElementById("writeIgnoreColumn");
	const column1Dropdown = document.getElementById("column1Dropdown");
	const column2Dropdown = document.getElementById("column2Dropdown");
	const column3Dropdown = document.getElementById("column3Dropdown");
	const column4Dropdown = document.getElementById("column4Dropdown");
	const column5Dropdown = document.getElementById("column5Dropdown");
	const column6Dropdown = document.getElementById("column6Dropdown");
	const column7Dropdown = document.getElementById("column7Dropdown");
	const column8Dropdown = document.getElementById("column8Dropdown");
	const column9Dropdown = document.getElementById("column9Dropdown");
	const column10Dropdown = document.getElementById("column10Dropdown");
	const column11Dropdown = document.getElementById("column11Dropdown");
	// Add more dropdown elements as needed

	fileNameInput.value = savedAQMPopupSettings.fileNameValue || "";
	blastNameInput.value = savedAQMPopupSettings.blastName || "";
	patternNameInput.value = savedAQMPopupSettings.patternName || "";
	materialTypeInput.value = savedAQMPopupSettings.materialType || "";
	instructionInput.value = savedAQMPopupSettings.instruction || "";
	useHoleTypeAsInstructionInput.checked = savedAQMPopupSettings.useHoleTypeAsInstruction || false;
	writeIgnoreColumnInput.checked = savedAQMPopupSettings.writeIgnoreColumn || true;
	column1Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[0] : "Pattern";
	column2Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[1] : "Blast";
	column3Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[2] : "Name";
	column4Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[3] : "Easting";
	column5Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[4] : "Northing";
	column6Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[5] : "Elevation";
	column7Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[6] : "Angle";
	column8Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[7] : "Azimuth";
	column9Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[8] : "Diameter";
	column10Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[9] : "Instruction";
	column11Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[10] : "Material Type";
	// Set values for more dropdowns as needed
}

//TODO use the FloatingDialog class to create this popup
// Using SweetAlert Library Create a popup that gets input from the user.
// Updated addHolePopup function with proper field handling
function addHolePopup() {
	let blastNameValue = "Added_hole_" + new Date().getTime();
	//Retrieve the last entered values from local storage
	let savedAddHolePopupSettings = JSON.parse(localStorage.getItem("savedAddHolePopupSettings")) || {};
	let lastValues = {
		blastName: savedAddHolePopupSettings.blastName || blastNameValue,
		useCustomHoleID: savedAddHolePopupSettings.useCustomHoleID !== undefined ? savedAddHolePopupSettings.useCustomHoleID : false,
		useGradeZ: savedAddHolePopupSettings.useGradeZ !== undefined ? savedAddHolePopupSettings.useGradeZ : false,
		customHoleID: savedAddHolePopupSettings.customHoleID || "",
		elevation: savedAddHolePopupSettings.elevation || 0,
		gradeZ: savedAddHolePopupSettings.gradeZ || 0,
		diameter: savedAddHolePopupSettings.diameter || 115,
		type: savedAddHolePopupSettings.type || "Production",
		length: savedAddHolePopupSettings.length || 0,
		subdrill: savedAddHolePopupSettings.subdrill || 0,
		angle: savedAddHolePopupSettings.angle || 0,
		bearing: savedAddHolePopupSettings.bearing || 0,
		burden: savedAddHolePopupSettings.burden || 3.0,
		spacing: savedAddHolePopupSettings.spacing || 3.5
	};

	// Calculate default length if using grade Z
	const defaultLength = lastValues.useGradeZ ? Math.abs((lastValues.elevation - lastValues.gradeZ + lastValues.subdrill) / Math.cos(lastValues.angle * (Math.PI / 180))) : lastValues.length;

	// Calculate default grade if using length
	const defaultGradeZ = !lastValues.useGradeZ ? lastValues.elevation - (lastValues.length - lastValues.subdrill) * Math.cos(lastValues.angle * (Math.PI / 180)) : lastValues.gradeZ;

	Swal.fire({
		title: "Add a hole to the Pattern?",
		showCancelButton: true,
		confirmButtonText: "Confirm",
		cancelButtonText: "Cancel",
		html: `
		<div class="button-container-2col">
			<label class="labelWhite18" for="blastName">Blast Name</label>
			<input type="text3" id="blastName" placeholder="Blast Name" value="${lastValues.blastName}" />
		  	<label class="labelWhite18" for="useCustomHoleID">Use Custom Hole ID</label>
		  	<input type="checkbox" id="useCustomHoleID" name="useCustomHoleID" ${lastValues.useCustomHoleID ? "checked" : ""}>
            <label class="labelWhite18" for="useGradeZ">Use Grade Z</label>
		  	<input type="checkbox" id="useGradeZ" name="useGradeZ" ${lastValues.useGradeZ ? "checked" : ""}>
		  	<label class="labelWhite18" for="customHoleID">Hole ID</label>
		  	<input type="text3" id="customHoleID" placeholder="Custom Hole ID" value="${lastValues.customHoleID}" />
		  	<label class="labelWhite18" for="elevation">Start Z</label>
		  	<input type="number3" id="elevation" placeholder="Elevation" value="${lastValues.elevation}" inputmode="decimal" pattern="[0-9]*"/>
            <label class="labelWhite18" for="gradeZ">Grade Z</label>
		  	<input type="number3" id="gradeZ" placeholder="Grade Z" value="${defaultGradeZ}" inputmode="decimal" pattern="[0-9]*" ${!lastValues.useGradeZ ? "disabled" : ""}/>
			<label class="labelWhite18" for="diameter">Diameter</label>
			<input type="number3" id="diameter" name="diameter" placeholder="Diameter" value="${lastValues.diameter}" step=1 min="0" max="1000" inputmode="decimal" pattern="[0-9]*"/>
			<label class="labelWhite18" for="type">Type</label>
			<input type="text3" id="type" name="type" placeholder="Type" value="${lastValues.type}"/>
		  	<label class="labelWhite18" for="length">Length</label>
		  	<input type="number3" id="length" placeholder="Length" value="${defaultLength}" inputmode="decimal" pattern="[0-9]*" ${lastValues.useGradeZ ? "disabled" : ""}/>
            <label class="labelWhite18" for="subdrill">Subdrill</label>
		  	<input type="number3" id="subdrill" placeholder="Subdrill" value="${lastValues.subdrill}" inputmode="decimal" pattern="[0-9]*"/>
		  	<label class="labelWhite18" for="angle">Angle</label>
		  	<input type="number3" id="angle" placeholder="Angle" value="${lastValues.angle}" min="0" max="60" inputmode="decimal" pattern="[0-9]*"/>
		  	<label class="labelWhite18" for="bearing">Bearing</label>
		  	<input type="number3" id="bearing" placeholder="Bearing" value="${lastValues.bearing}" inputmode="decimal" pattern="[0-9]*"/>
			<label class="labelWhite18" for="burden">Burden</label>
			<input type="number3" id="burden" name="burden" placeholder="Burden" value="${lastValues.burden}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
			<label class="labelWhite18" for="spacing">Spacing</label>
			<input type="number3" id="spacing" name="spacing" placeholder="Spacing" value="${lastValues.spacing}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
		  </div>
	  `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		},
		didOpen: () => {
			// Add event listeners after the popup is opened
			const useGradeZCheckbox = document.getElementById("useGradeZ");
			const gradeZInput = document.getElementById("gradeZ");
			const lengthInput = document.getElementById("length");
			const elevationInput = document.getElementById("elevation");
			const angleInput = document.getElementById("angle");
			const subdrillInput = document.getElementById("subdrill");

			// Function to update fields based on checkbox state
			function updateFieldsBasedOnUseGradeZ() {
				const useGradeZ = useGradeZCheckbox.checked;

				// Enable/disable fields
				gradeZInput.disabled = !useGradeZ;
				lengthInput.disabled = useGradeZ;

				// Update calculations
				if (useGradeZ) {
					// Calculate length from grade
					const elevation = parseFloat(elevationInput.value) || 0;
					const gradeZ = parseFloat(gradeZInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedLength = Math.abs((elevation - gradeZ + subdrill) / Math.cos(angleRad));
					lengthInput.value = calculatedLength.toFixed(2);
				} else {
					// Calculate grade from length
					const elevation = parseFloat(elevationInput.value) || 0;
					const length = parseFloat(lengthInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedGradeZ = elevation - (length - subdrill) * Math.cos(angleRad);
					gradeZInput.value = calculatedGradeZ.toFixed(2);
				}
			}

			// Add event listeners for changes
			useGradeZCheckbox.addEventListener("change", updateFieldsBasedOnUseGradeZ);
			gradeZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			lengthInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			elevationInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			angleInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			subdrillInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);

			// Initial update
			updateFieldsBasedOnUseGradeZ();
		}
	}).then((result) => {
		if (result.isConfirmed) {
			const useCustomHoleID = document.getElementById("useCustomHoleID").checked;
			const useGradeZ = document.getElementById("useGradeZ").checked;
			const customHoleID = document.getElementById("customHoleID").value;

			const blastNameInput = document.getElementById("blastName");
			const blastNameValue = blastNameInput.value;
			if (blastNameValue === null || blastNameValue === "") {
				// Show an alert to the user
				Swal.fire({
					title: "Invalid Blast Name",
					showCancelButton: true,
					showConfirmButton: false,
					html: `<label class="labelWhite18">Error parsing Blast Name</label>`,
					customClass: {
						container: "custom-popup-container",
						title: "swal2-title",
						cancelButton: "Try Again",
						content: "swal2-content",
						htmlContainer: "swal2-html-container",
						icon: "error"
					}
				});
				return; // Exit the function
			}

			//diameter checks
			const diameterInput = document.getElementById("diameter");
			const diameterValue = parseFloat(diameterInput.value);
			if (isNaN(diameterValue) || diameterValue < 0 || diameterValue > 1000) {
				// Show an alert to the user
				showModalMessage("Diameter Invalid", "Please enter a valid diameter between 0 to 1000 millimeters", "info", () => {
					console.log("User acknowledged the Invalid Diameter");
				});
				return; // Exit the function
			}
			//type checks which is only text
			const typeInput = document.getElementById("type");
			const typeValue = typeInput.value;
			if (typeValue === null || typeValue === "") {
				// Show an alert to the user
				showModalMessage("Type Invalid", "Please enter a valid Type.", "info", () => {
					console.log("User acknowledged the Invalid Type");
				});
				return; // Exit the function
			}
			const elevationInput = document.getElementById("elevation");
			const elevationValue = parseFloat(elevationInput.value);
			if (isNaN(elevationValue) || elevationValue < -20000 || elevationValue > 20000) {
				// Show an alert to the user
				showModalMessage("Elevation Invalid", "Please enter a valid elevation -20000 to 20000 meters", "info", () => {
					console.log("User acknowledged the the invalid elevation");
				});
				return; // Exit the function
			}
			const gradeZInput = document.getElementById("gradeZ");
			const gradeZValue = parseFloat(gradeZInput.value);
			if (isNaN(gradeZValue) || gradeZValue < -20000 || gradeZValue > 20000) {
				// Show an alert to the user
				showModalMessage("Grade Z Invalid", "Please enter an grade Z between -20000 and 20000 meters.", "info", () => {
					console.log("User acknowledged the the invalid grade Z");
				});
				return; // Exit the function
			}
			const lengthInput = document.getElementById("length");
			const lengthValue = parseFloat(lengthInput.value);
			if (isNaN(lengthValue) || lengthValue < 0 || lengthValue > 100) {
				// Show an alert to the user
				showModalMessage("Length Invalid", "Please enter a length between 0 and 100 meters.", "info", () => {
					console.log("User acknowledged the the invalid length");
				});
				return; // Exit the function
			}

			const subdrillInput = document.getElementById("subdrill");
			const subdrillValue = parseFloat(subdrillInput.value);
			if (isNaN(subdrillValue) || subdrillValue < 0 || subdrillValue > 100) {
				// Show an alert to the user
				showModalMessage("Subdrill Invalid", "Please enter an subdrill between 0 and 100 meters.", "info", () => {
					console.log("User acknowledged the the invalid subdrill");
				});
				return; // Exit the function
			}

			const angleInput = document.getElementById("angle");
			const angleValue = parseFloat(angleInput.value);

			if (isNaN(angleValue) || angleValue < 0 || angleValue > 60) {
				// Show an alert to the user
				showModalMessage("Angle Invalid", "Please enter an angle between 0 and 60 degrees.", "info", () => {
					console.log("User acknowledged the the invalid angle");
				});
				return; // Exit the function
			}
			const bearingInput = document.getElementById("bearing");
			const bearingValue = parseFloat(bearingInput.value);

			if (isNaN(bearingValue) || bearingValue < 0 || bearingValue > 360) {
				// Show an alert to the user
				showModalMessage("Bearing Invalid", "Please enter an bearing between 0 and 360 degrees.", "info", () => {
					console.log("User acknowledged the the invalid bearing");
				});
				return; // Exit the function
			}
			// Step 1) Get burden value and validate
			const burdenInput = document.getElementById("burden");
			const burdenValue = parseFloat(burdenInput.value);

			if (isNaN(burdenValue) || burdenValue <= 0 || burdenValue > 50) {
				// Show an alert to the user
				showModalMessage("Burden Invalid", "Please enter a burden between 0.1 and 50 meters.", "info", () => {
					console.log("User acknowledged the invalid burden");
				});
				return; // Exit the function
			}

			// Step 2) Get spacing value and validate
			const spacingInput = document.getElementById("spacing");
			const spacingValue = parseFloat(spacingInput.value);

			if (isNaN(spacingValue) || spacingValue <= 0 || spacingValue > 50) {
				// Show an alert to the user
				showModalMessage("Spacing Invalid", "Please enter a spacing between 0.1 and 50 meters.", "info", () => {
					console.log("User acknowledged the invalid spacing");
				});
				return; // Exit the function
			}

			lastValues = {
				blastName: blastNameValue,
				useCustomHoleID: useCustomHoleID,
				useGradeZ: useGradeZ,
				customHoleID: customHoleID,
				elevation: elevationValue,
				gradeZ: gradeZValue,
				diameter: diameterValue,
				type: typeValue,
				length: lengthValue,
				subdrill: subdrillValue,
				angle: angleValue,
				bearing: bearingValue,
				burden: burdenValue,
				spacing: spacingValue
			};
			localStorage.setItem("savedAddHolePopupSettings", JSON.stringify(lastValues));

			// PROXIMITY CHECK: Check for nearby holes before adding
			const proximityHoles = checkHoleProximity(parseFloat(worldX), parseFloat(worldY), parseFloat(diameterValue), allBlastHoles);

			if (proximityHoles.length > 0) {
				const newHoleInfo = {
					entityName: blastNameValue,
					holeID: useCustomHoleID ? customHoleID : (points.length + 1).toString(),
					x: parseFloat(worldX),
					y: parseFloat(worldY),
					diameter: parseFloat(diameterValue)
				};

				showProximityWarning(proximityHoles, newHoleInfo).then((proximityResult) => {
					if (proximityResult.isConfirmed) {
						// User chose to continue - add the hole
						addHole(useCustomHoleID, useGradeZ, blastNameValue, useCustomHoleID ? customHoleID : points.length + 1, parseFloat(worldX), parseFloat(worldY), parseFloat(elevationValue), parseFloat(gradeZValue), parseFloat(diameterValue), typeValue, parseFloat(lengthValue), parseFloat(subdrillValue), parseFloat(angleValue), parseFloat(bearingValue), parseFloat(burdenValue), parseFloat(spacingValue));
					} else if (proximityResult.isDenied) {
						// User chose to skip - don't add this hole
						console.log("Skipped hole due to proximity");
					}
					// If proximityResult.isDismissed (cancel), do nothing
				});
			} else {
				// No proximity issues - add the hole normally
				addHole(useCustomHoleID, useGradeZ, blastNameValue, useCustomHoleID ? customHoleID : allBlastHoles.length + 1, parseFloat(worldX), parseFloat(worldY), parseFloat(elevationValue), parseFloat(gradeZValue), parseFloat(diameterValue), typeValue, parseFloat(lengthValue), parseFloat(subdrillValue), parseFloat(angleValue), parseFloat(bearingValue), parseFloat(burdenValue), parseFloat(spacingValue));
			}
		} else {
			worldX = null;
			worldY = null;
		}
	});
}

function handlePatternAddingClick(event) {
	if (isAddingPattern) {
		// Get the click/touch coordinates relative to the canvas
		//const rect = canvas.getBoundingClientRect();
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addPatternPopup(parseFloat(worldX.toFixed(3)), parseFloat(worldY.toFixed(3)));
		//console.log("worldX: " + worldX + " worldY: " + worldY);
	} else {
		worldX = null;
		worldY = null;
	}
}
//TODO use the FloatingDialog class to create this popup
function addPatternPopup(worldX, worldY) {
	//Retrieve the last entered values from local storage
	let savedAddPatternPopupSettings = JSON.parse(localStorage.getItem("savedAddPatternPopupSettings")) || {};
	let lastValues = {
		blastName: savedAddPatternPopupSettings.blastName || "Created_Blast" + Date.now(),
		nameTypeIsNumerical: savedAddPatternPopupSettings.nameTypeIsNumerical !== undefined ? savedAddPatternPopupSettings.nameTypeIsNumerical : false,
		rowOrientation: savedAddPatternPopupSettings.rowOrientation || 90.0,
		x: savedAddPatternPopupSettings.x || worldX,
		y: savedAddPatternPopupSettings.y || worldY,
		z: savedAddPatternPopupSettings.z || 100,
		useGradeZ: savedAddPatternPopupSettings.useGradeZ || false,
		gradeZ: savedAddPatternPopupSettings.gradeZ || 94,
		diameter: savedAddPatternPopupSettings.diameter || 115,
		type: savedAddPatternPopupSettings.type || "Production",
		angle: savedAddPatternPopupSettings.angle || 0,
		bearing: savedAddPatternPopupSettings.bearing || 180,
		length: savedAddPatternPopupSettings.length || 6.2,
		subdrill: savedAddPatternPopupSettings.subdrill || 0,
		spacingOffset: savedAddPatternPopupSettings.spacingOffset || 0.5,
		burden: savedAddPatternPopupSettings.burden || 3.0,
		spacing: savedAddPatternPopupSettings.spacing || 3.3,
		rows: savedAddPatternPopupSettings.rows || 6,
		holesPerRow: savedAddPatternPopupSettings.holesPerRow || 10
	};

	// Show loading spinner while the popup is created
	Swal.showLoading();

	// Create the SweetAlert popup
	Swal.fire({
		title: "Add a Pattern?",
		showCancelButton: true,
		confirmButtonText: "Confirm",
		cancelButtonText: "Cancel",
		html: `
        <div class="button-container-2col">
          <label class="labelWhite18" for="blastName">Blast Name</label>
          <input type="text3" id="blastName" name="blastName" placeholder="Blast Name" value="${lastValues.blastName}"/>
          <label class="labelWhite18" for="nameTypeIsNumerical">Numerical Names</label>
          <input type="checkbox" id="nameTypeIsNumerical" name="nameTypeIsNumerical" ${lastValues.nameTypeIsNumerical ? "checked" : ""}>
          
          <label class="labelWhite18" for="rowOrientation">Orientation</label>
          <input type="number3" id="rowOrientation" name="rowOrientation" placeholder="rowOrientation" value="${lastValues.rowOrientation}" step=0.1 min="0" max="359.999" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="x">Start X</label>
          <input type="number3" id="x" name="x" placeholder="X" value="${worldX}" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="y">Start Y</label>
          <input type="number3" id="y" name="y" placeholder="Y" value="${worldY}" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="z">Start Z</label>
          <input type="number3" id="z" name="z" placeholder="Z" value="${lastValues.z}" inputmode="decimal" pattern="[0-9]*"/>
          
          <label class="labelWhite18" for="useGradeZ">Use Grade Z</label>
          <input type="checkbox" id="useGradeZ" name="useGradeZ" ${lastValues.useGradeZ ? "checked" : ""}>
          
          <label class="labelWhite18" for="gradeZ">Grade Z</label>
          <input type="number3" id="gradeZ" placeholder="Grade Z" value="${lastValues.gradeZ}" inputmode="decimal" pattern="[0-9]*" ${!lastValues.useGradeZ ? "disabled" : ""}/>
          
          <label class="labelWhite18" for="diameter">Diameter</label>
          <input type="number3" id="diameter" name="diameter" placeholder="Diameter" value="${lastValues.diameter}" step=1 min="0" max="1000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="type">Type</label>
          <input type="text3" id="type" name="type" placeholder="Type" value="${lastValues.type}"/>
          <label class="labelWhite18" for="angle">Angle</label>
          <input type="number3" id="angle" name="angle" placeholder="Angle" value="${lastValues.angle}" step="1" min="0" max="60" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="bearing">Bearing</label>
          <input type="number3" id="bearing" name="bearing" placeholder="Bearing" value="${lastValues.bearing}" step=0.1 min="0" max="359.999" inputmode="decimal" pattern="[0-9]*"/>
          
          <label class="labelWhite18" for="length">Length</label>
          <input type="number3" id="length" name="length" placeholder="Length" value="${lastValues.length}" inputmode="decimal" pattern="[0-9]*" ${lastValues.useGradeZ ? "disabled" : ""}/>
          
          <label class="labelWhite18" for="subdrill">Subdrill</label>
          <input type="number3" id="subdrill" name="subdrill" placeholder="Subdrill" value="${lastValues.subdrill}" step="0.1" min="0.0" max="100" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacingOffset">Offset</label>
          <input type="number3" id="spacingOffset" name="spacingOffset" placeholder="SpacingOffset" value="${lastValues.spacingOffset}" step="0.1" min="-1.0" max="1.0" inputmode="decimal" pattern="[0-9]*"/>
          <div class="labelWhite12" id="infolabel1" name="infolabel1">Offset Information: </div> 
          <div class="labelWhite12" id="infolabel2" name="infolabel2">Staggered = -0.5 or 0.5, Square = -1, 0, 1</div> 
          <label class="labelWhite18" for="burden">Burden</label>
          <input type="number3" id="burden" name="burden" placeholder="Burden" value="${lastValues.burden}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacing">Spacing</label>
          <input type="number3" id="spacing" name="spacing" placeholder="Spacing" value="${lastValues.spacing}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="rows">Rows</label>
          <input type="number3" id="rows" name="rows" placeholder="Rows" value="${lastValues.rows}" step="1" min="1" max="500" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="holesPerRow">Holes Per Row</label>
          <input type="number3" id="holesPerRow" name="holesPerRow" placeholder="Per Row" value="${lastValues.holesPerRow}" step="1" min="1" max="500" inputmode="decimal" pattern="[0-9]*"/>
        </div>
      `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		},
		didOpen: () => {
			// Get references to form elements
			const useGradeZCheckbox = document.getElementById("useGradeZ");
			const gradeZInput = document.getElementById("gradeZ");
			const lengthInput = document.getElementById("length");
			const zInput = document.getElementById("z");
			const angleInput = document.getElementById("angle");
			const subdrillInput = document.getElementById("subdrill");

			// Function to update fields based on checkbox state
			function updateFieldsBasedOnUseGradeZ() {
				const useGradeZ = useGradeZCheckbox.checked;

				// Enable/disable fields
				gradeZInput.disabled = !useGradeZ;
				lengthInput.disabled = useGradeZ;

				// Update calculations
				if (useGradeZ) {
					// Calculate length from grade
					const collarZ = parseFloat(zInput.value) || 0;
					const gradeZ = parseFloat(gradeZInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedLength = Math.abs((collarZ - gradeZ + subdrill) / Math.cos(angleRad));
					lengthInput.value = calculatedLength.toFixed(2);
				} else {
					// Calculate grade from length
					const collarZ = parseFloat(zInput.value) || 0;
					const length = parseFloat(lengthInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedGradeZ = collarZ - (length - subdrill) * Math.cos(angleRad);
					gradeZInput.value = calculatedGradeZ.toFixed(2);
				}
			}

			// Add event listeners for changes
			useGradeZCheckbox.addEventListener("change", updateFieldsBasedOnUseGradeZ);
			gradeZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			lengthInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			zInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			angleInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			subdrillInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);

			// Initial update
			updateFieldsBasedOnUseGradeZ();
		}
	})
		.then((result) => {
			if (result.isConfirmed) {
				// Retrieve values from the input fields
				const entityName = document.getElementById("blastName").value;
				const offset = document.getElementById("spacingOffset").value;
				const nameTypeIsNumerical = document.getElementById("nameTypeIsNumerical").checked; // This boolean controls naming
				const rowOrientation = parseFloat(document.getElementById("rowOrientation").value);
				const useGradeZ = document.getElementById("useGradeZ").checked;
				const x = parseFloat(document.getElementById("x").value);
				const y = parseFloat(document.getElementById("y").value);
				const z = parseFloat(document.getElementById("z").value);
				const gradeZ = parseFloat(document.getElementById("gradeZ").value);
				const diameter = parseFloat(document.getElementById("diameter").value);
				const type = document.getElementById("type").value;
				const angle = parseFloat(document.getElementById("angle").value);
				const bearing = parseFloat(document.getElementById("bearing").value);
				const length = parseFloat(document.getElementById("length").value);
				const subdrill = parseFloat(document.getElementById("subdrill").value);
				const burden = parseFloat(document.getElementById("burden").value);
				const spacing = parseFloat(document.getElementById("spacing").value);
				const rows = parseInt(document.getElementById("rows").value);
				const holesPerRow = parseInt(document.getElementById("holesPerRow").value);

				// Add this line to debug
				console.log("nameTypeIsNumerical received:", nameTypeIsNumerical);

				let patternnameTypeIsNumerical = nameTypeIsNumerical;
				console.log("patternnameTypeIsNumerical set to:", patternnameTypeIsNumerical);

				// Input validation
				if (entityName === null || entityName === "") {
					showModalMessage("Entity Name Invalid", "Please enter a valid Entity Name.", "warning");
					return; // Stop execution if validation fails
				}
				// [Add any other validation checks here, ensure they return to stop execution if invalid]

				// Save settings to localStorage
				lastValues = {
					blastName: entityName,
					offset: offset,
					nameTypeIsNumerical: nameTypeIsNumerical,
					useGradeZ: useGradeZ,
					rowOrientation: rowOrientation,
					x: x,
					y: y,
					z: z,
					gradeZ: gradeZ,
					diameter: diameter,
					type: type,
					angle: angle,
					bearing: bearing,
					length: length,
					subdrill: subdrill,
					burden: burden,
					spacing: spacing,
					rows: rows,
					holesPerRow: holesPerRow
				};
				localStorage.setItem("savedAddPatternPopupSettings", JSON.stringify(lastValues));

				// Use the obtained values to add the pattern
				addPattern(offset, entityName, nameTypeIsNumerical, useGradeZ, rowOrientation, x, y, z, gradeZ, diameter, type, angle, bearing, length, subdrill, burden, spacing, rows, holesPerRow);

				// ⭐ Crucial: Update the TreeView after adding the pattern
				if (typeof debouncedUpdateTreeView === "function") {
					debouncedUpdateTreeView();
				} else if (typeof updateTreeView === "function") {
					updateTreeView();
				}
			}
		})
		.finally(() => {
			// Hide the loading spinner when the popup is closed
			Swal.hideLoading();
		});
}

// Same Space Checker
function checkHoleProximity(newX, newY, newDiameter, existingHoles) {
	// Use 0.1m for dummy holes or holes with no diameter
	const checkDiameter = newDiameter || 0.1;
	const minDistance = checkDiameter / 1000; // Convert mm to meters, 1 diameter minimum

	const proximityHoles = [];

	for (let i = 0; i < existingHoles.length; i++) {
		const existingHole = existingHoles[i];
		const existingDiameter = existingHole.holeDiameter || 0.1;
		const existingMinDistance = existingDiameter / 1000;

		// Calculate distance between hole centers
		const distance = Math.sqrt(Math.pow(newX - existingHole.startXLocation, 2) + Math.pow(newY - existingHole.startYLocation, 2));

		// Check if holes are too close (less than 1 diameter apart)
		const combinedMinDistance = Math.max(minDistance, existingMinDistance);
		if (distance < combinedMinDistance) {
			proximityHoles.push({
				hole: existingHole,
				distance: distance,
				requiredDistance: combinedMinDistance
			});
		}
	}

	return proximityHoles;
}

// Function to show proximity warning and get user decision
//TODO use the FloatingDialog class to create this popup
function showProximityWarning(proximityHoles, newHoleInfo) {
	const holeList = proximityHoles.map((ph) => `• ${ph.hole.entityName}:${ph.hole.holeID} (${ph.distance.toFixed(3)}m apart, need ${ph.requiredDistance.toFixed(3)}m)`).join("\n");

	return Swal.fire({
		title: "Hole Proximity Warning",
		html: `
			<div style="text-align: left; max-height: 300px; overflow-y: auto;">
				<p><strong>New hole would be too close to existing holes:</strong></p>
				<p>New hole: ${newHoleInfo.entityName}:${newHoleInfo.holeID} at (${newHoleInfo.x.toFixed(3)}, ${newHoleInfo.y.toFixed(3)})</p>
				<br>
				<p><strong>Conflicting holes:</strong></p>
				<pre style="font-size: 12px; color: #ff6b6b;">${holeList}</pre>
				<br>
				<p><strong>Options:</strong></p>
				<ul style="text-align: left;">
					<li><strong>Continue:</strong> Add this hole and continue adding others</li>
					<li><strong>Skip:</strong> Skip this hole and continue with pattern</li>
					<li><strong>Cancel:</strong> Cancel the entire operation</li>
				</ul>
			</div>
		`,
		icon: "warning",
		showCancelButton: true,
		showDenyButton: true,
		confirmButtonText: "Continue",
		denyButtonText: "Skip",
		cancelButtonText: "Cancel",
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			denyButton: "deny",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container"
		}
	});
}

// Function to generate the pattern of holes
// added rowid and posid 14 july 2025
function addPattern(offset, entityName, nameTypeIsNumerical, useGradeZ, rowOrientation, x, y, z, gradeZ, diameter, type, angle, bearing, length, subdrill, burden, spacing, rows, holesPerRow) {
	let entityType = "hole";
	let useGradeToCalcLength = useGradeZ;
	let startXLocation = parseFloat(x);
	let startYLocation = parseFloat(y);
	let startZLocation = parseFloat(z);
	let gradeZLocation = useGradeToCalcLength ? parseFloat(gradeZ) : parseFloat(startZLocation - (length - subdrill) * Math.cos(angle * (Math.PI / 180)));
	let holeLength = useGradeToCalcLength ? parseFloat(startZLocation - (gradeZLocation - subdrill) * Math.cos(angle * (Math.PI / 180))) : parseFloat(length);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let subdrillAmount = parseFloat(subdrill);
	let patternburden = parseFloat(burden);
	let patternspacing = parseFloat(spacing);
	let patternrows = parseInt(rows);
	let patternholesPerRow = parseInt(holesPerRow);
	let patternoffset = parseFloat(offset);
	let patternnameTypeIsNumerical = nameTypeIsNumerical;
	let patternrowOrientation = parseFloat((90 - rowOrientation) * (Math.PI / 180));

	let referenceX = startXLocation;
	let referenceY = startYLocation;

	let currentLetter = "A";
	let globalHoleCounter = allBlastHoles.length > 0 ? Math.max(...allBlastHoles.map((h) => parseInt(h.holeID) || 0)) + 1 : 1;

	// Get the starting rowID for this pattern
	const startingRowID = getNextRowID(entityName);
	console.log("Starting rowID for addPattern:", startingRowID);

	for (let i = 0; i < patternrows; i++) {
		// Each pattern row gets its own rowID
		const currentRowID = startingRowID + i;

		for (let j = 0; j < patternholesPerRow; j++) {
			const relativeX = j * patternspacing;
			const relativeY = i * patternburden;

			let offsetX = 0;
			if (i % 2 === 1) {
				offsetX = patternoffset * patternspacing;
			}

			const rotatedX = (relativeX + offsetX) * Math.cos(patternrowOrientation) - relativeY * Math.sin(patternrowOrientation);
			const rotatedY = (relativeX + offsetX) * Math.sin(patternrowOrientation) + relativeY * Math.cos(patternrowOrientation);

			const finalX = referenceX + rotatedX;
			const finalY = referenceY + rotatedY;

			let holeID;
			const useCustomHoleID = true;

			if (!patternnameTypeIsNumerical) {
				holeID = currentLetter + (j + 1);
			} else {
				holeID = globalHoleCounter.toString();
				globalHoleCounter++;
			}

			// Position ID is sequential for each hole in this row (j + 1)
			const posID = j + 1;

			addHole(useCustomHoleID, useGradeZ, entityName, holeID, parseFloat(finalX), parseFloat(finalY), parseFloat(startZLocation), parseFloat(gradeZLocation), parseFloat(holeDiameter), holeType, parseFloat(holeLength), parseFloat(subdrillAmount), parseFloat(holeAngle), parseFloat(holeBearing), currentRowID, posID, patternburden, patternspacing);
		}

		// Increment the current letter for the next row ONLY IF alphanumeric naming is used
		if (!patternnameTypeIsNumerical) {
			if (currentLetter === "Z") {
				currentLetter = "AA";
			} else if (currentLetter === "ZZ") {
				currentLetter = "AAA";
			} else {
				currentLetter = incrementLetter(currentLetter);
			}
		}
	}

	// Reset the pattern adding state
	isAddingPattern = false;
	addPatternSwitch.checked = false;
	resetZoom();
	drawData(allBlastHoles, selectedHole);

	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	} else if (typeof updateTreeView === "function") {
		updateTreeView();
	}

	console.log("Generated pattern with " + patternrows + " rows (rowIDs " + startingRowID + "-" + (startingRowID + patternrows - 1) + ")");
}

function incrementLetter(str) {
	// Helper function to increment letters
	const lastIndex = str.length - 1;
	let carry = false;
	const newStr = str
		.split("")
		.reverse()
		.map((char, index) => {
			if (index === 0 || carry) {
				if (char === "Z") {
					carry = true;
					return "A";
				} else {
					carry = false;
					return String.fromCharCode(char.charCodeAt(0) + 1);
				}
			} else {
				return char;
			}
		})
		.reverse()
		.join("");
	if (carry) {
		return "A" + newStr;
	}
	return newStr;
}

function setMeasuredDate() {
	const date = new Date();
	const day = date.getDate();
	const month = date.getMonth() + 1;
	const year = date.getFullYear();
	const hours = date.getHours();
	const minutes = date.getMinutes();
	const seconds = date.getSeconds();
	return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
}

function handleBlastNameClick(event) {
	if (isBlastNameEditing) {
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && editBlastNameSwitch.checked == false) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (clickedHole && editBlastNameSwitch.checked == true) {
			editBlastNamePopup(selectedHole);
		}
	}

	clickedHole = null;
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	isBlastNameEditing = false;
	editBlastNameSwitch.checked = false;
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView(); // Use debounced version
}

// IMPORTANT IMPLEMENTING A ROW ID AND POS ID FOR BLASTHOLES THIS WILL HELP WITH ORDERING
// Helper function to get the next rowID for a given entityName
function getNextRowID(entityName) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest rowID for this entityName
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);
	if (entityHoles.length === 0) {
		return 1;
	}

	let maxRowID = 0;
	entityHoles.forEach((hole) => {
		if (hole.rowID && !isNaN(hole.rowID)) {
			maxRowID = Math.max(maxRowID, parseInt(hole.rowID));
		}
	});

	return maxRowID + 1;
}

// Helper function to get the next posID for a given entityName and rowID
function getNextPosID(entityName, rowID) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest posID for this entityName and rowID
	const rowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID);

	if (rowHoles.length === 0) {
		return 1;
	}

	let maxPosID = 0;
	rowHoles.forEach((hole) => {
		if (hole.posID && !isNaN(hole.posID)) {
			maxPosID = Math.max(maxPosID, parseInt(hole.posID));
		}
	});

	return maxPosID + 1;
}

/**
 * Add hole to the points array popup using sweetalert and then draw the points
 * @param {boolean} useCustomHoleID - If true, use the custom hole ID
 * @param {boolean} useGradeZ - If true, use grade Z instead of length
 * @param {string} entityName - The name of the entity
 * @param {number} holeID - The ID of the hole
 * @param {number} startXLocation - The X location of the start of the hole
 * @param {number} startYLocation - The Y location of the start of the hole
 * @param {number} startZLocation - The Z location of the start of the hole
 * @param {number} gradeZLocation - The Z location of the grade of the hole
 * @param {number} diameter - The diameter of the hole
 * @param {string} type - The type of the hole
 * @param {number} length - The length of the hole
 * @param {number} subdrill - The subdrill of the hole
 * @param {number} angle - The angle of the hole
 * @param {number} bearing - The bearing of the hole
 * @param {number} rowID - The row ID (Vulcan-style organization)
 * @param {number} posID - The position ID within the row (Vulcan-style organization)
 * @param {number} burden - The burden of the hole
 * @param {number} spacing - The spacing of the hole
 *
 */
function addHole(useCustomHoleID, useGradeZ, entityName, holeID, startXLocation, startYLocation, startZLocation, gradeZLocation, diameter, type, length, subdrill, angle, bearing, rowID = null, posID = null, burden, spacing) {
	if (typeof entityName === "string" && entityName.trim() !== "") {
		entityName = entityName.trim();
	} else {
		entityName = "undefined";
	}
	const entityType = "hole";

	// Initialize allBlastHoles as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	// Auto-assign rowID and posID if not provided (for individual hole creation)
	if (rowID === null) {
		rowID = getNextRowID(entityName);
	}
	if (posID === null) {
		posID = getNextPosID(entityName, rowID);
	}

	let newHoleID = null;
	if (useCustomHoleID === true) {
		// CRITICAL: Check for duplicate hole ID before using the custom ID
		const originalHoleID = holeID.toString();
		newHoleID = validateUniqueHoleID(entityName, originalHoleID);

		if (newHoleID !== originalHoleID) {
			console.warn("🚨 Duplicate hole ID detected during addHole:", entityName + ":" + originalHoleID, "→ Auto-assigned:", newHoleID);
		}
	} else if (useCustomHoleID === false) {
		if (allBlastHoles !== null) {
			newHoleID = allBlastHoles.length + 1;
		} else {
			newHoleID = 1;
		}
	} else {
		newHoleID = 9999;
	}

	// Parse values first
	startXLocation = parseFloat(startXLocation);
	startYLocation = parseFloat(startYLocation);
	startZLocation = parseFloat(startZLocation);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeLengthCalculated = parseFloat(length);
	let subdrillAmount = parseFloat(subdrill);
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let connectorCurve = 0;

	// Handle NaN values
	if (isNaN(holeAngle)) {
		holeAngle = 0;
	}
	if (isNaN(holeBearing)) {
		holeBearing = 0;
	}

	// Calculate length from gradeZ if length is null and useGradeZ is true
	if (useGradeZ && isNaN(holeLengthCalculated) && !isNaN(parseFloat(gradeZLocation))) {
		let deltaZ = startZLocation - parseFloat(gradeZLocation);
		holeLengthCalculated = Math.abs(deltaZ / Math.cos(holeAngle * (Math.PI / 180)));
	}

	// Calculate gradeZLocation from length - subdrill if gradeZLocation is null
	if (useGradeZ && isNaN(parseFloat(gradeZLocation)) && !isNaN(holeLengthCalculated)) {
		gradeZLocation = startZLocation - (holeLengthCalculated - subdrillAmount) * Math.cos(holeAngle * (Math.PI / 180));
	}

	// Set default length to 0 if both length and gradeZ are null
	if (isNaN(holeLengthCalculated)) {
		holeLengthCalculated = 0;
	}

	// Calculate subdrill length
	let subdrillLength = holeAngle > 0 ? subdrillAmount / Math.sin((90 - holeAngle) * (Math.PI / 180)) : subdrillAmount;

	// Calculate total length including subdrill
	let totalLength = holeLengthCalculated + subdrillLength;

	// Calculate end locations using the total length (includes subdrill)
	let endXLocation = parseFloat(startXLocation + totalLength * Math.cos((90 - angle) * (Math.PI / 180)) * Math.cos(((450 - bearing) % 360) * (Math.PI / 180)));
	let endYLocation = parseFloat(startYLocation + totalLength * Math.cos((90 - angle) * (Math.PI / 180)) * Math.sin(((450 - bearing) % 360) * (Math.PI / 180)));
	let endZLocation = parseFloat(startZLocation - totalLength * Math.cos(angle * (Math.PI / 180)));

	// Calculate grade locations using only hole length (no subdrill)
	let gradeXLocation = parseFloat(startXLocation + holeLengthCalculated * Math.cos((90 - angle) * (Math.PI / 180)) * Math.cos(((450 - bearing) % 360) * (Math.PI / 180)));
	let gradeYLocation = parseFloat(startYLocation + holeLengthCalculated * Math.cos((90 - angle) * (Math.PI / 180)) * Math.sin(((450 - bearing) % 360) * (Math.PI / 180)));
	gradeZLocation = parseFloat(startZLocation - holeLengthCalculated * Math.cos(angle * (Math.PI / 180)));

	// Check if endXLocation, endYLocation, or endZLocation is NaN
	if (isNaN(endXLocation)) {
		endXLocation = startXLocation;
	}
	if (isNaN(endYLocation)) {
		endYLocation = startYLocation;
	}
	if (isNaN(endZLocation)) {
		endZLocation = startZLocation;
	}

	// Check if gradeXLocation, gradeYLocation, or gradeZLocation is NaN
	if (isNaN(gradeXLocation)) {
		gradeXLocation = startXLocation;
	}
	if (isNaN(gradeYLocation)) {
		gradeYLocation = startYLocation;
	}
	if (isNaN(gradeZLocation)) {
		gradeZLocation = startZLocation;
	}

	let toHoleCombinedID = entityName.toString() + ":::" + newHoleID.toString();
	let timingDelayMilliseconds = 0;
	let colorHexDecimal = "red";
	let measuredLength = 0;
	let measuredLengthTimeStamp = "09/05/1975 00:00:00";
	let measuredMass = 0;
	let measuredMassTimeStamp = "09/05/1975 00:00:00";
	let measuredComment = "None";
	let measuredCommentTimeStamp = "09/05/1975 00:00:00";

	let benchHeight = holeLengthCalculated * Math.cos(holeAngle * (Math.PI / 180));

	// PROXIMITY CHECK: Check for nearby holes before adding
	const proximityHoles = checkHoleProximity(startXLocation, startYLocation, holeDiameter, allBlastHoles);

	if (proximityHoles.length > 0) {
		// Show warning and get user decision
		const newHoleInfo = {
			entityName: entityName,
			holeID: newHoleID.toString(),
			x: startXLocation,
			y: startYLocation,
			diameter: holeDiameter
		};

		showProximityWarning(proximityHoles, newHoleInfo).then((result) => {
			if (result.isConfirmed) {
				// User chose to continue - add the hole
				addHoleToAllBlastHoles(
					entityName,
					entityType,
					newHoleID,
					startXLocation,
					startYLocation,
					startZLocation,
					endXLocation,
					endYLocation,
					endZLocation,
					gradeXLocation,
					gradeYLocation,
					gradeZLocation,
					subdrillAmount,
					subdrillLength,
					benchHeight,
					holeDiameter,
					holeType,
					holeLengthCalculated,
					holeAngle,
					holeBearing,
					toHoleCombinedID,
					timingDelayMilliseconds,
					colorHexDecimal,
					measuredLength,
					measuredLengthTimeStamp,
					measuredMass,
					measuredMassTimeStamp,
					measuredComment,
					measuredCommentTimeStamp,
					rowID,
					posID,
					burden || 0,
					spacing || 0,
					connectorCurve || 0
				);
			} else if (result.isDenied) {
				// User chose to skip - don't add this hole but continue
				console.log("Skipped hole due to proximity: " + newHoleID);
			}
			// If result.isDismissed (cancel), do nothing - operation is cancelled
		});

		return; // Exit early, let the promise handle the result
	}

	// No proximity issues - add the hole normally
	addHoleToAllBlastHoles(
		entityName,
		entityType,
		newHoleID,
		startXLocation,
		startYLocation,
		startZLocation,
		endXLocation,
		endYLocation,
		endZLocation,
		gradeXLocation,
		gradeYLocation,
		gradeZLocation,
		subdrillAmount,
		subdrillLength,
		benchHeight,
		holeDiameter,
		holeType,
		holeLengthCalculated,
		holeAngle,
		holeBearing,
		toHoleCombinedID,
		timingDelayMilliseconds,
		colorHexDecimal,
		measuredLength,
		measuredLengthTimeStamp,
		measuredMass,
		measuredMassTimeStamp,
		measuredComment,
		measuredCommentTimeStamp,
		rowID,
		posID,
		burden || 0,
		spacing || 0,
		connectorCurve || 0
	);

	if (isAddingHole && !isAddingPattern) {
		debouncedUpdateTreeView();
		drawData(allBlastHoles, selectedHole);
	}
}

// Helper function to actually add the hole to allBlastHoles array
function addHoleToAllBlastHoles(
	entityName,
	entityType,
	newHoleID,
	startXLocation,
	startYLocation,
	startZLocation,
	endXLocation,
	endYLocation,
	endZLocation,
	gradeXLocation,
	gradeYLocation,
	gradeZLocation,
	subdrillAmount,
	subdrillLength,
	benchHeight,
	holeDiameter,
	holeType,
	holeLengthCalculated,
	holeAngle,
	holeBearing,
	toHoleCombinedID,
	timingDelayMilliseconds,
	colorHexDecimal,
	measuredLength,
	measuredLengthTimeStamp,
	measuredMass,
	measuredMassTimeStamp,
	measuredComment,
	measuredCommentTimeStamp,
	rowID,
	posID,
	burden,
	spacing,
	connectorCurve
) {
	allBlastHoles.push({
		entityName: entityName,
		entityType: entityType,
		holeID: newHoleID.toString(),
		startXLocation: startXLocation,
		startYLocation: startYLocation,
		startZLocation: startZLocation,
		endXLocation: endXLocation,
		endYLocation: endYLocation,
		endZLocation: endZLocation,
		gradeXLocation: gradeXLocation,
		gradeYLocation: gradeYLocation,
		gradeZLocation: gradeZLocation,
		subdrillAmount: subdrillAmount,
		subdrillLength: subdrillLength,
		benchHeight: benchHeight,
		holeDiameter: holeDiameter,
		holeType: holeType,
		holeLengthCalculated: holeLengthCalculated,
		holeAngle: holeAngle,
		holeBearing: holeBearing,
		fromHoleID: toHoleCombinedID.toString(),
		timingDelayMilliseconds: timingDelayMilliseconds,
		colorHexDecimal: colorHexDecimal.toString(),
		measuredLength: measuredLength,
		measuredLengthTimeStamp: measuredLengthTimeStamp,
		measuredMass: measuredMass,
		measuredMassTimeStamp: measuredMassTimeStamp,
		measuredComment: measuredComment,
		measuredCommentTimeStamp: measuredCommentTimeStamp,
		visible: true,
		rowID: parseInt(rowID),
		posID: parseInt(posID),
		burden: burden,
		spacing: spacing,
		connectorCurve: connectorCurve
	});

	//console.log("Added Hole: " + newHoleID + " (Row: " + rowID + ", Pos: " + posID + ")");
}

function handleMeasuredLengthClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredLengthTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole.holeID);
		if (clickedHole && measuredLengthSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			}
		} else if (clickedHole && measuredLengthSwitch.checked == true) {
			measuredLengthPopup();
		}
	}
}

function handleMeasuredMassClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredMassTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredMassSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredMassSwitch.checked == true) {
			measuredMassPopup();
		}
	}
}

function handleMeasuredCommentClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredCommentTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredCommentSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredCommentSwitch.checked == true) {
			measuredCommentPopup();
		}
	}
}

function handleHoleTypeEditClick(event) {
	if (isTypeEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editHoleTypePopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editHoleTypePopupSwitch.checked == true) {
			editHoleTypePopup();
		}
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editHoleTypePopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

function handleHoleLengthEditClick(event) {
	if (isLengthPopupEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editLengthPopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editLengthPopupSwitch.checked == true) {
			editHoleLengthPopup();
		}
		// Replace the problematic lines with null-safe versions:
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editLengthPopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView();
		}
	}
}

// Modified handleSelection function to support multiple KAD object selection
function handleSelection(event) {
	if (developerModeEnabled) {
		console.log("=== HANDLE SELECTION DEBUG ===");
		console.log("isSelectionPointerActive:", isSelectionPointerActive);
		console.log("event.shiftKey:", event.shiftKey);
		console.log("Click coordinates:", event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
	}

	if (isSelectionPointerActive) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Step 5) Respect radio selection mode
		const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
		const selectingKAD = selectKADRadio && selectKADRadio.checked;

		// Check if Shift key is pressed for multiple selection
		const isShiftPressed = event.shiftKey;

		// Step 6) Try Holes (only if Holes radio is selected)
		let clickedHole = null;
		if (selectingHoles) {
			clickedHole = getClickedHole(clickX, clickY);
		}

		if (clickedHole && selectingHoles && !isMultiHoleSelectionEnabled) {
			// Single hole selection
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			} else {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			}
		}

		// Step 7) Multiple holes (only if Holes radio is selected)
		let multipleClickedHoles = selectingHoles ? getMultipleClickedHoles(clickX, clickY) : [];
		if (selectingHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles];
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedMultipleKADObjects = []; // Clear multiple KAD selection
		}

		// Step 8) Try KAD objects (only if KAD radio is selected)
		let clickedKADObject = null;
		if (selectingKAD) {
			clickedKADObject = getClickedKADObject(clickX, clickY);

			if (clickedKADObject) {
				// Allow multiple selection for ALL entity types, not just poly
				if (isShiftPressed) {
					if (developerModeEnabled) {
						console.log("Shift pressed - multiple selection mode for", clickedKADObject.entityType);
					}

					// Multiple selection mode with Shift key
					const existingIndex = selectedMultipleKADObjects.findIndex(function (obj) {
						return obj.entityName === clickedKADObject.entityName && obj.entityType === clickedKADObject.entityType;
					});

					if (existingIndex === -1) {
						// Add to multiple selection
						selectedMultipleKADObjects.push(clickedKADObject);
					} else {
						// Remove from multiple selection
						selectedMultipleKADObjects.splice(existingIndex, 1);
					}

					// Clear single selection when using multiple
					selectedKADObject = null;
					selectedKADPolygon = null;
				} else {
					// Single selection - clear multiple selection
					selectedKADObject = clickedKADObject;
					selectedKADPolygon = clickedKADObject; // Maintain backward compatibility
					selectedMultipleKADObjects = [];

					const entity = getEntityFromKADObject(selectedKADObject);
					const hasMultipleElements = entity && entity.data.length > 1;
					selectedPoint = entity.data[clickedKADObject.elementIndex];
				}

				// Clear hole selections when KAD object is selected
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// Step 9) Nothing was clicked - clear all selections if not shift clicking
		if (!isShiftPressed && !clickedHole && !multipleClickedHoles.length && !clickedKADObject) {
			if (selectingKAD) {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = [];
				selectedPoint = null;
			}
			if (selectingHoles) {
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// Consolidated status update (moved from inside if blocks)
		let statusMsg = "";
		if (selectedMultipleHoles.length > 0) {
			statusMsg += selectedMultipleHoles.length + " hole(s) selected";
			console.log("Selected Multiple Holes:", selectedMultipleHoles);
		} else if (selectedHole) {
			statusMsg += "1 hole selected";
		}
		if (selectedMultipleKADObjects.length > 0) {
			if (statusMsg) statusMsg += ", ";
			statusMsg += selectedMultipleKADObjects.length + " KAD object(s) selected";
			console.log("Selected Multiple KAD Objects:", selectedMultipleKADObjects);
		} else if (selectedKADObject) {
			if (statusMsg) statusMsg += ", ";
			statusMsg += "1 KAD object selected";
		}
		if (!statusMsg) {
			statusMsg = "No objects selected";
		}
		updateStatusMessage(statusMsg);

		// Highlight corresponding tree nodes
		if (treeView) {
			const nodeIds = [];
			(selectedMultipleHoles.length > 0 ? selectedMultipleHoles : selectedHole ? [selectedHole] : []).forEach((hole) => {
				nodeIds.push("hole⣿" + hole.holeID);
			});
			(selectedMultipleKADObjects.length > 0 ? selectedMultipleKADObjects : selectedKADObject ? [selectedKADObject] : []).forEach((kad) => {
				nodeIds.push(kad.entityType + "⣿" + kad.entityName);
			});
			treeView.highlightNodes(nodeIds);
		}

		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("Selection pointer NOT active - exiting");
	}
}

function completePolygonSelection() {
	if (!isPolygonSelectionActive || polyPointsX.length < 3) return;

	// Step 1) Remove the last moving point
	polyPointsX.pop();
	polyPointsY.pop();

	// Step 2) Clear previous selections
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	selectedHole = null; // Clear single hole selection

	// Step 3) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	// Step 4) Mutually exclusive selection logic
	if (selectingHoles) {
		// Only select holes
		allBlastHoles.forEach((hole) => {
			if (isHoleVisible(hole) && isPointInPolygon(hole.startXLocation, hole.startYLocation, polyPointsX, polyPointsY)) {
				selectedMultipleHoles.push(hole);
			}
		});
	} else if (selectingKAD) {
		// Only select KAD objects
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			if (!isEntityVisible(entityName)) continue;

			let isInsideSelection = false;

			// For all entity types, check if any point is inside the selection polygon
			for (const point of entity.data) {
				if (isPointInPolygon(point.pointXLocation, point.pointYLocation, polyPointsX, polyPointsY)) {
					isInsideSelection = true;
					break;
				}
			}

			// Additional check: if any segment intersects the selection polygon boundary
			if (!isInsideSelection && entity.data.length >= 2) {
				let numPoints = entity.data.length;
				let isClosed = entity.entityType === "poly";

				for (let i = 0; i < (isClosed ? numPoints : numPoints - 1); i++) {
					const p1x = entity.data[i].pointXLocation;
					const p1y = entity.data[i].pointYLocation;
					const p2x = entity.data[(i + 1) % numPoints].pointXLocation;
					const p2y = entity.data[(i + 1) % numPoints].pointYLocation;

					for (let j = 0; j < polyPointsX.length; j++) {
						const q1x = polyPointsX[j];
						const q1y = polyPointsY[j];
						const q2x = polyPointsX[(j + 1) % polyPointsX.length];
						const q2y = polyPointsY[(j + 1) % polyPointsY.length];

						if (lineSegmentsIntersect(p1x, p1y, p2x, p2y, q1x, q1y, q2x, q2y)) {
							isInsideSelection = true;
							break;
						}
					}
					if (isInsideSelection) break;
				}
			}

			if (isInsideSelection) {
				// Create object in same format as shift-click selection
				const kadObject = {
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: 0, // Default to first element
					selectionType: "entity" // Mark as full entity selection
				};

				// Add specific properties based on entity type
				if (entity.entityType === "circle" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.radius = entity.data[0].radius;
				} else if (entity.entityType === "text" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.text = entity.data[0].text;
				} else if (entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
				}

				selectedMultipleKADObjects.push(kadObject);
			}
		}
	}

	// Step 5) Update status message
	let statusMsg = "";
	if (selectedMultipleHoles.length > 0) {
		statusMsg += selectedMultipleHoles.length + " hole(s) selected";
	}
	if (selectedMultipleKADObjects.length > 0) {
		if (statusMsg) statusMsg += ", ";
		statusMsg += selectedMultipleKADObjects.length + " KAD object(s) selected";
	}
	if (!statusMsg) {
		statusMsg = "No objects found in selection area";
	}
	updateStatusMessage(statusMsg);

	// Step 6) Enable multi-selection mode if we have selections
	if (selectedMultipleHoles.length > 0) {
		isMultiHoleSelectionEnabled = true;
	}

	// Step 7) Clear polygon selection points
	polyPointsX = [];
	polyPointsY = [];

	// Step 8) Update visual display and tree view
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();

	// Step 9) Highlight selected nodes in tree view using existing system
	if (treeView) {
		const nodeIds = [];

		// Add selected holes to node IDs
		if (selectedMultipleHoles.length > 0) {
			selectedMultipleHoles.forEach((hole) => {
				nodeIds.push("hole⣿" + hole.holeID);
			});
		}

		// Add selected KAD objects to node IDs
		if (selectedMultipleKADObjects.length > 0) {
			selectedMultipleKADObjects.forEach((kad) => {
				nodeIds.push(kad.entityType + "⣿" + kad.entityName);
			});
		}

		// Highlight all selected nodes at once
		treeView.highlightNodes(nodeIds);
	}
}
function handleHoleEditingSelection(event) {
	if (isHoleEditing || selectPointerTool.checked) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

function recalculateContours(allBlastHoles, deltaX, deltaY) {
	// Only recalculate if contours or direction arrows are being displayed
	if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
		return {
			contourLinesArray: [],
			directionArrows: []
		};
	}

	try {
		const contourData = [];
		holeTimes = calculateTimes(allBlastHoles);
		timeChart();

		// Prepare contour data
		for (let i = 0; i < holeTimes.length; i++) {
			const [entityName, holeID] = holeTimes[i][0].split(":::");
			const time = holeTimes[i][1];

			const hole = allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);

			if (hole) {
				contourData.push({
					x: hole.startXLocation,
					y: hole.startYLocation,
					z: time
				});
			}
		}

		if (contourData.length === 0) {
			throw new Error("No valid contour data holes found.");
		}

		const maxHoleTime = Math.max(...contourData.map((hole) => hole.z));

		// Calculate contour lines and store them in contourLinesArray
		contourLinesArray = [];
		directionArrows = [];
		let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
		interval = parseInt(intervalAmount);

		// Iterate over contour levels
		for (let contourLevel = 0; contourLevel <= maxHoleTime; contourLevel += interval) {
			const { contourLines, directionArrows } = delaunayContours(contourData, contourLevel, maxEdgeLength);
			const epsilon = 1; // Adjust this value to control the level of simplification
			const simplifiedContourLines = contourLines.map((line) => simplifyLine(line, epsilon));
			contourLinesArray.push(simplifiedContourLines);

			//console.log("contourLinesArray: ", contourLinesArray);
			//console.log("directionArrows: ", directionArrows);
		}
		// Return both contour lines
		return {
			contourLinesArray,
			directionArrows
		};
	} catch (err) {
		console.error(err);
	}
}

function calculateHoleGeometry(clickedHole, newValue, modeLAB) {
	const index = allBlastHoles.findIndex((hole) => hole.holeID === clickedHole.holeID && hole.entityName === clickedHole.entityName);
	if (index === -1) {
		return; // Hole not found
	}

	// Work directly on the original hole object instead of creating a copy
	let hole = allBlastHoles[index];

	// Destructure for easier access
	let { startXLocation: startX, startYLocation: startY, startZLocation: startZ, holeAngle, holeBearing, benchHeight, subdrillAmount } = hole;

	const radBearing = ((450 - holeBearing) % 360) * (Math.PI / 180);

	if (modeLAB === 1) {
		// Length
		const newLength = parseFloat(newValue);
		hole.holeLengthCalculated = newLength;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			const subdrillLength = subdrillAmount / cosAngle;
			const newBenchDrillLength = newLength - subdrillLength;
			hole.benchHeight = newBenchDrillLength * cosAngle;
		}

		// Recalculate everything based on the new length
		const newTotalVerticalDrop = newLength * cosAngle;
		hole.endZLocation = startZ - newTotalVerticalDrop;
		const horizontalProjection = newLength * sinAngle;
		hole.endXLocation = startX + horizontalProjection * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjection * Math.sin(radBearing);

		hole.gradeZLocation = startZ - hole.benchHeight;
		const benchDrillLength = hole.benchHeight / (Math.abs(cosAngle) > 1e-9 ? cosAngle : 1);
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);
	} else if (modeLAB === 2) {
		// Angle
		const newAngle = parseFloat(newValue);
		hole.holeAngle = newAngle;
		const radAngle = newAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + subdrillAmount) / cosAngle;
		} // For horizontal holes, length is independent

		hole.gradeZLocation = startZ - benchHeight;
		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0; // No bench drop for horizontal
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 3) {
		// Bearing
		const newBearing = parseFloat(newValue);
		hole.holeBearing = newBearing;
		const newRadBearing = ((450 - newBearing) % 360) * (Math.PI / 180);
		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(newRadBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(newRadBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(newRadBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(newRadBearing);

		// FIX: Add the missing endZLocation calculation
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 4) {
		// Easting (X) - Simple delta shift
		const deltaX = newValue - hole.startXLocation;
		hole.startXLocation = newValue;
		hole.gradeXLocation += deltaX;
		hole.endXLocation += deltaX;
	} else if (modeLAB === 5) {
		// Northing (Y) - Simple delta shift
		const deltaY = newValue - hole.startYLocation;
		hole.startYLocation = newValue;
		hole.gradeYLocation += deltaY;
		hole.endYLocation += deltaY;
	} else if (modeLAB === 6) {
		// Elevation (Z)
		const deltaZ = newValue - hole.startZLocation;
		hole.startZLocation = newValue;
		hole.gradeZLocation += deltaZ;
		hole.endZLocation += deltaZ;
	} else if (modeLAB === 7) {
		// Diameter
		hole.holeDiameter = newValue;
	} else if (modeLAB === 8) {
		// Subdrill Amount
		const newSubdrillAmount = parseFloat(newValue);

		if (isNaN(newSubdrillAmount)) {
			console.warn("Invalid subdrill amount:", newValue);
			return;
		}
		hole.subdrillAmount = newSubdrillAmount;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + newSubdrillAmount) / cosAngle;
		}

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	}
	debouncedUpdateTreeView(); // Use debounced version
	// No need to reassign allBlastHoles[index] since we're working on the original object
}

function timeChart() {
	const chart = document.getElementById("timeChart");
	// If no holeTimes data, create a blank chart instead of returning
	if (!Array.isArray(holeTimes) || holeTimes.length === 0) {
		const layout = {
			title: {
				text: "Time Window Chart - No Data",
				xanchor: "right",
				font: {
					size: 10
				}
			},
			plot_bgcolor: noneColor,
			paper_bgcolor: noneColor,
			font: {
				color: textFillColor
			},
			modebar: {
				orientation: "v",
				bgcolor: noneColor,
				color: "rgba(255, 0, 0, 0.4)",
				activecolor: "red",
				position: "left"
			},
			margin: {
				l: 5,
				r: 50,
				b: 25,
				t: 25,
				pad: 2
			},
			xaxis: {
				title: {
					text: "milliseconds (ms)",
					font: {
						size: 10
					}
				},
				showgrid: true,
				range: [0, 100]
			},
			yaxis: {
				title: {
					text: "Holes Firing",
					font: {
						size: 10
					}
				},
				showgrid: true,
				range: [0, 10]
			},
			height: 380,
			width: chart.offsetWidth - 50,
			annotations: [
				{
					text: "Load holes and connect them to see timing data",
					xref: "paper",
					yref: "paper",
					x: 0.5,
					y: 0.5,
					xanchor: "center",
					yanchor: "middle",
					showarrow: false,
					font: {
						size: 12,
						color: textFillColor
					}
				}
			]
		};

		Plotly.react("timeChart", [], layout, {
			responsive: true,
			displayModeBar: true,
			modeBarButtonsToRemove: ["lasso2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
			modeBarButtons: [["select2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]]
		});

		return; // Exit early after creating blank chart
	}

	const times = holeTimes.map((time) => time[1]);
	const maxTime = Math.max(...times);
	const timeRange = parseInt(document.getElementById("timeRange").value);
	const timeOffset = parseInt(document.getElementById("timeOffset").value);
	const numBins = Math.ceil(maxTime / timeRange);
	const binStart = -timeOffset;

	const measuredMassRadio = document.getElementById("measuredMassRadio");
	const holeCountRadio = document.getElementById("holeCountRadio");
	let useMass;
	useMass = useMass ? holeCountRadio?.checked : measuredMassRadio?.checked || false;

	let counts = Array(numBins).fill(0);
	let massSum = Array(numBins).fill(0);
	let validMassCount = 0;

	for (let hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			counts[binIndex]++;
			const mass = Number(hole.measuredMass);
			if (useMass && !isNaN(mass) && isFinite(mass)) {
				massSum[binIndex] += mass;
				validMassCount++;
			}
		}
	}

	const fallbackToCount = useMass && validMassCount < 2;
	const yValues = useMass && !fallbackToCount ? massSum : counts;

	const binEdges = Array(numBins)
		.fill(0)
		.map((_, index) => index * timeRange + binStart);

	const binCenters = binEdges.map((edge) => edge + timeRange / 2);
	const xTickInterval = Math.ceil(numBins / 10); // label ~5 ticks
	const tickvals = binCenters.filter((_, i) => i % xTickInterval === 0);
	const ticktext = tickvals.map((center) => center - timeRange / 2 + "–" + (center + timeRange / 2));

	const holeIDs = Array(numBins).fill(null);

	for (const hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			holeIDs[binIndex] = holeIDs[binIndex] || [];
			holeIDs[binIndex].push(hole.entityName + ":" + hole.holeID);
		}
	}

	const entityholeIDTexts = holeIDs.map((bin) => {
		if (!bin) return "";
		return bin
			.map((combinedID) => {
				const [entityName, holeID] = combinedID.split(":");
				const hole = allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
				return hole ? hole.entityName + ":" + hole.holeID : "";
			})
			.filter(Boolean)
			.join(", ");
	});

	const hoverText = entityholeIDTexts.map((text, index) => {
		const totalMass = useMass && !fallbackToCount && massSum[index] ? massSum[index].toFixed(1) + " kg" : "";
		return totalMass ? text + "<br>Mass: " + totalMass : text;
	});

	const defaultColor = Array(numBins).fill("red");

	const currentLayout = chart?._fullLayout;
	const newYLabel = useMass && !fallbackToCount ? "Total Measured Mass (kg)" : "Holes Firing";
	const currentYLabel = currentLayout?.yaxis?.title?.text;
	const preserveYRange = currentYLabel === newYLabel;

	const maxYValue = Math.max(...yValues) + 1;

	const layout = {
		title: {
			text: "Time Window Chart",
			xanchor: "right",
			font: {
				size: 10
			}
		},
		plot_bgcolor: noneColor,
		paper_bgcolor: noneColor,
		font: {
			color: textFillColor
		},
		modebar: {
			orientation: "v",
			bgcolor: noneColor,
			color: "rgba(255, 0, 0, 0.4)",
			activecolor: "red",
			position: "left"
		},
		margin: {
			l: 5,
			r: 50,
			b: 25,
			t: 25,
			pad: 2
		},
		xaxis: {
			title: {
				text: "milliseconds (ms)",
				font: {
					size: 10
				}
			},
			showgrid: true,
			rangeslider: {
				visible: true,
				thickness: 0.1
			},
			tickvals: "auto", //tickvals, // if you want bin ranges
			ticktext: "~s" //ticktext, //if you want bin ranges
		},
		yaxis: {
			title: {
				text: newYLabel,
				font: {
					size: 10
				}
			},
			showgrid: true,
			automargin: true,
			range: preserveYRange && currentLayout ? [...currentLayout.yaxis.range] : [0, maxYValue - 0.5]
		},
		height: 380,
		width: chart.offsetWidth - 50 // ✅ dynamic width based on container,
	};

	const data = [
		{
			x: binCenters,
			y: yValues,
			type: "bar",
			width: timeRange, // 🔧 match bin width
			marker: {
				color: defaultColor
			},
			text: hoverText,
			textposition: "none", // ✅ disables labels drawn on bars
			//hoverinfo: "text+y",
			hovertemplate: "Bin: %{x} ms<br>" + (useMass && !fallbackToCount ? "Mass" : "Value") + ": %{y}<extra></extra>"
		}
	];

	Plotly.react("timeChart", data, layout, {
		responsive: true,
		displayModeBar: true,
		modeBarButtonsToRemove: ["lasso2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
		modeBarButtons: [["select2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]]
	});

	// ✅ Clear previously registered listeners
	chart.removeAllListeners?.("plotly_selected");
	chart.removeAllListeners?.("plotly_click");
	chart.removeAllListeners?.("plotly_deselect");

	let lastClickedIndex = null;

	chart.on("plotly_selected", function (eventData) {
		const selectedHoles = eventData?.points?.map((p) => p.pointNumber) || [];
		const newColors = defaultColor.map((color, index) => (selectedHoles.includes(index) ? "lime" : color));
		Plotly.restyle("timeChart", {
			"marker.color": [newColors]
		});

		timingWindowHolesSelected = selectedHoles
			.flatMap((index) => {
				return holeIDs[index]
					? holeIDs[index].map((combinedID) => {
							const [entityName, holeID] = combinedID.split(":");
							return allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
					  })
					: [];
			})
			.filter(Boolean);

		drawData(allBlastHoles, selectedHole);
	});

	chart.on("plotly_click", function (data) {
		const clickedIndex = data.points?.[0]?.pointIndex;
		if (clickedIndex == null) return;

		const currentColors = data.points[0].data.marker.color.slice();
		if (lastClickedIndex !== null) currentColors[lastClickedIndex] = "red";
		currentColors[clickedIndex] = "lime";

		Plotly.restyle("timeChart", {
			"marker.color": [currentColors]
		});
		lastClickedIndex = clickedIndex;

		timingWindowHolesSelected = holeIDs[clickedIndex]
			? holeIDs[clickedIndex]
					.map((combinedID) => {
						const [entityName, holeID] = combinedID.split(":");
						return allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
					})
					.filter(Boolean)
			: [];

		drawData(allBlastHoles, selectedHole);
	});

	chart.on("plotly_deselect", function () {
		Plotly.restyle("timeChart", {
			"marker.color": [defaultColor]
		});
		timingWindowHolesSelected = [];
		lastClickedIndex = null;
		drawData(allBlastHoles, selectedHole);
	});
}

// Log Helper Functions for the play slider
function playSpeedLogScale(sliderValue) {
	if (sliderValue <= 50) {
		// First half: 0.01 to 1.0
		const normalizedValue = sliderValue / 50;
		const minLog = Math.log10(0.01);
		const maxLog = Math.log10(1.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	} else {
		// Second half: 1.0 to 10.0
		const normalizedValue = (sliderValue - 50) / 50;
		const minLog = Math.log10(1.0);
		const maxLog = Math.log10(10.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	}
}

function updatePlaySpeed() {
	const playSpeedInput = document.getElementById("playSpeed");
	const sliderValue = parseFloat(playSpeedInput.value);

	// Use logarithmic scaling instead of direct value
	playSpeed = playSpeedLogScale(sliderValue);

	// Update button text with actual speed
	const playButton = document.getElementById("play");
	playButton.textContent = "PLAY @ " + playSpeed.toFixed(3) + "x";
}

// Optional: Add visual markers to show the scale divisions
function addPlaySpeedMarkers() {
	const slider = document.getElementById("playSpeed");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.01x</span><span>1x</span><span>10x</span>";

	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}

// Add click event listener to the "Play" button
const playButton = document.getElementById("play");

playButton.addEventListener("click", () => {
	//refreshPoints();
	updatePlaySpeed(); // Update play speed
	/* const maxTime = Math.max(...holeTimes.map((time) => time[1])); // Get the max time */
	// Safer maxTime calculation
	let maxTime = 0;
	if (holeTimes && holeTimes.length > 0) {
		const times = holeTimes.map((time) => time[1]).filter((t) => !isNaN(t) && isFinite(t));
		maxTime = times.length > 0 ? Math.max(...times) : 0;
	}
	console.log("5. Calculated maxTime:", maxTime);
	console.log("6. After maxTime calc, slider value:", playSpeedInput.value);

	isPlaying = true;
	console.log("7. After setting isPlaying, slider value:", playSpeedInput.value);

	clearInterval(animationInterval);
	console.log("8. After clearInterval, slider value:", playSpeedInput.value);

	updatePlaySpeed();
	console.log("9. After updatePlaySpeed, slider value:", playSpeedInput.value);

	isPlaying = true;
	// Clear previous animation interval before starting a new one
	clearInterval(animationInterval);

	let currentTime = 0;
	let lastFrameTime = performance.now(); // Track real-world time
	const frameRate = 60; // 60 FPS
	const frameInterval = 1000 / frameRate; // ~16.67ms per frame

	/* play.textContent = "Playing at " + parseFloat(playSpeed).toFixed(3) + "x speed"; */

	// Start the animation loop at 60fps
	animationInterval = setInterval(() => {
		const now = performance.now();
		const realTimeElapsed = now - lastFrameTime; // Real milliseconds elapsed
		const blastTimeToAdvance = realTimeElapsed * playSpeed; // Scale by playSpeed

		currentTime += blastTimeToAdvance;
		lastFrameTime = now;

		if (currentTime <= maxTime + playSpeed * 100) {
			// Give some buffer at the end
			timingWindowHolesSelected = allBlastHoles.filter((hole) => hole.holeTime <= currentTime);
			drawData(allBlastHoles, timingWindowHolesSelected);
		} else {
			stopButton.click();
			clearInterval(animationInterval);
		}
	}, frameInterval); // Run at consistent 60fps
});

// Add click event listener to the "Stop" button
const stopButton = document.getElementById("stop");
stopButton.addEventListener("click", () => {
	clearInterval(animationInterval); // Stop the ongoing animation
	isPlaying = false;
	timingWindowHolesSelected = []; // Reset the selected holes array
	//drawData(points, timingWindowHolesSelected); // Call drawPoints to reset the highlights
});

// Add input event listener to the playSpeed input range
const playSpeedInput = document.getElementById("playSpeed");
playSpeedInput.addEventListener("input", updatePlaySpeed);

function drawLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function
	//the legend should display the roundedAngleDip Ranges and there colors
	const legend0to5 = "rgb(51, 139, 255)";
	const legend5to7 = "rgb(0, 102, 204)";
	const legend7to9 = "rgb(0, 204, 204)";
	const legend9to12 = "rgb(102, 204, 0)";
	const legend12to15 = "rgb(204, 204, 0)";
	const legend15to17 = "rgb(255, 128, 0)";
	const legend17to20 = "rgb(255, 0, 0)";
	const legend20above = "rgb(153, 0, 76)";
	//draw the legend
	ctx.beginPath();
	ctx.fill();
	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Slope", 10, canvas.height / 2 - 70);
	ctx.fillText("0\u00B0-5\u00B0", 10, canvas.height / 2 - 40);
	ctx.fillText("5\u00B0-7\u00B0", 10, canvas.height / 2 - 10);
	ctx.fillText("7\u00B0-9\u00B0", 10, canvas.height / 2 + 20);
	ctx.fillText("9\u00B0-12\u00B0", 10, canvas.height / 2 + 50);
	ctx.fillText("12\u00B0-15\u00B0", 10, canvas.height / 2 + 80);
	ctx.fillText("15\u00B0-17\u00B0", 10, canvas.height / 2 + 110);
	ctx.fillText("17\u00B0-20\u00B0", 10, canvas.height / 2 + 140);
	ctx.fillText("20\u00B0+", 10, canvas.height / 2 + 170);
	ctx.fillStyle = legend0to5;
	ctx.fillRect(60, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend5to7;
	ctx.fillRect(60, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to9;
	ctx.fillRect(60, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend9to12;
	ctx.fillRect(60, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend12to15;
	ctx.fillRect(60, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend15to17;
	ctx.fillRect(60, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend17to20;
	ctx.fillRect(60, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend20above;
	ctx.fillRect(60, canvas.height / 2 + 155, 20, 20);
	ctx.stroke();
}

function worldToCanvas(x, y) {
	return [(x - centroidX) * currentScale + canvas.width / 2, (-y + centroidY) * currentScale + canvas.height / 2];
}

// Helper to fetch display options once
function getDisplayOptions() {
	return {
		holeID: document.getElementById("display1").checked,
		holeLen: document.getElementById("display2").checked,
		holeDia: document.getElementById("display2A").checked,
		holeAng: document.getElementById("display3").checked,
		holeDip: document.getElementById("display4").checked,
		holeBea: document.getElementById("display5").checked,
		holeSubdrill: document.getElementById("display5B").checked,
		connector: document.getElementById("display5A").checked,
		delayValue: document.getElementById("display6").checked,
		initiationTime: document.getElementById("display6A").checked,
		contour: document.getElementById("display8").checked,
		slopeMap: document.getElementById("display8A").checked,
		burdenRelief: document.getElementById("display8B").checked,
		firstMovement: document.getElementById("display8C").checked,
		xValue: document.getElementById("display9").checked,
		yValue: document.getElementById("display10").checked,
		zValue: document.getElementById("display11").checked,
		holeType: document.getElementById("display12").checked,
		measuredLength: document.getElementById("display13").checked,
		measuredMass: document.getElementById("display14").checked,
		measuredComment: document.getElementById("display15").checked,
		voronoiPF: document.getElementById("display16").checked,
		displayRowAndPosId: document.getElementById("rowAndPosDisplay").checked
	};
}

// Build hole map for quick lookup by entityName and holeID
function buildHoleMap(allBlastHoles) {
	const map = new Map();
	if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
		for (const pt of allBlastHoles) {
			map.set(pt.entityName + ":::" + pt.holeID, pt);
		}
	}
	return map;
}

let drawMouseLines = true; //used to debug mouse location

function drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, showSnapRadius = true, showMouseLines = true) {
	//draw a vertical lin the height of the canvas at the mouse x location and draw a line the width of the canvas at the y location of the mouse. it should be color grey at 50% opacity
	if (showMouseLines) {
		ctx.lineWidth = 0.5;
		ctx.beginPath();
		ctx.moveTo(mouseX, 0);
		ctx.lineTo(mouseX, canvas.height);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
		ctx.beginPath();
		ctx.moveTo(0, mouseY);
		ctx.lineTo(canvas.width, mouseY);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
	if (showSnapRadius && snapRadiusPixels > 0) {
		// Draw the snapping radius circle
		ctx.beginPath();
		ctx.arc(mouseX, mouseY, snapRadiusPixels, 0, 2 * Math.PI);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
}

// Main draw function
function drawData(allBlastHoles, selectedHole) {
	if (canvas) {
		// For UI version 2, this is ESSENTIAL.
		// For UI version 1, it adds robustness if its display size could ever change.
		if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
		}
	}

	if (ctx) {
		clearCanvas();
		ctx.imageSmoothingEnabled = false;

		const displayOptions = getDisplayOptions();
		let holeMap = new Map();
		if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			holeMap = buildHoleMap(allBlastHoles);
		}

		// Draw background images FIRST (bottom layer)
		drawBackgroundImage();

		// Draw surfaces SECOND
		drawSurface();

		// Highlight single selected point if needed
		if (selectedPoint !== null) {
			const [x, y] = worldToCanvas(selectedPoint.pointXLocation, selectedPoint.pointYLocation);
			drawHiHole(x, y, 10, "rgba(255, 102, 255, 0.3)", "rgba(255, 0, 255, 0.6)");
		}

		// In drawData function, replace the drawing logic with hierarchical visibility:
		if (drawingsGroupVisible) {
			// ✅ ADD: Check overall drawings group visibility
			for (const [name, entity] of allKADDrawingsMap.entries()) {
				// ✅ Check entity visibility
				if (entity.visible === false) continue;

				// ✅ ADD: Check sub-group visibility based on entity type
				let subGroupVisible = true;
				switch (entity.entityType) {
					case "point":
						subGroupVisible = pointsGroupVisible;
						break;
					case "line":
						subGroupVisible = linesGroupVisible;
						break;
					case "poly":
						subGroupVisible = polygonsGroupVisible;
						break;
					case "circle":
						subGroupVisible = circlesGroupVisible;
						break;
					case "text":
						subGroupVisible = textsGroupVisible;
						break;
				}

				if (!subGroupVisible) continue; // ✅ Skip if sub-group is hidden

				if (developerModeEnabled && entity.entityType === "point") {
					entity.data.forEach((point) => {
						// ✅ Check individual element visibility
						if (point.visible === false) return;
						const screenX = (point.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(point.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						let lineWidthForDisplay = point.lineWidth;
						if (point.lineWidth < 2) {
							lineWidthForDisplay = 2;
						}
						drawKADPoints(screenX, screenY, point.pointZLocation, lineWidthForDisplay, point.color);
						drawKADCoordinates(point, screenX, screenY);
					});
				} else if (entity.entityType === "point") {
					// Apply pixel distance simplification to points for performance
					const originalPoints = entity.data.filter((point) => point.visible !== false);
					const simplifiedPoints = simplifyByPxDist(originalPoints, 3);

					for (const pointData of simplifiedPoints) {
						let lineWidthForDisplay = pointData.lineWidth;
						if (pointData.lineWidth < 2) {
							lineWidthForDisplay = 2;
						}
						const [x, y] = worldToCanvas(pointData.pointXLocation, pointData.pointYLocation);
						drawKADPoints(x, y, pointData.pointZLocation, lineWidthForDisplay, pointData.color);
						drawKADCoordinates(pointData, x, y);
					}
				} else if (entity.entityType === "circle") {
					// ✅ FIXED: Move visibility check inside forEach loop
					entity.data.forEach((circle) => {
						if (circle.visible === false) return; // ✅ Check individual element visibility
						const screenX = (circle.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(circle.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						drawKADCircles(screenX, screenY, circle.pointZLocation, circle.radius, circle.lineWidth, circle.color);
						drawKADCoordinates(circle, screenX, screenY);
					});
				} else if (entity.entityType === "text") {
					entity.data.forEach((textData) => {
						if (textData.visible === false) return; // ✅ Check individual element visibility
						if (textData && textData.text) {
							const screenX = (textData.pointXLocation - centroidX) * currentScale + canvas.width / 2;
							const screenY = -(textData.pointYLocation - centroidY) * currentScale + canvas.height / 2;
							drawKADTexts(screenX, screenY, textData.pointZLocation, textData.text, textData.color);
							drawKADCoordinates(textData, screenX, screenY);
						}
					});
				} else if (developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// ✅ FIXED: Filter visible points first, then use filtered data
					const visiblePoints = entity.data.filter((point) => point.visible !== false);
					if (visiblePoints.length < 2) continue;

					// Draw all segments without any simplification
					for (let i = 0; i < visiblePoints.length - 1; i++) {
						const currentPoint = visiblePoints[i];
						const nextPoint = visiblePoints[i + 1];

						const [sx, sy] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						const [ex, ey] = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);

						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, currentPoint.lineWidth, currentPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === visiblePoints[visiblePoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					const isClosed = entity.entityType === "poly";
					if (isClosed && visiblePoints.length > 2) {
						const firstPoint = visiblePoints[0];
						const lastPoint = visiblePoints[visiblePoints.length - 1];
						const [sx, sy] = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						const [ex, ey] = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);

						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, lastPoint.lineWidth, lastPoint.color, false);

						// drawKADCoordinates(lastPoint, ex, ey);
					}
				} else if (!developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// --- Pixel-distance simplification for performance ---
					const originalPoints = entity.data.filter((point) => point.visible !== false);
					if (originalPoints.length < 2) continue;

					// Simplify by pixel distance
					let pointThreshold = 2;
					if (currentScale > 1) {
						pointThreshold = 2;
					} else {
						pointThreshold = 1;
					}

					const simplifiedPoints = simplifyByPxDist(originalPoints, pointThreshold);

					// Draw the simplified line/polygon
					for (let i = 0; i < simplifiedPoints.length - 1; i++) {
						const currentPoint = simplifiedPoints[i];
						const nextPoint = simplifiedPoints[i + 1];

						const [sx, sy] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						const [ex, ey] = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);

						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, currentPoint.lineWidth, currentPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === simplifiedPoints[simplifiedPoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					const isClosed = entity.entityType === "poly";
					if (isClosed && simplifiedPoints.length > 2) {
						const firstPoint = simplifiedPoints[0];
						const lastPoint = simplifiedPoints[simplifiedPoints.length - 1];
						const [sx, sy] = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						const [ex, ey] = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);

						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, lastPoint.lineWidth, lastPoint.color, false);
					}
				}
			}
		}

		// Voronoi Powder Factor
		if (displayOptions.voronoiPF) {
			// VORONOI PF & OVERLAYS
			const tri = delaunayTriangles(allBlastHoles, maxEdgeLength);
			const blastBoundaryPolygon = createBlastBoundaryPolygon(tri.resultTriangles);
			const offsetBoundaryPolygon = offsetPolygonClipper(blastBoundaryPolygon, getAverageDistance(allBlastHoles) / 2);
			// console.log("DEBUG: VORONOI PF");
			switch (selectedVoronoiMetric) {
				case "powderFactor":
					// console.log("Drawing Powder Factor");
					//get the min and max values for the PF if isVoronoiLegendFixed is false
					let minPF, maxPF, intervalPF, deltaPF;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI PF NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.powderFactor).filter((v) => v != null && !isNaN(v));
						minPF = 0; //values.length > 0 ? Math.min(...values) : 0;
						maxPF = values.length > 0 ? Math.max(...values) : 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF / 4;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI PF FIXED");
						minPF = 0;
						maxPF = 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF > 0 ? Math.ceil(deltaPF / 10) : 0.5;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getPFColor(value, minPF, maxPF), "Legend Powder Factor", minPF, maxPF, intervalPF);
					break;
				case "mass":
					// console.log("Drawing Mass");
					let minMass, maxMass, intervalMass, deltaMass;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI MASS NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.mass).filter((v) => v != null && !isNaN(v));
						minMass = values.length > 0 ? Math.min(...values) : 0;
						maxMass = values.length > 0 ? Math.max(...values) : 500;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass / 4;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI MASS FIXED");
						minMass = 0;
						maxMass = 1000;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass > 0 ? Math.ceil(deltaMass / 10) : 250;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getMassColor(value, minMass, maxMass), "Legend Mass", minMass, maxMass, intervalMass);
					break;
				case "volume": {
					// console.log("Drawing Volume");
					let minVol, maxVol, intervalVol, deltaVol;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.volume).filter((v) => v != null && !isNaN(v));
						minVol = values.length > 0 ? Math.min(...values) : 0;
						maxVol = values.length > 0 ? Math.max(...values) : 100;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = deltaVol / 10;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					} else {
						minVol = 0;
						maxVol = 5000;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = 500;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getVolumeColor(value, minVol, maxVol), "Legend Volume", minVol, maxVol, intervalVol);
					break;
				}
				case "area": {
					// console.log("Drawing Area");
					let minArea, maxArea, intervalArea, deltaArea;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.area).filter((v) => v != null && !isNaN(v));
						minArea = values.length > 0 ? Math.min(...values) : 0;
						maxArea = values.length > 0 ? Math.max(...values) : 100;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = deltaArea / 10;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					} else {
						minArea = 0;
						maxArea = 500;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = 50;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getAreaColor(value, minArea, maxArea), "Legend Area", minArea, maxArea, intervalArea);
					break;
				}
				case "measuredLength": {
					// console.log("Drawing Measured Length");
					let minMLen, maxMLen, intervalMLen, deltaMLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.measuredLength).filter((v) => v != null && !isNaN(v));
						minMLen = values.length > 0 ? Math.min(...values) : 0;
						maxMLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = deltaMLen / 10;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					} else {
						minMLen = 0;
						maxMLen = 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = 5;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minMLen, maxMLen), "Legend Measured Length", minMLen, maxMLen, intervalMLen);
					break;
				}
				case "designedLength": {
					// console.log("Drawing Designed Length");
					let minDLen, maxDLen, intervalDLen, deltaDLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.designedLength).filter((v) => v != null && !isNaN(v));
						minDLen = values.length > 0 ? Math.min(...values) : 0;
						maxDLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = deltaDLen / 10;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					} else {
						minDLen = 0;
						maxDLen = 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = 5;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minDLen, maxDLen), "Legend Designed Length", minDLen, maxDLen, intervalDLen);
					break;
				}
				case "holeFiringTime": {
					// console.log("Drawing Hole Firing Time");
					let minHTime, maxHTime, intervalHTime, deltaHTime;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const holeTimes = clippedCells.map((c) => c.holeFiringTime).filter((t) => t != null && !isNaN(t));
						minHTime = holeTimes.length > 0 ? Math.min(...holeTimes) : 0;
						maxHTime = holeTimes.length > 0 ? Math.max(...holeTimes) : 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime / 10;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					} else {
						minHTime = 0;
						maxHTime = 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime > 0 ? Math.ceil(deltaHTime / 10) : 1000;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					}
					drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getHoleFiringTimeColor(value, minHTime, maxHTime), "Legend Hole Firing Time", minHTime, maxHTime, intervalHTime);
					break;
				}
			}
		}

		// Slope Map
		if (displayOptions.slopeMap) {
			const centroid = {
				x: centroidX,
				y: centroidY
			};
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			drawDelauanySlopeMap(resultTriangles, centroid, strokeColor);
			for (const triangle of resultTriangles) {
				drawTriangleAngleText(triangle, centroid, strokeColor);
			}
			drawLegend(strokeColor);
		}

		// Burden Relief
		if (displayOptions.burdenRelief) {
			const centroid = {
				x: centroidX,
				y: centroidY
			};
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			drawDelauanyBurdenRelief(reliefTriangles, centroid, strokeColor);
			for (const triangle of reliefTriangles) {
				drawTriangleBurdenReliefText(triangle, centroid, strokeColor);
			}
			drawReliefLegend(strokeColor);
		}

		// First Movement Direction Arrows
		if (displayOptions.firstMovement) {
			connScale = document.getElementById("connSlider").value;
			for (const arrow of directionArrows) {
				const [startX, startY] = worldToCanvas(arrow[0], arrow[1]);
				const [endX, endY] = worldToCanvas(arrow[2], arrow[3]);
				drawDirectionArrow(startX, startY, endX, endY, arrow[4], strokeColor, arrow[5]);
			}
		}

		// Main hole loop
		ctx.lineWidth = 1;
		ctx.strokeStyle = strokeColor;
		ctx.font = parseInt(currentFontSize) + "px Arial";
		if (blastGroupVisible && allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			// ✅ ADD: Check blast group visibility
			for (const hole of allBlastHoles) {
				if (hole.visible === false) continue;
				const [x, y] = worldToCanvas(hole.startXLocation, hole.startYLocation);
				const [gradeX, gradeY] = worldToCanvas(hole.gradeXLocation, hole.gradeYLocation);
				const [lineEndX, lineEndY] = worldToCanvas(hole.endXLocation, hole.endYLocation);

				toeSizeInMeters = document.getElementById("toeSlider").value;
				connScale = document.getElementById("connSlider").value;

				// Draw collar-to-toe track if angled
				if (hole.holeAngle > 0) {
					drawTrack(x, y, lineEndX, lineEndY, gradeX, gradeY, strokeColor, hole.subdrillAmount);
				}

				// Highlight selected holes for animation/time window selection
				handleHoleHighlighting(hole, x, y);

				// Draw toe if hole length is not zero
				if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
					const radiusInPixels = toeSizeInMeters * currentScale;
					drawHoleToe(lineEndX, lineEndY, transparentFillColor, strokeColor, radiusInPixels);
				}

				// Calculate text offsets
				const textOffset = parseInt((hole.holeDiameter / 1000) * holeScale * currentScale);
				const leftSideToe = parseInt(lineEndX) - textOffset;
				const rightSideToe = parseInt(lineEndX) + textOffset;
				const leftSideCollar = parseInt(x) - textOffset;
				const rightSideCollar = parseInt(x) + textOffset;
				const topSideToe = parseInt(lineEndY - textOffset);
				const middleSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize / 4));
				const bottomSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize));
				const topSideCollar = parseInt(y - textOffset);
				const middleSideCollar = parseInt(y + parseInt(currentFontSize / 2));
				const bottomSideCollar = parseInt(y + textOffset + parseInt(currentFontSize));

				// Draw text/labels based on displayOptions
				drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, {
					leftSideToe,
					rightSideToe,
					leftSideCollar,
					rightSideCollar,
					topSideToe,
					middleSideToe,
					bottomSideToe,
					topSideCollar,
					middleSideCollar,
					bottomSideCollar,
					holeMap,
					displayOptions
				});

				// Draw main hole geometry, with selection highlight logic
				drawHoleMainShape(hole, x, y, selectedHole);

				// Font slider/label only needs to be updated once, after loop
			}
		}
		// After all other drawing operations but before font updates
		if (isPolygonSelectionActive) {
			drawPolygonSelection(ctx);
		}
		// Add preview lines right after polygon selection
		drawKADPreviewLine(ctx);

		// Holes Displayed Count
		ctx.fillStyle = "red";
		ctx.font = "12px Arial";
		if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length < 1) {
			ctx.fillText("Holes Displayed: 0", 10, canvas.height - 85);
		} else {
			ctx.fillText("Holes Displayed: " + allBlastHoles.length, 10, canvas.height - 85);
		}
		// Use lastMouseX and lastMouseY if available, otherwise default to 0
		const mouseX = typeof lastMouseX !== "undefined" ? lastMouseX : 0;
		const mouseY = typeof lastMouseY !== "undefined" ? lastMouseY : 0;
		// Convert canvas (mouse) coordinates to world coordinates
		const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
		const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;
		ctx.fillText("Mouse Location: [x] " + mouseX + " [y] " + mouseY + " [scale] 1:" + currentScale.toFixed(4), 10, canvas.height - 70);
		ctx.fillText("World Location: [x] " + worldX.toFixed(2) + " [y] " + worldY.toFixed(2), 10, canvas.height - 55);
		ctx.fillStyle = "blue";
		ctx.fillText("Version Build: " + buildVersion, 10, canvas.height - 40);

		if (drawMouseLines) {
			drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, true, true);
		}

		// Draw live ruler while measuring
		if (isRulerActive && rulerStartPoint && !rulerEndPoint) {
			// Get current snap result at mouse position
			const snapResult = canvasToWorldWithSnap(mouseX, mouseY);

			// // DEBUG: Log the actual values being used
			// console.log("Live Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, rulerStartPoint.z);
			// console.log("  Mouse Point:", snapResult.worldX, snapResult.worldY, snapResult.worldZ);
			// console.log("  Snap Result:", snapResult);

			// Use the snapped coordinates
			const worldMouseX = snapResult.worldX;
			const worldMouseY = snapResult.worldY;
			const worldMouseZ = snapResult.worldZ;

			// Ensure we have valid Z values
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = worldMouseZ !== undefined && worldMouseZ !== null ? worldMouseZ : startZ;

			// console.log("  Final Z values - startZ:", startZ, "endZ:", endZ);

			// Draw the full ruler from start point to mouse position
			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, worldMouseX, worldMouseY, endZ);
		}
		// Draw active rulers (completed measurements)
		if (isRulerActive && rulerStartPoint && rulerEndPoint) {
			// Ensure Z values exist and are valid numbers
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = rulerEndPoint.z !== undefined && rulerEndPoint.z !== null ? rulerEndPoint.z : 0;

			// console.log("Completed Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, startZ);
			// console.log("  End Point:", rulerEndPoint.x, rulerEndPoint.y, endZ);

			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, rulerEndPoint.x, rulerEndPoint.y, endZ);
		}
		// Draw completed bearing measurement
		if (isRulerProtractorActive && rulerProtractorPoints.length === 3) {
			drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, rulerProtractorPoints[2].x, rulerProtractorPoints[2].y);
		}

		// Draw live bearing measurement preview
		if (isRulerProtractorActive && rulerProtractorPoints.length > 0 && rulerProtractorPoints.length < 3) {
			const worldMouseX = (mouseX - canvas.width / 2) / currentScale + centroidX;
			const worldMouseY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

			if (rulerProtractorPoints.length === 1) {
				// After first click - show line from center to mouse
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, worldMouseX, worldMouseY, rulerProtractorPoints[0].x, rulerProtractorPoints[0].y); // Same point for p3
			} else if (rulerProtractorPoints.length === 2) {
				// After second click - show both legs with live second leg
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, worldMouseX, worldMouseY);
			}
		}
		// Add this line at the end of the drawData function, just before the final closing brace
		drawPatternInPolygonVisual();
		drawPatternOnPolylineVisual();
		drawKADPolygonHighlightSelectedVisuals();
		drawHolesAlongLineVisuals();
		drawKADHighlightSelectionVisuals(); // ADD THIS AS THE VERY LAST LINE:
		// drawAllKADSelectionVisuals(); // this function doesn't get used...
		drawSurfaceLegend();
		drawMultilineText(ctx, statusMessage, canvas.width / 2, 16, 16, "center", strokeColor, strokeColor, true);
		// Update font slider and label after loop (once)
		fontSlider.value = currentFontSize;
		fontLabel.textContent = "Font Size: " + parseFloat(currentFontSize).toFixed(1) + "px";
		if (printMode) {
			drawPrintBoundary(ctx);
		}
	} else {
		// Handle missing context
		return;
	}
}

function drawKADCoordinates(kadPoint, screenX, screenY) {
	const displayOptions = getDisplayOptions();

	// Calculate text offset based on current scale and font size
	const textOffset = Math.max(10, parseInt(currentFontSize * 0.5));
	const leftSide = parseInt(screenX) - textOffset;
	const rightSide = parseInt(screenX) + textOffset;
	const topSide = parseInt(screenY - textOffset);
	const middleSide = parseInt(screenY + parseInt(currentFontSize / 2));
	const bottomSide = parseInt(screenY + textOffset + parseInt(currentFontSize));

	// Set font for coordinate display
	ctx.font = parseInt(currentFontSize * 0.5) + "px Arial";

	// Display X coordinate (right side, top)
	if (displayOptions.xValue) {
		drawText(rightSide, topSide, parseFloat(kadPoint.pointXLocation).toFixed(2), textFillColor);
	}

	// Display Y coordinate (right side, middle)
	if (displayOptions.yValue) {
		drawText(rightSide, middleSide, parseFloat(kadPoint.pointYLocation).toFixed(2), textFillColor);
	}

	// Display Z coordinate (right side, bottom)
	if (displayOptions.zValue) {
		drawText(rightSide, bottomSide, parseFloat(kadPoint.pointZLocation).toFixed(2), textFillColor);
	}
}

function drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, getColorForMetric, legendLabel, minValue, maxValue, step) {
	const legendX = 10,
		legendY = canvas.height / 2 - 70,
		gradientWidth = 20,
		gradientHeight = 160;
	ctx.fillStyle = strokeColor;
	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillText(legendLabel || "Legend " + selectedVoronoiMetric, legendX, legendY - 15);

	// Create gradient for legend
	const gradient = ctx.createLinearGradient(0, legendY, 0, legendY + gradientHeight);
	const stops = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0];
	stops.forEach(function (stop) {
		const value = minValue + stop * (maxValue - minValue);
		const color = getColorForMetric(value);
		if (typeof color !== "string" || color.includes("NaN")) {
			// fallback or skip this color stop
		} else {
			gradient.addColorStop(stop, color);
		}
	});
	ctx.fillStyle = gradient;
	ctx.fillRect(legendX + 50, legendY, gradientWidth, gradientHeight);

	ctx.fillStyle = "darkgrey";
	ctx.textAlign = "left";
	ctx.textBaseline = "middle";
	// Draw tick marks and labels
	for (let v = minValue; v <= maxValue; v += step) {
		const y = legendY + ((v - minValue) / (maxValue - minValue)) * gradientHeight;
		ctx.strokeStyle = "#aaa";
		ctx.beginPath();
		ctx.moveTo(legendX + 50 + gradientWidth, y);
		ctx.lineTo(legendX + 50 + gradientWidth + 8, y);
		ctx.stroke();
		ctx.fillText(v.toFixed(1), legendX, y);
	}

	const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
	//modes available: min, max, average, mode

	const clippedCells = clipVoronoiCells(voronoiMetrics);

	for (const cell of clippedCells) {
		const value = cell[selectedVoronoiMetric];
		if (!cell.polygon || value == null) continue;
		ctx.beginPath();
		for (let j = 0; j < cell.polygon.length; j++) {
			const pt = cell.polygon[j];
			const [x, y] = worldToCanvas(pt.x !== undefined ? pt.x : pt[0], pt.y !== undefined ? pt.y : pt[1]);
			if (j === 0) ctx.moveTo(x, y);
			else ctx.lineTo(x, y);
		}
		ctx.closePath();
		ctx.fillStyle = getColorForMetric(value);
		ctx.fill();
		ctx.strokeStyle = "#222";
		ctx.lineWidth = 1;
		ctx.stroke();
	}
}

// === Helper: Draw hole labels, connectors, delay text, etc. ===
function drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, ctxObj) {
	const { leftSideToe, rightSideToe, leftSideCollar, rightSideCollar, topSideToe, middleSideToe, bottomSideToe, topSideCollar, middleSideCollar, bottomSideCollar, holeMap, displayOptions } = ctxObj;

	if (displayOptions.holeID) {
		drawText(rightSideCollar, topSideCollar, hole.holeID, textFillColor);
	}
	if (displayOptions.holeDia) {
		drawText(rightSideCollar, middleSideCollar, parseFloat(hole.holeDiameter).toFixed(0), "green");
	}
	if (displayOptions.holeLen) {
		drawText(rightSideCollar, bottomSideCollar, parseFloat(hole.holeLengthCalculated).toFixed(1), depthColor);
	}
	if (displayOptions.holeAng) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeDip) {
		drawRightAlignedText(leftSideToe, topSideToe, 90 - parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeBea) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.holeBearing).toFixed(1), "red");
	}
	if (displayOptions.holeSubdrill) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.subdrillAmount).toFixed(1), "blue");
	}
	if (displayOptions.initiationTime) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, hole.holeTime, "red");
	}
	if (displayOptions.connector && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			try {
				drawArrow(startX, startY, x, y, connColor, connScale, hole.connectorCurve || 0);
			} catch (error) {
				console.error("Error drawing arrow:", error);
			}
		}
	}
	if (displayOptions.delayValue && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			const pointDelay = hole.timingDelayMilliseconds;
			drawArrowDelayText(startX, startY, x, y, connColor, pointDelay, hole.connectorCurve || 0);
		}
	}
	if (displayOptions.xValue) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.startXLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.yValue) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, parseFloat(hole.startYLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.zValue) {
		drawRightAlignedText(leftSideCollar, bottomSideCollar, parseFloat(hole.startZLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.holeType) {
		drawText(rightSideCollar, middleSideCollar, hole.holeType, "green");
	}
	if (displayOptions.measuredLength) {
		drawRightAlignedText(leftSideCollar, bottomSideToe, hole.measuredLength, "#FF4400");
	}
	if (displayOptions.measuredMass) {
		drawRightAlignedText(leftSideCollar, topSideToe, hole.measuredMass, "#FF6600");
	}
	if (displayOptions.measuredComment) {
		drawText(rightSideCollar, middleSideCollar, hole.measuredComment, "#FF8800");
	}
	if (displayOptions.displayRowAndPosId) {
		drawRightAlignedText(leftSideCollar, topSideCollar, "Row:" + hole.rowID, "#FF00FF");
		drawRightAlignedText(leftSideCollar, middleSideCollar, "Pos:" + hole.posID, "#FF00FF");
	}
}

function drawConnectStadiumZone(sx, sy, endX, endY, connectAmount) {
	// Only draw stadium zone if multi-connector tool is active
	if (isAddingMultiConnector) {
		// Convert world coordinates to canvas coordinates
		const [canvasStartX, canvasStartY] = worldToCanvas(sx, sy);
		const [canvasEndX, canvasEndY] = worldToCanvas(endX, endY);

		// connectAmount is already in meters, so just multiply by currentScale
		const radiusPx = connectAmount * currentScale;

		// Calculate the line vector and perpendicular vector
		const dx = canvasEndX - canvasStartX;
		const dy = canvasEndY - canvasStartY;
		const length = Math.sqrt(dx * dx + dy * dy);

		// Avoid division by zero
		if (length < 1) return;

		// Normalize the direction vector
		const dirX = dx / length;
		const dirY = dy / length;

		// Get perpendicular vector (for width)
		const perpX = -dirY;
		const perpY = dirX;

		// Calculate the four corners of the rectangle
		const corner1X = canvasStartX + perpX * radiusPx;
		const corner1Y = canvasStartY + perpY * radiusPx;
		const corner2X = canvasStartX - perpX * radiusPx;
		const corner2Y = canvasStartY - perpY * radiusPx;
		const corner3X = canvasEndX - perpX * radiusPx;
		const corner3Y = canvasEndY - perpY * radiusPx;
		const corner4X = canvasEndX + perpX * radiusPx;
		const corner4Y = canvasEndY + perpY * radiusPx;
		// Set stadium zone color with transparency
		ctx.strokeStyle = "rgba(0, 255, 0, 0.4)";
		ctx.fillStyle = "rgba(0, 255, 0, 0.15)";
		ctx.lineWidth = 2;
		ctx.setLineDash([5, 5]); // Set dashed line with 5px gap and 5px dash

		// Draw the stadium shape (rounded rectangle)
		ctx.beginPath();

		// Start at the center of the first semicircle
		ctx.arc(canvasStartX, canvasStartY, radiusPx, Math.atan2(perpY, perpX), Math.atan2(-perpY, -perpX), false);

		// Line to second corner
		ctx.lineTo(corner3X, corner3Y);

		// Second semicircle
		ctx.arc(canvasEndX, canvasEndY, radiusPx, Math.atan2(-perpY, -perpX), Math.atan2(perpY, perpX), false);

		// Line back to first corner
		ctx.lineTo(corner1X, corner1Y);

		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		// CRITICAL: Reset line dash back to solid line
		ctx.setLineDash([]);
	}
}

// === Helper: Draw main hole, highlight if selected ===
function drawHoleMainShape(hole, x, y, selectedHole) {
	const diameterPx = parseInt((hole.holeDiameter / 1000) * currentScale * holeScale);

	let highlightType = null;
	let highlightColor1 = null,
		highlightColor2 = null,
		highlightText = null;

	// Check if we're in connector mode
	if (isAddingConnector || isAddingMultiConnector) {
		// First selected hole in connector mode (using fromHoleStore)
		if (fromHoleStore && fromHoleStore === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)";
			drawConnectStadiumZone(hole.startXLocation, hole.startYLocation, currentMouseWorldX, currentMouseWorldY, connectAmount);
		}
		// Second selected hole in connector mode (using firstSelectedHole/secondSelectedHole)
		else if (firstSelectedHole && firstSelectedHole === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName;
		} else if (secondSelectedHole && secondSelectedHole === hole) {
			highlightType = "second";
			highlightColor1 = "rgba(255, 255, 0, 0.2)";
			highlightColor2 = "rgba(255, 200, 0, .8)";
			highlightText = "2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)";
		}
	}
	// Regular selection highlighting (NOT in connector mode)
	else if (selectedHole != null && selectedHole === hole) {
		highlightType = "selected";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		highlightText = "Editing Selected Hole: " + selectedHole.holeID + " in: " + selectedHole.entityName + " with Single Selection Mode \n key to clear Selection";
	}
	// Multiple selection highlighting
	else if (selectedMultipleHoles != null && selectedMultipleHoles.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		highlightType = "multi";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		if (hole === selectedMultipleHoles[0]) {
			highlightText = "Editing Selected Holes: {" + selectedMultipleHoles.map((h) => h.holeID).join(",") + "} \n key to clear Selection";
		} else {
			highlightText = "";
		}
	}

	// Draw highlight, if any
	if (highlightType) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 900) * holeScale * currentScale), highlightColor1, highlightColor2);
		ctx.fillStyle = highlightColor2;
		ctx.font = "12px Arial";
		drawMultilineText(ctx, highlightText, 2, 20, 16, "left", highlightColor2, highlightColor1, false);
	}

	// Draw main hole/track shape (dummy, missing, or real)
	ctx.lineWidth = 1;
	ctx.strokeStyle = strokeColor;
	if (parseFloat(hole.holeLengthCalculated).toFixed(1) == 0.0) {
		drawDummy(x, y, parseInt(0.2 * holeScale * currentScale), strokeColor);
	} else if (hole.holeDiameter == 0) {
		drawNoDiameterHole(x, y, 10, strokeColor);
	} else {
		drawHole(x, y, diameterPx, fillColor, strokeColor);
	}
}

// === Helper: Handle Highlighting for Animation/Time Window ===
function handleHoleHighlighting(hole, x, y) {
	if (isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 400) * holeScale * currentScale), "rgba(255, 150, 0, 0.7)", "rgba(200, 200, 0, 0.7)");
	}
	if (!isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 500) * holeScale * currentScale), "rgba(0, 255, 0, 0.5)", "rgba(0, 255, 0, 0.7)");
	}
}

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	const canvasX = evt.clientX - rect.left;
	const canvasY = evt.clientY - rect.top;

	lastMouseX = canvasX;
	lastMouseY = canvasY;

	return {
		x: canvasX,
		y: canvasY
	};
}

function openHelp() {
	window.open("kirrausermanual.html");
}

function zoomIn() {
	currentScale += 1; // increase the current scale by 1
	currentFontSize += 1;
	drawData(allBlastHoles, selectedHole);
}

function zoomOut() {
	currentScale = Math.max(0.25, currentScale - 1); // decrease the current scale by 0.25, but not below 1
	currentFontSize -= 1;
	drawData(allBlastHoles, selectedHole);
}

function getHoleBoundaries() {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null;
	}

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	for (const hole of allBlastHoles) {
		if (hole.startXLocation < minX) minX = hole.startXLocation;
		if (hole.startXLocation > maxX) maxX = hole.startXLocation;
		if (hole.startYLocation < minY) minY = hole.startYLocation;
		if (hole.startYLocation > maxY) maxY = hole.startYLocation;
	}

	return {
		minX,
		maxX,
		minY,
		maxY
	};
}

function getKADBoundaries() {
	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	if (allKADDrawingsMap.size === 0) {
		return null;
	}

	for (const entity of allKADDrawingsMap.values()) {
		if (entity.data && Array.isArray(entity.data)) {
			for (const point of entity.data) {
				if (point.pointXLocation < minX) minX = point.pointXLocation;
				if (point.pointXLocation > maxX) maxX = point.pointXLocation;
				if (point.pointYLocation < minY) minY = point.pointYLocation;
				if (point.pointYLocation > maxY) maxY = point.pointYLocation;
			}
		}
	}
	return {
		minX,
		maxX,
		minY,
		maxY
	};
}

function zoomToFitAll() {
	const holeBoundaries = getHoleBoundaries();
	const kadBoundaries = getKADBoundaries();
	const surfaceBoundaries = getSurfaceBoundaries(); // NEW
	const imageBoundaries = getImageBoundaries(); // NEW

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	// Include hole boundaries
	if (holeBoundaries) {
		minX = Math.min(minX, holeBoundaries.minX);
		maxX = Math.max(maxX, holeBoundaries.maxX);
		minY = Math.min(minY, holeBoundaries.minY);
		maxY = Math.max(maxY, holeBoundaries.maxY);
	}

	// Include KAD drawing boundaries
	if (kadBoundaries) {
		minX = Math.min(minX, kadBoundaries.minX);
		maxX = Math.max(maxX, kadBoundaries.maxX);
		minY = Math.min(minY, kadBoundaries.minY);
		maxY = Math.max(maxY, kadBoundaries.maxY);
	}

	// NEW: Include surface boundaries
	if (surfaceBoundaries) {
		minX = Math.min(minX, surfaceBoundaries.minX);
		maxX = Math.max(maxX, surfaceBoundaries.maxX);
		minY = Math.min(minY, surfaceBoundaries.minY);
		maxY = Math.max(maxY, surfaceBoundaries.maxY);
	}

	// NEW: Include background image boundaries
	if (imageBoundaries) {
		minX = Math.min(minX, imageBoundaries.minX);
		maxX = Math.max(maxX, imageBoundaries.maxX);
		minY = Math.min(minY, imageBoundaries.minY);
		maxY = Math.max(maxY, imageBoundaries.maxY);
	}

	if (minX === Infinity) {
		// Just set defaults without calling resetZoom()
		currentScale = scale;
		currentFontSize = fontSize;
		updateCentroids();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	centroidX = minX + (maxX - minX) / 2;
	centroidY = minY + (maxY - minY) / 2;

	const dataWidth = maxX - minX;
	const dataHeight = maxY - minY;

	if (dataWidth === 0 || dataHeight === 0) {
		currentScale = 1;
	} else {
		const scaleX = (canvas.width * 0.9) / dataWidth;
		const scaleY = (canvas.height * 0.9) / dataHeight;
		currentScale = Math.min(scaleX, scaleY);
	}
	drawData(allBlastHoles, selectedHole);
}
// REPLACE the entire function:
function getSurfaceBoundaries() {
	if (loadedSurfaces.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedSurfaces.forEach((surface) => {
		if (surface.points && surface.points.length > 0) {
			surface.points.forEach((point) => {
				if (point.x < minX) minX = point.x;
				if (point.x > maxX) maxX = point.x;
				if (point.y < minY) minY = point.y;
				if (point.y > maxY) maxY = point.y;
			});
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY
	};
}

// REPLACE the entire function:
function getImageBoundaries() {
	if (loadedImages.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedImages.forEach((image) => {
		if (image.bbox && image.bbox.length >= 4) {
			// image.bbox is [minX, minY, maxX, maxY] format
			if (image.bbox[0] < minX) minX = image.bbox[0];
			if (image.bbox[2] > maxX) maxX = image.bbox[2];
			if (image.bbox[1] < minY) minY = image.bbox[1];
			if (image.bbox[3] > maxY) maxY = image.bbox[3];
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY
	};
}

function resetZoom() {
	currentScale = scale; // reset the current scale to the original scale
	currentFontSize = fontSize;

	//calculate the centroids from the data in the maps and points
	updateCentroids();
	drawData(allBlastHoles, selectedHole);
	zoomToFitAll();
}
///SAVE and LOAD POINTS ARRAY TO LOCAL STORAGE /////////////////////////////////
function saveHolesToLocalStorage(allBlastHoles) {
	if (allBlastHoles !== null) {
		/* STRUCTURE OF THE POINTS ARRAY
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
        entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID,burden,spacing,connectorCurve
    */
		const lines = allBlastHoles.map((hole) => {
			return `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.gradeXLocation},${hole.gradeYLocation},${hole.gradeZLocation},${hole.subdrillAmount},${hole.subdrillLength},${hole.benchHeight},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated},${hole.holeAngle},${hole.holeBearing},${hole.initiationTime},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}\n`;
		});

		const csvString = lines.join("\n");
		const pointsMap = new Map();

		localStorage.setItem("kirraDataPoints", csvString);

		for (const entity of pointsMap.values()) {
			// console.log(entity);
		}
	}
	console.log("All blast Holes saved to local storage");
	console.log(allBlastHoles);
}

function refreshPoints() {
	saveHolesToLocalStorage(allBlastHoles);
	const playSpeedInput = document.getElementById("playSpeed");
	if (allBlastHoles.length > 1000) {
		playSpeedInput.max = 50;
	} else {
		playSpeedInput.max = 15;
	}
	// Clear the current points array
	allBlastHoles = [];
	// console.log("Points array cleared - RefreshPoints()");

	// Load allBlastHoles from local storage
	const csvString = localStorage.getItem("kirraDataPoints");
	if (csvString) {
		allBlastHoles = parseK2Dcsv(csvString);

		// CRITICAL: Validate data integrity after reload
		const duplicateCheck = checkAndResolveDuplicateHoleIDs(allBlastHoles, "data reload");
		if (duplicateCheck.hasDuplicates) {
			console.warn("🚨 Data corruption detected during reload - duplicates resolved automatically");
			// Save the corrected data back to localStorage
			saveHolesToLocalStorage(allBlastHoles);
		}

		//updateCentroids();
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles

		drawData(allBlastHoles, selectedHole);

		// Debugging: Log the points array for each entity
		const blastHolesMap = new Map();
		for (const hole of allBlastHoles) {
			if (!blastHolesMap.has(hole.entityName)) {
				blastHolesMap.set(hole.entityName, {
					entityName: hole.entityName,
					data: []
				});
			}
			blastHolesMap.get(hole.entityName).data.push(hole);
		}
		for (const entity of blastHolesMap.values()) {
			// console.log(entity);
		}
		debouncedUpdateTreeView(); // Use debounced version
		return allBlastHoles;
	}
	return null;
}

// Use this function whenever you need to refresh the state and redraw the canvas
// For example, after deleting a hole or renumbering holes:
// refreshPoints();

function loadHolesFromLocalStorage() {
	// Initialize points as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}
	/* STRUCTURE OF THE POINTS ARRAY
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
        entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID
    */
	const csvString = localStorage.getItem("kirraDataPoints");
	//console.log(csvString);
	if (csvString) {
		allBlastHoles = parseK2Dcsv(csvString);
		//console.log(points);
		updateCentroids();
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
		drawData(allBlastHoles, selectedHole);
		//console.log the points array in a blob for each entityname
		const blastHolesMap = new Map();
		for (const hole of allBlastHoles) {
			if (!blastHolesMap.has(hole.entityName)) {
				blastHolesMap.set(hole.entityName, {
					entityName: hole.entityName,
					data: []
				});
			}
			blastHolesMap.get(hole.entityName).data.push(hole);
		}
		for (const entity of blastHolesMap.values()) {
			//console.log(entity);
		}
		console.log("///////////////////POINTS DATA ON LOAD//////////////");
		console.log(allBlastHoles);
		return allBlastHoles;
	}
	return null;
}

// --- IndexedDB & Local Storage Management ---

let db;
const DB_NAME = "Kirra2D-DATABASE";
const STORE_NAME = "KADDRAWINGS";
const SURFACE_STORE_NAME = "KADSURFACE";
const IMAGE_STORE_NAME = "KADIMAGES";
const BLASTHOLES_STORE_NAME = "BLASTHOLES";

// Define all required stores - THIS WAS MISSING
const REQUIRED_STORES = [STORE_NAME, SURFACE_STORE_NAME, IMAGE_STORE_NAME, BLASTHOLES_STORE_NAME];

// Start with a higher version that you'll use going forward
const DB_VERSION = 5; // Set this higher than your current version

async function initDB() {
	return new Promise((resolve, reject) => {
		// Open without version to get current state
		const initialRequest = indexedDB.open(DB_NAME);

		initialRequest.onsuccess = (event) => {
			const db = event.target.result;
			const currentVersion = db.version;
			const existingStores = Array.from(db.objectStoreNames);
			const missingStores = REQUIRED_STORES.filter((store) => !existingStores.includes(store));

			console.log("Current version: " + currentVersion);
			console.log("Existing stores: " + existingStores);
			console.log("Missing stores: " + missingStores);

			if (missingStores.length === 0) {
				// All good, use this connection
				resolve(db);
			} else {
				// Need to upgrade
				db.close();

				const upgradeRequest = indexedDB.open(DB_NAME, currentVersion + 1);

				upgradeRequest.onsuccess = () => resolve(upgradeRequest.result);
				upgradeRequest.onerror = () => reject(upgradeRequest.error);

				upgradeRequest.onupgradeneeded = (event) => {
					const upgradeDb = event.target.result;
					console.log("Upgrading database - creating missing stores");

					missingStores.forEach((storeName) => {
						console.log(`Creating store: ${storeName}`);
						const store = upgradeDb.createObjectStore(storeName, {
							keyPath: "id"
						});

						if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
							store.createIndex("name", "name", {
								unique: false
							});
							store.createIndex("type", "type", {
								unique: false
							});
						}
					});
				};
			}
		};

		initialRequest.onerror = () => reject(initialRequest.error);

		// Handle new database creation
		initialRequest.onupgradeneeded = (event) => {
			const db = event.target.result;
			console.log("Creating new database with all stores");

			REQUIRED_STORES.forEach((storeName) => {
				console.log(`Creating store: ${storeName}`);
				const store = db.createObjectStore(storeName, {
					keyPath: "id"
				});

				if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
					store.createIndex("name", "name", {
						unique: false
					});
					store.createIndex("type", "type", {
						unique: false
					});
				}
			});
		};
	});
}

let saveTimeout;
//Staged Saving for large files as these can't be save on the instantquit of a window close.
function debouncedSaveKAD() {
	// Clear any existing pending save
	clearTimeout(saveTimeout);
	// Set a new save to trigger after 2 seconds
	saveTimeout = setTimeout(() => {
		console.log("Auto-saving KAD drawings to DB...");
		// Only save if DB is initialized
		if (db) {
			saveKADToDB(allKADDrawingsMap);
		} else {
			console.log("DB not ready, skipping auto-save");
		}
	}, 2000);
}

function saveKADToDB(mapData) {
	if (!db) {
		console.error("DB not initialized. Cannot save.");
		return;
	}

	const transaction = db.transaction([STORE_NAME], "readwrite");
	const store = transaction.objectStore(STORE_NAME);
	let request;

	if (mapData.size === 0) {
		request = store.delete("kadDrawingData"); // ✅ Use consistent record key
	} else {
		const dataToStore = Array.from(mapData.entries());
		request = store.put({
			id: "kadDrawingData",
			data: dataToStore
		}); // ✅ Proper object format
	}

	request.onerror = (event) => {
		console.error("Error saving KAD data to IndexedDB:", event.target.error);
	};
}

function loadKADFromDB() {
	return new Promise((resolve, reject) => {
		if (!db) {
			console.error("DB not initialized. Cannot load.");
			return reject("DB not initialized");
		}
		const transaction = db.transaction([STORE_NAME], "readonly");
		const store = transaction.objectStore(STORE_NAME);
		const request = store.get("kadDrawingData"); // ✅ Use same record key

		request.onsuccess = (event) => {
			const result = event.target.result;
			if (result && result.data && result.data.length > 0) {
				allKADDrawingsMap = new Map(result.data); // ✅ Access the data property
				console.log("✅ //-- LOADED UNIFIED DRAWING OBJECTS FROM IndexedDB --//");
				debouncedUpdateTreeView();
				drawData(allBlastHoles, selectedHole);
				resolve(true);
			} else {
				resolve(false);
			}
		};

		request.onerror = (event) => {
			console.error("Error loading KAD data from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}
//Improved saveSurfaceToDB
async function saveSurfaceToDB(surfaceId) {
	return new Promise((resolve, reject) => {
		try {
			// ✅ FIX: Better validation and error handling
			if (!db) {
				console.error("❌ Database not initialized");
				reject(new Error("Database not initialized"));
				return;
			}

			const surface = loadedSurfaces.get(surfaceId);
			if (!surface) {
				console.error("❌ Surface not found in loadedSurfaces:", surfaceId);
				reject(new Error(`Surface ${surfaceId} not found`));
				return;
			}

			// ✅ FIX: Validate surface structure
			if (!surface.points || !Array.isArray(surface.points)) {
				console.error("❌ Surface missing points array:", surface);
				reject(new Error("Surface missing valid points array"));
				return;
			}

			if (!surface.triangles || !Array.isArray(surface.triangles)) {
				console.error("❌ Surface missing triangles array:", surface);
				reject(new Error("Surface missing valid triangles array"));
				return;
			}

			// ✅ FIX: Validate triangle format before saving
			const isValidTriangleFormat = surface.triangles.every((triangle) => {
				return triangle.vertices && Array.isArray(triangle.vertices) && triangle.vertices.length === 3 && triangle.vertices.every((vertex) => vertex && typeof vertex.x === "number" && typeof vertex.y === "number" && typeof vertex.z === "number");
			});

			if (!isValidTriangleFormat) {
				console.error("❌ Invalid triangle format detected:", surface.triangles.slice(0, 3));
				reject(new Error("Invalid triangle format - vertices must be objects with x,y,z properties"));
				return;
			}

			console.log("✅ Saving surface to database:", {
				id: surfaceId,
				name: surface.name,
				pointCount: surface.points.length,
				triangleCount: surface.triangles.length
			});

			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);

			// ✅ FIX: Create properly structured surface record
			const surfaceRecord = {
				id: surfaceId,
				name: surface.name,
				type: surface.type || "triangulated",
				points: surface.points,
				triangles: surface.triangles,
				visible: surface.visible !== undefined ? surface.visible : true,
				gradient: surface.gradient || "default",
				transparency: surface.transparency || 1.0,
				created: surface.created || new Date().toISOString(),
				metadata: surface.metadata || {}
			};

			// ✅ FIX: Add proper transaction handlers
			transaction.oncomplete = () => {
				console.log("✅ Surface saved successfully to database:", surfaceId);
				resolve(true);
			};

			transaction.onerror = (event) => {
				console.error("❌ Transaction failed:", event.target.error);
				reject(new Error(`Transaction failed: ${event.target.error}`));
			};

			transaction.onabort = (event) => {
				console.error("❌ Transaction aborted:", event.target.error);
				reject(new Error(`Transaction aborted: ${event.target.error}`));
			};

			// Perform the actual save operation
			const request = store.put(surfaceRecord);

			request.onsuccess = (event) => {
				console.log("✅ Surface record stored successfully");
				// Transaction will complete automatically
			};

			request.onerror = (event) => {
				console.error("❌ Failed to store surface record:", event.target.error);
				reject(new Error(`Failed to store surface: ${event.target.error}`));
			};
		} catch (error) {
			console.error("❌ Unexpected error in saveSurfaceToDB:", error);
			reject(error);
		}
	});
}
// Load a specific surface into the multi-surface system
async function loadSurfaceIntoMemory(surfaceId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const store = transaction.objectStore(SURFACE_STORE_NAME);
		const request = store.get(surfaceId);

		return new Promise((resolve) => {
			request.onsuccess = () => {
				const surfaceData = request.result;
				if (surfaceData) {
					loadedSurfaces.set(surfaceData.id, {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						gradient: surfaceData.gradient || "default",
						transparency: surfaceData.transparency || 1.0 // Add this line
					});
					console.log("✅ Surface " + surfaceData.name + " loaded into memory");
				}
				resolve(surfaceData);
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading surface into memory:", error);
		return null;
	}
}

async function loadAllSurfacesIntoMemory() {
	try {
		if (!db) return;

		const transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const store = transaction.objectStore(SURFACE_STORE_NAME);
		const request = store.getAll();

		return new Promise((resolve) => {
			request.onsuccess = () => {
				const surfaces = request.result || [];
				surfaces.forEach((surfaceData) => {
					loadedSurfaces.set(surfaceData.id, {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						gradient: surfaceData.gradient || "default",
						transparency: surfaceData.transparency || 1.0 // Add this line
					});
				});
				console.log("📊 Loaded " + loadedSurfaces.size + " surfaces into memory");
				resolve();
			};
			request.onerror = () => resolve();
		});
	} catch (error) {
		console.error("Error loading surfaces:", error);
	}
}

function exportSurfaceToDXF(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		showModalMessage("Export Failed", "Surface not found", "error");
		return;
	}

	try {
		console.log("Exporting surface " + surface.name + " to DXF");

		// Create DXF content with header
		let dxfContent = "";
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "HEADER\n";
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// Start ENTITIES section
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "ENTITIES\n";

		// Export triangles as 3DFACE entities
		if (surface.triangles && surface.triangles.length > 0) {
			surface.triangles.forEach((triangle) => {
				if (triangle.length >= 3) {
					const p1 = triangle[0];
					const p2 = triangle[1];
					const p3 = triangle[2];

					dxfContent += "0\n";
					dxfContent += "3DFACE\n";
					dxfContent += "8\n";
					dxfContent += "SURFACE_" + surface.name + "\n";

					// First corner
					dxfContent += "10\n";
					dxfContent += p1[0] + "\n";
					dxfContent += "20\n";
					dxfContent += p1[1] + "\n";
					dxfContent += "30\n";
					dxfContent += p1[2] + "\n";

					// Second corner
					dxfContent += "11\n";
					dxfContent += p2[0] + "\n";
					dxfContent += "21\n";
					dxfContent += p2[1] + "\n";
					dxfContent += "31\n";
					dxfContent += p2[2] + "\n";

					// Third corner
					dxfContent += "12\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "22\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "32\n";
					dxfContent += p3[2] + "\n";

					// Fourth corner (same as third for triangle)
					dxfContent += "13\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "23\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "33\n";
					dxfContent += p3[2] + "\n";
				}
			});
		}

		// End ENTITIES section
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// End of file
		dxfContent += "0\n";
		dxfContent += "EOF\n";

		// Create and download the file
		const blob = new Blob([dxfContent], {
			type: "application/dxf"
		});
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = surface.name + "_surface.dxf";
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);

		showModalMessage("Export Successful", "Surface " + surface.name + " exported as DXF with " + surface.triangles.length + " 3D faces", "success");
	} catch (error) {
		console.error("Error exporting surface to DXF:", error);
		showModalMessage("Export Failed", "Error exporting surface: " + error.message, "error");
	}
}

// Surface visibility management
function setSurfaceVisibility(surfaceId, visible) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = visible;
		console.log("👁️ Surface " + surface.name + " visibility: " + visible);
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleSurfaceVisibility(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = !surface.visible;
		setSurfaceVisibility(surfaceId, surface.visible);
	}
}

// ✅ Function to remove hidden entities from current selections
function clearHiddenFromSelections() {
	// Clear hidden holes from single selection
	if (selectedHole && !isHoleVisible(selectedHole)) {
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
	}

	// Clear hidden holes from multiple selection
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles = selectedMultipleHoles.filter((hole) => isHoleVisible(hole));
		if (selectedMultipleHoles.length === 0) {
			selectedMultipleHoles = [];
		}
	}

	// Clear hidden KAD objects from selection
	if (selectedKADObject && !isEntityVisible(selectedKADObject.entityName)) {
		selectedKADObject = null;
	}

	// Clear hidden polygons from selection
	if (selectedKADPolygon && !isEntityVisible(selectedKADPolygon.entityName)) {
		selectedKADPolygon = null;
	}

	// Clear from fromHoleStore if hidden
	if (fromHoleStore && !isHoleVisible(fromHoleStore)) {
		fromHoleStore = null;
	}

	// Clear move tool selections
	if (moveToolSelectedHole && moveToolSelectedHole.length > 0) {
		moveToolSelectedHole = moveToolSelectedHole.filter((hole) => isHoleVisible(hole));
		if (moveToolSelectedHole.length === 0) {
			moveToolSelectedHole = null;
			isDraggingHole = false;
		}
	}
}

// ✅ Helper function to check if an entity/element is visible
function isEntityVisible(entityName, elementId = null) {
	// Check overall group visibility first
	if (!drawingsGroupVisible) return false;

	const entity = allKADDrawingsMap.get(entityName);
	if (!entity) return false;

	// Check entity-level visibility
	if (entity.visible === false) return false;

	// Check sub-group visibility based on entity type
	switch (entity.entityType) {
		case "point":
			if (!pointsGroupVisible) return false;
			break;
		case "line":
			if (!linesGroupVisible) return false;
			break;
		case "poly":
			if (!polygonsGroupVisible) return false;
			break;
		case "circle":
			if (!circlesGroupVisible) return false;
			break;
		case "text":
			if (!textsGroupVisible) return false;
			break;
	}

	// Check element-level visibility if specified
	if (elementId !== null && entity.data) {
		const element = entity.data.find((el) => el.pointID == elementId);
		if (element && element.visible === false) return false;
	}

	return true;
}

// ✅ Helper function to check if a hole is visible
function isHoleVisible(hole) {
	if (!blastGroupVisible) return false;
	if (hole.visible === false) return false;
	return true;
}

//=== KAD Drawing Visibility Management ===
function setKADEntityVisibility(entityName, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = visible;
		console.log("👁️ KAD Entity " + entityName + " visibility: " + visible);

		// ✅ Clear hidden entities from selections
		clearHiddenFromSelections();
		// TODO FIX THE REMOVAL OF ENTITIES FROM SELECTIONS
		//! Its not working you can still delete invisible entities. Which is undesirable.
		updateTreeViewVisibilityStates();

		drawData(allBlastHoles, selectedHole);
	}
}

function setKADElementVisibility(entityName, pointID, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity && entity.data) {
		const element = entity.data.find((el) => el.pointID == pointID);
		if (element) {
			element.visible = visible;
			console.log("👁️ KAD Element " + entityName + ":" + pointID + " visibility: " + visible);

			// ✅ Clear hidden entities from selections
			clearHiddenFromSelections();
			drawData(allBlastHoles, selectedHole);
			updateTreeViewVisibilityStates();
		}
	}
}

function toggleKADEntityVisibility(entityName) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = !entity.visible;
		setKADEntityVisibility(entityName, entity.visible);
	}
}

//=== Blast Hole Visibility Management ===
function setHoleVisibility(holeID, visible) {
	const hole = points.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = visible;
		console.log("👁️ Hole " + holeID + " visibility: " + visible);

		// ✅ Clear hidden entities from selections
		clearHiddenFromSelections();
		drawData(allBlastHoles, selectedHole);
	}
}

function setEntityVisibility(entityName, visible) {
	const entityHoles = points.filter((h) => h.entityName === entityName);
	entityHoles.forEach((hole) => {
		hole.visible = visible;
	});
	console.log("👁️ Entity " + entityName + " visibility: " + visible + " (affecting " + entityHoles.length + " holes)");

	// ✅ Clear hidden entities from selections
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
}

function toggleHoleVisibility(holeID) {
	const hole = points.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = !hole.visible;
		setHoleVisibility(holeID, hole.visible);
	}
}
//=== Group Visibility Management ===
// ✅ ADD: Update all group visibility functions to call updateTreeViewVisibilityStates()
function setBlastGroupVisibility(visible) {
	blastGroupVisible = visible;
	console.log("👁️ Blast Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setDrawingsGroupVisibility(visible) {
	drawingsGroupVisible = visible;
	console.log("👁️ Drawings Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setSurfacesGroupVisibility(visible) {
	surfacesGroupVisible = visible;
	console.log("👁️ Surfaces Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setImagesGroupVisibility(visible) {
	imagesGroupVisible = visible;
	console.log("👁️ Images Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setPointsGroupVisibility(visible) {
	pointsGroupVisible = visible;
	console.log("👁️ Points Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setLinesGroupVisibility(visible) {
	linesGroupVisible = visible;
	console.log("👁️ Lines Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setPolygonsGroupVisibility(visible) {
	polygonsGroupVisible = visible;
	console.log("👁️ Polygons Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setCirclesGroupVisibility(visible) {
	circlesGroupVisible = visible;
	console.log("👁️ Circles Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

function setTextsGroupVisibility(visible) {
	textsGroupVisible = visible;
	console.log("👁️ Texts Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ✅ ADD: Update tree visual states
}

// Delete surface from IndexedDB
async function deleteSurfaceFromDB(surfaceId) {
	try {
		if (!db) {
			console.log("❌ Cannot delete surface - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.delete(surfaceId);

			request.onsuccess = () => {
				console.log("✅ Surface " + surfaceId + " deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("❌ Failed to delete surface " + surfaceId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("❌ Transaction failed for deleting surface " + surfaceId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting surface:", error);
		throw error;
	}
}

// Delete all surfaces from IndexedDB
async function deleteAllSurfacesFromDB() {
	try {
		if (!db) {
			console.log("❌ Cannot delete surfaces - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				console.log("✅ All surfaces deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("❌ Failed to delete all surfaces:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all surfaces:", error);
		throw error;
	}
}

// Delete all images from IndexedDB (useful for cleanup)
async function deleteAllImagesFromDB() {
	try {
		if (!db) return;

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				console.log("✅ All images deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("❌ Failed to delete all images:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all images:", error);
		throw error;
	}
}

// REPLACE this function to accept imageId parameter:
async function saveImageToDB(imageId) {
	try {
		const image = loadedImages.get(imageId);
		if (!db || !image || !image.canvas) {
			throw new Error("Missing database or image data");
		}

		// Create blob from canvas
		const blob = await new Promise((resolve, reject) => {
			image.canvas.toBlob((result) => {
				if (result) resolve(result);
				else reject(new Error("Failed to create blob"));
			});
		});

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);

			const imageRecord = {
				id: imageId,
				name: image.name,
				type: image.type || "imagery",
				bbox: image.bbox,
				blob: blob,
				visible: image.visible,
				transparency: image.transparency,
				savedAt: new Date().toISOString()
			};

			const request = store.put(imageRecord);
			request.onsuccess = () => {
				debouncedUpdateTreeView();
				resolve(imageRecord);
			};
			request.onerror = () => reject(request.error);
			transaction.onerror = () => reject(transaction.error);
		});
	} catch (error) {
		console.error("Error saving image:", error);
		throw error;
	}
}

// Load image from IndexedDB

// Load a specific image into the multi-image system
async function loadImageIntoMemory(imageId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.get(imageId);

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const imageData = request.result;
				if (imageData) {
					// Convert blob back to canvas
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					img.onload = () => {
						canvas.width = img.width;
						canvas.height = img.height;
						ctx.drawImage(img, 0, 0);

						loadedImages.set(imageId, {
							id: imageId,
							name: imageData.name,
							canvas: canvas,
							bbox: imageData.bbox,
							type: imageData.type,
							visible: imageData.visible !== false,
							transparency: imageData.transparency || 1.0
						});

						console.log("✅ Image " + imageData.name + " loaded into memory");
						resolve(imageData);
					};

					img.src = URL.createObjectURL(imageData.blob);
				} else {
					resolve(null);
				}
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading image into memory:", error);
		return null;
	}
}

// Replace your current loadAllImagesIntoMemory function with this:
async function loadAllImagesIntoMemory() {
	try {
		if (!db) return;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.getAll();

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const images = request.result || [];

				// Load each image into memory
				for (const imageData of images) {
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					await new Promise((imgResolve) => {
						img.onload = () => {
							canvas.width = img.width;
							canvas.height = img.height;
							ctx.drawImage(img, 0, 0);

							loadedImages.set(imageData.id, {
								id: imageData.id,
								name: imageData.name,
								canvas: canvas,
								bbox: imageData.bbox,
								type: imageData.type,
								visible: imageData.visible !== false,
								transparency: imageData.transparency || 1.0
							});

							imgResolve();
						};
						img.onerror = () => imgResolve(); // Continue even if image fails
						img.src = URL.createObjectURL(imageData.blob);
					});
				}

				console.log("🖼️ Loaded " + loadedImages.size + " images into memory");
				resolve();
			};
			request.onerror = () => {
				console.error("Failed to load images from database");
				resolve();
			};
		});
	} catch (error) {
		console.error("Error loading images into memory:", error);
	}
}
// Image visibility management
function setImageVisibility(imageId, visible) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = visible;
		console.log("👁️ Image " + image.name + " visibility: " + visible);
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleImageVisibility(imageId) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = !image.visible;
		setImageVisibility(imageId, image.visible);
	}
}

// Delete image from IndexedDB
async function deleteImageFromDB(imageId) {
	try {
		if (!db) {
			console.log("❌ Cannot delete image - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.delete(imageId);

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log(`✅ Image "${imageId}" deleted from IndexedDB`);
				resolve();
			};

			request.onerror = () => {
				console.error("❌ Failed to delete image " + imageId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("❌ Transaction failed for deleting image " + imageId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting image:", error);
		throw error;
	}
}
// Delete all images from IndexedDB (useful for cleanup)
async function deleteAllImagesFromDB() {
	try {
		if (!db) return;

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log("✅ All images deleted from IndexedDB");
				resolve();
			};

			request.onerror = () => {
				console.error("❌ Failed to delete all images:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all images:", error);
		throw error;
	}
}

// Call in console if needed: deleteAllImagesFromDB()

// Debug function - add temporarily to check what's in the database
async function debugDatabaseContents() {
	try {
		if (!db) {
			console.log("Database not initialized");
			return;
		}

		// Check surfaces
		const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
		const surfaceRequest = surfaceStore.getAll();

		surfaceRequest.onsuccess = () => {
			console.log("🔍 Surfaces in database:", surfaceRequest.result.length);
			surfaceRequest.result.forEach((surface) => {
				console.log("  - Surface:", surface.name, "Points:", surface.points?.length, "Triangles:", surface.triangles?.length);
			});
		};

		// Check images
		const imageTransaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const imageStore = imageTransaction.objectStore(IMAGE_STORE_NAME);
		const imageRequest = imageStore.getAll();

		imageRequest.onsuccess = () => {
			console.log("🔍 Images in database:", imageRequest.result.length);
			imageRequest.result.forEach((image) => {
				console.log("  - Image:", image.name, "Type:", image.type, "Bbox:", image.bbox);
			});
		};
	} catch (error) {
		console.error("Error checking database contents:", error);
	}
}

function checkAndPromptForStoredData() {
	const allBlastHolesData = localStorage.getItem("kirraDataPoints");

	if (!db) {
		// Fallback for when DB fails to initialize
		if (allBlastHolesData) showPopup(false);
		return;
	}

	// Check for KAD drawings
	const kadTransaction = db.transaction([STORE_NAME], "readonly");
	const kadStore = kadTransaction.objectStore(STORE_NAME);
	const kadRequest = kadStore.get("kadDrawingData");

	kadRequest.onsuccess = (event) => {
		const kadData = event.target.result;

		// ALSO check for surfaces
		const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
		const surfaceRequest = surfaceStore.getAll();

		surfaceRequest.onsuccess = (surfaceEvent) => {
			const surfaceData = surfaceEvent.target.result || [];

			// Show popup if ANY data exists: points, drawings, OR surfaces
			if (allBlastHolesData || (kadData && kadData.data && kadData.data.length > 0) || surfaceData.length > 0) {
				showPopup(true);
				debouncedUpdateTreeView();
			}
		};
	};

	kadRequest.onerror = (event) => {
		console.error("Could not check for KAD data in IndexedDB.", event.target.error);
		if (allBlastHolesData) showPopup(false);
	};
}
async function showPopup(isDBReady) {
	console.log("showPopup called with isDBReady:", isDBReady);

	// Step 1) Determine text color based on dark mode
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	// Step 2) Create the HTML content for the dialog with proper styling
	const dialogContent = '<div style="text-align: center; padding: 10px 0;">' + '<div class="labelWhite18" style="margin-bottom: 15px; color: ' + textColor + '; font-weight: 500;">' + "Do you want to pick up from where you left off?" + "</div>" + '<div class="labelWhite15" style="margin-bottom: 10px; color: ' + textColor + '; opacity: 0.9;">' + "Your previous work is still available." + "</div>" + "</div>";

	// Step 3) Create promise to handle async dialog response
	return new Promise((resolve) => {
		// Step 4) Create the FloatingDialog instance
		const dialog = new FloatingDialog({
			title: "Welcome back to Kirra 2D!",
			content: dialogContent,
			width: 480,
			height: 220,
			showConfirm: true,
			showCancel: false,
			showDeny: true,
			confirmText: "Continue Previous",
			denyText: "Start Fresh",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior - must click a button
			layoutType: "default",
			onConfirm: async () => {
				// Step 5) User chose to continue previous work
				console.log("User chose to continue previous work");
				points = loadHolesFromLocalStorage();

				if (isDBReady) {
					try {
						await loadKADFromDB();
						await loadAllSurfacesIntoMemory();
						await loadAllImagesIntoMemory();
					} catch (err) {
						console.error("Failed to load data from DB.", err);
					}
				}

				zoomToFitAll();
				debouncedUpdateTreeView();
				dialog.close();
				resolve("confirmed");
			},
			onDeny: async () => {
				// Step 6) User chose to start fresh
				console.log("User chose to start fresh");
				await clearLoadedData();
				debouncedUpdateTreeView();
				zoomToFitAll();
				dialog.close();
				resolve("denied");
			}
		});

		// Step 7) Override the create method to customize the dialog
		const originalCreate = dialog.create.bind(dialog);
		dialog.create = function () {
			originalCreate();

			// Hide the X close button for modal behavior
			const closeBtn = this.element.querySelector(".floating-dialog-header button");
			if (closeBtn) {
				closeBtn.style.display = "none";
			}

			// Step 8) Style the header
			const header = this.element.querySelector(".floating-dialog-header");
			if (header) {
				header.style.borderBottom = "2px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");
			}

			// Step 9) Add custom styling to buttons
			const footer = this.element.querySelector(".floating-dialog-footer");
			if (footer) {
				// Increase spacing between buttons
				footer.style.gap = "40px";
				footer.style.padding = "12px 20px";
				footer.style.borderTop = "1px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");

				const denyBtn = footer.querySelector(".floating-dialog-btn.deny");
				const confirmBtn = footer.querySelector(".floating-dialog-btn.confirm");

				if (denyBtn && confirmBtn) {
					// Step 10) Style the "Start Fresh" button (orange)
					denyBtn.style.backgroundColor = "#ff9d00";
					denyBtn.style.setProperty("color", "#000000", "important");
					denyBtn.style.borderColor = "#ff9d00";
					denyBtn.style.minWidth = "120px";
					denyBtn.style.padding = "8px 16px";
					denyBtn.style.fontSize = "12px";
					denyBtn.style.fontWeight = "500";
					denyBtn.style.borderRadius = "4px";
					denyBtn.style.transition = "all 0.2s ease";
					// denyBtn.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";

					// Hover effect for Start Fresh button
					denyBtn.onmouseover = function () {
						this.style.backgroundColor = "#e77a00";
						// this.style.boxShadow = "0 3px 6px rgba(255, 157, 0, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					denyBtn.onmouseout = function () {
						this.style.backgroundColor = "#ff9d00";
						// this.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";
						// this.style.transform = "translateY(0)";
					};

					// Step 11) Style the "Continue Previous Work" button (green)
					confirmBtn.style.backgroundColor = "#00771c";
					confirmBtn.style.setProperty("color", "#ffffff", "important");
					confirmBtn.style.borderColor = "#00a91c";
					confirmBtn.style.minWidth = "160px";
					confirmBtn.style.padding = "8px 16px";
					confirmBtn.style.fontSize = "12px";
					confirmBtn.style.fontWeight = "500";
					confirmBtn.style.borderRadius = "4px";
					confirmBtn.style.transition = "all 0.2s ease";
					// confirmBtn.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";

					// Hover effect for Continue button
					confirmBtn.onmouseover = function () {
						this.style.backgroundColor = "#008f17";
						// this.style.boxShadow = "0 3px 6px rgba(0, 169, 28, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					confirmBtn.onmouseout = function () {
						this.style.backgroundColor = "#00a91c";
						// this.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";
						// this.style.transform = "translateY(0)";
					};
				}
			}
		};

		// Step 12) Show the dialog
		dialog.show();
	});
}

// Listen for changes in the kirraDataPoints key
window.addEventListener("storage", function (event) {
	if (event.key === "kirraDataPoints") {
		console.log("kirraDataPoints changed");
	} else {
		console.log("kirraDataPoints not changed");
	}
});

// Replace the entire updateCentroids function with this simplified version:
function updateCentroids() {
	// Calculate centroid of allBlastholes
	let sumX = 0;
	let sumY = 0;
	let records = 0;

	// Include hole points
	if (allBlastHoles !== null) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			sumX += allBlastHoles[i].startXLocation;
			sumY += allBlastHoles[i].startYLocation;
			records++;
		}
	}

	// Include all KAD objects (everything is now in allKADDrawingsMap)
	if (allKADDrawingsMap.size > 0) {
		for (const entity of allKADDrawingsMap.values()) {
			for (const dataPoint of entity.data) {
				sumX += dataPoint.pointXLocation;
				sumY += dataPoint.pointYLocation;
				records++;
			}
		}
	}

	// Include surface points in centroid calculation
	if (loadedSurfaces.size > 0) {
		loadedSurfaces.forEach((surface) => {
			if (surface.points && surface.points.length > 0) {
				for (const point of surface.points) {
					sumX += point.x;
					sumY += point.y;
					records++;
				}
			}
		});
	}

	if (records > 0) {
		centroidX = sumX / records;
		centroidY = sumY / records;
	}
}

const darkModeToggle = document.getElementById("dark-mode-toggle");
const body = document.body;
const sidenavLeft = document.getElementById("sidenavLeft");
const sidenavRight = document.getElementById("sidenavRight");
// Check if dark mode preference exists in local storage
const darkModePref = localStorage.getItem("darkMode");
if (darkModePref === "true") {
	body.classList.add("dark-mode");
	sidenavLeft.classList.add("dark-mode");
	sidenavRight.classList.add("dark-mode");
	canvas.classList.add("dark-canvas");
	darkModeToggle.checked = true;
}

darkModeToggle.addEventListener("change", () => {
	if (darkModeToggle.checked) {
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		sidenavRight.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
		localStorage.setItem("darkMode", "true");
	} else {
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		sidenavRight.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
		localStorage.setItem("darkMode", "false");
	}
	darkModeEnabled = document.body.classList.contains("dark-mode");
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "darkgrey" : "lightgrey";
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "cyan" : "blue";
	angleDipColor = darkModeEnabled ? "orange" : "darkorange";
	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	drawData(allBlastHoles, selectedHole);
});

function endKadTools() {
	// Check if any KAD drawing tool is active
	const anyKADToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked;

	if (anyKADToolActive) {
		// Cancel current tool entirely
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addCircleDraw.checked = false;
		addPolyDraw.checked = false;
		addTextDraw.checked = false;

		// Reset states
		createNewEntity = true;
		lastKADDrawPoint = null;

		// Update drawing flags
		isDrawingPoint = false;
		isDrawingLine = false;
		isDrawingCircle = false;
		isDrawingPoly = false;
		isDrawingText = false;
		clearCurrentDrawingEntity(); // Clear current drawing entity
		updateStatusMessage("Drawing tools cancelled");
		setTimeout(() => {
			updateStatusMessage("");
		}, 1500);

		// Redraw to clear any preview lines/indicators
		drawData(allBlastHoles, selectedHole);
	}

	// Also handle polygon selection 
	if (isPolygonSelectionActive) {
		// isPolygonSelectionActive = false;
		polyPointsX = [];
		polyPointsY = [];
		updateStatusMessage("Polygon selection cancelled");
		setTimeout(() => {
			updateStatusMessage("");
		}, 1500);
		drawData(allBlastHoles, selectedHole);
	}
}

function findClosestKadPoint(worldPoint, snapDistance) {
	let closestPoint = null;
	let minDistance = snapDistance;

	for (const [name, entity] of allKADDrawingsMap.entries()) {
		if (entity.entityType === "line" || entity.entityType === "poly") {
			for (let i = 0; i < entity.data.length; i++) {
				const pt = entity.data[i];
				const dx = pt.pointXLocation - worldPoint.x;
				const dy = pt.pointYLocation - worldPoint.y;
				const dist = Math.sqrt(dx * dx + dy * dy);

				if (dist < minDistance) {
					minDistance = dist;
					closestPoint = {
						entityName: name,
						pointIndex: i,
						point: pt
					};
				}
			}
		}
	}
	return closestPoint;
}

/// VERY SURE THIS DOES NOT GET CALLED.
function handleKADModificationClick(event) {
	// Get the mouse position in world coordinates
	const [worldX, worldY] = canvasToWorld(event.offsetX, event.offsetY);

	// Find the closest KAD entity using our new unified function
	selectedKADPoint = getClickedKADEntity(worldX, worldY);

	if (selectedKADPoint) {
		const entity = selectedKADPoint.entity;
		console.log("DEBUG: entity object:", entity);
		console.log("DEBUG: entity.entityName:", entity.entityName);
		console.log("DEBUG: entity.entityType:", entity.entityType);
		console.log("DEBUG: entity.data:", entity.data);

		console.log("SUCCESS: Modification target found:", entity.entityName);
		updateStatusMessage("Selected entity: " + entity.entityName + " (Right-click to edit)");

		// For lines, points, circles, text - set selectedKADObject (used by highlighting)
		selectedKADObject = {
			entityName: entity.entityName,
			entityType: entity.entityType,
			pointXLocation: selectedKADPoint.clickedX,
			pointYLocation: selectedKADPoint.clickedY,
			// Add other properties as needed by existing code
			...entity.data[0] // Copy properties from first point
		};
		console.log("DEBUG: selectedKADObject created:", selectedKADObject);
		//selectedKADPolygon = null; // Clear the other variable
	} else {
		console.log("No modifiable KAD entity found at click location.");
		updateStatusMessage("");
		// Clear both legacy variables
		selectedKADPolygon = null;
		selectedKADObject = null;
	}

	// Redraw to show highlighting
	drawData(allBlastHoles, selectedHole);
}
/// VERY SURE THIS ABOVE DOES NOT GET CALLED.

window.onload = function () {
	// --- Dark Mode Setup ---
	darkModeEnabled = localStorage.getItem("darkMode") === "true";
	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}
	// ADD WELCOME MESAGES.
	const messages = ["Welcome to Kirra2D!", "Support the development.", "Buy Brent a coffee\nhttps://buymeacoffee.com/brentbuffham"];

	messages.forEach((msg, index) => {
		const delay = 1000 + index * 3000;

		setTimeout(() => {
			updateStatusMessage(msg);

			// 🔄 Clear the last message 4 seconds after it's shown
			if (index === messages.length - 1) {
				setTimeout(() => updateStatusMessage(""), 4000);
			}
		}, delay);
	});

	// --- Key Listeners ---
	document.addEventListener("keydown", (event) => {
		// Handle drawing key events (delete/backspace) when drawing tools are active
		// BUT only if user is not typing in an input field
		if ((isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText) && !event.target.matches('input, textarea, [contenteditable="true"]')) {
			handleDrawingKeyEvents(event);
		}
		
		// Add these listeners in your init function (e.g., DOMContentLoaded or initialize function)
		if (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S") {
			isSelfSnapEnabled = true;
		}
		
		// Escape Key to reset tools
		if (event.key === "Escape") {
			console.log("Escape pressed - resetting all");
			resetAllSelectedStores();
			endKadTools();
			selectedPoint = null;
			selectedHole = null;
			selectedPoint = null;
			selectedKADObject = null;
			selectedKADPolygon = null;
			selectedKADPoint = null;
			selectedKADLine = null;
			selectedKADCircle = null;
			selectedKADText = null;
			selectedMultipleHoles = [];
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			hasSelectedMultipleHoles = false;
			clearAllSelectionState();

			if (isPolygonSelectionActive) {
				polyPointsX = [];
				polyPointsY = [];
				updateStatusMessage("Polygon selection cleared - click to start new selection");
			}
			if (isPatternInPolygonActive) {
				selectedPolygon = null;
				patternStartPoint = null;
				patternEndPoint = null;
				patternReferencePoint = null;
				patternPolygonStep = 0;
				updateStatusMessage("Pattern tool reset - select polygon to start");
			} else if (isHolesAlongLineActive) {
				lineStartPoint = null;
				lineEndPoint = null;
				holesLineStep = 0;
				updateStatusMessage("Holes along line tool reset\nClick to set start point");
			} else if (isHolesAlongPolyLineActive) {
				selectedPolyline = null;
				polylineStartPoint = null;
				polylineEndPoint = null;
				polylineStep = 0;
				updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
			} else if (isRulerActive) {
				rulerStartPoint = null;
				rulerEndPoint = null;
				updateStatusMessage("Ruler tool reset\nClick to set start point");
			} else if (isRulerProtractorActive) {
				rulerProtractorPoints = [];
				updateStatusMessage("Protractor tool reset\nClick to set center point");
			}
			selectedKADPolygon = null;
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			selectedMultipleHoles = [];
			drawData(allBlastHoles, selectedHole);
		}
		// Shift Key for multi-select
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = true;
			isMultiHoleSelectionEnabled = true;
		}
	});

	document.addEventListener("keyup", (event) => {
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = false;
			isMultiHoleSelectionEnabled = false;
		}

		if (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S") {
			isSelfSnapEnabled = false;
		}

	});

	///-------CRITICAL IMPORTANT --------///
	// This code is critical and must be called before any other database operations.
	// It is responsible for initializing the database and loading the stored data.
	// If the database is not initialized, the application will not work correctly.
	// This code should be called only once during application initialization,
	// typically in window.onload or similar startup code, not inside event handlers.
	// This placement means the database initialization would run every time certain keys
	// are pressed, which is inefficient and could cause issues with multiple database
	initDB()
		.then((database) => {
			db = database; // ✅ Set the global db variable
			console.log("✅ Database initialized successfully");
			updatePopup();
		})
		.catch((err) => {
			console.error("Failed to initialize database. Falling back to Local Storage.", err);
			if (localStorage.getItem("kirraDataPoints")) {
				updatePopup();
			}
		});

	updateColorsForDarkMode();
	clearCanvas();
};

// Add this helper function to centralize color updates
function updateColorsForDarkMode() {
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "lightgrey" : "darkgrey";
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "blue" : "cyan";
	angleDipColor = darkModeEnabled ? "darkcyan" : "orange";

	console.log("🎨 Colors updated for dark mode:", darkModeEnabled);
}

window.addEventListener("beforeunload", function () {
	saveHolesToLocalStorage(allBlastHoles);
});

function getKADBoundaries() {
	let minX = Infinity;
	let maxX = -Infinity;
	let minY = Infinity;
	let maxY = -Infinity;

	if (allKADDrawingsMap.size === 0) {
		return null;
	}

	for (const entity of allKADDrawingsMap.values()) {
		if (entity.data && Array.isArray(entity.data)) {
			for (const point of entity.data) {
				if (point.pointXLocation < minX) minX = point.pointXLocation;
				if (point.pointXLocation > maxX) maxX = point.pointXLocation;
				if (point.pointYLocation < minY) minY = point.pointYLocation;
				if (point.pointYLocation > maxY) maxY = point.pointYLocation;
			}
		}
	}

	return {
		minX,
		maxX,
		minY,
		maxY
	};
}

async function clearLoadedData() {
	// Clear hole data
	localStorage.removeItem("kirraDataPoints");
	allBlastHoles = [];

	// Clear ALL data from IndexedDB - not just KAD data
	if (db) {
		try {
			// Clear KAD data
			const kadTransaction = db.transaction([STORE_NAME], "readwrite");
			const kadStore = kadTransaction.objectStore(STORE_NAME);
			await new Promise((resolve, reject) => {
				const request = kadStore.clear();
				request.onsuccess = () => resolve();
				request.onerror = () => reject(request.error);
			});

			// Clear surface data
			await deleteAllSurfacesFromDB();

			// Clear image data
			await deleteAllImagesFromDB();

			console.log("✅ All database data cleared");
		} catch (error) {
			console.error("❌ Error clearing database:", error);
		}
	}

	// Clear memory maps
	allKADDrawingsMap.clear();
	loadedSurfaces.clear();
	loadedImages.clear();

	// Reset other states if necessary
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	selectedPoint = null;

	// Redraw the empty canvas
	drawData(allBlastHoles, selectedHole);
}
window.addEventListener("resize", () => {
	if (htmlUIVersion === "1") {
		canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
		canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
	} else {
		//drawing will handle
	}
	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	saveHolesToLocalStorage(allBlastHoles); // For smaller hole data

	drawData(allBlastHoles, selectedHole);
});

let isMobile = false;
// Check if the device is a mobile device
//const isMobile = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isMobileQuery = window.matchMedia("(max-width: 768px)");
if (isMobileQuery.matches) {
	isMobile = true;
} else {
	isMobile = false;
}

function updateFloatingToolbarPosition(sidebarOpen) {
	const toolbar = document.getElementById("toolbarPanel");
	if (!toolbar) return;

	// Only adjust on desktop (not mobile)
	if (!isMobile) {
		if (sidebarOpen) {
			toolbar.classList.add("sidebar-open");
		} else {
			toolbar.classList.remove("sidebar-open");
		}
	}
}

function openNavLeft() {
	console.log(isMobile);
	const sidenavHeight = 350;
	const screenHeight = window.innerHeight;
	const margin = screenHeight - sidenavHeight;

	if (isMobile) {
		body.style.bottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "0px";
		sidenavLeft.style.top = "60%";
		sidenavLeft.style.width = "100%";
		sidenavLeft.style.height = "350px";
	} else {
		body.style.marginLeft = "315px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "300px";
		sidenavLeft.style.paddingLeft = "5px";
		sidenavLeft.style.paddingRight = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update floating toolbar position
	updateFloatingToolbarPosition(true);
}

function closeNavLeft() {
	if (isMobile) {
		body.style.marginBottom = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "-5px";
		sidenavLeft.style.top = "-5px";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.height = "0px";
	} else {
		body.style.marginLeft = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.padding = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update floating toolbar position
	updateFloatingToolbarPosition(false);
}

function openNavRight() {
	if (isMobile) {
		const sidenavHeight = 350; // Change this value to match the actual height of the sidenav
		const screenHeight = window.innerHeight;
		const margin = screenHeight - sidenavHeight;

		body.style.marginBottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavRight.style.right = "0px";
		sidenavRight.style.top = "60%";
		sidenavRight.style.width = "100%";
		sidenavRight.style.height = "350px";
		//resize the timechart
		Plotly.relayout("timeChart", {
			width: 280
		});
	} else {
		body.style.marginRight = "315px"; // Push body to the left
		body.style.transition = "0.5s";
		sidenavRight.style.width = "300px";
		sidenavRight.style.right = "0";
		sidenavRight.style.paddingLeft = "0px";
		sidenavRight.style.paddingRight = "5px";
		sidenavRight.style.margin = "0px";
		//resize the timechart
		timeChart();
		newWidthRight = 315;
		resizeChart();
	}
}

function closeNavRight() {
	if (isMobile) {
		body.style.marginBottom = "0%"; // Push body down
		body.style.transition = "0.5s";
		sidenavRight.style.right = "-5px";
		sidenavRight.style.top = "-5px";
		sidenavRight.style.width = "0px";
		sidenavRight.style.height = "0px";
	} else {
		body.style.marginRight = "0px"; // Reset the margin to default
		body.style.transition = "0.5s";
		sidenavRight.style.width = "0px";
		sidenavRight.style.padding = "0px";
		sidenavRight.style.margin = "0px";
	}
}

//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//
//#region TOOLBAR

// Step 1) Keep old toolbar code but add null checks to prevent errors
const toolbar = document.getElementById("toolbarPanel");

let isDraggingTools = false;
let offsetX, offsetY;

// // Add improved drag event listeners that exclude the collapse button
// if (toolbar) {
// 	toolbar.addEventListener("mousedown", (e) => {
// 		// Check if clicking on collapse button or its children
// 		const isCollapseButton = e.target.closest(".toolbar-collapse-button");
// 		const isButton = e.target.closest("label.icon-button") || e.target.closest('input[type="checkbox"]') || e.target.closest('input[type="button"]') || e.target.closest('input[type="number2"]') || e.target.closest('input[type="range"]') || isCollapseButton;

// 		// Only start dragging if we're not clicking on any button
// 		if (!isButton) {
// 			isDraggingTools = true;
// 			offsetX = e.clientX - toolbar.getBoundingClientRect().left;
// 			offsetY = e.clientY - toolbar.getBoundingClientRect().top;
// 			toolbar.style.transition = "none";
// 		}
// 	});

// 	toolbar.addEventListener("touchstart", (e) => {
// 		const isCollapseButton = e.target.closest(".toolbar-collapse-button");
// 		const isButton = e.target.closest("label.icon-button") || e.target.closest('input[type="checkbox"]') || e.target.closest('input[type="button"]') || e.target.closest('input[type="number2"]') || e.target.closest('input[type="range"]') || isCollapseButton;

// 		if (!isButton) {
// 			isDraggingTools = true;
// 			offsetX = e.touches[0].clientX - toolbar.getBoundingClientRect().left;
// 			offsetY = e.touches[0].clientY - toolbar.getBoundingClientRect().top;
// 			toolbar.style.transition = "none";
// 		}
// 	});
// }

// document.addEventListener("mousemove", (e) => {
// 	if (isDraggingTools && toolbar) {
// 		// Added null check
// 		const x = e.clientX - offsetX;
// 		const y = e.clientY - offsetY;
// 		toolbar.style.left = x + "px";
// 		toolbar.style.top = y + "px";
// 	}
// });

// document.addEventListener("mouseup", () => {
// 	if (toolbar) {
// 		// Added null check
// 		isDraggingTools = false;
// 		toolbar.style.transition = ""; // Re-enable smooth transition
// 	}
// });

// document.addEventListener("touchmove", (e) => {
// 	if (isDraggingTools && toolbar) {
// 		// Added null check
// 		const x = e.touches[0].clientX - offsetX;
// 		const y = e.touches[0].clientY - offsetY;
// 		toolbar.style.left = x + "px";
// 		toolbar.style.top = y + "px";
// 	}
// });

// document.addEventListener("touchend", () => {
// 	if (toolbar) {
// 		// Added null check
// 		isDraggingTools = false;
// 		toolbar.style.transition = "";
// 	}
// });

// Step 2) Add new toolbar panel functionality
class ToolbarPanel {
	constructor() {
		this.container = document.getElementById("toolbarPanel");
		this.isCollapsed = false;
		this.isDragging = false;
		this.dragOffset = { x: 0, y: 0 };

		if (this.container) {
			this.init();
		}
	}

	init() {
		// Setup collapse button
		const collapseBtn = document.getElementById("toolbarCollapseBtn");
		if (collapseBtn) {
			collapseBtn.addEventListener("click", () => this.toggleCollapse());
		}

		// Setup close button
		const closeBtn = document.getElementById("toolbarCloseBtn");
		if (closeBtn) {
			closeBtn.addEventListener("click", () => this.hide());
		}

		// Setup dragging
		const header = document.getElementById("toolbarPanelHeader");
		if (header) {
			header.addEventListener("mousedown", (e) => this.startDrag(e));
		}

		// Load saved position
		this.loadPosition();

		// Load saved collapse state
		this.loadCollapseState();
	}

	toggleCollapse() {
		this.isCollapsed = !this.isCollapsed;
		this.container.classList.toggle("collapsed", this.isCollapsed);

		const btn = document.getElementById("toolbarCollapseBtn");
		if (btn) {
			btn.textContent = this.isCollapsed ? "+" : "−";
		}

		// Save state
		localStorage.setItem("kirra-toolbar-collapsed", this.isCollapsed);
	}

	hide() {
		this.container.style.display = "none";
		localStorage.setItem("kirra-toolbar-visible", "false");
	}

	show() {
		this.container.style.display = "flex";
		localStorage.setItem("kirra-toolbar-visible", "true");
	}

	startDrag(e) {
		if (e.target.closest(".tree-panel-controls")) return;

		this.isDragging = true;
		const rect = this.container.getBoundingClientRect();
		this.dragOffset.x = e.clientX - rect.left;
		this.dragOffset.y = e.clientY - rect.top;

		document.addEventListener("mousemove", this.handleDrag);
		document.addEventListener("mouseup", this.stopDrag);

		e.preventDefault();
	}

	handleDrag = (e) => {
		if (!this.isDragging) return;

		const x = e.clientX - this.dragOffset.x;
		const y = e.clientY - this.dragOffset.y;

		// Keep within viewport
		const maxX = window.innerWidth - this.container.offsetWidth;
		const maxY = window.innerHeight - this.container.offsetHeight;

		this.container.style.left = Math.max(0, Math.min(x, maxX)) + "px";
		this.container.style.top = Math.max(0, Math.min(y, maxY)) + "px";
	};

	stopDrag = () => {
		this.isDragging = false;
		document.removeEventListener("mousemove", this.handleDrag);
		document.removeEventListener("mouseup", this.stopDrag);

		// Save position
		this.savePosition();
	};

	savePosition() {
		const position = {
			left: this.container.style.left,
			top: this.container.style.top
		};
		localStorage.setItem("kirra-toolbar-position", JSON.stringify(position));
	}

	loadPosition() {
		const saved = localStorage.getItem("kirra-toolbar-position");
		if (saved) {
			try {
				const position = JSON.parse(saved);
				if (position.left) this.container.style.left = position.left;
				if (position.top) this.container.style.top = position.top;
			} catch (e) {
				console.error("Error loading toolbar position:", e);
			}
		}
	}

	loadCollapseState() {
		const collapsed = localStorage.getItem("kirra-toolbar-collapsed") === "true";
		if (collapsed) {
			this.toggleCollapse();
		}

		const visible = localStorage.getItem("kirra-toolbar-visible") !== "false";
		if (!visible) {
			this.hide();
		}
	}
}

// Step 3) Initialize the new toolbar panel
let toolbarPanel;
document.addEventListener("DOMContentLoaded", () => {
	toolbarPanel = new ToolbarPanel();
});

// Step 4) Update any existing references to show/hide toolbar
// For example, if you have a menu option to show the toolbar:
function showToolbar() {
	if (toolbarPanel) {
		toolbarPanel.show();
	} else {
		document.getElementById("toolbarPanel").style.display = "flex";
	}
}
//#endregion TOOLBAR
//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//

// Add event listeners for the floating toolbar buttons
const selectPointerTool = document.getElementById("selectPointer");
const selectByPolygonTool = document.getElementById("selectByPolygon");
const resetViewTool = document.getElementById("resetViewTool");
const moveToTool = document.getElementById("moveToTool");
const bearingTool = document.getElementById("bearingTool");
const rulerTool = document.getElementById("rulerTool");
const rulerProtractorTool = document.getElementById("rulerProtractorTool");

const selectHolesRadio = document.getElementById("selectHoles"); // Step 1) Radio: holes
const selectKADRadio = document.getElementById("selectKAD"); // Step 2) Radio: KAD

// Step 3) Radio change handlers - enforce exclusive selection type
selectHolesRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear KAD selections
		selectedKADObject = null;
		selectedKADPolygon = null;
		selectedMultipleKADObjects = [];
		updateStatusMessage("Selection mode: Holes only");
		drawData(allBlastHoles, selectedHole);
	}
});
selectKADRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear Hole selections
		selectedHole = null;
		selectedMultipleHoles = [];
		updateStatusMessage("Selection mode: KAD only");
		drawData(allBlastHoles, selectedHole);
	}
});

//---------------MOVE TOOL---------------//
// --- Move Tool State ---

let isDraggingHole = false;
let dragStartX = 0,
	dragStartY = 0;
let dragStartWorldX = 0,
	dragStartWorldY = 0;
let dragInitialPositions = [];

// Store the previous tool state to restore it when move tool is deactivated
let previousToolState = {
	isSelectionPointerActive: false,
	isPolygonSelectionActive: false,
	selectionMode: false
};
// Helper function to remove all canvas listeners
function removeAllCanvasListenersKeepDefault() {
	// Selection tool handlers
	canvas.removeEventListener("click", handleSelection);
	canvas.removeEventListener("touchstart", handleSelection);
	canvas.removeEventListener("click", selectInsidePolygon);
	canvas.removeEventListener("dblclick", completePolygonSelection);
	canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
	canvas.removeEventListener("mousemove", handlePolygonMouseMove);

	// Move tool handlers
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Bearing tool handlers
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);
}

//------------------------- MOVE TO TOOL START------------//
// --- Move Tool Activation ---
moveToTool.addEventListener("change", function () {
	if (this.checked) {
		// Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;
		endKadTools();
		resetFloatingToolbarButtons("moveToTool");
		// DON'T remove all canvas listeners - keep the main mouse tracking
		removeAllCanvasListenersKeepDefault();

		// Store current state to restore later
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		isMoveToolActive = true;
		moveToolSelectedHole = null;
		isDraggingHole = false;
		canvas.addEventListener("mousedown", handleMoveToolMouseDown);
		canvas.addEventListener("touchstart", handleMoveToolMouseDown);
		updateStatusMessage("Move Tool Activated\nSelect a hole and drag to move");
	} else {
		resetFloatingToolbarButtons("none");

		// Remove move tool listeners
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);

		// Clear move tool state
		isMoveToolActive = false;
		isDraggingHole = false;
		moveToolSelectedHole = null;

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners} else {
		resetFloatingToolbarButtons("none");

		// Remove move tool listeners
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);

		// ✅ ADD: Clear move tool state
		isMoveToolActive = false;
		isDraggingHole = false;
		moveToolSelectedHole = null;

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);

		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");

		// ✅ ADD: Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// Restore ruler tools if they were active
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}

		// ✅ ADD: Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}
		drawData(allBlastHoles, selectedHole);
	}
});

// Handle move tool mouse down - start dragging if holes are selected
function handleMoveToolMouseDown(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	// Step A) Convert CSS pixels -> canvas pixels (fixes staccato/offset on HiDPI)
	const scaleX = canvas.width / rect.width;
	const scaleY = canvas.height / rect.height;
	// Use raw canvas coordinates like the ruler tool
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// Step 10) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	if (selectingKAD) {
		// Prefer moving a KAD vertex
		const clickedKAD = getClickedKADObject(clickX, clickY);
		if (clickedKAD) {
			const entity = allKADDrawingsMap.get(clickedKAD.entityName);
			if (entity && entity.data && entity.data.length > 0) {
				// Resolve target index: vertex or nearest endpoint of segment
				let targetIndex = clickedKAD.elementIndex;
				if (clickedKAD.selectionType === "segment") {
					const worldClick = canvasToWorld(clickX, clickY);
					const i = clickedKAD.segmentIndex;
					const p1 = entity.data[i];
					const p2 = entity.data[(i + 1) % entity.data.length];
					const d1 = Math.hypot(worldClick[0] - p1.pointXLocation, worldClick[1] - p1.pointYLocation);
					const d2 = Math.hypot(worldClick[0] - p2.pointXLocation, worldClick[1] - p2.pointYLocation);
					targetIndex = d1 <= d2 ? i : (i + 1) % entity.data.length;
				}

				// Step 1) Store move target and highlight it
				moveToolSelectedKAD = {
					entityName: clickedKAD.entityName,
					elementIndex: targetIndex,
					// Add initial position storage like holes do
					initialX: entity.data[targetIndex].pointXLocation,
					initialY: entity.data[targetIndex].pointYLocation,
					initialZ: entity.data[targetIndex].pointZLocation
				};
				moveToolKADOriginalZ = parseFloat(entity.data[targetIndex].pointZLocation) || 0;

				// Step 2) Set selected KAD object for highlighting
				selectedKADObject = {
					entityName: clickedKAD.entityName,
					entityType: entity.entityType,
					elementIndex: targetIndex,
					selectionType: "vertex",
					pointXLocation: entity.data[targetIndex].pointXLocation,
					pointYLocation: entity.data[targetIndex].pointYLocation,
					pointZLocation: entity.data[targetIndex].pointZLocation
				};
				selectedPoint = entity.data[targetIndex];
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];

				// Step 3) Redraw to show the highlighted selection
				drawData(allBlastHoles, selectedHole);

				// Step 4) Start dragging process
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Move KAD point - drag to reposition");
				return;
			} else {
				// Step 5) Clicked empty space - clear any KAD selection
				moveToolSelectedKAD = null;
				selectedKADObject = null;
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];
				drawData(allBlastHoles, selectedHole);
				return;
			}
		}
	}
	if (selectingHoles) {
		// First priority: Use existing selections without checking for clicked holes
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			// Use multiple selected holes - start dragging immediately
			moveToolSelectedHole = selectedMultipleHoles;
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = selectedMultipleHoles.map((hole) => ({
				hole: hole,
				x: hole.startXLocation,
				y: hole.startYLocation
			}));
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else if (selectedHole) {
			// Use single selected hole - start dragging immediately
			moveToolSelectedHole = [selectedHole];
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = [
				{
					hole: selectedHole,
					x: selectedHole.startXLocation,
					y: selectedHole.startYLocation
				}
			];
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else {
			// No existing selections - check if we clicked on a hole to select it
			const clickedHole = getClickedHole(clickX, clickY);

			if (clickedHole) {
				// No holes selected but clicked on a hole - select it and start dragging
				selectedHole = clickedHole;
				moveToolSelectedHole = [clickedHole];
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				dragInitialPositions = [
					{
						hole: clickedHole,
						x: clickedHole.startXLocation,
						y: clickedHole.startYLocation
					}
				];
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				drawData(allBlastHoles, selectedHole);
			} else {
				// Clicked empty space with no holes selected - clear selection
				selectedHole = null;
				selectedPoint = null;
				//selectedMultiplePoints = [];
				selectedMultipleHoles = [];
				moveToolSelectedHole = null;
				drawData(allBlastHoles, selectedHole);
			}
		}
	}
}




// Handle move tool mouse move - move holes
function handleMoveToolMouseMove(event) {
	if (!isDraggingHole || (!moveToolSelectedHole && !moveToolSelectedKAD)) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);
	// Calculate movement delta
	const deltaX = (clientX - dragStartX) / currentScale;
	const deltaY = -(clientY - dragStartY) / currentScale;

	// Step 12) KAD move branch
	if (moveToolSelectedKAD) {
		const entity = allKADDrawingsMap.get(moveToolSelectedKAD.entityName);
		if (entity && entity.data && moveToolSelectedKAD.elementIndex < entity.data.length) {
			const rect = canvas.getBoundingClientRect();
			const scaleX = canvas.width / rect.width;
			const scaleY = canvas.height / rect.height;
			const canvasX = (clientX - rect.left) * scaleX;
			const canvasY = (clientY - rect.top) * scaleY;

			// Convert to world coordinates first
			const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
			const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

			// Use the excluding snap function
			// Use regular snap (including self-snap) if 'S' is held; otherwise exclude
			let snapResult;
			if (isSelfSnapEnabled) {
				snapResult = snapToNearestPoint(rawWorldX, rawWorldY);
			} else {
				snapResult = snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, moveToolSelectedKAD.entityName, moveToolSelectedKAD.elementIndex);
			}

			entity.data[moveToolSelectedKAD.elementIndex].pointXLocation = snapResult.worldX;
			entity.data[moveToolSelectedKAD.elementIndex].pointYLocation = snapResult.worldY;
			entity.data[moveToolSelectedKAD.elementIndex].pointZLocation = snapResult.snapped && snapResult.worldZ ? snapResult.worldZ : moveToolSelectedKAD.initialZ || 0;

			// Keep highlight in sync while dragging
			if (selectedKADObject && selectedKADObject.entityName === moveToolSelectedKAD.entityName && selectedKADObject.elementIndex === moveToolSelectedKAD.elementIndex) {
				selectedKADObject.pointXLocation = snapResult.worldX;
				selectedKADObject.pointYLocation = snapResult.worldY;
				selectedKADObject.pointZLocation = entity.data[moveToolSelectedKAD.elementIndex].pointZLocation;
			}

			// Keep selectedPoint in sync while dragging
			selectedPoint = entity.data[moveToolSelectedKAD.elementIndex];
		}
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Move all selected holes
	dragInitialPositions.forEach(({ hole, x, y }) => {
		calculateHoleGeometry(hole, parseFloat(x) + deltaX, 4); // Parameter 4 for X position
		calculateHoleGeometry(hole, parseFloat(y) + deltaY, 5); // Parameter 5 for Y position
	});

	// Throttle contour recalculation for better performance
	let disableContourThrottling = false; // Temporary flag to disable throttling
	if (disableContourThrottling || !contourUpdatePending) {
		if (!disableContourThrottling) {
			contourUpdatePending = true;
		}

		const updateContours = () => {
			if (allBlastHoles.length > 0) {
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, 0, 0);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				timeChart();
			}
			if (!disableContourThrottling) {
				contourUpdatePending = false;
			}
		};

		if (disableContourThrottling) {
			updateContours();
		} else {
			requestAnimationFrame(updateContours);
		}
	}

	drawData(allBlastHoles, selectedHole);
}
// Handle move tool mouse up - stop dragging
function handleMoveToolMouseUp(event) {
	if (isDraggingHole) {
		isDraggingHole = false;
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);

		// Step 13) Persist KAD changes if applicable
		if (moveToolSelectedKAD) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			moveToolSelectedKAD = null;
		}

		// Save changes and recalculate everything
		if (moveToolSelectedHole) {
			saveHolesToLocalStorage(allBlastHoles);

			// Recalculate everything after holes are moved
			if (allBlastHoles.length > 0) {
				// Recalculate triangulation
				if (displayContours.checked || displayRelief.checked || displayFirstMovements.checked) {
					const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

					// Recalculate hole times
					holeTimes = calculateTimes(allBlastHoles);

					// Recalculate contours
					const result = recalculateContours(allBlastHoles, 0, 0);
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}
			}
		}
		// Clear single selection and multiple selection.
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		moveToolSelectedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
}
//---------------END OF MOVE TOOL---------------//

//---------------BEARING TOOL---------------//
// Add event listener for the bearing tool
bearingTool.addEventListener("change", function () {
	if (this.checked) {
		// Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;

		resetFloatingToolbarButtons("bearingTool");
		removeAllCanvasListenersKeepDefault();

		// ✅ ADD: Store current state to restore later (was missing!)
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		isBearingToolActive = true;
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
		canvas.addEventListener("mousedown", handleBearingToolMouseDown);
		canvas.addEventListener("touchstart", handleBearingToolMouseDown);
		updateStatusMessage("Bearing Tool Activated\nSelect a hole and drag to rotate\nHold 'F' for focus mode");
		// Add keydown listener for F key
		document.addEventListener("keydown", handleBearingToolKeyDown);
		document.addEventListener("keyup", handleBearingToolKeyUp);
	} else {
		resetFloatingToolbarButtons("none");

		// Remove bearing tool listeners
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Remove key listeners
		document.removeEventListener("keydown", handleBearingToolKeyDown);
		document.removeEventListener("keyup", handleBearingToolKeyUp);

		// ✅ ADD: Clear bearing tool state
		isBearingToolActive = false;
		isDraggingBearing = false;
		bearingToolSelectedHole = null;

		// ✅ ADD: Clear the focus mode flag
		isFocusModeActive = false;

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);

		// Restore default canvas handlers so other tools work properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ✅ ADD: Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// ✅ ADD: Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}

		// Restore ruler protractor click handler if it was active
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Track F key state
let isFocusModeActive = false;

// Handle F key press for focus mode
function handleBearingToolKeyDown(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = true;
	}
}

function handleBearingToolKeyUp(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = false;
	}
}

// Handle bearing tool mouse down - start dragging if holes are selected
function handleBearingToolMouseDown(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// First priority: Use existing selections without checking for clicked holes
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// Use multiple selected holes - start dragging immediately
		bearingToolSelectedHole = selectedMultipleHoles;
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else if (selectedHole) {
		// Use single selected hole - start dragging immediately
		bearingToolSelectedHole = [selectedHole];
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else {
		// No existing selections - check if we clicked on a hole to select it
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole) {
			// No holes selected but clicked on a hole - select it and start dragging
			selectedHole = clickedHole;
			bearingToolSelectedHole = [clickedHole];
			isDraggingBearing = true;
			canvas.addEventListener("mousemove", handleBearingToolMouseMove);
			canvas.addEventListener("touchmove", handleBearingToolMouseMove);
			canvas.addEventListener("mouseup", handleBearingToolMouseUp);
			canvas.addEventListener("touchend", handleBearingToolMouseUp);
			drawData(allBlastHoles, selectedHole);
		} else {
			// Clicked empty space with no holes selected - clear selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			bearingToolSelectedHole = null;
			drawData(allBlastHoles, selectedHole);
		}
	}
}
// Handle bearing tool mouse move - rotate bearing
function handleBearingToolMouseMove(event) {
	if (!isDraggingBearing || !bearingToolSelectedHole) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isFocusModeActive) {
		// Focus mode: Each hole points to mouse location (original behavior)
		bearingToolSelectedHole.forEach((hole) => {
			const eastingDiff = worldX - parseFloat(hole.startXLocation);
			const northingDiff = worldY - parseFloat(hole.startYLocation);

			let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
			if (newBearing < 0) newBearing += 360;

			calculateHoleGeometry(hole, newBearing, 3);
		});
	} else {
		// Default mode: All holes get same bearing based on first hole
		const firstHole = bearingToolSelectedHole[0];
		const eastingDiff = worldX - parseFloat(firstHole.startXLocation);
		const northingDiff = worldY - parseFloat(firstHole.startYLocation);

		let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
		if (newBearing < 0) newBearing += 360;

		// Apply the same bearing to all selected holes
		bearingToolSelectedHole.forEach((hole) => {
			calculateHoleGeometry(hole, newBearing, 3);
		});
	}

	drawData(allBlastHoles, selectedHole);
}

// Handle bearing tool mouse up - stop dragging
function handleBearingToolMouseUp(event) {
	if (isDraggingBearing) {
		isDraggingBearing = false;
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Save changes
		if (bearingToolSelectedHole) {
			saveHolesToLocalStorage(allBlastHoles);
		}
		// Clear single selection and he multiple selection
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}
}

//---------------END OF BEARING TOOL---------------//

//---------------SELECTION TOOLS---------------//
selectPointerTool.addEventListener("change", function () {
	if (this.checked) {
		isSelectionPointerActive = true;
		isPolygonSelectionActive = false;
		isMultiHoleSelectionEnabled = false;
		//selectedKADPolygon = null;
		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectPointerTool");
		clearAllSelectionState();
		endKadTools();
		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Enable point selection mode
		canvas.addEventListener("click", handleSelection);
		canvas.addEventListener("touchstart", handleSelection);
		updateStatusMessage("Point selection mode enabled\nShift to select multiple.\n Escape to clear selection.");
		drawData(allBlastHoles, selectedHole);
	} else {
		isSelectionPointerActive = false;
		isMultiHoleSelectionEnabled = false;
		// Disable point selection mode
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Update the function to properly check and handle KAD tools
function kadContextMenu(e) {
	e.preventDefault(); // Prevent context menu

	// Check if any KAD drawing tool is active
	const anyKADToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked;

	if (anyKADToolActive) {
		// Start a new object within the same tool
		createNewEntity = true; // This will create a new entity name on next click
		lastKADDrawPoint = null; // Reset preview line

		// Show status message
		updateStatusMessage("Starting new object - continue drawing");

		// Brief visual feedback
		setTimeout(() => {
			updateStatusMessage("");
		}, 1500);

		// Redraw to clear any preview lines
		drawData(allBlastHoles, selectedHole);
	}
}

///-----------------------------RIGHT CLICK STUFF GOES HERE-----------------------------//

// Add this function near your other menu functions
function closeAllContextMenus() {
	// Find all elements that could be context menus
	const existingMenus = document.querySelectorAll('.context-menu, [style*="position: absolute"][style*="background"], div[onclick]');

	existingMenus.forEach((menu) => {
		// Check if it looks like a context menu (has background and position styling)
		const style = menu.style;
		if (style.position === "absolute" && (style.background || style.backgroundColor) && document.body.contains(menu)) {
			try {
				document.body.removeChild(menu);
				console.log("🗑️ Removed existing context menu");
				debouncedUpdateTreeView(); // Use debounced version
			} catch (error) {
				// Menu already removed
			}
		}
	});
}

// Modified context menu handler to support multiple KAD objects
canvas.addEventListener("contextmenu", function (e) {
	e.preventDefault();
	closeAllContextMenus();

	// Prevent right-click from triggering drag behavior
	isDragging = false;
	clearTimeout(longPressTimeout);

	const anyKADToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked;

	const rect = canvas.getBoundingClientRect();
	const clickX = e.clientX - rect.left;
	const clickY = e.clientY - rect.top;

	// If a KAD tool is active, handle new object creation
	if (anyKADToolActive) {
		clearCurrentDrawingEntity();
		kadContextMenu(e);
		return;
	}

	// Get the clicked object to check if it's within snap radius
	const clickedHole = getClickedHole(clickX, clickY);
	const clickedKADObject = getClickedKADObject(clickX, clickY);

	// Check if we clicked within snap radius of a selected object
	const snapRadius = getSnapToleranceInWorldUnits();
	const worldCoords = canvasToWorld(clickX, clickY);

	// For multiple KAD objects selected
	if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 1) {
		// Check if we clicked on one of the selected objects
		let clickedOnSelected = false;

		for (const kadObj of selectedMultipleKADObjects) {
			const entity = allKADDrawingsMap.get(kadObj.entityName);
			if (entity) {
				for (const point of entity.data) {
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldCoords[0], 2) + Math.pow(point.pointYLocation - worldCoords[1], 2));
					if (distance <= snapRadius) {
						clickedOnSelected = true;
						break;
					}
				}
			}
			if (clickedOnSelected) break;
		}

		if (clickedOnSelected) {
			showMultipleKADPropertyEditor(selectedMultipleKADObjects);
			debouncedUpdateTreeView();
			return;
		}
	}

	// For holes: Check multiple selection first, then single hole
	if (selectedMultipleHoles && selectedMultipleHoles.length > 1) {
		// Check if we clicked on one of the selected holes
		let clickedOnSelected = false;
		for (const hole of selectedMultipleHoles) {
			const distance = Math.sqrt(Math.pow(hole.startXLocation - worldCoords[0], 2) + Math.pow(hole.startYLocation - worldCoords[1], 2));
			if (distance <= snapRadius) {
				clickedOnSelected = true;
				break;
			}
		}

		if (clickedOnSelected) {
			showHolePropertyEditor(selectedMultipleHoles);
			debouncedUpdateTreeView();
			return;
		}
	}

	if (clickedHole) {
		const holeDistance = Math.sqrt(Math.pow(clickedHole.startXLocation - worldCoords[0], 2) + Math.pow(clickedHole.startYLocation - worldCoords[1], 2));
		if (holeDistance <= snapRadius) {
			showHolePropertyEditor(clickedHole);
			debouncedUpdateTreeView();
			return;
		}
	}

	// For single KAD objects
	if (isSelectionPointerActive || isPolygonSelectionActive) {
		if (clickedKADObject) {
			// Check if within snap radius
			let withinSnapRadius = false;
			const entity = allKADDrawingsMap.get(clickedKADObject.entityName);

			if (entity) {
				if (clickedKADObject.selectionType === "vertex") {
					// For vertex selection, check distance to the specific vertex
					const point = entity.data[clickedKADObject.elementIndex];
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldCoords[0], 2) + Math.pow(point.pointYLocation - worldCoords[1], 2));
					withinSnapRadius = distance <= snapRadius;
				} else if (clickedKADObject.selectionType === "segment") {
					// For segment selection, use the clicked position
					withinSnapRadius = true; // Already validated by getClickedKADObject
				}
			}

			if (withinSnapRadius && isKADObjectSelected(clickedKADObject)) {
				showKADPropertyEditorPopup(clickedKADObject);
				debouncedUpdateTreeView();
				return;
			}
		}
	}

	// Check for surfaces and other context menus...
	const clickedSurfaceId = isPointInSurface(clickX, clickY);
	if (clickedSurfaceId) {
		showSurfaceContextMenu(clickX, clickY, clickedSurfaceId);
		return;
	}

	// Check for background images...
	let clickedImageId = null;
	for (const [imageId, image] of loadedImages.entries()) {
		if (image.visible && isPointInBackgroundImage(clickX, clickY, image)) {
			clickedImageId = imageId;
			break;
		}
	}

	if (clickedImageId) {
		showImageContextMenu(clickX, clickY, clickedImageId);
		return;
	}

	// Default canvas context menu...
	try {
		showContextMenu(e);
	} catch (err) {
		// Step 1) Show status message for right clicks without objects
		updateStatusMessage("Right clicks need to be performed on an Object.");

		// Step 2) Set timeout to clear message after 1000ms
		setTimeout(() => {
			updateStatusMessage("");
		}, 2000);
		console.log(err);
	}
});

function isClickOnSelectedPolygon(worldX, worldY, selectedPolygon) {
	if (!selectedPolygon || !allKADDrawingsMap.has(selectedPolygon.entityName)) {
		return null;
	}

	const entity = allKADDrawingsMap.get(selectedPolygon.entityName);
	const points = entity.data;
	const tolerance = getSnapToleranceInWorldUnits(); // Adjust click tolerance based on zoom

	// Check if click is on any point of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		const dx = worldX - point.pointXLocation;
		const dy = worldY - point.pointYLocation;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance) {
			// Return the clicked point with metadata - USE DYNAMIC VALUES
			return {
				...point,
				mapType: "allKADDrawingsMap", // ← Use unified map name
				entityType: entity.entityType, // ← Use actual entity type from data
				entityName: entity.entityName // ← Add entity name for consistency
			};
		}
	}

	// Check if click is on any segment of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point1 = points[i];
		const point2 = points[(i + 1) % points.length]; // Wrap around to first point

		// Calculate distance from click point to line segment
		const segmentDistance = distanceToLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

		if (segmentDistance <= tolerance) {
			// Return the first point of the segment with metadata - USE DYNAMIC VALUES
			return {
				...point1,
				mapType: "allKADDrawingsMap", // ← Use unified map name
				entityType: entity.entityType, // ← Use actual entity type from data
				entityName: entity.entityName // ← Add entity name for consistency
			};
		}
	}

	return null;
}

// Helper function to calculate distance from point to line segment
function distanceToLineSegment(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;
	const length = dx * dx + dy * dy;

	if (length === 0) {
		// Points are the same, return distance to point
		const dpx = px - x1;
		const dpy = py - y1;
		return Math.sqrt(dpx * dpx + dpy * dpy);
	}

	// Calculate parameter t for closest point on line segment
	const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / length));

	// Calculate closest point on segment
	const closestX = x1 + t * dx;
	const closestY = y1 + t * dy;

	// Return distance to closest point
	const dcx = px - closestX;
	const dcy = py - closestY;
	return Math.sqrt(dcx * dcx + dcy * dcy);
}

// ENHANCED: Fix getClickedKADObject to return specific element information
function getClickedKADObject(clickX, clickY) {
	const worldX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(clickY - canvas.height / 2) / currentScale + centroidY;

	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		const tolerance = getSnapToleranceInWorldUnits();
		let closestMatch = null;
		let minDistance = tolerance;

		// Iterate through all entities
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			// ✅ CHECK VISIBILITY FIRST - Skip hidden entities
			if (!isEntityVisible(entityName)) continue;
			// For single-point entities (points, circles, text)
			if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
				for (let i = 0; i < entity.data.length; i++) {
					const point = entity.data[i];
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));

					if (distance <= tolerance && distance < minDistance) {
						closestMatch = {
							...point,
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i,
							selectionType: "point"
						};
						minDistance = distance;
					}
				}
			}
			// For multi-point entities (lines and polygons) - prioritize SEGMENTS over vertices
			else if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length < 2) continue;

				// FIRST: Check segments (higher priority than vertices)
				const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

				for (let i = 0; i < numSegments; i++) {
					const point1 = points[i];
					const point2 = points[(i + 1) % points.length]; // Wrap for polygons

					// Calculate distance from click to line segment
					const segmentDistance = pointToLineSegmentDistance(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

					if (segmentDistance <= tolerance && segmentDistance < minDistance) {
						// Find the closest point on the segment for the clicked location
						const closestPoint = getClosestPointOnLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

						closestMatch = {
							...point1, // Use first point's properties as base
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i, // This is the specific segment clicked
							selectionType: "segment",
							clickedX: closestPoint.x,
							clickedY: closestPoint.y
						};
						minDistance = segmentDistance;
					}
				}

				// SECOND: Check vertices (lower priority, only if no segment found)
				if (!closestMatch) {
					for (let i = 0; i < points.length; i++) {
						const point = points[i];
						const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));

						if (distance <= tolerance && distance < minDistance) {
							closestMatch = {
								...point,
								mapType: "allKADDrawingsMap",
								entityName: entityName,
								entityType: entity.entityType,
								elementIndex: i,
								segmentIndex: i,
								selectionType: "vertex"
							};
							minDistance = distance;
						}
					}
				}
			}
		}

		return closestMatch;
	}

	return null;
}
// Helper function to check if a clicked KAD object is currently selected
function isKADObjectSelected(clickedObject) {
	if (!clickedObject) return false;

	// Check against selectedKADObject
	if (selectedKADObject) {
		return selectedKADObject.entityName === clickedObject.entityName && selectedKADObject.elementIndex === clickedObject.elementIndex && selectedKADObject.entityType === clickedObject.entityType;
	}

	// Check against selectedKADPolygon (backward compatibility)
	if (selectedKADPolygon && clickedObject.entityType === "poly") {
		return selectedKADPolygon.entityName === clickedObject.entityName;
	}

	return false;
}

function jsColorPaletteForPicker() {
	// These options apply to all color pickers on the page
	jscolor.presets.default = {
		format: "rgb",
		palette: [
			"#770000",
			"#FF0000",
			"#FF9900",
			"#FFFF00",
			"#00ff00",
			"#009900",
			"#00ffFF",
			"#0099ff",
			"#0000FF",
			"#FF00FF", //10 per row
			"#550000",
			"#AA0000",
			"#883300",
			"#bbbb00",
			"#33AA00",
			"#006600",
			"#007F7F",
			"#002288",
			"#000099",
			"#7F007F", //10 per row
			"#010101",
			"#222222",
			"#333333",
			"#444444",
			"#555555",
			"#777777",
			"#888888",
			"#AAAAAA",
			"#cccccc",
			"#FEFEFE"
		]
	};
}

// ENHANCED: Unified KAD Property Editor with FloatingDialog and hide functionality
function showKADPropertyEditorPopup(kadObject) {
	const isMultiElement = kadObject.entityType === "line" || kadObject.entityType === "poly" || kadObject.entityType === "point" || kadObject.entityType === "circle" || kadObject.entityType === "text";

	const entity = getEntityFromKADObject(kadObject);
	const hasMultipleElements = entity && entity.data.length > 1;

	// Determine if this is a line/poly (they share the same dialog)
	const isLineOrPoly = kadObject.entityType === "line" || kadObject.entityType === "poly";

	const title = hasMultipleElements ? `Edit ${kadObject.entityType.toUpperCase()} - ${kadObject.entityName} - Element ${kadObject.elementIndex + 1}` : `Edit ${kadObject.entityType.toUpperCase()} - ${kadObject.entityName}`;

	const currentColor = kadObject.color || "#FF0000";

	// Define form fields using the same pattern as showHolePropertyEditor
	const fields = [
		{
			label: "Color",
			name: "editKADColor",
			type: "color",
			value: currentColor
		},
		{
			label: "X Location",
			name: "editXLocation",
			type: "number",
			value: kadObject.pointXLocation || 0,
			step: "0.001"
		},
		{
			label: "Y Location",
			name: "editYLocation",
			type: "number",
			value: kadObject.pointYLocation || 0,
			step: "0.001"
		},
		{
			label: "Z Location",
			name: "editZLocation",
			type: "number",
			value: kadObject.pointZLocation || 0,
			step: "0.001"
		},
		{
			label: "Only Z (set all Z values to this value)",
			name: "onlyZCheckbox",
			type: "checkbox",
			checked: kadObject.onlyZ || false
		}
	];

	// Add specific fields based on entity type
	if (isLineOrPoly) {
		fields.push({
			label: "Line Width",
			name: "editLineWidth",
			type: "number",
			value: kadObject.lineWidth || 1,
			min: "0.1",
			max: "10",
			step: "0.1"
		});

		fields.push({
			label: "Type",
			name: "editType",
			type: "select",
			value: kadObject.entityType,
			options: [
				{
					value: "line",
					text: "Open (Line)"
				},
				{
					value: "poly",
					text: "Closed (Polygon)"
				}
			]
		});
	} else if (kadObject.entityType === "circle") {
		fields.push({
			label: "Radius",
			name: "editRadius",
			type: "number",
			value: kadObject.radius || 1,
			min: "0.1",
			max: "100",
			step: "0.1"
		});
	} else if (kadObject.entityType === "text") {
		fields.push({
			label: "Text",
			name: "editText",
			type: "text",
			value: kadObject.text || ""
		});
	} else if (kadObject.entityType === "point") {
		fields.push({
			label: "Point Diameter/Line Width",
			name: "editLineWidth",
			type: "number",
			value: kadObject.lineWidth || 1,
			min: "0.1",
			max: "10",
			step: "0.1"
		});
	}

	// Create enhanced form content using the existing helper function
	const formContent = createEnhancedFormContent(fields, hasMultipleElements, false);

	// Add info note
	const noteDiv = document.createElement("div");
	noteDiv.style.fontSize = "12px";
	noteDiv.style.color = "#aaa";
	noteDiv.style.gridColumn = "1 / -1";
	noteDiv.style.marginTop = "10px";
	noteDiv.innerHTML = `
        <b>All:</b> Move all points by the same offset as this point (unless Only Z is checked).<br>
        <b>This:</b> Move only this point (unless Only Z is checked).
    `;
	formContent.appendChild(noteDiv);

	// Create the dialog with 4 buttons
	const dialog = new FloatingDialog({
		title: title,
		content: formContent,
		layoutType: "compact",
		showConfirm: hasMultipleElements, // Show "All" button only for multi-element objects
		showDeny: true, // "This" button
		showCancel: true, // "Cancel" button
		showOption1: true, // "Hide" button
		confirmText: "All",
		denyText: "This",
		cancelText: "Cancel",
		option1Text: "Hide",
		width: 350,
		height: isLineOrPoly ? 400 : 350,
		onConfirm: () => {
			// Get form values and apply to all elements
			const formData = getFormData(formContent);

			// Handle line/poly conversion first
			const isLineOrPoly = kadObject.entityType === "line" || kadObject.entityType === "poly";
			if (isLineOrPoly && formData.editType && formData.editType !== kadObject.entityType) {
				convertLinePolyType(kadObject, formData.editType);
			}

			// Build properties object
			const newProperties = {
				color: formData.editKADColor,
				pointXLocation: parseFloat(formData.editXLocation),
				pointYLocation: parseFloat(formData.editYLocation),
				pointZLocation: parseFloat(formData.editZLocation),
				lineWidth: formData.editLineWidth,
				radius: formData.editRadius,
				text: formData.editText,
				onlyZ: formData.onlyZCheckbox
			};

			// Use existing function
			updateKADObjectProperties(kadObject, newProperties, "all");
			debouncedSaveKAD();
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
		},
		onDeny: () => {
			// Get form values and apply to this element only
			const formData = getFormData(formContent);

			// Handle line/poly conversion first
			const isLineOrPoly = kadObject.entityType === "line" || kadObject.entityType === "poly";
			if (isLineOrPoly && formData.editType && formData.editType !== kadObject.entityType) {
				convertLinePolyType(kadObject, formData.editType);
			}

			// Build properties object
			const newProperties = {
				color: formData.editKADColor,
				pointXLocation: parseFloat(formData.editXLocation),
				pointYLocation: parseFloat(formData.editYLocation),
				pointZLocation: parseFloat(formData.editZLocation),
				lineWidth: formData.editLineWidth,
				radius: formData.editRadius,
				text: formData.editText,
				onlyZ: formData.onlyZCheckbox
			};

			// Use existing function
			updateKADObjectProperties(kadObject, newProperties, "element");
			debouncedSaveKAD();
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
		},
		onCancel: () => {
			// Just close, no changes
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
		},
		onOption1: () => {
			// Hide entire entity using the proper visibility function
			setKADEntityVisibility(kadObject.entityName, false);
			clearAllSelectionState();
			//debouncedSaveKAD(); don't save visbility it is only for the view.
			drawData(allBlastHoles, selectedHole);
			dialog.close();
		}
	});

	dialog.show();
}

// New function to show property editor for multiple KAD objects
function showMultipleKADPropertyEditor(kadObjects) {
	if (!kadObjects || kadObjects.length === 0) return;

	// Create form content
	const formContent = document.createElement("div");

	// Common properties that can be edited for all polygons
	const fields = [
		{
			label: "Color",
			name: "editKADColor",
			type: "color",
			value: kadObjects[0].data?.[0]?.color || "#FF0000"
		},
		{
			label: "Line Width",
			name: "editLineWidth",
			type: "number",
			value: kadObjects[0].data?.[0]?.lineWidth || "2",
			step: "0.5",
			min: "0.5",
			max: "10"
		},
		{
			label: "Z Elevation",
			name: "editZLocation",
			type: "number",
			value: "0",
			step: "0.1"
		}
	];

	// Create form fields
	fields.forEach((field) => {
		const fieldDiv = document.createElement("div");
		fieldDiv.className = "form-field";
		fieldDiv.style.marginBottom = "10px";

		const label = document.createElement("label");
		label.textContent = field.label + ":";
		label.style.display = "inline-block";
		label.style.width = "100px";
		fieldDiv.appendChild(label);

		const input = document.createElement("input");
		input.type = field.type;
		input.name = field.name;
		input.value = field.value;

		if (field.type === "number") {
			input.step = field.step || "1";
			if (field.min) input.min = field.min;
			if (field.max) input.max = field.max;
		}

		if (field.type === "color") {
			input.className = "jscolor";
			input.setAttribute("data-jscolor", "{}");
		}

		fieldDiv.appendChild(input);
		formContent.appendChild(fieldDiv);
	});

	// Add note about multiple selection
	const noteDiv = document.createElement("div");
	noteDiv.style.marginTop = "15px";
	noteDiv.style.fontSize = "12px";
	noteDiv.style.color = "#666";
	noteDiv.innerHTML = "Editing " + kadObjects.length + " polygon(s)";
	formContent.appendChild(noteDiv);

	// Create dialog
	const dialog = new FloatingDialog({
		title: "Edit Multiple Polygons",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 250,
		showConfirm: true,
		showCancel: true,
		confirmText: "Apply",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			// Apply changes to all selected polygons
			kadObjects.forEach((kadObj) => {
				const entity = allKADDrawingsMap.get(kadObj.entityName);
				if (entity) {
					// Update all points in the polygon
					entity.data.forEach((point) => {
						if (formData.editKADColor) {
							point.color = formData.editKADColor;
						}
						if (formData.editLineWidth) {
							point.lineWidth = parseFloat(formData.editLineWidth);
						}
						if (formData.editZLocation) {
							point.pointZLocation = parseFloat(formData.editZLocation);
						}
					});
				}
			});

			// Save and redraw
			debouncedSaveKAD();
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
			updateStatusMessage("Updated " + kadObjects.length + " polygon(s)");
			setTimeout(() => updateStatusMessage(""), 2000);
		},
		onCancel: () => {
			// Just close
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
		}
	});

	dialog.show();

	// Initialize color picker if present
	if (typeof jscolor !== "undefined") {
		jscolor.install();
	}
}

// NEW: Function to convert between line and poly
function convertLinePolyType(kadObject, newType) {
	const entity = getEntityFromKADObject(kadObject);
	if (!entity) return;

	// Update entity type
	entity.entityType = newType;

	// Update all data points to reflect the new type
	entity.data.forEach((point) => {
		point.entityType = newType;
		if (newType === "poly") {
			point.closed = true;
		} else {
			point.closed = false;
		}
	});

	updateStatusMessage(`Converted ${kadObject.entityName} to ${newType}`);
	debouncedUpdateTreeView(); // ✅ ADDED: Update tree view swatches
	setTimeout(() => updateStatusMessage(""), 2000);
}

function updateKADObjectProperties(kadObject, newProperties, scope = "all") {
	const map = allKADDrawingsMap;
	const entity = map.get(kadObject.entityName);

	if (entity) {
		const onlyZ = newProperties.onlyZ;
		if (scope === "element") {
			// Only this point
			const elementIndex = kadObject.elementIndex;
			if (elementIndex !== undefined && elementIndex < entity.data.length) {
				const item = entity.data[elementIndex];
				if (newProperties.color) item.color = newProperties.color;
				if (newProperties.lineWidth) item.lineWidth = parseFloat(newProperties.lineWidth);
				if (newProperties.radius) item.radius = parseFloat(newProperties.radius);
				if (newProperties.text) item.text = newProperties.text;

				if (onlyZ) {
					if (newProperties.pointZLocation !== undefined) item.pointZLocation = parseFloat(newProperties.pointZLocation);
				} else {
					if (newProperties.pointXLocation !== undefined) item.pointXLocation = parseFloat(newProperties.pointXLocation);
					if (newProperties.pointYLocation !== undefined) item.pointYLocation = parseFloat(newProperties.pointYLocation);
					if (newProperties.pointZLocation !== undefined) item.pointZLocation = parseFloat(newProperties.pointZLocation);
				}
				updateStatusMessage("Updated element " + (elementIndex + 1) + " of " + kadObject.entityType + " " + kadObject.entityName);
			}
		} else {
			// All points
			const elementIndex = kadObject.elementIndex;
			const item = entity.data[elementIndex];
			let dx = 0,
				dy = 0,
				dz = 0;
			if (!onlyZ && item) {
				if (newProperties.pointXLocation !== undefined) dx = parseFloat(newProperties.pointXLocation) - item.pointXLocation;
				if (newProperties.pointYLocation !== undefined) dy = parseFloat(newProperties.pointYLocation) - item.pointYLocation;
				if (newProperties.pointZLocation !== undefined) dz = parseFloat(newProperties.pointZLocation) - item.pointZLocation;
			}
			entity.data.forEach((pt) => {
				if (newProperties.color) pt.color = newProperties.color;
				if (newProperties.lineWidth) pt.lineWidth = parseFloat(newProperties.lineWidth);
				if (newProperties.radius) pt.radius = parseFloat(newProperties.radius);
				if (newProperties.text) pt.text = newProperties.text;
				if (newProperties.pointDiameter) pt.pointDiameter = parseFloat(newProperties.pointDiameter);

				if (onlyZ) {
					if (newProperties.pointZLocation !== undefined) pt.pointZLocation = parseFloat(newProperties.pointZLocation);
				} else {
					if (newProperties.pointXLocation !== undefined) pt.pointXLocation += dx;
					if (newProperties.pointYLocation !== undefined) pt.pointYLocation += dy;
					if (newProperties.pointZLocation !== undefined) pt.pointZLocation += dz;
				}
			});
			updateStatusMessage("Updated all elements in " + kadObject.entityType + " " + kadObject.entityName);
		}
		drawData(allBlastHoles, selectedHole);
		debouncedUpdateTreeView();
		setTimeout(() => updateStatusMessage(""), 2000);
	} else {
		console.error("Entity not found:", kadObject.entityName, "in unified map");
	}
}
// Helper to update KAD object in map
function updateKADObjectInMap(kadObject) {
	const map = window[kadObject.mapType]; // Get the map (, etc.)
	const entity = map.get(kadObject.entityName);

	if (entity) {
		// Find and update the specific object
		const objectIndex = entity.data.findIndex((item) => item.pointID === kadObject.pointID && item.pointXLocation === kadObject.pointXLocation && item.pointYLocation === kadObject.pointYLocation);

		if (objectIndex !== -1) {
			entity.data[objectIndex] = kadObject;
		}
	}
}

//TODO: Rebuild with FloatingDialog class maybe
function showSurfaceContextMenu(x, y, surfaceId = null) {
	// Get the specific surface if ID provided, otherwise first visible surface
	const surface = surfaceId ? loadedSurfaces.get(surfaceId) : Array.from(loadedSurfaces.values()).find((s) => s.visible);
	if (!surface) return;

	const menu = document.createElement("div");
	menu.className = "context-menu";
	menu.style.position = "absolute";
	menu.style.left = x + "px";
	menu.style.top = y + "px";

	// Use dynamic colors based on current theme
	const isDarkMode = document.body.classList.contains("dark-mode") || window.matchMedia("(prefers-color-scheme: dark)").matches;
	const backgroundColor = isDarkMode ? "#2d2d2d" : "#ffffff";
	const borderColor = isDarkMode ? "#555555" : "#cccccc";
	const textColor = isDarkMode ? "#ffffff" : "#000000";
	const hoverColor = isDarkMode ? "#ff0000" : "#ff0000";

	menu.style.backgroundColor = backgroundColor;
	menu.style.border = "1px solid " + borderColor;
	menu.style.borderRadius = "8px";
	menu.style.padding = "4px";
	menu.style.boxShadow = isDarkMode ? "0 2px 8px rgba(0,0,0,0.5)" : "0 2px 8px rgba(0,0,0,0.15)";
	menu.style.zIndex = "10000";
	menu.style.color = textColor;
	menu.style.minWidth = "180px";

	// --- TITLE ---
	const titleDiv = document.createElement("div");
	titleDiv.textContent = surface.name || "Surface";
	titleDiv.style.fontWeight = "bold";
	titleDiv.style.fontSize = "15px";
	titleDiv.style.padding = "8px 12px 4px 12px";
	titleDiv.style.borderBottom = "1px solid " + borderColor;
	titleDiv.style.marginBottom = "4px";
	titleDiv.style.color = textColor;
	menu.appendChild(titleDiv);

	// Toggle visibility option
	const toggleOption = document.createElement("div");
	toggleOption.textContent = surface.visible ? "Hide Surface" : "Show Surface";
	toggleOption.style.padding = "8px 12px";
	toggleOption.style.cursor = "pointer";
	toggleOption.style.color = textColor;
	toggleOption.onmouseover = () => {
		toggleOption.style.backgroundColor = hoverColor;
	};
	toggleOption.onmouseout = () => {
		toggleOption.style.backgroundColor = backgroundColor;
	};
	toggleOption.onclick = (e) => {
		e.stopPropagation();
		setSurfaceVisibility(surface.id, !surface.visible);
		drawData(allBlastHoles, selectedHole);
		safeRemoveMenu(menu);
	};

	// Remove surface option
	const removeOption = document.createElement("div");
	removeOption.textContent = "Remove Surface";
	removeOption.style.padding = "8px 12px";
	removeOption.style.cursor = "pointer";
	removeOption.style.color = textColor;
	removeOption.onmouseover = () => {
		removeOption.style.backgroundColor = hoverColor;
	};
	removeOption.onmouseout = () => {
		removeOption.style.backgroundColor = backgroundColor;
	};
	removeOption.onclick = async (e) => {
		e.stopPropagation();
		try {
			await deleteSurfaceFromDB(surface.id);
			loadedSurfaces.delete(surface.id);
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView();
			console.log("✅ Surface removed from both memory and database");
		} catch (error) {
			console.error("❌ Error removing surface:", error);
			loadedSurfaces.delete(surface.id);
			drawData(allBlastHoles, selectedHole);
		}
		safeRemoveMenu(menu);
	};

	// Delete all surfaces option
	const deleteOption = document.createElement("div");
	deleteOption.textContent = "Delete All Surfaces";
	deleteOption.style.padding = "8px 12px";
	deleteOption.style.cursor = "pointer";
	deleteOption.style.color = textColor;
	deleteOption.onmouseover = () => {
		deleteOption.style.backgroundColor = hoverColor;
	};
	deleteOption.onmouseout = () => {
		deleteOption.style.backgroundColor = backgroundColor;
	};
	deleteOption.onclick = async (e) => {
		e.stopPropagation();
		try {
			await deleteAllSurfacesFromDB();
			loadedSurfaces.clear();
			drawData(allBlastHoles, selectedHole);
			console.log("✅ All surfaces deleted from database and memory");
		} catch (error) {
			console.error("❌ Error deleting all surfaces:", error);
		}
		safeRemoveMenu(menu);
	};

	// Transparency slider
	const transparencyOption = document.createElement("div");
	transparencyOption.textContent = "Transparency:";
	transparencyOption.appendChild(document.createElement("br"));
	transparencyOption.style.padding = "8px 12px";
	const slider = document.createElement("input");
	slider.type = "range";
	slider.min = "0";
	slider.max = "100";
	slider.value = Math.round((surface.transparency || 1.0) * 100);
	slider.style.width = "95%";
	slider.style.margin = "8px auto 0";
	slider.style.display = "block";
	slider.onclick = (e) => e.stopPropagation();
	slider.oninput = (e) => {
		e.stopPropagation();
		const newTransparency = slider.value / 100;
		surface.transparency = newTransparency;
		saveSurfaceToDB(surface.id).catch((err) => console.error("Failed to save surface transparency:", err));
		drawData(allBlastHoles, selectedHole);
	};
	transparencyOption.appendChild(slider);

	// Legend toggle option
	const legendOption = document.createElement("div");
	legendOption.textContent = showSurfaceLegend ? "Hide Legend" : "Show Legend";
	legendOption.style.padding = "8px 12px";
	legendOption.style.cursor = "pointer";
	legendOption.style.color = textColor;
	legendOption.onmouseover = () => {
		legendOption.style.backgroundColor = hoverColor;
	};
	legendOption.onmouseout = () => {
		legendOption.style.backgroundColor = backgroundColor;
	};
	legendOption.onclick = (e) => {
		e.stopPropagation();
		showSurfaceLegend = !showSurfaceLegend;
		drawData(allBlastHoles, selectedHole);
		safeRemoveMenu(menu);
	};

	// Gradient submenu
	const gradientOption = document.createElement("div");
	gradientOption.textContent = "Color Gradient ▶";
	gradientOption.style.padding = "8px 12px";
	gradientOption.style.cursor = "pointer";
	gradientOption.style.color = textColor;
	gradientOption.style.position = "relative";
	const gradientSubmenu = document.createElement("div");
	gradientSubmenu.style.position = "absolute";
	gradientSubmenu.style.left = "100%";
	gradientSubmenu.style.top = "0";
	gradientSubmenu.style.backgroundColor = backgroundColor;
	gradientSubmenu.style.border = "1px solid " + borderColor;
	gradientSubmenu.style.borderRadius = "8px";
	gradientSubmenu.style.padding = "4px";
	gradientSubmenu.style.boxShadow = isDarkMode ? "0 2px 8px rgba(0,0,0,0.5)" : "0 2px 8px rgba(0,0,0,0.15)";
	gradientSubmenu.style.minWidth = "150px";
	gradientSubmenu.style.display = "none";
	const gradients = [
		{
			name: "Default",
			value: "default"
		},
		{
			name: "Hillshade 🌤️",
			value: "hillshade"
		},
		{
			name: "Viridis 🌈",
			value: "viridis"
		},
		{
			name: "Turbo 🔥",
			value: "turbo"
		},
		{
			name: "Parula 🔵",
			value: "parula"
		},
		{
			name: "Cividis 🔵",
			value: "cividis"
		},
		{
			name: "Terrain 🟢",
			value: "terrain"
		}
	];
	gradients.forEach((gradient) => {
		const gradientItem = document.createElement("div");
		gradientItem.textContent = gradient.name;
		gradientItem.style.padding = "6px 10px";
		gradientItem.style.cursor = "pointer";
		gradientItem.style.color = textColor;
		const surfaceUsesThisGradient = (surface.gradient || "default") === gradient.value;
		if (surfaceUsesThisGradient) {
			gradientItem.style.backgroundColor = hoverColor;
			gradientItem.textContent = "✓ " + gradient.name;
		}
		gradientItem.onmouseover = () => {
			if (!surfaceUsesThisGradient) gradientItem.style.backgroundColor = hoverColor;
		};
		gradientItem.onmouseout = () => {
			if (!surfaceUsesThisGradient) gradientItem.style.backgroundColor = backgroundColor;
		};
		gradientItem.onclick = () => {
			surface.gradient = gradient.value;
			saveSurfaceToDB(surface.id).catch((err) => console.error("Failed to save surface gradient:", err));
			console.log("Updated gradient for surface '" + (surface.name || surface.id) + "' to: " + gradient.value);
			drawData(allBlastHoles, selectedHole);
			document.body.removeChild(menu);
		};
		gradientSubmenu.appendChild(gradientItem);
	});
	gradientOption.onmouseover = () => {
		gradientOption.style.backgroundColor = hoverColor;
		gradientSubmenu.style.display = "block";
	};
	gradientOption.onmouseout = () => {
		gradientOption.style.backgroundColor = backgroundColor;
		setTimeout(() => {
			if (!gradientSubmenu.matches(":hover") && !gradientOption.matches(":hover")) {
				gradientSubmenu.style.display = "none";
			}
		}, 100);
	};
	gradientOption.appendChild(gradientSubmenu);

	// Add all options to menu
	menu.appendChild(toggleOption);
	menu.appendChild(removeOption);
	menu.appendChild(deleteOption);
	menu.appendChild(transparencyOption);
	menu.appendChild(legendOption);
	menu.appendChild(gradientOption);
	document.body.appendChild(menu);

	// Remove menu when clicking elsewhere
	setTimeout(() => {
		document.addEventListener("click", function removeMenu() {
			safeRemoveMenu(menu);
			document.removeEventListener("click", removeMenu);
		});
	}, 0);
}
// Add this helper function near your other menu functions
function safeRemoveMenu(menu) {
	try {
		if (menu && document.body.contains(menu)) {
			document.body.removeChild(menu);
		}
	} catch (error) {
		// Menu already removed or not found - ignore
		console.log("Menu already removed");
	}
}

// Update the polygon tool event listener to properly handle conflicts
selectByPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectByPolygonTool");
		endKadTools();
		clearAllSelectionState();
		isPolygonSelectionActive = true;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		isDraggingHole = false;

		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectByPolygonTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Add polygon selection listeners
		canvas.addEventListener("click", selectInsidePolygon);
		canvas.addEventListener("dblclick", completePolygonSelection);
		canvas.addEventListener("touchstart", selectInsidePolygonTouch);
		canvas.addEventListener("mousemove", handlePolygonMouseMove);

		// Clear any existing selection
		polyPointsX = [];
		polyPointsY = [];
		selectedMultipleHoles = [];
		updateStatusMessage("Polygon selection mode enabled\nClick to encircle holes.\nDouble-click to complete selection.");
	} else {
		isPolygonSelectionActive = false;

		// Remove polygon listeners
		canvas.removeEventListener("click", selectInsidePolygon);
		canvas.removeEventListener("dblclick", completePolygonSelection);
		canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
		canvas.removeEventListener("mousemove", handlePolygonMouseMove);

		// Clear polygon points
		polyPointsX = [];
		polyPointsY = [];
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

function selectInsidePolygon(event) {
	if (!isPolygonSelectionActive) return;

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Remove right-click completion - now handled by double-click

	// Left click - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Improved point-in-polygon test
//! NOW USES THE UNIFIED ISPOINTINPOLYGON FUNCTION
function isPointInPolygon(x, y, polyX, polyY) {
	let inside = false;
	const nvert = polyX.length;

	for (let i = 0, j = nvert - 1; i < nvert; j = i++) {
		// Convert polygon coordinates to match hole coordinates
		if (polyY[i] > y != polyY[j] > y && x < ((polyX[j] - polyX[i]) * (y - polyY[i])) / (polyY[j] - polyY[i]) + polyX[i]) {
			inside = !inside;
		}
	}

	return inside;
}

// Create a new touch handler for polygon selection
function selectInsidePolygonTouch(event) {
	if (!isPolygonSelectionActive) return;

	event.preventDefault(); // Prevent default touch behavior

	const rect = canvas.getBoundingClientRect();
	const touch = event.touches[0] || event.changedTouches[0];
	const clickX = touch.clientX - rect.left;
	const clickY = touch.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Two finger tap to finish polygon and select holes
	if (event.touches.length >= 2) {
		if (polyPointsX.length >= 3) {
			// Clear existing selection
			selectedMultipleHoles = [];

			// Check ALL holes against the polygon
			allBlastHoles.forEach((hole) => {
				if (!hole) return;

				// Get hole coordinates
				const holeX = hole.startXLocation;
				const holeY = hole.startYLocation;

				// console.log("Checking hole:", point.holeID, "at:", holeX, holeY, "against polygon with points:", polyPointsX.length);

				if (isPointInPolygon(holeX, holeY, polyPointsX, polyPointsY)) {
					selectedMultipleHoles.push(hole);
					// console.log("Selected hole:", hole.holeID);
				}
			});

			// Update averages and sliders after selection
			if (selectedMultipleHoles.length > 0) {
				updateSelectionAveragesAndSliders(selectedMultipleHoles);
			}

			console.log("Total holes selected:", selectedMultipleHoles.length);
		}

		// Clear the polygon after selection
		polyPointsX = [];
		polyPointsY = [];
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Single finger tap - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Add mouse move handler for live polygon preview
function handlePolygonMouseMove(event) {
	if (!isPolygonSelectionActive || polyPointsX.length === 0) return;

	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Convert mouse coordinates to world coordinates
	const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

	// Update the last point (moving point)
	if (polyPointsX.length > 0) {
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
		drawData(allBlastHoles, selectedHole);
	}
}

//use the same function for the resetView in the resetViewTool
resetViewTool.addEventListener("change", function () {
	if (this.checked) {
		resetZoom();
		drawData(allBlastHoles, selectedHole);
		resetViewTool.checked = false;
	}
});

// #region CUSTOM CSV
//---------------- CUSTOM STRUCTURED CSV IMPORTER - FLOATING DIALOG ONLY ----------------//
fileInputCustomCSV.addEventListener("change", function () {
	const file = this.files[0];
	if (file && file.name.toLowerCase().endsWith(".csv")) {
		Papa.parse(file, {
			skipEmptyLines: true,
			complete: (results) => showCsvImportModal(results.data, file.name),
			error: (error) => {
				const errorDialog = new FloatingDialog({
					title: "Error",
					content: "Could not parse the CSV file: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
			}
		});
	} else if (file) {
		const warningDialog = new FloatingDialog({
			title: "Invalid File",
			content: "Please select a valid .csv file.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false
		});
		warningDialog.show();
		this.value = "";
	}
});

// ===================================================================
// FIELD MAPPING STRUCTURE
// ===================================================================

const HOLE_FIELD_MAPPING = {
	entityName: {
		property: "entityName",
		type: "string",
		default: "Imported_Blast",
		required: false,
		validation: function (value) {
			return true;
		}
	},
	holeID: {
		property: "holeID",
		type: "string",
		required: true,
		validation: function (value) {
			return value && value.trim().length > 0;
		}
	},
	startXLocation: {
		property: "startXLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		}
	},
	startYLocation: {
		property: "startYLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		}
	},
	startZLocation: {
		property: "startZLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		}
	},
	endXLocation: {
		property: "endXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	endYLocation: {
		property: "endYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	endZLocation: {
		property: "endZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	gradeXLocation: {
		property: "gradeXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	gradeYLocation: {
		property: "gradeYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	gradeZLocation: {
		property: "gradeZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		}
	},
	holeDiameter: {
		property: "holeDiameter",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	holeAngle: {
		property: "holeAngle",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= -90 && parseFloat(value) <= 90);
		}
	},
	holeBearing: {
		property: "holeBearing",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0 && parseFloat(value) < 360);
		}
	},
	holeLengthCalculated: {
		property: "holeLengthCalculated",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	subdrillAmount: {
		property: "subdrillAmount",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	benchHeight: {
		property: "benchHeight",
		type: "number",
		default: 10,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	holeType: {
		property: "holeType",
		type: "string",
		default: "Production",
		validation: function (value) {
			return true;
		}
	},
	rowID: {
		property: "rowID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		}
	},
	posID: {
		property: "posID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		}
	},
	fromHoleID: {
		property: "fromHoleID",
		type: "string",
		default: null,
		validation: function (value) {
			return true;
		}
	},
	timingDelayMilliseconds: {
		property: "timingDelayMilliseconds",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	initiationTime: {
		property: "initiationTime",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	colorHexDecimal: {
		property: "colorHexDecimal",
		type: "string",
		default: "red",
		validation: function (value) {
			return true;
		}
	},
	measuredLength: {
		property: "measuredLength",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	measuredMass: {
		property: "measuredMass",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		}
	},
	measuredComment: {
		property: "measuredComment",
		type: "string",
		default: "None",
		validation: function (value) {
			return true;
		}
	}
};

/**
 * Enhanced updateHoleFromCsvData function that properly calculates geometry
 */
function updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit) {
	// Update basic properties first
	Object.keys(HOLE_FIELD_MAPPING).forEach(function (fieldName) {
		const mapping = HOLE_FIELD_MAPPING[fieldName];
		const rawValue = getValue(fieldName);

		// Skip if no value provided and not required
		if ((rawValue === undefined || rawValue === null || rawValue === "") && !mapping.required) {
			if (hole[mapping.property] === undefined && mapping.default !== null) {
				hole[mapping.property] = mapping.default;
			}
			return;
		}

		// Validate the value
		if (!mapping.validation(rawValue)) {
			console.warn("Invalid value for field " + fieldName + ": " + rawValue);
			if (mapping.required) {
				throw new Error("Invalid value for required field " + fieldName + ": " + rawValue);
			}
			return;
		}

		// Convert and assign the value
		let convertedValue;
		switch (mapping.type) {
			case "number":
				convertedValue = parseFloat(rawValue);
				// Handle diameter units
				if (fieldName === "holeDiameter" && !isNaN(convertedValue)) {
					switch (diameterUnit) {
						case "m":
							convertedValue = convertedValue * 1000;
							break;
						case "in":
							convertedValue = convertedValue * 25.4;
							break;
					}
				}
				// Handle angle convention
				if (fieldName === "holeAngle" && !isNaN(convertedValue)) {
					if (angleConvention === "dip") {
						convertedValue = 90 - convertedValue;
					}
				}
				break;
			case "integer":
				convertedValue = parseInt(rawValue);
				break;
			default:
				convertedValue = String(rawValue).trim();
				break;
		}

		hole[mapping.property] = convertedValue;
	});

	// Ensure all required properties exist
	setHoleDefaults(hole);

	// Step 3) Set timingDelayMilliseconds to initiationTime
	// This ensures imported holes use initiation time as their delay
	if (hole.initiationTime !== undefined && !isNaN(hole.initiationTime)) {
		hole.timingDelayMilliseconds = hole.initiationTime;
	}

	// Calculate missing geometry - this is the key fix
	calculateMissingGeometry(hole);
}

/**
 * Calculate missing geometry when no explicit geometry data is provided
 * FIXED: Proper bearing and angle calculations
 */
function calculateMissingGeometry(hole) {
	const hasEndCoords = hole.endXLocation !== hole.startXLocation || hole.endYLocation !== hole.startYLocation || hole.endZLocation !== hole.startZLocation;

	if (hasEndCoords && (hole.holeAngle === 0 || hole.holeBearing === 0 || hole.holeLengthCalculated === 0)) {
		// Calculate from end coordinates - FIXED CALCULATIONS
		const dx = hole.endXLocation - hole.startXLocation;
		const dy = hole.endYLocation - hole.startYLocation;
		const dz = hole.endZLocation - hole.startZLocation; // Note: should be negative for downward holes

		const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

		if (length > 0) {
			hole.holeLengthCalculated = length;

			// FIXED: Proper bearing calculation
			// 0° = North, 90° = East, 180° = South, 270° = West
			let bearing = Math.atan2(dx, dy) * (180 / Math.PI);
			if (bearing < 0) bearing += 360;
			hole.holeBearing = bearing;

			// FIXED: Proper angle calculation
			// 0° = vertical down, 90° = horizontal
			const horizontalDistance = Math.sqrt(dx * dx + dy * dy);
			if (horizontalDistance > 0) {
				hole.holeAngle = Math.atan2(horizontalDistance, Math.abs(dz)) * (180 / Math.PI);
			} else {
				hole.holeAngle = 0; // Vertical
			}
		}
	} else if (!hasEndCoords || hole.holeLengthCalculated === 0) {
		// Calculate from angle/bearing/length or set defaults
		if (hole.holeLengthCalculated === 0) {
			const benchHeight = hole.benchHeight || 10;
			const subdrillAmount = hole.subdrillAmount || 1;
			hole.holeLengthCalculated = benchHeight + subdrillAmount;
		}

		// FIXED: Proper coordinate calculation from angle and bearing
		calculateHoleEndCoordinates(hole);
	}
}

/**
 * NEW: Proper calculation of end coordinates from angle, bearing, and length
 */
function calculateHoleEndCoordinates(hole) {
	const angleRad = hole.holeAngle * (Math.PI / 180);
	const bearingRad = hole.holeBearing * (Math.PI / 180);

	// FIXED: Proper bearing to direction calculation
	// Bearing: 0° = North (positive Y), 90° = East (positive X)
	const horizontalDistance = hole.holeLengthCalculated * Math.sin(angleRad);
	const verticalDistance = hole.holeLengthCalculated * Math.cos(angleRad);

	// Calculate end coordinates
	hole.endXLocation = hole.startXLocation + horizontalDistance * Math.sin(bearingRad);
	hole.endYLocation = hole.startYLocation + horizontalDistance * Math.cos(bearingRad);
	hole.endZLocation = hole.startZLocation - verticalDistance; // Going down

	// Calculate grade coordinates (at bench height)
	const benchHeight = hole.benchHeight || 10;
	const gradeAngleRad = hole.holeAngle * (Math.PI / 180);
	const gradeHorizontalDistance = benchHeight * Math.tan(gradeAngleRad);
	const gradeVerticalDistance = benchHeight;

	hole.gradeXLocation = hole.startXLocation + gradeHorizontalDistance * Math.sin(bearingRad);
	hole.gradeYLocation = hole.startYLocation + gradeHorizontalDistance * Math.cos(bearingRad);
	hole.gradeZLocation = hole.startZLocation - gradeVerticalDistance;
}

/**
 * Set default properties and ensure all required fields are populated
 */
function setHoleDefaults(hole) {
	hole.entityType = "hole";
	if (hole.visible === undefined) hole.visible = true;
	if (!hole.fromHoleID || hole.fromHoleID === null) {
		hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
	}
	if (!hole.measuredLengthTimeStamp) hole.measuredLengthTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredMassTimeStamp) hole.measuredMassTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredCommentTimeStamp) hole.measuredCommentTimeStamp = "09/05/1975 00:00:00";

	// Ensure numeric properties are valid
	const numericProps = ["startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeLengthCalculated", "holeAngle", "holeBearing", "holeDiameter", "subdrillAmount", "benchHeight", "timingDelayMilliseconds", "initiationTime", "measuredLength", "measuredMass"];

	numericProps.forEach(function (prop) {
		if (isNaN(hole[prop])) {
			switch (prop) {
				case "startXLocation":
				case "startYLocation":
				case "startZLocation":
					throw new Error("Invalid coordinates for hole " + hole.holeID);
				case "endXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "endYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "endZLocation":
					hole[prop] = hole.startZLocation;
					break;
				case "gradeXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "gradeYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "gradeZLocation":
					hole[prop] = hole.startZLocation - 10;
					break;
				case "holeLengthCalculated":
					hole[prop] = 10;
					break;
				case "benchHeight":
					hole[prop] = 10;
					break;
				default:
					hole[prop] = 0;
					break;
			}
		}
	});
}

/**
 * Main CSV processing function
 */
function processCsvData(data, columnOrder, fileName) {
	const entityName = fileName.split(".")[0] || "Imported_Blast_" + Math.floor(Math.random() * 16777215).toString(16);
	const headerRows = parseInt(columnOrder.headerRows, 10) || 0;
	const angleConvention = columnOrder.angle_convention || "angle";
	const diameterUnit = columnOrder.diameter_unit || "mm";
	const duplicateHandling = columnOrder.duplicate_handling || "update-blast-hole";

	const addedHoles = [];
	const updatedHoles = [];

	// Process each data row
	data.slice(headerRows).forEach(function (row, index) {
		const getValue = function (colName) {
			const colIndex = columnOrder[colName];
			if (colIndex !== undefined && colIndex !== null && colIndex !== "" && colIndex !== "0") {
				const val = row[parseInt(colIndex, 10) - 1];
				return val !== undefined && val !== null ? String(val).trim() : undefined;
			}
			return undefined;
		};

		// Validate mandatory fields
		const holeID = getValue("holeID");
		const startX = parseFloat(getValue("startXLocation"));
		const startY = parseFloat(getValue("startYLocation"));
		const startZ = parseFloat(getValue("startZLocation"));

		if (!holeID || isNaN(startX) || isNaN(startY) || isNaN(startZ)) {
			console.warn("Skipping row " + (index + headerRows + 1) + ": Missing mandatory fields");
			return;
		}

		const holeEntityName = getValue("entityName") || entityName;
		let rowID = getValue("rowID");
		let posID = getValue("posID");

		//Add all the undeclared values.
		let burden = getValue("burden");
		let spacing = getValue("spacing");
		let connectorCurve = getValue("connectorCurve");
		let measuredLength = getValue("measuredLength");
		let measuredMass = getValue("measuredMass");
		let measuredComment = getValue("measuredComment");
		let measuredLengthTimeStamp = getValue("measuredLengthTimeStamp");
		let measuredMassTimeStamp = getValue("measuredMassTimeStamp");
		let measuredCommentTimeStamp = getValue("measuredCommentTimeStamp");
		let colorHexDecimal = getValue("colorHexDecimal");
		let initiationTime = getValue("initiationTime");
		let timingDelayMilliseconds = getValue("timingDelayMilliseconds");
		let fromHoleID = getValue("fromHoleID");
		let holeType = getValue("holeType");
		let holeLengthCalculated = getValue("holeLengthCalculated");
		let holeAngle = getValue("holeAngle");
		let holeBearing = getValue("holeBearing");
		let holeDiameter = getValue("holeDiameter");
		let subdrillAmount = getValue("subdrillAmount");
		let subdrillLength = getValue("subdrillLength");
		let benchHeight = getValue("benchHeight");

		if (rowID && !isNaN(rowID)) rowID = parseInt(rowID);
		else rowID = null;
		if (posID && !isNaN(posID)) posID = parseInt(posID);
		else posID = null;

		// Check for duplicates
		let existingHoleIndex = -1;
		let isUpdate = false;
		let hole = null;

		if (duplicateHandling === "update-blast-hole") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return h.entityName === holeEntityName && h.holeID === holeID;
			});
		} else if (duplicateHandling === "update-location") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return Math.abs(h.startXLocation - startX) <= 0.01 && Math.abs(h.startYLocation - startY) <= 0.01;
			});
		}

		if (existingHoleIndex !== -1 && duplicateHandling !== "skip") {
			hole = allBlastHoles[existingHoleIndex];
			isUpdate = true;
		} else if (existingHoleIndex !== -1 && duplicateHandling === "skip") {
			return;
		} else {
			// Create new hole
			hole = {
				entityName: holeEntityName,
				entityType: "hole",
				holeID: holeID,
				startXLocation: startX,
				startYLocation: startY,
				startZLocation: startZ,
				endXLocation: startX,
				endYLocation: startY,
				endZLocation: startZ,
				gradeXLocation: startX,
				gradeYLocation: startY,
				gradeZLocation: startZ - 10,
				subdrillAmount: subdrillAmount || 0,
				subdrillLength: subdrillLength || 0,
				benchHeight: benchHeight || 10,
				holeDiameter: holeDiameter || 0,
				holeType: holeType || "Production",
				fromHoleID: fromHoleID || holeEntityName + ":::" + holeID,
				timingDelayMilliseconds: timingDelayMilliseconds || 0,
				colorHexDecimal: colorHexDecimal || "red",
				holeLengthCalculated: holeLengthCalculated || 0,
				holeAngle: holeAngle || 0,
				holeBearing: holeBearing || 0,
				initiationTime: initiationTime || 0,
				measuredLength: measuredLength || 0,
				measuredLengthTimeStamp: measuredLengthTimeStamp || "09/05/1975 00:00:00",
				measuredMass: measuredMass || 0,
				measuredMassTimeStamp: measuredMassTimeStamp || "09/05/1975 00:00:00",
				measuredComment: measuredComment || "None",
				measuredCommentTimeStamp: measuredCommentTimeStamp || "09/05/1975 00:00:00",
				visible: true,
				rowID: rowID,
				posID: posID,
				burden: burden || 0,
				spacing: spacing || 0,
				connectorCurve: connectorCurve || 0
			};
		}

		// Update hole properties
		try {
			updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit);
		} catch (error) {
			console.error("Error updating hole " + holeID + ":", error);
			return;
		}

		// Add to tracking arrays
		if (isUpdate) {
			updatedHoles.push(hole);
		} else {
			allBlastHoles.push(hole);
			addedHoles.push(hole);
		}
	});

	const importedHoles = addedHoles.concat(updatedHoles);
	console.log("CSV Import Results: added=" + addedHoles.length + ", updated=" + updatedHoles.length);

	return importedHoles;
}

/**
 * FloatingDialog CSV Import Modal with Aesthetic Groupings and Two Tables
 */
function showCsvImportModal(csvData, fileName) {
	if (!csvData || csvData.length === 0) {
		const errorDialog = new FloatingDialog({
			title: "Empty File",
			content: "The selected CSV file is empty or could not be read.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false
		});
		errorDialog.show();
		return;
	}

	const headerRowForPreview = csvData[0];
	const columnOptions = headerRowForPreview
		.map(function (header, index) {
			return '<option value="' + (index + 1) + '">Col ' + (index + 1) + ": " + header + "</option>";
		})
		.join("");
	const ignoreOption = '<option value="0">-- calculate --</option>';

	// Define field groups for aesthetic organization
	const fieldGroups = [
		{
			title: "Hole Identifiers",
			fields: [
				{ name: "entityName", label: "Blast Name", required: false },
				{ name: "holeID", label: "Hole ID*", required: true },
				{ name: "holeType", label: "Hole Type", required: false },
				{ name: "rowID", label: "Row ID", required: false },
				{ name: "posID", label: "Position ID", required: false }
			]
		},
		{
			title: "Hole Location - Collar",
			fields: [
				{ name: "startXLocation", label: "Start X(mE)*", required: true },
				{ name: "startYLocation", label: "Start Y(mN)*", required: true },
				{ name: "startZLocation", label: "Start Z(mRL)*", required: true }
			]
		},
		{
			title: "Hole Location - End/Toe",
			fields: [
				{ name: "endXLocation", label: "End X(mE)", required: false },
				{ name: "endYLocation", label: "End Y(mN)", required: false },
				{ name: "endZLocation", label: "End Z(mRL)", required: false }
			]
		},
		{
			title: "Hole Location - Grade",
			fields: [
				{ name: "gradeXLocation", label: "Grade X(mE)", required: false },
				{ name: "gradeYLocation", label: "Grade Y(mN)", required: false },
				{ name: "gradeZLocation", label: "Grade Z(mRL)", required: false }
			]
		},
		{
			title: "Hole Geometry",
			fields: [
				{ name: "holeAngle", label: "Hole Angle/Dip", required: false },
				{ name: "holeBearing", label: "Hole Bearing", required: false },
				{ name: "holeLengthCalculated", label: "Hole Length", required: false },
				{ name: "benchHeight", label: "Bench Height(m)", required: false },
				{ name: "subdrillAmount", label: "Subdrill(m)", required: false },
				{ name: "holeDiameter", label: "Diameter", required: false }
			]
		},
		{
			title: "Timing & Connections",
			fields: [
				{ name: "fromHoleID", label: "From Hole ID", required: false },
				{ name: "timingDelayMilliseconds", label: "Timing Delay", required: false },
				{ name: "colorHexDecimal", label: "Tie Color", required: false },
				{ name: "initiationTime", label: "Initiation Time", required: false }
			]
		},
		{
			title: "Measured Values",
			fields: [
				{ name: "measuredLength", label: "Measured Length", required: false },
				{ name: "measuredMass", label: "Measured Mass", required: false },
				{ name: "measuredComment", label: "Measured Comment", required: false }
			]
		}
	];

	// Create main content container
	const mainContainer = document.createElement("div");
	mainContainer.style.display = "flex";
	mainContainer.style.flexDirection = "column";
	mainContainer.style.height = "100%";

	// Header section with file info and basic settings
	const headerSection = document.createElement("div");
	headerSection.style.padding = "10px";
	headerSection.style.borderBottom = "1px solid var(--light-mode-border)";
	headerSection.className = "button-container-2col";

	headerSection.innerHTML =
		'<label class="labelWhite15"><strong>File:</strong> ' +
		fileName +
		"</label>" +
		"<div></div>" +
		'<label class="labelWhite15"><strong>Rows:</strong> ' +
		csvData.length +
		"</label>" +
		'<label class="labelWhite15"><strong>Columns:</strong> ' +
		csvData[0].length +
		"</label>" +
		'<label class="labelWhite12">Header rows to skip:</label>' +
		'<input type="number" id="csv-header-rows" value="1" min="0" max="10">' +
		'<label class="labelWhite12">Column Detection:</label>' +
		'<select id="csv-column-detection">' +
		'<option value="auto">Auto detect columns</option>' +
		'<option value="last-used">Use last used column order</option>' +
		'<option value="manual">Manual - don\'t detect columns</option>' +
		"</select>" +
		'<label class="labelWhite12">Auto-detect spatial rows:</label>' +
		'<input type="checkbox" id="csv-auto-detect-rows" checked>' +
		'<label class="labelWhite12">Duplicate Handling:</label>' +
		"<div>" +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-blast-hole" checked> Update by Blast+ID</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-location"> Update by location</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="skip"> Skip duplicates</label>' +
		"</div>" +
		'<label class="labelWhite12">Angle Convention:</label>' +
		'<select id="csv-angle-convention">' +
		'<option value="angle">Angle (0° = vertical)</option>' +
		'<option value="dip">Dip (0° = horizontal)</option>' +
		"</select>" +
		'<label class="labelWhite12">Diameter Units:</label>' +
		'<select id="csv-diameter-unit">' +
		'<option value="mm">mm</option>' +
		'<option value="m">m</option>' +
		'<option value="in">inches</option>' +
		"</select>";

	// Content area with three panels: mapping, original data, mapped data
	const contentArea = document.createElement("div");
	contentArea.style.flex = "1";
	contentArea.style.display = "flex";
	contentArea.style.overflow = "hidden";

	// Left panel - Field mapping with groups
	const leftPanel = document.createElement("div");
	leftPanel.style.width = "40%";
	leftPanel.style.padding = "10px";
	leftPanel.style.overflowY = "auto";
	leftPanel.style.borderRight = "1px solid var(--light-mode-border)";

	const mappingTitle = document.createElement("h3");
	mappingTitle.textContent = "Column Mapping";
	mappingTitle.className = "labelWhite15";
	mappingTitle.style.margin = "0 0 10px 0";
	leftPanel.appendChild(mappingTitle);

	// Add field groups to left panel
	fieldGroups.forEach(function (group) {
		const groupDiv = document.createElement("div");
		groupDiv.style.marginBottom = "15px";
		groupDiv.style.border = "1px solid var(--light-mode-border)";
		groupDiv.style.borderRadius = "4px";
		groupDiv.style.padding = "8px";

		const groupTitle = document.createElement("h4");
		groupTitle.textContent = group.title;
		groupTitle.className = "labelWhite12";
		groupTitle.style.margin = "0 0 8px 0";
		groupTitle.style.fontWeight = "bold";
		groupTitle.style.borderBottom = "1px solid var(--light-mode-border)";
		groupTitle.style.paddingBottom = "4px";
		groupDiv.appendChild(groupTitle);

		const fieldsContainer = document.createElement("div");
		fieldsContainer.className = "button-container-2col";

		group.fields.forEach(function (field) {
			const label = document.createElement("label");
			label.textContent = field.label;
			label.className = "labelWhite12";

			const select = document.createElement("select");
			select.id = "csv-col-" + field.name;
			select.name = field.name;

			if (!field.required) {
				select.innerHTML = ignoreOption + columnOptions;
			} else {
				select.innerHTML = columnOptions;
			}

			fieldsContainer.appendChild(label);
			fieldsContainer.appendChild(select);
		});

		groupDiv.appendChild(fieldsContainer);
		leftPanel.appendChild(groupDiv);
	});

	// Right panel - Data previews
	const rightPanel = document.createElement("div");
	rightPanel.style.width = "60%";
	rightPanel.style.padding = "10px";
	rightPanel.style.overflowY = "auto";
	rightPanel.style.display = "flex";
	rightPanel.style.flexDirection = "column";

	// Original data table
	const originalTitle = document.createElement("h4");
	originalTitle.textContent = "Original Data Preview";
	originalTitle.className = "labelWhite12";
	originalTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(originalTitle);

	const originalTableContainer = document.createElement("div");
	originalTableContainer.style.maxHeight = "200px";
	originalTableContainer.style.overflow = "auto";
	originalTableContainer.style.border = "1px solid var(--light-mode-border)";
	originalTableContainer.style.marginBottom = "15px";

	const originalTable = document.createElement("table");
	originalTable.style.width = "100%";
	originalTable.style.borderCollapse = "collapse";
	originalTable.style.fontSize = "10px";

	const originalThead = document.createElement("thead");
	const originalTbody = document.createElement("tbody");
	originalThead.id = "csv-original-headers";
	originalTbody.id = "csv-original-body";

	originalTable.appendChild(originalThead);
	originalTable.appendChild(originalTbody);
	originalTableContainer.appendChild(originalTable);
	rightPanel.appendChild(originalTableContainer);

	// Mapped data table
	const mappedTitle = document.createElement("h4");
	mappedTitle.textContent = "Mapped Data Preview";
	mappedTitle.className = "labelWhite12";
	mappedTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(mappedTitle);

	const mappedTableContainer = document.createElement("div");
	mappedTableContainer.style.maxHeight = "200px";
	mappedTableContainer.style.overflow = "auto";
	mappedTableContainer.style.border = "1px solid var(--light-mode-border)";
	mappedTableContainer.style.marginBottom = "10px";

	const mappedTable = document.createElement("table");
	mappedTable.style.width = "100%";
	mappedTable.style.borderCollapse = "collapse";
	mappedTable.style.fontSize = "10px";

	const mappedThead = document.createElement("thead");
	const mappedTbody = document.createElement("tbody");
	mappedThead.id = "csv-mapped-headers";
	mappedTbody.id = "csv-mapped-body";

	mappedTable.appendChild(mappedThead);
	mappedTable.appendChild(mappedTbody);
	mappedTableContainer.appendChild(mappedTable);
	rightPanel.appendChild(mappedTableContainer);

	// Assemble main container
	mainContainer.appendChild(headerSection);
	contentArea.appendChild(leftPanel);
	contentArea.appendChild(rightPanel);
	mainContainer.appendChild(contentArea);

	// Create the dialog
	const dialog = new FloatingDialog({
		title: "Import CSV: Map Columns",
		content: mainContainer,
		layoutType: "wide",
		width: 1200,
		height: 700,
		showConfirm: true,
		showCancel: true,
		confirmText: "Import",
		cancelText: "Cancel",
		onConfirm: function () {
			try {
				const columnOrder = getColumnOrderFromForm();
				const importedHoles = processCsvData(csvData, columnOrder, fileName);

				if (importedHoles && importedHoles.length > 0) {
					// CRITICAL: Recalculate everything after import like existing code does
					let sumX = 0,
						sumY = 0;
					allBlastHoles.forEach(function (hole) {
						sumX += hole.startXLocation;
						sumY += hole.startYLocation;
					});
					centroidX = sumX / allBlastHoles.length;
					centroidY = sumY / allBlastHoles.length;

					// Step 1) Apply smart row detection to imported holes
					const entitiesForRowDetection = new Map();
					importedHoles.forEach(function (hole) {
						if (!entitiesForRowDetection.has(hole.entityName)) {
							entitiesForRowDetection.set(hole.entityName, []);
						}
						entitiesForRowDetection.get(hole.entityName).push(hole);
					});

					// Step 2) Run smart row detection for each entity
					entitiesForRowDetection.forEach(function (holes, entityName) {
						improvedSmartRowDetection(holes, entityName);
					});

					// Step 3) Auto-assign rowID/posID for holes that still don't have them
					const unassignedHoles = importedHoles.filter(function (hole) {
						return hole.rowID === null || hole.rowID === 0 || hole.posID === null || hole.posID === 0;
					});
					unassignedHoles.forEach(function (hole) {
						if (!hole.rowID || hole.rowID === 0) {
							hole.rowID = getNextRowID(hole.entityName);
						}
						if (!hole.posID || hole.posID === 0) {
							hole.posID = 1;
						}
					});

					// Recalculate dependent data structures - ESSENTIAL for proper display
					if (allBlastHoles.length > 0) {
						const triangleResult = delaunayTriangles(allBlastHoles, maxEdgeLength);
						holeTimes = calculateTimes(allBlastHoles);

						// Recalculate contours
						const contourResult = recalculateContours(allBlastHoles, deltaX, deltaY);
						contourLinesArray = contourResult.contourLinesArray;
						directionArrows = contourResult.directionArrows;
					}

					// Update displays
					timeChart();
					drawData(allBlastHoles, null);

					// Update tree view if available
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}

					const successDialog = new FloatingDialog({
						title: "Successful Import",
						content: "Imported " + importedHoles.length + " holes successfully.",
						layoutType: "default",
						width: 300,
						height: 120,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false
					});
					successDialog.show();
				} else {
					const errorDialog = new FloatingDialog({
						title: "Failed Import",
						content: "No valid holes could be imported. Please check your column mapping and file format.",
						layoutType: "default",
						width: 400,
						height: 140,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false
					});
					errorDialog.show();
				}
			} catch (error) {
				console.error("Import error:", error);
				const errorDialog = new FloatingDialog({
					title: "Import Error",
					content: "An error occurred during import: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
			}

			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		},
		onCancel: function () {
			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		}
	});

	// Show the dialog
	dialog.show();

	// Set up event listeners and auto-detection after dialog is shown
	setupCsvDialogEventListeners(csvData, fieldGroups);
}

// Helper function to set up event listeners
function setupCsvDialogEventListeners(csvData, fieldGroups) {
	// Get saved column order from localStorage
	let savedColumnOrder = {};
	try {
		savedColumnOrder = JSON.parse(localStorage.getItem("csvColumnOrder") || "{}");
	} catch (e) {
		console.warn("Error parsing saved column order:", e);
		savedColumnOrder = {};
	}

	// Auto-mapping keywords
	const mappingKeywords = {
		entityName: ["blast", "pattern", "blastname", "patternname"],
		holeID: ["id", "holeid", "holeno", "name", "holename", "pointid", "no"],
		startXLocation: ["x", "cx", "easting", "startx", "start easting", "start east", "start x"],
		startYLocation: ["y", "cy", "northing", "starty", "start northing", "start north", "start y"],
		startZLocation: ["z", "cz", "rl", "collar", "elevation", "zcoord", "startz", "start elevation", "start z"],
		endXLocation: ["endx", "toex", "end easting", "end east", "tx", "end x", "toex"],
		endYLocation: ["endy", "toey", "end northing", "end north", "ty", "end y", "toey"],
		endZLocation: ["endz", "toerl", "end elevation", "tz", "end z", "toez"],
		gradeXLocation: ["gradex", "grade easting", "grade east", "gx", "grade x"],
		gradeYLocation: ["gradey", "grade northing", "grade north", "gy", "grade y"],
		gradeZLocation: ["gradez", "grade elevation", "gz", "grade z"],
		holeDiameter: ["diameter", "dia", "diam", "holediameter", "hole diameter"],
		subdrillAmount: ["subdrill", "subdrill amount", "sub drill amount", "sub drill"],
		benchHeight: ["bench", "benchheight", "bench height"],
		holeType: ["type", "holetype", "hole type", "material type", "materialtype"],
		holeLengthCalculated: ["length", "holelength", "hole length"],
		holeBearing: ["bearing", "azimuth", "azi", "bea", "heading", "holebearing", "hole bearing"],
		holeAngle: ["angle", "dip", "mast angle", "holeangle", "hole angle"],
		rowID: ["rowid", "row id", "row", "echelon", "rowno", "row number"],
		posID: ["posid", "pos id", "position", "pos", "position id", "pos number", "posno"],
		initiationTime: ["initiation", "initiationtime", "initiation time", "firing time", "firingtime"],
		fromHoleID: ["from", "fromhole", "from hole", "tie from", "tiefrom"],
		timingDelayMilliseconds: ["delay", "timing", "timingdelay", "timing delay", "ms", "milliseconds"],
		colorHexDecimal: ["color", "colour", "tie color", "tiecolor"],
		measuredLength: ["measured length", "measuredlength", "actual length", "actuallength"],
		measuredMass: ["measured mass", "measuredmass", "actual mass", "actualmass", "kg", "weight"],
		measuredComment: ["comment", "comments", "note", "notes", "measured comment"]
	};

	const headerRow = csvData[0].map(function (h) {
		return String(h || "")
			.toLowerCase()
			.replace(/[^a-z0-9]/g, "");
	});

	// Function to update both data previews
	const updateBothPreviews = function () {
		updateOriginalPreview();
		updateMappedPreview();
	};

	// Function to update original data preview
	const updateOriginalPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-original-headers");
		const previewBody = document.getElementById("csv-original-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Add headers
		if (csvData.length > 0) {
			csvData[0].forEach(function (header, index) {
				const th = document.createElement("th");
				th.textContent = "Col " + (index + 1) + ": " + header;
				th.style.padding = "4px 6px";
				th.style.border = "1px solid var(--light-mode-border)";
				th.style.backgroundColor = "rgba(50,50,50,0.3)";
				th.style.fontSize = "10px";
				th.className = "labelWhite12";
				previewHeaders.appendChild(th);
			});
		}

		// Add preview rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			row.forEach(function (cell) {
				const td = document.createElement("td");
				td.textContent = cell || "";
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";
				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});
	};

	// Function to update mapped data preview
	const updateMappedPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-mapped-headers");
		const previewBody = document.getElementById("csv-mapped-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Get current mapping
		const mappedFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				const selectEl = document.getElementById("csv-col-" + field.name);
				if (selectEl && selectEl.value !== "0") {
					mappedFields.push({
						name: field.name,
						label: field.label,
						columnIndex: parseInt(selectEl.value) - 1,
						required: field.required
					});
				}
			});
		});

		// Add mapped headers
		mappedFields.forEach(function (field) {
			const th = document.createElement("th");
			th.textContent = field.label + (field.required ? " *" : "");
			th.style.padding = "4px 6px";
			th.style.border = "1px solid var(--light-mode-border)";
			th.style.backgroundColor = "rgba(50,50,50,0.3)";
			th.style.fontSize = "10px";
			th.className = "labelWhite12";
			if (field.required) {
				th.style.fontWeight = "bold";
			}
			previewHeaders.appendChild(th);
		});

		// Add mapped data rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			mappedFields.forEach(function (field) {
				const td = document.createElement("td");
				const cellValue = row[field.columnIndex] || "";
				td.textContent = cellValue;
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";

				// Highlight missing required fields
				if (field.required && (!cellValue || cellValue.trim() === "")) {
					td.style.backgroundColor = "rgba(255, 107, 107, 0.3)";
				}

				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});

		// Show message if no fields are mapped
		if (mappedFields.length === 0) {
			const tr = document.createElement("tr");
			const td = document.createElement("td");
			td.colSpan = 1;
			td.textContent = "No fields mapped. Please select columns for the required fields.";
			td.style.textAlign = "center";
			td.style.fontStyle = "italic";
			td.style.padding = "10px";
			td.className = "labelWhite12";
			tr.appendChild(td);
			previewBody.appendChild(tr);
		}
	};

	// Function to apply auto-detection
	const applyAutoDetection = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			const keywords = mappingKeywords[field.name] || [];
			const colIndex = headerRow.findIndex(function (header) {
				return keywords.some(function (kw) {
					return header.includes(kw);
				});
			});

			if (colIndex !== -1) {
				selectEl.value = (colIndex + 1).toString();
			} else {
				selectEl.value = "0";
			}
		});

		updateMappedPreview();
	};

	// Function to apply last used settings
	const applyLastUsed = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			if (savedColumnOrder[field.name]) {
				selectEl.value = savedColumnOrder[field.name];
			}
		});

		// Apply saved settings for other fields
		if (savedColumnOrder.angle_convention) {
			const angleEl = document.getElementById("csv-angle-convention");
			if (angleEl) angleEl.value = savedColumnOrder.angle_convention;
		}

		if (savedColumnOrder.diameter_unit) {
			const diameterEl = document.getElementById("csv-diameter-unit");
			if (diameterEl) diameterEl.value = savedColumnOrder.diameter_unit;
		}

		updateMappedPreview();
	};

	// Set up column detection dropdown listener
	const columnDetectionSelect = document.getElementById("csv-column-detection");
	if (columnDetectionSelect) {
		columnDetectionSelect.addEventListener("change", function (e) {
			if (e.target.value === "auto") {
				applyAutoDetection();
			} else if (e.target.value === "last-used") {
				applyLastUsed();
			}
			// For "manual", do nothing - let user set manually
		});
	}

	// Set up header rows input listener
	const headerRowsEl = document.getElementById("csv-header-rows");
	if (headerRowsEl) {
		headerRowsEl.addEventListener("input", updateBothPreviews);
	}

	// Set up listeners for all select dropdowns to update mapped preview
	fieldGroups.forEach(function (group) {
		group.fields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (selectEl) {
				selectEl.addEventListener("change", updateMappedPreview);
			}
		});
	});

	// Initialize both previews and apply initial detection
	updateBothPreviews();
	applyAutoDetection();
}

// Helper function to get column order from form
function getColumnOrderFromForm() {
	const headerRowsEl = document.getElementById("csv-header-rows");
	const angleConventionEl = document.getElementById("csv-angle-convention");
	const diameterUnitEl = document.getElementById("csv-diameter-unit");
	const autoDetectRowsEl = document.getElementById("csv-auto-detect-rows");

	const order = {
		headerRows: headerRowsEl ? headerRowsEl.value : "1",
		angle_convention: angleConventionEl ? angleConventionEl.value : "angle",
		diameter_unit: diameterUnitEl ? diameterUnitEl.value : "mm",
		auto_detect_rows: autoDetectRowsEl ? autoDetectRowsEl.checked : true
	};

	// Get duplicate handling option
	const duplicateHandling = document.querySelector('input[name="csv-duplicate-handling"]:checked');
	order.duplicate_handling = duplicateHandling ? duplicateHandling.value : "update-blast-hole";

	// Get all field mappings
	const allFieldNames = ["entityName", "holeID", "startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeDiameter", "subdrillAmount", "benchHeight", "holeType", "holeLengthCalculated", "holeBearing", "holeAngle", "rowID", "posID", "initiationTime", "fromHoleID", "timingDelayMilliseconds", "colorHexDecimal", "measuredLength", "measuredMass", "measuredComment"];

	allFieldNames.forEach(function (fieldName) {
		const selectEl = document.getElementById("csv-col-" + fieldName);
		order[fieldName] = selectEl ? selectEl.value : "0";
	});

	// Save the column order to localStorage for future use
	try {
		saveHolesToLocalStorage(allBlastHoles);
	} catch (e) {
		console.warn("Error saving column order to localStorage:", e);
	}

	return order;
}

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// ===================================================================
// CONSOLIDATED SMART ROW DETECTION FUNCTIONS
// ===================================================================
// #region HDBSCAN-ROW-DETECTION

/**
 * SEQUENCE-BASED ROW DETECTION
 *
 * This function attempts to detect rows based on the naming/numbering pattern of hole IDs.
 * It analyzes the hole ID patterns and determines the best approach for grouping holes into rows.
 *
 * HOLE ID PATTERN ANALYSIS:
 * - Pure numeric (1, 2, 3, 4...) - Sequential numbered holes
 * - Alphanumeric (A1, A2, B1, B2...) - Letter+number combinations
 * - Mixed patterns - Combination of both
 * - Other patterns - Random text, symbols, etc.
 *
 * @param {Array} holesData - Array of hole objects with holeID properties
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection occurred, false if should fall back to spatial detection
 *
 * DETECTION CASES:
 * 1. All alphanumeric: Analyzes if letters represent rows (A1,A2,B1,B2) or types (I1,I2,B1,B2)
 * 2. Mixed numeric/alphanumeric: Sorts and applies spatial detection algorithms
 * 3. Pure numeric sequential: Applies geometric line-fitting or RDP algorithms
 */
function trySequenceBasedDetection(holesData, entityName) {
	// Initialize counters for different hole ID patterns
	let numericCount = 0; // Pure numbers: "1", "2", "123"
	let alphaNumericCount = 0; // Letter+number: "A1", "BUF5", "I23"
	let otherCount = 0; // Everything else: "Hole-A", "X", symbols

	// Analyze each hole ID to determine its pattern type
	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			// Regex matches pure numeric strings
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			// Regex matches one or more letters followed by one or more digits
			alphaNumericCount++;
		} else {
			// Everything that doesn't fit the above patterns
			otherCount++;
		}
	});

	// Log the pattern analysis for debugging
	console.log("Hole ID pattern analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount
	});

	// CASE 1: ALL ALPHANUMERIC PATTERNS (A1, A2, B1, B2, etc.)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		// Delegate to specialized function that determines if letters are rows or hole types
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: MIXED NUMERIC AND ALPHANUMERIC PATTERNS
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");

		// Create a unified sequence for spatial detection since numbering is inconsistent
		// Give each hole a sequential number for geometric analysis
		const allHoles = holesData
			.map((hole, index) => ({ hole, num: index + 1 }))
			.sort((a, b) => {
				// Custom sort: pure numbers first (in numeric order), then alphanumeric (alphabetically)
				const aIsNum = /^\d+$/.test(a.hole.holeID);
				const bIsNum = /^\d+$/.test(b.hole.holeID);

				if (aIsNum && bIsNum) {
					// Both are numeric - sort numerically
					return parseInt(a.hole.holeID) - parseInt(b.hole.holeID);
				}
				if (aIsNum && !bIsNum) return -1; // Numeric comes before alphanumeric
				if (!aIsNum && bIsNum) return 1; // Alphanumeric comes after numeric
				// Both alphanumeric - sort alphabetically
				return a.hole.holeID.localeCompare(b.hole.holeID);
			});

		// Use spatial detection algorithms since sequence-based logic won't work reliably
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}

	// CASE 3: PURE NUMERIC SEQUENTIAL PATTERNS (1, 2, 3, 4...)
	// Convert hole IDs to numbers and sort them
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num)) // Remove any that couldn't be parsed as numbers
		.sort((a, b) => a.num - b.num); // Sort numerically

	// Validate that we have enough holes and all were numeric
	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		// Not all holes were numeric, or too few holes for pattern detection
		return false;
	}

	// Check if the sequence is continuous (1,2,3,4... with no gaps)
	const firstNum = numericHoles[0].num;
	const isSequential = numericHoles.every((item, index) => item.num === firstNum + index);

	if (!isSequential) {
		// Numbers have gaps (like 1,2,4,7...) - not suitable for sequence-based detection
		return false;
	}

	// Choose geometric algorithm based on developer mode setting
	if (developerModeEnabled) {
		console.log("Using OPTION 2: Modified RDP Algorithm");
		return detectRowsUsingRDP(numericHoles, entityName);
	} else {
		console.log("Using OPTION 1: Sequential Line Fitting Algorithm");
		return detectRowsUsingLineFitting(numericHoles, entityName);
	}
}
/**
 * ALPHANUMERIC HOLE PATTERN HANDLER
 *
 * This function specifically handles holes with alphanumeric IDs (like A1, A2, B1, B2, or I1, I2, B1, B2).
 * It must determine whether the letters represent:
 * 1. ROW IDENTIFIERS (A=row1, B=row2, C=row3...) - Common in mining software
 * 2. HOLE TYPE PREFIXES (I=infill, B=buffer, P=production...) - Also common in mining
 *
 * DECISION LOGIC:
 * - If letters are sequential single characters (A,B,C,D...) → Likely rows
 * - If letters are multi-character codes (INF,BUF,PRD...) → Likely hole types
 * - If mixed pattern → Fall back to spatial detection
 *
 * @param {Array} holesData - Array of hole objects with alphanumeric holeIDs
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection, false to fall back to spatial
 *
 * EXAMPLES:
 * Row pattern: A1,A2,A3,B1,B2,B3,C1,C2 → A=row1, B=row2, C=row3
 * Type pattern: I1,I2,B1,B2,P1,P2 → Use spatial detection instead
 */
function handleAlphaNumericHoles(holesData, entityName) {
	// Map to group holes by their letter prefix
	const rowGroups = new Map();

	// Array to store parsed hole information
	const parsedHoles = [];

	// Parse each hole ID to extract letter prefix and numeric suffix
	holesData.forEach((hole) => {
		// Regex: ^([A-Z]+)(\d+)$ - captures letter(s) + number(s)
		// Examples: "A1"→["A","1"], "INF23"→["INF","23"], "B5"→["B","5"]
		const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
		if (match) {
			const letter = match[1].toUpperCase(); // Letter prefix (A, B, INF, etc.)
			const number = parseInt(match[2]); // Numeric suffix (1, 2, 23, etc.)

			// Store parsed information for analysis
			parsedHoles.push({
				hole: hole,
				letter: letter,
				number: number
			});

			// Group holes by their letter prefix
			if (!rowGroups.has(letter)) {
				rowGroups.set(letter, []);
			}
			rowGroups.get(letter).push({
				hole: hole,
				letter: letter,
				number: number
			});
		}
	});

	// Extract all unique letter prefixes for analysis
	const letterGroups = Array.from(rowGroups.keys());
	console.log("Found letter groups:", letterGroups.join(", "));

	// HEURISTIC ANALYSIS: Determine if letters represent rows or hole types
	//
	// INDICATORS FOR ROW USAGE:
	// 1. Single letters (A, B, C) are more likely rows than multi-letter codes
	// 2. Sequential single letters (A, B, C, D) strongly suggest row naming
	// 3. Consistent pattern across all holes
	//
	// INDICATORS FOR TYPE USAGE:
	// 1. Multi-letter codes (INF, BUF, PRD) suggest hole type abbreviations
	// 2. Non-sequential letters (A, I, B, P) suggest different types
	// 3. Mixed single/multi letter combinations

	const singleLetters = letterGroups.filter((l) => l.length === 1).sort();
	const multiLetters = letterGroups.filter((l) => l.length > 1);

	// Check if single letters form a sequential pattern (A, B, C, D...)
	let isSequentialRows = false;
	if (singleLetters.length >= 2) {
		isSequentialRows = singleLetters.every((letter, index) => {
			if (index === 0) return true; // First letter is always valid
			// Check if each letter is exactly 1 ASCII value higher than previous
			// A=65, B=66, C=67... so B-A=1, C-B=1, etc.
			return letter.charCodeAt(0) - singleLetters[index - 1].charCodeAt(0) === 1;
		});
	}

	// DECISION CRITERIA: Use letters as row identifiers if:
	// 1. All letters are sequential single characters (A,B,C,D...)
	// 2. We have at least 3 different letters (need multiple rows)
	// 3. No multi-letter codes present (pure single-letter pattern)
	const useLettersAsRows = isSequentialRows && singleLetters.length >= 3 && multiLetters.length === 0;

	if (useLettersAsRows) {
		console.log("Letters appear to represent rows (A, B, C pattern)");

		// TREAT LETTERS AS ROW IDENTIFIERS
		// Each letter prefix becomes a separate row, numbered sequentially
		const startingRowID = getNextRowID(entityName);

		singleLetters.forEach((rowLetter, rowIndex) => {
			const row = rowGroups.get(rowLetter);
			// Sort holes within each row by their numeric suffix (A1, A2, A3...)
			row.sort((a, b) => a.number - b.number);

			const rowID = startingRowID + rowIndex;

			// Assign row and position IDs to each hole in this letter group
			row.forEach((item, index) => {
				item.hole.rowID = rowID;
				item.hole.posID = index + 1; // Position within row (1, 2, 3...)
			});

			console.log("Row " + rowLetter + " → rowID " + rowID + " with " + row.length + " holes");
		});

		return true; // Successfully used letter-based row detection
	} else {
		console.log("Letters appear to be hole type prefixes (I=infill, B=buffer, etc.)");
		console.log("Falling back to spatial detection for mixed alphanumeric pattern");

		// TREAT LETTERS AS HOLE TYPE PREFIXES
		// Since letters don't represent rows, we need to use spatial detection
		// Convert to format expected by geometric line fitting algorithms
		const allHoles = [];
		let counter = 1;

		// Create a logical ordering for spatial analysis:
		// Sort letter groups alphabetically, then sort holes within each group numerically
		letterGroups.sort().forEach((letter) => {
			const group = rowGroups.get(letter);
			group.sort((a, b) => a.number - b.number); // I1, I2, I3... then B1, B2, B3...
			group.forEach((item) => {
				allHoles.push({
					hole: item.hole,
					num: counter++ // Give sequential numbers for geometric analysis
				});
			});
		});

		// Apply spatial detection algorithms since hole naming doesn't indicate rows
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}
}
/**
 * OPTION 1: SEQUENTIAL LINE FITTING ALGORITHM (Main Geometric Algorithm)
 *
 * This is the primary geometric algorithm for detecting rows in blast patterns.
 * It works by finding the longest sequences of holes that can be fit to straight lines,
 * using a tolerance based on hole diameter.
 *
 * ALGORITHM CONCEPT:
 * 1. For each hole, try to build the longest possible straight line of consecutive holes
 * 2. Use geometric line fitting to ensure holes are truly aligned
 * 3. Tolerance is based on hole diameter (2x diameter distance allowed from line)
 * 4. Process holes in order, marking used holes to avoid duplication
 *
 * STRENGTHS:
 * - Works well for regular drilling patterns
 * - Respects hole sequence (numbered 1,2,3,4...)
 * - Good for straight or slightly curved rows
 *
 * WEAKNESSES:
 * - Can break up rows if there are small alignment irregularities
 * - Requires sequential hole numbering to work optimally
 * - May create too many single-hole rows in irregular patterns
 *
 * @param {Array} numericHoles - Array of {hole, num} objects sorted by hole number
 * @param {string} entityName - Blast entity name for generating row IDs
 * @returns {boolean} - true if detection was successful
 */
function detectRowsUsingLineFitting(numericHoles, entityName) {
	// Need at least 2 holes to form any meaningful pattern
	if (numericHoles.length < 2) return false;

	// Calculate tolerance based on hole diameter
	// Default 115mm diameter if not specified (typical blast hole size)
	const holeDiameter = numericHoles[0].hole.holeDiameter || 115; // mm
	const tolerance = (holeDiameter * 2) / 1000; // Convert to meters (2x diameter)

	console.log("Line fitting tolerance:", tolerance.toFixed(3) + "m (2x diameter)");

	// Arrays to store detected rows and track which holes have been used
	const rows = [];
	const used = new Set(); // Set of hole indices that have been assigned to rows

	// MAIN ALGORITHM: Try to build rows starting from each unused hole
	// Process holes in sequence order (1, 2, 3, 4...) to maintain logical flow
	for (let startIdx = 0; startIdx < numericHoles.length; startIdx++) {
		if (used.has(startIdx)) continue; // Skip holes already assigned to rows

		// Find the longest sequence of consecutive holes that form a straight line
		const row = findLongestLineSequence(numericHoles, startIdx, tolerance, used);

		if (row.length >= 2) {
			// Only accept sequences with at least 2 holes as valid rows
			rows.push(row);

			// Mark all holes in this row as used
			row.forEach((hole) => used.add(numericHoles.indexOf(hole)));

			console.log("Found row with", row.length, "holes:", row.map((h) => h.num).join(","));
		}
	}

	// CLEANUP: Handle single holes that didn't fit into any row
	// These become individual single-hole rows (may indicate outliers or edge holes)
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
			console.log("Single hole row:", numericHoles[i].num);
		}
	}

	// ASSIGNMENT: Give each detected row a unique ID and assign positions within rows
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1; // Position within row (1, 2, 3...)
		});
	});

	console.log("Line fitting detected", rows.length, "rows");
	return rows.length > 0;
}

/**
 * FIND LONGEST LINE SEQUENCE HELPER
 *
 * Starting from a given hole, this function extends forward through consecutive holes
 * to build the longest possible sequence that forms a straight line within tolerance.
 *
 * ALGORITHM:
 * 1. Start with the given hole as the first point in the sequence
 * 2. Try adding each subsequent consecutive hole to the sequence
 * 3. Test if the extended sequence still forms a valid straight line
 * 4. Stop when adding the next hole would break the line constraint
 * 5. Return the longest valid sequence found
 *
 * KEY BEHAVIOR:
 * - Only looks FORWARD in the hole sequence (maintains drilling order)
 * - Stops at first hole that doesn't fit (ensures continuous sequences)
 * - Skips holes already used by previous rows
 *
 * @param {Array} numericHoles - All holes sorted by sequence number
 * @param {number} startIdx - Index of hole to start sequence from
 * @param {number} tolerance - Maximum distance allowed from line (meters)
 * @param {Set} used - Set of hole indices already assigned to other rows
 * @returns {Array} - Longest sequence of holes forming a straight line
 */
function findLongestLineSequence(numericHoles, startIdx, tolerance, used) {
	// Start sequence with the given hole
	const sequence = [numericHoles[startIdx]];

	// Try to extend the sequence by finding consecutive holes that fit the line
	// Only look FORWARD to maintain hole sequence order (drilling progression)
	for (let nextIdx = startIdx + 1; nextIdx < numericHoles.length; nextIdx++) {
		if (used.has(nextIdx)) continue; // Skip holes already used by other rows

		// Test if adding this hole would still form a valid straight line
		const testSequence = [...sequence, numericHoles[nextIdx]];

		if (sequenceFitsLine(testSequence, tolerance)) {
			// Hole fits the line - add it to the sequence and continue
			sequence.push(numericHoles[nextIdx]);
		} else {
			// Hole doesn't fit the line - stop extending sequence
			// This ensures rows are continuous (no gaps in hole sequence)
			break;
		}
	}

	return sequence;
}

/**
 * SEQUENCE LINE FITTING VALIDATOR
 *
 * Tests whether a sequence of holes can be considered to form a straight line
 * within the specified tolerance. Uses simple linear regression approach.
 *
 * GEOMETRIC METHOD:
 * 1. Define line using first and last points in sequence
 * 2. Calculate perpendicular distance from each intermediate point to this line
 * 3. If any point is farther than tolerance from line, sequence fails
 * 4. If all points are within tolerance, sequence passes
 *
 * ASSUMPTIONS:
 * - Uses first and last points to define the "ideal" line
 * - Assumes drilling follows a reasonably straight path
 * - Tolerance accounts for small drilling irregularities and survey errors
 *
 * @param {Array} sequence - Array of hole objects to test for linearity
 * @param {number} tolerance - Maximum allowed distance from line (meters)
 * @returns {boolean} - true if sequence forms a valid straight line
 */
function sequenceFitsLine(sequence, tolerance) {
	// Single hole or pair always forms a valid "line"
	if (sequence.length < 2) return true;

	// Extract coordinate points from hole objects
	const points = sequence.map((item) => ({
		x: item.hole.startXLocation,
		y: item.hole.startYLocation
	}));

	// Define line using first and last points (endpoints of sequence)
	// This represents the "ideal" straight line the holes should follow
	const start = points[0];
	const end = points[points.length - 1];

	// Test all intermediate points (exclude endpoints since they define the line)
	for (let i = 1; i < points.length - 1; i++) {
		const distance = distancePointToLine(points[i], start, end);
		if (distance > tolerance) {
			// Found a point too far from the line - sequence is not straight enough
			return false;
		}
	}

	// All intermediate points are within tolerance - sequence is acceptably straight
	return true;
}

/**
 * POINT-TO-LINE DISTANCE CALCULATOR
 *
 * Calculates the perpendicular (shortest) distance from a point to a line segment.
 * Uses the standard point-to-line distance formula from analytic geometry.
 *
 * MATHEMATICAL FORMULA:
 * For line defined by points (x1,y1) and (x2,y2), and test point (x0,y0):
 * distance = |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)² + (x2-x1)²)
 *
 * SPECIAL CASES:
 * - If line endpoints are identical (zero length), distance is 0
 * - Formula gives perpendicular distance, not diagonal distance
 *
 * @param {Object} point - Point to test {x, y}
 * @param {Object} lineStart - Line start point {x, y}
 * @param {Object} lineEnd - Line end point {x, y}
 * @returns {number} - Perpendicular distance from point to line (meters)
 */
function distancePointToLine(point, lineStart, lineEnd) {
	// Calculate line vector components
	const dx = lineEnd.x - lineStart.x;
	const dy = lineEnd.y - lineStart.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);

	// Handle degenerate case where line endpoints are identical
	if (lineLength === 0) return 0; // Start and end are the same point

	// Apply point-to-line distance formula
	// |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)² + (x2-x1)²)
	const distance = Math.abs((dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x) / lineLength);

	return distance;
}

/**
 * HDBSCAN-BASED ROW DETECTION (RECOMMENDED APPROACH)
 *
 * This algorithm uses hierarchical density-based clustering to detect rows
 * in blast hole patterns. It's superior to the existing algorithms because:
 * - No need to specify number of rows beforehand
 * - Handles varying row densities automatically
 * - Robust to noise and irregular patterns
 * - Works with any hole naming convention
 */

function detectRowsUsingHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using HDBSCAN for row detection on " + holesData.length + " holes");

	// Extract coordinates for clustering
	const points = holesData.map((hole) => [hole.startXLocation, hole.startYLocation]);

	// Calculate minimum cluster size based on expected holes per row
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20)); // Estimate 20 rows max

	// Since we don't have HDBSCAN library, we'll implement a simplified version
	// In production, use: import { HDBSCAN } from 'hdbscan-js';
	const clusters = simplifiedHDBSCAN(points, minClusterSize);

	// Convert clusters to row assignments
	assignClustersToRows(holesData, clusters, entityName);

	console.log("HDBSCAN detected " + clusters.length + " rows");
	return clusters.length > 0;
}

/**
 * SIMPLIFIED HDBSCAN IMPLEMENTATION
 *
 * This is a simplified version for demonstration. In production,
 * use a proper HDBSCAN library like hdbscan-js or sklearn in Python
 */
function simplifiedHDBSCAN(points, minClusterSize) {
	// Step 1: Calculate distance matrix
	const distances = calculateDistanceMatrix(points);

	// Step 2: Build minimum spanning tree based on mutual reachability
	const mst = buildMinimumSpanningTree(points, distances, minClusterSize);

	// Step 3: Build cluster hierarchy
	const hierarchy = buildClusterHierarchy(mst);

	// Step 4: Extract stable clusters
	const clusters = extractStableClusters(hierarchy, minClusterSize);

	return clusters;
}

function calculateDistanceMatrix(points) {
	const n = points.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const dx = points[i][0] - points[j][0];
			const dy = points[i][1] - points[j][1];
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances[i][j] = distances[j][i] = dist;
		}
	}

	return distances;
}

function buildMinimumSpanningTree(points, distances, minPts) {
	const n = points.length;
	const edges = [];

	// Calculate core distances (distance to k-th nearest neighbor)
	const coreDistances = points.map((point, i) => {
		const dists = distances[i].slice();
		dists.sort((a, b) => a - b);
		return dists[minPts]; // k-th nearest neighbor distance
	});

	// Calculate mutual reachability distances and create edges
	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const mutualReachability = Math.max(coreDistances[i], coreDistances[j], distances[i][j]);
			edges.push({ from: i, to: j, weight: mutualReachability });
		}
	}

	// Sort edges by weight (Kruskal's algorithm)
	edges.sort((a, b) => a.weight - b.weight);

	// Build MST using Union-Find
	const parent = Array(n)
		.fill()
		.map((_, i) => i);
	const mst = [];

	function find(x) {
		if (parent[x] !== x) {
			parent[x] = find(parent[x]);
		}
		return parent[x];
	}

	function union(x, y) {
		const px = find(x);
		const py = find(y);
		if (px !== py) {
			parent[px] = py;
			return true;
		}
		return false;
	}

	for (const edge of edges) {
		if (union(edge.from, edge.to)) {
			mst.push(edge);
			if (mst.length === n - 1) break;
		}
	}

	return mst;
}

function buildClusterHierarchy(mst) {
	// Sort MST edges by weight (reverse order for hierarchy building)
	const sortedEdges = mst.slice().sort((a, b) => b.weight - a.weight);

	const hierarchy = [];
	const components = new Map();
	let nextClusterId = 0;

	// Initialize each point as its own component
	for (const edge of mst) {
		if (!components.has(edge.from)) components.set(edge.from, [edge.from]);
		if (!components.has(edge.to)) components.set(edge.to, [edge.to]);
	}

	// Build hierarchy by merging components
	for (const edge of sortedEdges) {
		const comp1 = components.get(edge.from);
		const comp2 = components.get(edge.to);

		if (comp1 && comp2 && comp1 !== comp2) {
			const merged = [...comp1, ...comp2];
			const clusterId = nextClusterId++;

			hierarchy.push({
				id: clusterId,
				points: merged,
				distance: edge.weight,
				children: [comp1, comp2]
			});

			// Update component references
			for (const point of merged) {
				components.set(point, merged);
			}
		}
	}

	return hierarchy;
}

function extractStableClusters(hierarchy, minClusterSize) {
	// Simplified cluster extraction - select clusters with good stability
	const clusters = [];
	const processed = new Set();

	// Sort by cluster size and distance for stability
	const candidates = hierarchy
		.filter((cluster) => cluster.points.length >= minClusterSize)
		.sort((a, b) => {
			// Prefer larger clusters with smaller distances (more stable)
			const stabilityA = a.points.length / (1 + a.distance);
			const stabilityB = b.points.length / (1 + b.distance);
			return stabilityB - stabilityA;
		});

	for (const candidate of candidates) {
		// Check if any points are already assigned to a cluster
		if (!candidate.points.some((point) => processed.has(point))) {
			clusters.push(candidate.points);
			for (const point of candidate.points) {
				processed.add(point);
			}
		}
	}

	return clusters;
}

/**
 * ENHANCED GRID-BASED CLUSTERING (ALTERNATIVE APPROACH)
 *
 * This algorithm uses an adaptive grid structure to detect rows,
 * inspired by spatial co-location pattern mining techniques
 */
function detectRowsUsingAdaptiveGrid(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Adaptive Grid clustering for row detection");

	// Calculate bounding box and optimal grid size
	const bounds = calculateBounds(holesData);
	const gridSize = estimateOptimalGridSize(holesData, bounds);

	// Create adaptive grid
	const grid = createAdaptiveGrid(holesData, bounds, gridSize);

	// Find connected components in grid
	const components = findGridComponents(grid);

	// Convert components to rows
	const rows = componentsToRows(components, holesData);

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, index) => {
		const rowID = startingRowID + index;
		row.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});

	console.log("Adaptive Grid detected " + rows.length + " rows");
	return rows.length > 0;
}

function calculateBounds(holesData) {
	const xs = holesData.map((h) => h.startXLocation);
	const ys = holesData.map((h) => h.startYLocation);

	return {
		minX: Math.min(...xs),
		maxX: Math.max(...xs),
		minY: Math.min(...ys),
		maxY: Math.max(...ys)
	};
}

function estimateOptimalGridSize(holesData, bounds) {
	// Estimate grid size based on average hole spacing
	const distances = [];

	for (let i = 0; i < holesData.length; i++) {
		for (let j = i + 1; j < holesData.length; j++) {
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances.push(dist);
		}
	}

	distances.sort((a, b) => a - b);

	// Use median of shortest 10% of distances as grid size
	const shortDistances = distances.slice(0, Math.floor(distances.length * 0.1));
	const medianSpacing = shortDistances[Math.floor(shortDistances.length / 2)];

	return medianSpacing * 1.5; // 1.5x median spacing for grid size
}

function createAdaptiveGrid(holesData, bounds, gridSize) {
	const grid = new Map();

	holesData.forEach((hole, index) => {
		const cellX = Math.floor((hole.startXLocation - bounds.minX) / gridSize);
		const cellY = Math.floor((hole.startYLocation - bounds.minY) / gridSize);
		const key = cellX + "," + cellY;

		if (!grid.has(key)) {
			grid.set(key, []);
		}
		grid.get(key).push({ hole, index });
	});

	return grid;
}

function findGridComponents(grid) {
	const visited = new Set();
	const components = [];

	for (const [cellKey, holes] of grid) {
		if (!visited.has(cellKey) && holes.length > 0) {
			const component = [];
			const queue = [cellKey];
			visited.add(cellKey);

			while (queue.length > 0) {
				const currentKey = queue.shift();
				const currentHoles = grid.get(currentKey) || [];
				component.push(...currentHoles);

				// Check adjacent cells
				const [x, y] = currentKey.split(",").map(Number);
				const neighbors = [
					[x - 1, y],
					[x + 1, y],
					[x, y - 1],
					[x, y + 1], // 4-connected
					[x - 1, y - 1],
					[x - 1, y + 1],
					[x + 1, y - 1],
					[x + 1, y + 1] // 8-connected
				];

				for (const [nx, ny] of neighbors) {
					const neighborKey = nx + "," + ny;
					if (grid.has(neighborKey) && !visited.has(neighborKey)) {
						visited.add(neighborKey);
						queue.push(neighborKey);
					}
				}
			}

			if (component.length > 0) {
				components.push(component);
			}
		}
	}

	return components;
}

function componentsToRows(components, holesData) {
	return components.map((component) => {
		// Sort holes within component by position along dominant axis
		const holes = component.map((item) => item.hole);

		// Determine dominant direction for sorting
		const direction = estimateRowDirection(holes);

		// Sort holes along the row direction
		holes.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		return holes;
	});
}

function estimateRowDirection(holes) {
	if (holes.length < 2) return 0;

	// Use PCA to find principal direction
	const meanX = holes.reduce((sum, h) => sum + h.startXLocation, 0) / holes.length;
	const meanY = holes.reduce((sum, h) => sum + h.startYLocation, 0) / holes.length;

	let covarXX = 0,
		covarXY = 0,
		covarYY = 0;

	holes.forEach((hole) => {
		const dx = hole.startXLocation - meanX;
		const dy = hole.startYLocation - meanY;
		covarXX += dx * dx;
		covarXY += dx * dy;
		covarYY += dy * dy;
	});

	// Calculate principal direction (eigenvector of covariance matrix)
	const trace = covarXX + covarYY;
	const det = covarXX * covarYY - covarXY * covarXY;
	const eigenvalue1 = (trace + Math.sqrt(trace * trace - 4 * det)) / 2;

	// Principal direction angle
	if (Math.abs(covarXY) > 1e-10) {
		return Math.atan2(eigenvalue1 - covarXX, covarXY);
	} else {
		return covarXX > covarYY ? 0 : Math.PI / 2;
	}
}

// Helper function to assign clusters to rows
function assignClustersToRows(holesData, clusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	clusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;
		const rowHoles = cluster.map((pointIndex) => holesData[pointIndex]);

		// Sort holes within row by spatial position
		const direction = estimateRowDirection(rowHoles);
		rowHoles.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		// Assign row and position IDs
		rowHoles.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});
}

/**
 * UPDATED SMART ROW DETECTION WITH SEQUENCE PRIORITY
 *
 * This maintains the priority of sequential hole numbering while using
 * better algorithms when sequence-based detection fails
 */
function improvedSmartRowDetection(holesData, entityName) {
	if (!holesData || holesData.length === 0) return;

	console.log("Improved smart row detection for " + holesData.length + " holes in entity: " + entityName);

	// METHOD 1: ALWAYS TRY SEQUENCE-BASED DETECTION FIRST (HIGHEST PRIORITY)
	// This respects the drilling order and numbered patterns which are most reliable
	if (trySequenceBasedDetection(holesData, entityName)) {
		console.log("Used sequence-based row detection (PRIORITY METHOD)");
		return;
	}

	// METHOD 2: Enhanced spatial detection with sequence weighting
	// Use HDBSCAN but weight points based on sequence proximity
	if (detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName)) {
		console.log("Used sequence-weighted HDBSCAN row detection");
		return;
	}

	// METHOD 3: Try pure spatial HDBSCAN (when sequence is completely random)
	if (detectRowsUsingHDBSCAN(holesData, entityName)) {
		console.log("Used pure spatial HDBSCAN row detection");
		return;
	}

	// METHOD 4: Try Adaptive Grid clustering
	if (detectRowsUsingAdaptiveGrid(holesData, entityName)) {
		console.log("Used Adaptive Grid row detection");
		return;
	}

	// METHOD 5: Fallback to your existing bearing-based detection
	useBearingBasedDetection(holesData, entityName);
	console.log("Used bearing-based spatial detection as fallback");
}

/**
 * SEQUENCE-WEIGHTED HDBSCAN
 *
 * This combines the power of HDBSCAN with respect for hole numbering sequence.
 * Points that are close in sequence get a distance penalty reduction, making
 * them more likely to cluster together even if slightly farther apart spatially.
 */
function detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Sequence-Weighted HDBSCAN for row detection");

	// First, try to extract numeric sequence from hole IDs
	const sequenceInfo = extractSequenceInformation(holesData);

	if (!sequenceInfo.hasValidSequence) {
		console.log("No valid sequence found, falling back to pure spatial HDBSCAN");
		return false;
	}

	// Create distance matrix that considers both spatial and sequence proximity
	const weightedDistances = calculateSequenceWeightedDistances(holesData, sequenceInfo);

	// Run HDBSCAN with the weighted distances
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20));
	const clusters = simplifiedHDBSCANWithDistanceMatrix(weightedDistances, minClusterSize);

	// Post-process clusters to respect sequence order within rows
	const orderedClusters = orderClustersbySequence(clusters, holesData, sequenceInfo);

	// Assign to rows
	assignOrderedClustersToRows(holesData, orderedClusters, entityName);

	console.log("Sequence-Weighted HDBSCAN detected " + orderedClusters.length + " rows");
	return orderedClusters.length > 0;
}

/**
 * EXTRACT SEQUENCE INFORMATION
 *
 * Analyzes hole IDs to determine if there's a meaningful sequence that should
 * be preserved during clustering
 */
function extractSequenceInformation(holesData) {
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;
	const sequenceMap = new Map(); // Maps holeID to sequence number

	// Analyze hole ID patterns (same as your existing logic)
	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
			sequenceMap.set(hole.holeID, parseInt(hole.holeID));
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
			// For alphanumeric, use the numeric part as sequence
			const match = hole.holeID.match(/(\d+)$/);
			if (match) {
				sequenceMap.set(hole.holeID, parseInt(match[1]));
			}
		} else {
			otherCount++;
			// For other patterns, use index as sequence
			sequenceMap.set(hole.holeID, index);
		}
	});

	// Determine if we have a valid sequence
	const hasValidSequence =
		numericCount > holesData.length * 0.7 || // 70% numeric
		alphaNumericCount > holesData.length * 0.7; // 70% alphanumeric

	console.log("Sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
		hasValidSequence: hasValidSequence
	});

	return {
		hasValidSequence,
		sequenceMap,
		totalHoles: holesData.length
	};
}

/**
 * CALCULATE SEQUENCE-WEIGHTED DISTANCES
 *
 * Modifies spatial distances to give preference to holes that are close
 * in the numbering sequence, making them more likely to cluster together
 */
function calculateSequenceWeightedDistances(holesData, sequenceInfo) {
	const n = holesData.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	// Get sequence numbers for all holes
	const sequences = holesData.map((hole) => sequenceInfo.sequenceMap.get(hole.holeID) || 0);
	const maxSequenceDiff = Math.max(...sequences) - Math.min(...sequences);

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			// Calculate spatial distance
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const spatialDistance = Math.sqrt(dx * dx + dy * dy);

			// Calculate sequence distance (normalized)
			const sequenceDiff = Math.abs(sequences[i] - sequences[j]);
			const normalizedSequenceDiff = sequenceDiff / maxSequenceDiff;

			// SEQUENCE WEIGHTING FORMULA:
			// - If holes are close in sequence (low sequenceDiff), reduce distance
			// - If holes are far in sequence (high sequenceDiff), increase distance
			// - Weight factor controls how much sequence matters vs spatial distance
			const sequenceWeight = 0.3; // 30% influence from sequence
			const sequencePenalty = 1 + sequenceWeight * normalizedSequenceDiff;
			const sequenceBonus = Math.max(0.5, 1 - sequenceWeight * Math.exp(-sequenceDiff / 5));

			// Apply sequence weighting
			let weightedDistance;
			if (sequenceDiff <= 3) {
				// Holes very close in sequence get a distance bonus
				weightedDistance = spatialDistance * sequenceBonus;
			} else {
				// Holes far in sequence get a distance penalty
				weightedDistance = spatialDistance * sequencePenalty;
			}

			distances[i][j] = distances[j][i] = weightedDistance;
		}
	}

	return distances;
}

/**
 * ORDER CLUSTERS BY SEQUENCE
 *
 * After clustering, ensure holes within each cluster are ordered by sequence
 */
function orderClustersbySequence(clusters, holesData, sequenceInfo) {
	return clusters.map((cluster) => {
		// Get holes in this cluster
		const clusterHoles = cluster.map((index) => ({
			hole: holesData[index],
			index: index,
			sequence: sequenceInfo.sequenceMap.get(holesData[index].holeID) || 0
		}));

		// Sort by sequence number
		clusterHoles.sort((a, b) => a.sequence - b.sequence);

		return clusterHoles.map((item) => item.index);
	});
}

/**
 * ASSIGN ORDERED CLUSTERS TO ROWS
 *
 * Assigns cluster results to rows while preserving sequence order
 */
function assignOrderedClustersToRows(holesData, orderedClusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	orderedClusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;

		cluster.forEach((holeIndex, positionInRow) => {
			const hole = holesData[holeIndex];
			hole.rowID = rowID;
			hole.posID = positionInRow + 1; // Position respects sequence order
		});

		console.log("Row " + rowID + " has " + cluster.length + " holes in sequence order");
	});
}

/**
 * ENHANCED SEQUENCE-BASED DETECTION (REPLACES YOUR EXISTING VERSION)
 *
 * This improves your existing trySequenceBasedDetection with better algorithms
 * while maintaining the priority of sequential numbering
 */
function enhancedSequenceBasedDetection(holesData, entityName) {
	// Same pattern analysis as your original code
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;

	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
		} else {
			otherCount++;
		}
	});

	console.log("Enhanced sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount
	});

	// CASE 1: All alphanumeric (keep your existing logic)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: Mixed patterns - improved handling
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");
		return handleMixedSequencePattern(holesData, entityName);
	}

	// CASE 3: Pure numeric - enhanced algorithms
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num))
		.sort((a, b) => a.num - b.num);

	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		return false; // Not suitable for sequence-based detection
	}

	// Check sequence continuity with gap tolerance
	const gaps = analyzeSequenceGaps(numericHoles);

	if (gaps.hasReasonablePattern) {
		console.log("Using enhanced sequence-based detection with gap tolerance");
		return enhancedSequentialDetection(numericHoles, entityName, gaps);
	}

	return false; // Fall back to spatial detection
}

/**
 * ANALYZE SEQUENCE GAPS
 *
 * Determines if the numeric sequence has a reasonable pattern even with gaps
 */
function analyzeSequenceGaps(numericHoles) {
	const numbers = numericHoles.map((item) => item.num);
	const gaps = [];

	for (let i = 1; i < numbers.length; i++) {
		gaps.push(numbers[i] - numbers[i - 1]);
	}

	// Analyze gap pattern
	const gapCounts = {};
	gaps.forEach((gap) => {
		gapCounts[gap] = (gapCounts[gap] || 0) + 1;
	});

	const uniqueGaps = Object.keys(gapCounts)
		.map(Number)
		.sort((a, b) => a - b);
	const mostCommonGap = uniqueGaps.reduce((a, b) => (gapCounts[a] > gapCounts[b] ? a : b));
	const gapVariability = uniqueGaps.length;

	// Consider pattern reasonable if:
	// - Most common gap is 1 (consecutive numbering)
	// - OR gaps are small and consistent (like 1,2,1,2,1...)
	// - OR large gaps but very consistent (like 10,10,10... for every 10th hole)
	const hasReasonablePattern =
		mostCommonGap === 1 || // Mostly consecutive
		(gapVariability <= 3 && Math.max(...uniqueGaps) <= 5) || // Small, consistent gaps
		(gapVariability === 1 && gaps.length > 5); // Very consistent larger gaps

	console.log("Gap analysis:", {
		gaps: gaps.slice(0, 10), // First 10 gaps
		mostCommonGap,
		gapVariability,
		hasReasonablePattern
	});

	return {
		hasReasonablePattern,
		mostCommonGap,
		gaps,
		gapVariability
	};
}

/**
 * ENHANCED SEQUENTIAL DETECTION
 *
 * Uses improved algorithms while respecting sequence order
 */
function enhancedSequentialDetection(numericHoles, entityName, gapInfo) {
	// Choose algorithm based on gap pattern
	if (gapInfo.mostCommonGap === 1 && gapInfo.gapVariability <= 2) {
		// Mostly consecutive - use improved line fitting
		console.log("Using improved sequential line fitting");
		return improvedSequentialLineFitting(numericHoles, entityName);
	} else if (gapInfo.gapVariability === 1) {
		// Consistent gaps - use pattern-based detection
		console.log("Using pattern-based detection for consistent gaps");
		return patternBasedSequentialDetection(numericHoles, entityName, gapInfo.mostCommonGap);
	} else {
		// Irregular gaps - use sequence-aware spatial clustering
		console.log("Using sequence-aware spatial clustering for irregular gaps");
		return sequenceAwareSpatialClustering(numericHoles, entityName);
	}
}

/**
 * PATTERN-BASED SEQUENTIAL DETECTION
 *
 * For holes with consistent gaps (like every 5th hole: 5,10,15,20...)
 */
function patternBasedSequentialDetection(numericHoles, entityName, pattern) {
	const tolerance = calculateAdaptiveTolerance(numericHoles);
	const rows = [];
	const used = new Set();

	// Group holes by their position in the pattern cycle
	const patternGroups = new Map();

	numericHoles.forEach((item, index) => {
		const patternPosition = item.num % pattern;
		if (!patternGroups.has(patternPosition)) {
			patternGroups.set(patternPosition, []);
		}
		patternGroups.get(patternPosition).push({ item, index });
	});

	// Process each pattern group as potential rows
	for (const [position, group] of patternGroups) {
		if (group.length >= 2) {
			// Test if this group forms good spatial rows
			const groupItems = group.map((g) => g.item);
			const spatialRows = detectSpatialRowsInGroup(groupItems, tolerance);

			spatialRows.forEach((row) => {
				if (row.length >= 2) {
					rows.push(row);
					row.forEach((hole) => {
						const originalIndex = numericHoles.indexOf(hole);
						if (originalIndex !== -1) used.add(originalIndex);
					});
				}
			});
		}
	}

	// Handle remaining holes
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
		}
	}

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1;
		});
	});

	console.log("Pattern-based detection found " + rows.length + " rows");
	return rows.length > 0;
}

/**
 * HANDLE MIXED SEQUENCE PATTERNS
 *
 * Better handling for mixed numeric/alphanumeric patterns while preserving sequence
 */
function handleMixedSequencePattern(holesData, entityName) {
	console.log("Enhanced mixed pattern handling");

	// Create unified sequence that preserves the original intent
	const sequencedHoles = createUnifiedSequence(holesData);

	// Try to detect patterns in the unified sequence
	if (sequencedHoles.hasValidPattern) {
		return enhancedSequentialDetection(sequencedHoles.holes, entityName, sequencedHoles.gapInfo);
	}

	// If no valid pattern, use sequence-weighted spatial clustering
	console.log("No clear pattern, using sequence-weighted spatial clustering");
	return detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName);
}

function createUnifiedSequence(holesData) {
	// Separate holes by type and create logical ordering
	const numericHoles = [];
	const alphaNumericHoles = [];
	const otherHoles = [];

	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericHoles.push({ hole, num: parseInt(hole.holeID), originalIndex: index });
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
			if (match) {
				alphaNumericHoles.push({
					hole,
					letter: match[1],
					num: parseInt(match[2]),
					originalIndex: index
				});
			}
		} else {
			otherHoles.push({ hole, num: index, originalIndex: index });
		}
	});

	// Create unified sequence
	let unifiedSequence = [];
	let counter = 1;

	// Add numeric holes first (sorted)
	numericHoles.sort((a, b) => a.num - b.num);
	numericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add alphanumeric holes (sorted by letter then number)
	alphaNumericHoles.sort((a, b) => {
		if (a.letter !== b.letter) {
			return a.letter.localeCompare(b.letter);
		}
		return a.num - b.num;
	});
	alphaNumericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add other holes last
	otherHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Analyze the unified sequence
	const gapInfo = analyzeSequenceGaps(unifiedSequence);

	return {
		holes: unifiedSequence,
		hasValidPattern: gapInfo.hasReasonablePattern,
		gapInfo
	};
}

// #endregion HDBSCAN-ROW-DETECTION

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// #endregion CUSTOM CSV

//---------------- START RULER TOOL ----------------//
// Add these global variables for ruler functionality (around line 80)

// Helper function to format numbers to 2 decimal places
function formatTo2Decimals(num) {
	return parseFloat(num).toFixed(2);
}

// Helper function to format numbers to 1 decimal place
function formatTo1Decimal(num) {
	return parseFloat(num).toFixed(1);
}

function drawRuler(startX, startY, startZ, endX, endY, endZ) {
	// Handle undefined/null Z values - use 0 as fallback
	const safeStartZ = startZ || 0;
	const safeEndZ = endZ || 0;

	// Calculate differences (following your formula exactly)
	const deltaX = endX - startX; // ΔX
	const deltaY = endY - startY; // ΔY
	const deltaZ = safeEndZ - safeStartZ; // ΔZ

	// Calculate 2D plan distance (horizontal distance, hypotenuse of blue triangle D)
	// Plan Length = √(ΔX² + ΔY²)
	const planDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

	// Calculate true 3D distance (hypotenuse of purple triangle C)
	// Total Length = √(ΔX² + ΔY² + ΔZ²)
	const totalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

	// Calculate bearing angle (horizontal direction)
	const lineAngle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;

	// Calculate elevation angle A (green angle from horizontal plane)
	// Angle A = arctan(|ΔZ| / Plan Length)
	const elevationAngle = planDistance > 0 ? (Math.atan(Math.abs(deltaZ) / planDistance) * 180) / Math.PI : 0;

	// Calculate slope percentage for additional context
	const slopePercent = planDistance > 0 ? (Math.abs(deltaZ) / planDistance) * 100 : 0;

	// Convert world coordinates to canvas coordinates
	const canvasStartX = (startX - centroidX) * currentScale + canvas.width / 2;
	const canvasStartY = -(startY - centroidY) * currentScale + canvas.height / 2;
	const canvasEndX = (endX - centroidX) * currentScale + canvas.width / 2;
	const canvasEndY = -(endY - centroidY) * currentScale + canvas.height / 2;

	// Draw main ruler line
	ctx.beginPath();
	ctx.moveTo(canvasStartX, canvasStartY);
	ctx.lineTo(canvasEndX, canvasEndY);
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 2;
	ctx.stroke();

	// Prepare text content with correct values
	const distanceText = "Z1: " + formatTo2Decimals(safeStartZ) + "m, Z2: " + formatTo2Decimals(safeEndZ) + "m"; //formatTo2Decimals(planDistance) + "m";
	const measurementsText = "Plan: " + formatTo2Decimals(planDistance) + "m, Total: " + formatTo2Decimals(totalDistance) + "m";
	const deltaDipText = "ΔZ: " + formatTo2Decimals(deltaZ) + "m, Angle: " + formatTo2Decimals(elevationAngle) + "°";
	const slopeText = "Slope: " + formatTo2Decimals(slopePercent) + "%";

	// Set text properties
	ctx.font = "12px Arial";
	ctx.fillStyle = darkModeEnabled ? "#00cccc" : "#004444";

	// Measure text dimensions
	const distanceTextWidth = ctx.measureText(distanceText).width;
	const measurementsTextWidth = ctx.measureText(measurementsText).width;
	const deltaDipTextWidth = ctx.measureText(deltaDipText).width;
	const slopeTextWidth = ctx.measureText(slopeText).width;
	const textHeight = 14;
	const padding = 6;

	// Calculate background rectangle dimensions for 4 lines
	const bgWidth = Math.max(distanceTextWidth, measurementsTextWidth, deltaDipTextWidth, slopeTextWidth) + padding * 2;
	const bgHeight = textHeight * 4 + padding * 5; // FOUR lines of text with padding

	// Calculate background position
	const bgX = canvasEndX + 5;
	const bgY = canvasEndY - bgHeight - 10;

	// Draw rounded rectangle background
	ctx.fillStyle = darkModeEnabled ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"; // Semi-transparent white
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 1;

	// Create rounded rectangle path
	const radius = 4;
	ctx.beginPath();
	ctx.moveTo(bgX + radius, bgY);
	ctx.lineTo(bgX + bgWidth - radius, bgY);
	ctx.quadraticCurveTo(bgX + bgWidth, bgY, bgX + bgWidth, bgY + radius);
	ctx.lineTo(bgX + bgWidth, bgY + bgHeight - radius);
	ctx.quadraticCurveTo(bgX + bgWidth, bgY + bgHeight, bgX + bgWidth - radius, bgY + bgHeight);
	ctx.lineTo(bgX + radius, bgY + bgHeight);
	ctx.quadraticCurveTo(bgX, bgY + bgHeight, bgX, bgY + bgHeight - radius);
	ctx.lineTo(bgX, bgY + radius);
	ctx.quadraticCurveTo(bgX, bgY, bgX + radius, bgY);
	ctx.closePath();

	// Fill and stroke the background
	ctx.fill();
	ctx.stroke();

	// Draw text with proper spacing for 4 lines
	ctx.fillStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.font = "12px Arial";

	// Draw distance text (first line)
	ctx.fillText(distanceText, bgX + padding, bgY + padding + textHeight);
	// Draw measurements text (second line)
	ctx.fillText(measurementsText, bgX + padding, bgY + padding + textHeight * 2 + 2);
	// Draw delta and dip (third line)
	ctx.fillText(deltaDipText, bgX + padding, bgY + padding + textHeight * 3 + 4);
	// Draw slope percentage (fourth line)
	ctx.fillText(slopeText, bgX + padding, bgY + padding + textHeight * 4 + 6);

	// Draw meter increments (perpendicular tick marks) - use plan distance for tick spacing
	if (planDistance > 0) {
		for (let i = 0; i <= Math.floor(planDistance); i++) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.2m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.2 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.2 * Math.sin(perpAngle);
			const tick2X = tickX - 0.2 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.2 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}

		// Draw half-meter increments (shorter tick marks)
		for (let i = 0.5; i < planDistance; i += 1) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.1m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.1 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.1 * Math.sin(perpAngle);
			const tick2X = tickX - 0.1 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.1 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			// Draw tick mark
			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}
	}
}
// Convert the Java paintAngleMeasure function
function drawProtractor(p1X, p1Y, p2X, p2Y, p3X, p3Y) {
	// Don't draw anything if p2 and p3 are the same as p1 (first click only)
	if (p2X === p1X && p2Y === p1Y && p3X === p1X && p3Y === p1Y) {
		return;
	}

	// Calculate distances
	const d1 = Math.sqrt(Math.pow(p2X - p1X, 2) + Math.pow(p2Y - p1Y, 2));
	const d2 = Math.sqrt(Math.pow(p3X - p1X, 2) + Math.pow(p3Y - p1Y, 2));

	// Calculate bearings (North = 0°, East = 90°)
	const bearing1 = (90 - (Math.atan2(p2Y - p1Y, p2X - p1X) * 180) / Math.PI + 360) % 360;
	const bearing2 = (90 - (Math.atan2(p3Y - p1Y, p3X - p1X) * 180) / Math.PI + 360) % 360;

	// Calculate angle between the two lines
	let angle = Math.abs(bearing1 - bearing2);
	if (angle > 180) angle = 360 - angle;

	// Convert to canvas coordinates
	const canvasP1X = (p1X - centroidX) * currentScale + canvas.width / 2;
	const canvasP1Y = -(p1Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP2X = (p2X - centroidX) * currentScale + canvas.width / 2;
	const canvasP2Y = -(p2Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP3X = (p3X - centroidX) * currentScale + canvas.width / 2;
	const canvasP3Y = -(p3Y - centroidY) * currentScale + canvas.height / 2;

	// Draw lines
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 1;

	// First line (center to p2)
	if (d1 > 0) {
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP2X, canvasP2Y);
		ctx.stroke();

		// Text for first line
		ctx.fillStyle = darkModeEnabled ? "rgba(255, 255, 255, 0.2)" : "rgba(0, 0, 0, 0.2)";
		ctx.font = "12px Arial";
		const text1 = formatTo2Decimals(d1) + "m " + formatTo1Decimal(bearing1) + "°";
		const textWidth1 = ctx.measureText(text1).width;
		ctx.fillRect(canvasP2X + 5, canvasP2Y - 20, textWidth1 + 4, 16);
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.strokeRect(canvasP2X + 5, canvasP2Y - 20, textWidth1 + 4, 16);
		ctx.fillStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.fillText(text1, canvasP2X + 7, canvasP2Y - 8);
	}

	// Second line (center to p3) - only if p3 is different from p1
	if (d2 > 0 && !(p3X === p1X && p3Y === p1Y)) {
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP3X, canvasP3Y);
		ctx.stroke();

		// Text for second line
		ctx.fillStyle = darkModeEnabled ? "rgba(255, 255, 255, 0.2)" : "rgba(0, 0, 0, 0.2)";
		ctx.font = "12px Arial";
		const text2 = formatTo2Decimals(d2) + "m " + formatTo1Decimal(bearing2) + "°";
		const textWidth2 = ctx.measureText(text2).width;
		ctx.fillRect(canvasP3X + 5, canvasP3Y - 20, textWidth2 + 4, 16);
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.strokeRect(canvasP3X + 5, canvasP3Y - 20, textWidth2 + 4, 16);
		ctx.fillStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.fillText(text2, canvasP3X + 7, canvasP3Y - 8);

		// Angle text at center point (only when we have both lines)
		const text3 = formatTo1Decimal(angle) + "° / " + formatTo1Decimal(360 - angle) + "°";
		const textWidth3 = ctx.measureText(text3).width;
		ctx.fillStyle = darkModeEnabled ? "rgba(255, 255, 255, 0.2)" : "rgba(0, 0, 0, 0.2)";
		ctx.fillRect(canvasP1X + 5, canvasP1Y - 40, textWidth3 + 4, 16);
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.strokeRect(canvasP1X + 5, canvasP1Y - 40, textWidth3 + 4, 16);
		ctx.fillStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.fillText(text3, canvasP1X + 7, canvasP1Y - 28);

		// Draw arc between the lines
		const arcRadius = (Math.min(d1, d2) / 3) * currentScale;
		if (arcRadius > 5) {
			// Calculate the actual angles of the lines in canvas coordinates
			const angle1 = Math.atan2(canvasP2Y - canvasP1Y, canvasP2X - canvasP1X);
			const angle2 = Math.atan2(canvasP3Y - canvasP1Y, canvasP3X - canvasP1X);

			// Calculate the difference between angles
			let angleDiff = angle2 - angle1;

			// Normalize to [-π, π]
			while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
			while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

			// Always draw the smaller arc (interior angle)
			let startAngle, endAngle, counterClockwise;

			if (Math.abs(angleDiff) <= Math.PI) {
				// The direct path is the smaller arc
				startAngle = angle1;
				endAngle = angle2;
				counterClockwise = angleDiff > 0;
			} else {
				// The direct path is the larger arc, so we need to go the other way
				startAngle = angle2;
				endAngle = angle1;
				counterClockwise = angleDiff < 0;
			}

			ctx.beginPath();
			ctx.arc(canvasP1X, canvasP1Y, arcRadius, startAngle, endAngle, counterClockwise);
			ctx.strokeStyle = "#FF0000"; // Red for arc
			ctx.lineWidth = 2;
			ctx.stroke();
		}
	}
}
// Add event listeners for the ruler tools
rulerTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerActive = true;
		rulerStartPoint = null;
		rulerEndPoint = null;
		canvas.addEventListener("click", handleRulerClick);
		updateStatusMessage("Ruler Tool Activated\nSelect 2 points to measure distance\nChange tool to remove.");
	} else {
		isRulerActive = false;
		rulerStartPoint = null;
		rulerEndPoint = null;
		canvas.removeEventListener("click", handleRulerClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});
//Protractor Tool addlistener
rulerProtractorTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerProtractorTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerProtractorActive = true;
		rulerProtractorPoints = [];
		canvas.addEventListener("click", handleRulerProtractorClick);
		updateStatusMessage("Protractor Tool Activated\nSelect 3 points to measure bearing\nChange tool to remove.");
	} else {
		isRulerProtractorActive = false;
		rulerProtractorPoints = [];
		canvas.removeEventListener("click", handleRulerProtractorClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Handle ruler clicks
function handleRulerClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (!rulerStartPoint) {
		// First click - set start point, ruler will now follow mouse
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ
		};
		rulerEndPoint = null;
	} else if (!rulerEndPoint) {
		// Second click - lock in the end point, measurement is complete
		rulerEndPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ
		};
	} else {
		// Third click - start new measurement
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ
		};
		rulerEndPoint = null;
	}
	drawData(allBlastHoles, selectedHole);
}
// Handle ruler bearing clicks (3 points)
function handleRulerProtractorClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	rulerProtractorPoints.push({
		x: worldX,
		y: worldY
	});

	if (rulerProtractorPoints.length > 3) {
		// Start new measurement after 3 points
		rulerProtractorPoints = [
			{
				x: worldX,
				y: worldY
			}
		];
	}

	drawData(allBlastHoles, selectedHole);
}

//----------------- END RULER TOOLS --------------------//
// Add these tool references after the existing ones
const patternInPolygonTool = document.getElementById("patternInPolygonTool");
const holesAlongLineTool = document.getElementById("holesAlongLineTool");
const holesAlongPolyLineTool = document.getElementById("holesAlongPolyLineTool");

// Add state variables for the new tools
let isPatternInPolygonActive = false;
let isHolesAlongLineActive = false;
let isHolesAlongPolyLineActive = false;

// Pattern in Polygon Tool state
let patternPolygonStep = 0; // 0=select polygon, 1=select start point, 2=select end point, 3=select reference point
let selectedPolygon = null;
let patternStartPoint = null;
let patternEndPoint = null;
let patternReferencePoint = null;
// KAD Polygon selection for editing
let selectedKADPolygon = null; // Keep selectedKADPolygon for backward compatibility
let selectedKADObject = null; // For all KAD objects (points, lines, circles, text)

// Holes Along Line Tool state
let holesLineStep = 0; // 0=select start point, 1=select end point
let lineStartPoint = null;
let lineEndPoint = null;

// Holes Along PolyLine Tool state
let lastClickTime = null;
// Add state variables for the polyline tool
let polylineStep = 0; // 0=select line/polygon, 1=select start point, 2=select end point
let selectedPolyline = null;
let polylineStartPoint = null;
let polylineEndPoint = null;

// Add this wherever I finish clipping holes to polygon boundaries
function finalizePatternInPolygon(entityName) {
	// After clipping operations are complete
	renumberPatternAfterClipping(entityName);

	// Recalculate times and redraw
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, 0, 0);
	if (result) {
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
	}

	drawData(allBlastHoles, selectedHole);
	updateTreeView(); // Update the tree to show new numbering
}

//---------------PATTERN IN POLYGON TOOL---------------//
patternInPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("patternInPolygonTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["patternInPolygonTool", "selectPointerTool", "defaultListeners"]);

		endKadTools();
		isPatternInPolygonActive = true;
		patternPolygonStep = 0;
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;

		canvas.addEventListener("click", handlePatternInPolygonClick);
		canvas.addEventListener("touchstart", handlePatternInPolygonClick);

		updateStatusMessage("Step 1: Click on a polygon to select it");
	} else {
		resetFloatingToolbarButtons("none");
		isPatternInPolygonActive = false;
		patternPolygonStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;

		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handlePatternInPolygonClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (patternPolygonStep) {
		case 0: // Select polygon
			const clickedEntityInfo = getClickedKADEntity(worldX, worldY);
			if (clickedEntityInfo && clickedEntityInfo.entity.entityType === "poly") {
				selectedPolygon = clickedEntityInfo.entity; // ← Extract just the entity
				patternPolygonStep = 1;
				updateStatusMessage("Step 2: Click to select pattern start point");
			} else {
				updateStatusMessage("No polygon found.\nStep 1: Click on a polygon to select it");
			}
			break;

		case 1: // Select start point
			patternStartPoint = {
				x: worldX,
				y: worldY
			};
			patternPolygonStep = 2;
			updateStatusMessage("Step 3: Click to select pattern\nend point (for orientation)");
			console.log("Pattern start point set to:", worldX.toFixed(2), worldY.toFixed(2));
			break;

		case 2: // Select end point
			patternEndPoint = {
				x: worldX,
				y: worldY
			};
			patternPolygonStep = 3;
			updateStatusMessage("Step 4: Click to select reference point");
			console.log("Pattern end point set to:", worldX.toFixed(2), worldY.toFixed(2));
			break;

		case 3: // Select reference point
			patternReferencePoint = {
				x: worldX,
				y: worldY
			};
			updateStatusMessage("Reference point selected");
			console.log("Pattern reference point set to:", worldX.toFixed(2), worldY.toFixed(2));
			showPatternInPolygonPopup();
			// Dont deactivate the tool here - let the popup handle it
			// patternInPolygonTool.checked = false;
			// patternInPolygonTool.dispatchEvent(new Event("change")); // ← THIS IS THE PROBLEM!
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
//---------------HOLES ALONG POLYLINE TOOL---------------//
holesAlongPolyLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongPolyLineTool");

		endKadTools();
		isHolesAlongPolyLineActive = true;
		polylineStep = 0;
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.addEventListener("click", handleHolesAlongPolyLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Set cursor to indicate selection mode
		canvas.style.cursor = "crosshair";

		updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongPolyLineActive = false;
		polylineStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});
// Updated click handler with multi-step process
function handleHolesAlongPolyLineClick(event) {
	if (!isHolesAlongPolyLineActive) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (polylineStep) {
		case 0: // Select line/polygon
			// Use the same robust selection method as the select pointer tool
			const clickedKADObject = getClickedKADObject(clickX, clickY);

			if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
				selectedPolyline = {
					type: clickedKADObject.entityType === "line" ? "line" : "polygon",
					vertices: allKADDrawingsMap.get(clickedKADObject.entityName).data.map((point) => ({
						x: point.pointXLocation,
						y: point.pointYLocation
					})),
					entity: allKADDrawingsMap.get(clickedKADObject.entityName)
				};
				polylineStep = 1;
				updateStatusMessage("Step 2: Click on a vertex or point along the " + selectedPolyline.type + " to set the start point.");
				console.log("Selected " + selectedPolyline.type + " with", selectedPolyline.vertices.length, "vertices");
				break;
			}

			updateStatusMessage("No line or polygon found. Step 1: Click on an existing line, polyline, or polygon edge.");
			break;

		case 1: // Select start point
			polylineStartPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineStartPoint) {
				polylineStep = 2;
				updateStatusMessage("Step 3: Click on another vertex along the line to set the end point.");
				console.log("Start point set at:", polylineStartPoint);
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;

		case 2: // Select end point
			polylineEndPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineEndPoint) {
				console.log("End point set at:", polylineEndPoint);

				// Create path from start to end point - now with polygon awareness
				const isPolygon = selectedPolyline.type === "polygon";
				const pathVertices = createPathBetweenVertices(selectedPolyline.vertices, polylineStartPoint, polylineEndPoint, isPolygon);

				if (pathVertices.length >= 2) {
					// Pass the polygon type and original vertices to the popup for reverse handling
					showHolesAlongPolylinePopup(pathVertices, selectedPolyline);
				} else {
					updateStatusMessage("Invalid path between selected points. Please try again.");
					polylineStep = 1;
					polylineStartPoint = null;
					polylineEndPoint = null;
				}

				// DON'T deactivate the tool here - let the popup handle it
				// holesAlongPolyLineTool.checked = false;
				// holesAlongPolyLineTool.dispatchEvent(new Event("change"));
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
//---------------HOLES ALONG LINE TOOL---------------//
holesAlongLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongLineTool");

		endKadTools();
		isHolesAlongLineActive = true;
		holesLineStep = 0;
		lineStartPoint = null;
		lineEndPoint = null;

		canvas.addEventListener("click", handleHolesAlongLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongLineClick);

		updateStatusMessage("Step 1: Click to select line start point");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongLineActive = false;
		holesLineStep = 0;

		// Clear line points to remove visual feedback
		lineStartPoint = null;
		lineEndPoint = null;

		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// 		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handleHolesAlongLineClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (holesLineStep) {
		case 0: // Select start point
			lineStartPoint = {
				x: worldX,
				y: worldY
			};
			holesLineStep = 1;
			updateStatusMessage("Step 2: Click to select line end point");
			break;

		case 1: // Select end point
			lineEndPoint = {
				x: worldX,
				y: worldY
			};
			showHolesAlongLinePopup();
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
// Helper function to update status messages
function updateStatusMessage(message) {
	// You can display this in a status bar or console
	//console.log(message);
	statusMessage = message;
	// If you have a status element in your HTML, update it:
	// document.getElementById("statusMessage").textContent = message;
}
// Enhanced snapping function for CAD vertices and hole points
function findNearestSnapPoint(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	let closestPoint = null;
	let minDistance = tolerance;
	let snapType = null;

	console.log("Searching for snap points near:", worldX.toFixed(2), worldY.toFixed(2), "tolerance:", tolerance);

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "polygons for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Polygon", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Polygon vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY
						};
						snapType = "CAD Polygon Vertex";
						console.log("Found closer CAD polygon vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "lines for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Line", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Line vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY
						};
						snapType = "CAD Line Vertex";
						console.log("Found closer CAD line vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search hole collar allBlastHoles
	if (allBlastHoles && allBlastHoles.length > 0) {
		console.log("Searching", allBlastHoles.length, "holes for snap allBlastHoles");
		allBlastHoles.forEach((hole, holeIndex) => {
			// Collar point
			if (hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
				const collarDistance = Math.sqrt(Math.pow(worldX - hole.startXLocation, 2) + Math.pow(worldY - hole.startYLocation, 2));
				if (collarDistance < minDistance) {
					minDistance = collarDistance;
					closestPoint = {
						x: hole.startXLocation,
						y: hole.startYLocation
					};
					snapType = "Hole Collar (" + hole.holeID + ")";
					console.log("Found closer hole collar, distance:", collarDistance.toFixed(2));
				}
			}

			// Grade point (if exists)
			if (hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
				const gradeDistance = Math.sqrt(Math.pow(worldX - hole.gradeXLocation, 2) + Math.pow(worldY - hole.gradeYLocation, 2));
				if (gradeDistance < minDistance) {
					minDistance = gradeDistance;
					closestPoint = {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation
					};
					snapType = "Hole Grade (" + hole.holeID + ")";
					console.log("Found closer hole grade, distance:", gradeDistance.toFixed(2));
				}
			}

			// Toe point (calculated from hole geometry)
			if (hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
				const toeDistance = Math.sqrt(Math.pow(worldX - hole.endXLocation, 2) + Math.pow(worldY - hole.endYLocation, 2));
				if (toeDistance < minDistance) {
					minDistance = toeDistance;
					closestPoint = {
						x: hole.endXLocation,
						y: hole.endYLocation
					};
					snapType = "Hole Toe (" + hole.holeID + ")";
					console.log("Found closer hole toe, distance:", toeDistance.toFixed(2));
				}
			}
		});
	} else {
		console.log("No holes found or allBlastHoles array is empty");
	}

	if (closestPoint) {
		console.log("SNAP FOUND:", snapType, "at", closestPoint.x.toFixed(2), closestPoint.y.toFixed(2), "distance:", minDistance.toFixed(2));
	} else {
		console.log("No snap allBlastHoles found within tolerance");
	}

	return closestPoint
		? {
				point: closestPoint,
				type: snapType,
				distance: minDistance
		  }
		: null;
}
// Helper function to find the closest vertex to a click point (keep original for compatibility)
function findClosestVertex(clickX, clickY, vertices, tolerance = getSnapToleranceInWorldUnits()) {
	let closestVertex = null;
	let minDistance = tolerance;

	vertices.forEach((vertex, index) => {
		const distance = Math.sqrt(Math.pow(clickX - vertex.x, 2) + Math.pow(clickY - vertex.y, 2));
		if (distance < minDistance) {
			minDistance = distance;
			closestVertex = {
				...vertex,
				index: index
			};
		}
	});

	return closestVertex;
}
// Helper function to create a path between two vertices
// Now properly handles polygons as closed shapes
function createPathBetweenVertices(vertices, startVertex, endVertex, isPolygon = false) {
	const startIndex = startVertex.index;
	const endIndex = endVertex.index;

	if (startIndex === endIndex) {
		return [startVertex];
	}

	let pathVertices = [];

	if (!isPolygon) {
		// For open polylines/lines - original logic
		if (startIndex < endIndex) {
			for (let i = startIndex; i <= endIndex; i++) {
				pathVertices.push(vertices[i]);
			}
		} else {
			for (let i = startIndex; i >= endIndex; i--) {
				pathVertices.push(vertices[i]);
			}
		}
	} else {
		// For polygons - handle as closed loop
		const totalVertices = vertices.length;

		// Calculate forward path distance (going from start to end in forward direction)
		let forwardDistance;
		if (endIndex >= startIndex) {
			forwardDistance = endIndex - startIndex;
		} else {
			forwardDistance = totalVertices - startIndex + endIndex;
		}

		// Calculate backward path distance (going from start to end in backward direction)
		let backwardDistance;
		if (startIndex >= endIndex) {
			backwardDistance = startIndex - endIndex;
		} else {
			backwardDistance = startIndex + (totalVertices - endIndex);
		}

		// Choose the shorter path by default (can be overridden by reverse option)
		let useForwardPath = forwardDistance <= backwardDistance;

		if (useForwardPath) {
			// Forward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex + 1) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		} else {
			// Backward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex - 1 + totalVertices) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		}

		console.log("Polygon path created:", {
			startIndex: startIndex,
			endIndex: endIndex,
			forwardDistance: forwardDistance,
			backwardDistance: backwardDistance,
			usedForwardPath: useForwardPath,
			pathLength: pathVertices.length
		});
	}

	return pathVertices;
}

function toRadians(degrees) {
	return (degrees * Math.PI) / 180;
}

function toDegrees(radians) {
	return (radians * 180) / Math.PI;
}

function toBearing(degrees) {
	return (degrees + 90) % 360;
}
// ADDED ROWID AND POSID
function generatePatternInPolygon(patternSettings) {
	if (!selectedPolygon || !patternStartPoint || !patternEndPoint || !patternReferencePoint) {
		console.error("Missing pattern data");
		return;
	}

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	console.log("Generating pattern in polygon. REF X:[" + patternReferencePoint.x + ", " + patternReferencePoint.y + "]");

	// Extract pattern settings
	const { blastName, burden, spacing, spacingOffset, collarZ, gradeZ, subdrill, angle, bearing, diameter, type, startNumber, nameTypeIsNumerical, useGradeZ, length, patternType } = patternSettings;

	// Calculate the orientation angle from start to end point
	const dx = patternEndPoint.x - patternStartPoint.x;
	const dy = patternEndPoint.y - patternStartPoint.y;

	// Calculate orientation (bearing from first to second point)
	let orientation = ((Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;

	console.log("Line bearing (Start to End):", orientation.toFixed(2) + "°");

	// Get polygon vertices
	const polygonVertices = selectedPolygon.data.map((point) => ({
		x: point.pointXLocation,
		y: point.pointYLocation
	}));

	console.log("Polygon vertices:", polygonVertices.length);

	// Find polygon bounds
	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;
	polygonVertices.forEach((vertex) => {
		const x = vertex.x;
		const y = vertex.y;
		minX = Math.min(minX, x);
		maxX = Math.max(maxX, x);
		minY = Math.min(minY, y);
		maxY = Math.max(maxY, y);
	});

	const polygonWidth = maxX - minX;
	const polygonHeight = maxY - minY;
	const polygonDiagonal = Math.sqrt(polygonWidth * polygonWidth + polygonHeight * polygonHeight);

	// Use the reference point as pattern origin
	const patternOriginX = patternReferencePoint.x;
	const patternOriginY = patternReferencePoint.y;
	console.log("Pattern in polygon. ORIGIN  X:[" + patternOriginX + ", " + patternOriginY + "]");

	// Store original holes count to identify new holes
	const originalHolesCount = allBlastHoles.length;

	// Generate the pattern grid
	const rowBearing = orientation;
	const columnBearing = (orientation + 90) % 360;

	console.log("Row bearing:", rowBearing.toFixed(2) + "°");
	console.log("Column bearing:", columnBearing.toFixed(2) + "°");

	const rowRadians = toRadians(rowBearing);
	const columnRadians = toRadians(columnBearing);

	// Calculate grid extents based on polygon size
	const bufferFactor = 10.0;
	const maxDistance = polygonDiagonal * bufferFactor;

	const numRows = Math.ceil(maxDistance / burden);
	const numCols = Math.ceil(maxDistance / spacing);

	const halfRows = Math.floor(numRows / 2);
	const halfCols = Math.floor(numCols / 2);

	// Find the grid point closest to (0,0)
	let centerGridX = 0;
	let centerGridY = 0;
	let minDistToCenter = Infinity;

	for (let i = -1; i <= 1; i++) {
		for (let k = -1; k <= 1; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const gridX = colOffset;
			const gridY = i * burden;
			const distToCenter = Math.sqrt(gridX * gridX + gridY * gridY);

			if (distToCenter < minDistToCenter) {
				minDistToCenter = distToCenter;
				centerGridX = gridX;
				centerGridY = gridY;
			}
		}
	}

	const gridXOffset = -centerGridX;
	const gridYOffset = -centerGridY;

	console.log("Grid adjustment: Found center grid point at (" + centerGridX.toFixed(2) + ", " + centerGridY.toFixed(2) + "), applying offset (" + gridXOffset.toFixed(2) + ", " + gridYOffset.toFixed(2) + ")");

	// Collect all holes that will be inside the polygon WITH their original grid coordinates
	const holesInPolygon = [];

	// Generate grid of holes - collect valid holes first
	for (let i = -halfRows; i <= halfRows; i++) {
		for (let k = -halfCols; k <= halfCols; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const adjustedColOffset = colOffset + gridXOffset;
			const adjustedRowOffset = i * burden + gridYOffset;

			// Calculate position using row and column bearings
			const yFromColumn = adjustedRowOffset * Math.sin(columnRadians);
			const xFromColumn = adjustedRowOffset * Math.cos(columnRadians);
			const yFromRow = adjustedColOffset * Math.sin(rowRadians);
			const xFromRow = adjustedColOffset * Math.cos(rowRadians);

			const holeX = patternOriginX + xFromColumn + xFromRow;
			const holeY = patternOriginY + yFromColumn + yFromRow;

			// Check if hole is inside polygon
			if (isPointInPolygonVertices(holeX, holeY, polygonVertices)) {
				holesInPolygon.push({
					x: holeX,
					y: holeY,
					originalGridRow: i,
					originalGridCol: k,
					isStaggered: isStaggered && i % 2 !== 0
				});
			}
		}
	}

	// Group holes by their ORIGINAL GRID ROW
	const uniqueGridRows = [...new Set(holesInPolygon.map((hole) => hole.originalGridRow))];
	uniqueGridRows.sort((a, b) => a - b);

	console.log("Unique grid rows found:", uniqueGridRows);

	const rows = [];
	uniqueGridRows.forEach((gridRowIndex) => {
		const holesInThisGridRow = holesInPolygon.filter((hole) => hole.originalGridRow === gridRowIndex);

		const rowBearingRadians = (90 - orientation) * (Math.PI / 180);
		holesInThisGridRow.forEach((hole) => {
			hole.spacingProjection = hole.x * Math.cos(rowBearingRadians) + hole.y * Math.sin(rowBearingRadians);
		});

		holesInThisGridRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
		rows.push(holesInThisGridRow);
	});

	// Determine the actual grid ranges
	let minActualRow = Math.min(...uniqueGridRows);
	let maxActualRow = Math.max(...uniqueGridRows);
	let minActualCol = Infinity;
	let maxActualCol = -Infinity;

	holesInPolygon.forEach((hole) => {
		minActualCol = Math.min(minActualCol, hole.originalGridCol);
		maxActualCol = Math.max(maxActualCol, hole.originalGridCol);
	});

	console.log("Actual grid range: rows " + minActualRow + " to " + maxActualRow + ", cols " + minActualCol + " to " + maxActualCol);

	// Get the starting rowID for this pattern (first row will get this rowID)
	const startingRowID = getNextRowID(blastName);
	console.log("Starting rowID for polygon pattern:", startingRowID);

	let holeCounter = startNumber;

	// Process rows from first (lowest row letter) to last (highest row letter)
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		const row = rows[rowIndex];

		// Each row in the pattern gets its own rowID
		const currentRowID = startingRowID + rowIndex;

		// Calculate actual row letter based on the row's original grid position
		const actualRowGridIndex = row[0].originalGridRow;
		const rowLetterIndex = actualRowGridIndex - minActualRow;

		let rowLetter = "A";
		for (let l = 0; l < rowLetterIndex; l++) {
			rowLetter = incrementLetter(rowLetter);
		}

		// Process holes in this row
		for (let colIndex = 0; colIndex < row.length; colIndex++) {
			const hole = row[colIndex];

			let holeID;
			if (nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				const actualColGridIndex = hole.originalGridCol;
				let colNumber = actualColGridIndex - minActualCol + 1;

				// Apply offset logic based on spacingOffset value and row position
				if (spacingOffset <= -1) {
					colNumber = colNumber + rowLetterIndex;
				} else if (spacingOffset > -1 && spacingOffset < 1) {
					// colNumber stays the same
				} else if (spacingOffset >= 1) {
					// colNumber stays the same
				}

				holeID = rowLetter + colNumber;
			}

			// Position ID is sequential for each hole in this row (starts at 1 for each row)
			const posID = colIndex + 1;

			// Add hole using existing addHole function with rowID and posID
			addHole(true, useGradeZ, blastName, holeID, hole.x, hole.y, collarZ, gradeZ, diameter, type, length, subdrill, angle, bearing, currentRowID, posID, burden, spacing);
		}
	}

	const holesAdded = allBlastHoles.length - originalHolesCount;
	console.log("Generated pattern in polygon with " + holesAdded + " holes across " + rows.length + " rows (rowIDs " + startingRowID + "-" + (startingRowID + rows.length - 1) + ")");

	//! REDO with the FloatingDialog class
	if (holesAdded === 0) {
		showModalMessage("No Holes Generated", "No holes were generated in the polygon. Please check your pattern settings and polygon shape.", "warning");
	} else {
		showModalMessage("Pattern Generated", "Successfully generated " + holesAdded + " holes in the polygon across " + rows.length + " rows (Rows " + startingRowID + "-" + (startingRowID + rows.length - 1) + ").", "success");
	}

	// Update display
	drawData(allBlastHoles, selectedHole);
	saveHolesToLocalStorage(allBlastHoles);
}
//! REDO with the FloatingDialog class
// Function to show holes along line popup
function showHolesAlongLinePopup() {
	let blastNameValue = "LinePattern_" + Date.now();
	// Retrieve the last entered values from local storage
	let savedHolesAlongLineSettings = JSON.parse(localStorage.getItem("savedHolesAlongLineSettings")) || {};
	let lastValues = {
		blastName: savedHolesAlongLineSettings.blastName || blastNameValue,
		spacing: savedHolesAlongLineSettings.spacing || 3.0,
		collarZ: savedHolesAlongLineSettings.collarZ || 0,
		gradeZ: savedHolesAlongLineSettings.gradeZ || -10,
		subdrill: savedHolesAlongLineSettings.subdrill || 1,
		angle: savedHolesAlongLineSettings.angle || 0,
		bearing: savedHolesAlongLineSettings.bearing || 180,
		diameter: savedHolesAlongLineSettings.diameter || 115,
		type: savedHolesAlongLineSettings.type || "Production",
		startNumber: savedHolesAlongLineSettings.startNumber || 1,
		nameTypeIsNumerical: savedHolesAlongLineSettings.nameTypeIsNumerical !== undefined ? savedHolesAlongLineSettings.nameTypeIsNumerical : true,
		useGradeZ: savedHolesAlongLineSettings.useGradeZ !== undefined ? savedHolesAlongLineSettings.useGradeZ : true,
		useLineBearing: savedHolesAlongLineSettings.useLineBearing !== undefined ? savedHolesAlongLineSettings.useLineBearing : true,
		length: savedHolesAlongLineSettings.length || 10
	};

	// Calculate default length if using grade Z
	const defaultLength = lastValues.useGradeZ ? Math.abs((lastValues.collarZ - lastValues.gradeZ + lastValues.subdrill) / Math.cos(lastValues.angle * (Math.PI / 180))) : lastValues.length;

	// Calculate default grade if using length
	const defaultGradeZ = !lastValues.useGradeZ ? lastValues.collarZ - (lastValues.length - lastValues.subdrill) * Math.cos(lastValues.angle * (Math.PI / 180)) : lastValues.gradeZ;

	// Show loading spinner while the popup is created
	Swal.showLoading();

	// Update the bearing calculation in showHolesAlongLinePopup:
	// Calculate line bearing for display
	let lineBearing = 0;
	if (lineStartPoint && lineEndPoint) {
		const dx = lineEndPoint.x - lineStartPoint.x;
		const dy = lineEndPoint.y - lineStartPoint.y;
		// In world coordinates: North = 0°, East = 90°, South = 180°, West = 270°
		// Since +Y is North in world coordinates, we need to use atan2(dx, dy) not atan2(dy, dx)
		lineBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;
	}
	const perpBearing = (lineBearing + 90) % 360;

	//! REDO with the FloatingDialog class
	Swal.fire({
		title: "Generate Holes Along Line",
		showCancelButton: true,
		confirmButtonText: "OK",
		cancelButtonText: "Cancel",
		html: `
        <div class="button-container-2col">
          <label class="labelWhite18" for="blastName">Blast Name</label>
          <input type="text3" id="blastName" name="blastName" placeholder="Blast Name" value="${lastValues.blastName}"/>
          <label class="labelWhite18" for="nameTypeIsNumerical">Numerical Names</label>
          <input type="checkbox" id="nameTypeIsNumerical" name="nameTypeIsNumerical" ${lastValues.nameTypeIsNumerical ? "checked" : ""}>
          <label class="labelWhite18" for="startNumber">Starting Hole Number</label>
          <input type="number3" id="startNumber" name="startNumber" placeholder="Start Number" value="${lastValues.startNumber}" step="1" min="1" max="9999" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacing">Spacing (m)</label>
          <input type="number3" id="spacing" name="spacing" placeholder="Spacing" value="${lastValues.spacing}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="collarZ">Collar Elevation (m)</label>
          <input type="number3" id="collarZ" name="collarZ" placeholder="Collar Z" value="${lastValues.collarZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="useGradeZ">Use Grade Z</label>
          <input type="checkbox" id="useGradeZ" name="useGradeZ" ${lastValues.useGradeZ ? "checked" : ""}>
          <label class="labelWhite18" for="gradeZ">Grade Elevation (m)</label>
          <input type="number3" id="gradeZ" name="gradeZ" placeholder="Grade Z" value="${defaultGradeZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*" ${!lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="length">Length (m)</label>
          <input type="number3" id="length" name="length" placeholder="Length" value="${defaultLength}" step="0.1" min="0.1" max="1000" inputmode="decimal" pattern="[0-9]*" ${lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="subdrill">Subdrill (m)</label>
          <input type="number3" id="subdrill" name="subdrill" placeholder="Subdrill" value="${lastValues.subdrill}" step="0.1" min="-50" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="angle">Hole Angle (° from vertical)</label>
          <input type="number3" id="angle" name="angle" placeholder="Angle" value="${lastValues.angle}" step="1" min="0" max="60" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="useLineBearing">Bearings are 90° to Row</label>
		<input type="checkbox" id="useLineBearing" name="useLineBearing" ${lastValues.useLineBearing ? "checked" : ""}>
		<label class="labelWhite18" for="bearing">Hole Bearing (°)</label>
		<input type="number3" id="bearing" name="bearing" placeholder="Bearing" value="${lastValues.bearing}" step="0.1" min="0" max="359.999" inputmode="decimal" pattern="[0-9]*" ${lastValues.useLineBearing ? "disabled" : ""}>
		<div class="labelWhite12" style="text-align: center;">Row Bearing: ${lineBearing.toFixed(1)}°</div>
		<div class="labelWhite12" style="text-align: right;">Directions: N=0°, E=90°, S=180°, W=270°</div>
		<div class="labelWhite12" style="text-align: center;">Perpendicular Bearing: ${perpBearing.toFixed(1)}°</div>
		<div></div>
          <label class="labelWhite18" for="diameter">Diameter (mm)</label>
          <input type="number3" id="diameter" name="diameter" placeholder="Diameter" value="${lastValues.diameter}" step="1" min="1" max="1000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="type">Hole Type</label>
          <input type="text3" id="type" name="type" placeholder="Type" value="${lastValues.type}"/>
        </div>
      `,
		customClass: {
			container: "custom-popup-container",
			popup: "custom-popup-container",
			title: "swal2-title",
			content: "swal2-content",
			confirmButton: "confirm",
			cancelButton: "cancel"
		},
		didOpen: () => {
			//! REDO with the FloatingDialog class
			// Add event listeners after the popup is opened
			const useGradeZCheckbox = document.getElementById("useGradeZ");
			const gradeZInput = document.getElementById("gradeZ");
			const lengthInput = document.getElementById("length");
			const collarZInput = document.getElementById("collarZ");
			const angleInput = document.getElementById("angle");
			const subdrillInput = document.getElementById("subdrill");
			const useLineBearingCheckbox = document.getElementById("useLineBearing");
			const bearingInput = document.getElementById("bearing");

			// Function to update fields based on checkbox state
			function updateFieldsBasedOnUseGradeZ() {
				const useGradeZ = useGradeZCheckbox.checked;

				// Enable/disable fields
				gradeZInput.disabled = !useGradeZ;
				lengthInput.disabled = useGradeZ;

				// Update calculations
				if (useGradeZ) {
					// Calculate length from grade
					const collarZ = parseFloat(collarZInput.value) || 0;
					const gradeZ = parseFloat(gradeZInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedLength = Math.abs((collarZ - gradeZ + subdrill) / Math.cos(angleRad));
					lengthInput.value = calculatedLength.toFixed(2);
				} else {
					// Calculate grade from length
					const collarZ = parseFloat(collarZInput.value) || 0;
					const length = parseFloat(lengthInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedGradeZ = collarZ - (length - subdrill) * Math.cos(angleRad);
					gradeZInput.value = calculatedGradeZ.toFixed(2);
				}
			}

			// Function to handle line bearing checkbox
			function updateBearingField() {
				bearingInput.disabled = useLineBearingCheckbox.checked;
			}

			// Add event listeners for changes
			useGradeZCheckbox.addEventListener("change", updateFieldsBasedOnUseGradeZ);
			gradeZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			lengthInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			collarZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			angleInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			subdrillInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			useLineBearingCheckbox.addEventListener("change", updateBearingField);

			// Initial update
			updateFieldsBasedOnUseGradeZ();
			updateBearingField();

			// Hide the loading spinner when the popup is ready
			Swal.hideLoading();
		}
	})
		.then((result) => {
			//! REDO with the FloatingDialog class
			if (result.isConfirmed) {
				// Retrieve values from the input fields
				const blastName = document.getElementById("blastName").value;
				const nameTypeIsNumerical = document.getElementById("nameTypeIsNumerical").checked;
				const useGradeZ = document.getElementById("useGradeZ").checked;
				const useLineBearing = document.getElementById("useLineBearing").checked;
				const startNumber = parseInt(document.getElementById("startNumber").value);
				const spacing = parseFloat(document.getElementById("spacing").value);
				const collarZ = parseFloat(document.getElementById("collarZ").value);
				const gradeZ = parseFloat(document.getElementById("gradeZ").value);
				const length = parseFloat(document.getElementById("length").value);
				const subdrill = parseFloat(document.getElementById("subdrill").value);
				const angle = parseFloat(document.getElementById("angle").value);
				const bearing = parseFloat(document.getElementById("bearing").value);
				const diameter = parseFloat(document.getElementById("diameter").value);
				const type = document.getElementById("type").value;

				// Validation checks
				if (!blastName || blastName.trim() === "") {
					showModalMessage("Invalid Blast Name", "Please enter a Blast Name.", "warning");
					return;
				}

				if (isNaN(spacing) || spacing <= 0) {
					showModalMessage("Invalid Spacing", "Please enter a positive spacing value.", "warning");
					return;
				}

				// Save values to localStorage
				const newValues = {
					blastName: blastName,
					nameTypeIsNumerical: nameTypeIsNumerical,
					startNumber: startNumber,
					spacing: spacing,
					collarZ: collarZ,
					gradeZ: gradeZ,
					length: length,
					subdrill: subdrill,
					angle: angle,
					bearing: bearing,
					diameter: diameter,
					type: type,
					useGradeZ: useGradeZ,
					useLineBearing: useLineBearing
				};
				localStorage.setItem("savedHolesAlongLineSettings", JSON.stringify(newValues));

				// Generate the holes along the line
				generateHolesAlongLine({
					blastName: blastName,
					nameTypeIsNumerical: nameTypeIsNumerical,
					useGradeZ: useGradeZ,
					useLineBearing: useLineBearing,
					startNumber: startNumber,
					spacing: spacing,
					collarZ: collarZ,
					gradeZ: gradeZ,
					length: length,
					subdrill: subdrill,
					angle: angle,
					bearing: bearing - 90,
					diameter: diameter,
					type: type
				});
			}
		})
		.finally(() => {
			// Reset tool
			debouncedUpdateTreeView(); // Use debounced version
			holesAlongLineTool.checked = false;
			holesAlongLineTool.dispatchEvent(new Event("change"));
		});
}
// Update the generateHolesAlongLine function to correctly apply the bearing:
// Update the generateHolesAlongLine function to use rowID/posID:
function generateHolesAlongLine(params) {
	//! REDO with the FloatingDialog class
	if (!lineStartPoint || !lineEndPoint) {
		console.error("Missing line points");
		return;
	}

	console.log("Generating holes along line...");
	console.log("Start:", lineStartPoint);
	console.log("End:", lineEndPoint);
	console.log("Parameters:", params);

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
		console.log("Initialized empty allBlastHoles array");
	}

	// Calculate line length and direction
	const dx = lineEndPoint.x - lineStartPoint.x;
	const dy = lineEndPoint.y - lineStartPoint.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);
	const unitX = dx / lineLength;
	const unitY = dy / lineLength;

	// Calculate line bearing in world coordinates
	const lineBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;
	console.log("Line bearing:", lineBearing.toFixed(2) + "°");

	// Generate holes along the line
	const numHoles = Math.floor(lineLength / params.spacing) + 1;
	const entityName = params.blastName || "LinePattern_" + Date.now();
	const originalHolesCount = allBlastHoles.length;

	// Calculate hole bearing based on user preference
	const holeBearing = params.useLineBearing ? (lineBearing + 90) % 360 : params.bearing;
	console.log("Using hole bearing:", holeBearing.toFixed(2) + "°");

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for line pattern");

	// Generate holes starting from the first point
	for (let i = 0; i < numHoles; i++) {
		const distanceAlongLine = i * params.spacing;
		const holeX = lineStartPoint.x + unitX * distanceAlongLine;
		const holeY = lineStartPoint.y + unitY * distanceAlongLine;

		// Calculate hole ID
		let holeID;
		if (params.nameTypeIsNumerical) {
			holeID = params.startNumber + i;
		} else {
			// Use alphabetical naming like A1, A2, etc.
			const letter = String.fromCharCode(65 + Math.floor(i / 26));
			const number = (i % 26) + 1;
			holeID = letter + number;
		}

		// Position ID is sequential for each hole in this row
		const posID = i + 1;

		// Add hole to points array with rowID and posID
		addHole(
			true, // useCustomHoleID - always true for pattern generation
			params.useGradeZ, // useGradeZ from params
			entityName,
			holeID, // holeID
			holeX, // startX
			holeY, // startY
			params.collarZ, // startZ
			params.gradeZ, // gradeZ
			params.diameter, // diameter
			params.type, // holeType
			params.length, // length
			params.subdrill, // subdrill
			params.angle, // angle
			holeBearing, // bearing - use calculated bearing perpendicular to line if useLineBearing is true
			rowID, // rowID - all holes in this line get the same rowID
			posID, // posID - sequential position in the row
			params.burden, // burden - Need to add to the show dialog popup for every hole add.
			params.spacing // spacing
		);
	}

	// Redraw
	debouncedUpdateTreeView(); // Use debounced version
	drawData(allBlastHoles, selectedHole);
	saveHolesToLocalStorage(allBlastHoles);

	const holesAdded = allBlastHoles.length - originalHolesCount;
	console.log("Generated " + holesAdded + " holes along line with rowID " + rowID);

	//! REDO with the FloatingDialog class
	// Show success/failure message with custom styling
	if (holesAdded === 0) {
		showModalMessage("No Holes Generated", "No holes were generated along the line. Please check your line and spacing settings.", "warning");
	} else {
		showModalMessage("Line Pattern Generated", `Successfully generated ${holesAdded} holes along the line (Row ${rowID}).`, "success");
	}
}
/**
 * Finds the KAD entity (line or poly) closest to a world coordinate click.
 * This function unifies the logic for selecting both open and closed polylines.
 * @param {number} worldX The x-coordinate of the click in world units.
 * @param {number} worldY The y-coordinate of the click in world units.
 * @returns {object|null} The selected entity object or null if nothing is found.
 */
function getClickedKADEntity(worldX, worldY) {
	if (allKADDrawingsMap.size === 0) return null;

	const tolerance = getSnapToleranceInWorldUnits();
	const candidateEntities = [];

	// Check each line or poly entity
	for (const [name, entity] of allKADDrawingsMap.entries()) {
		// ✅ CHECK VISIBILITY FIRST - Skip hidden entities
		if (!isEntityVisible(name)) continue;

		const points = entity.data;
		if (points.length < 1) continue;

		let minDistance = Infinity;
		let clickedVertex = null;
		let clickedSegment = null;
		const isClosed = entity.entityType === "poly";

		// For single-point entities (points, circles, text), only check the point
		if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
			const point = points[0]; // These entities have only one point
			const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));

			if (distance <= tolerance) {
				candidateEntities.push({
					entity: entity,
					minDistance: distance,
					selectionType: "point",
					clickedVertex: {
						index: 0,
						x: point.pointXLocation,
						y: point.pointYLocation,
						distance: distance
					},
					clickedSegment: null
				});
			}
			continue; // Skip to next entity
		}
		if (entity.entityType === "line") {
			// For lines, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}
		if (entity.entityType === "poly") {
			// For polygons, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}

		// If no vertex found, check segments
		if (!clickedVertex) {
			const numSegments = isClosed ? points.length : points.length - 1;
			for (let i = 0; i < numSegments; i++) {
				const p1 = points[i];
				const p2 = points[(i + 1) % points.length]; // Wraps around for closed polys

				const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

				if (distance <= tolerance && distance < minDistance) {
					minDistance = distance;
					clickedSegment = {
						startIndex: i,
						endIndex: (i + 1) % points.length,
						startPoint: {
							x: p1.pointXLocation,
							y: p1.pointYLocation
						},
						endPoint: {
							x: p2.pointXLocation,
							y: p2.pointYLocation
						},
						distance: distance
					};
				}
			}
		}

		// If we found a vertex or segment, add this entity as a candidate
		if (clickedVertex || clickedSegment) {
			candidateEntities.push({
				entity: entity,
				minDistance: minDistance,
				selectionType: clickedVertex ? "vertex" : "segment",
				clickedVertex: clickedVertex,
				clickedSegment: clickedSegment
			});
		}
	}

	if (candidateEntities.length === 0) {
		console.log("No KAD entities found near click location");
		return null;
	}

	// Sort by distance (closest first)
	candidateEntities.sort((a, b) => a.minDistance - b.minDistance);
	const selected = candidateEntities[0];

	console.log("Found", candidateEntities.length, "entities near click.");
	console.log("Selected entity:", selected.entity.entityName, "by", selected.selectionType, "at distance:", selected.minDistance.toFixed(3));

	// Determine the snap point
	let snappedX = worldX;
	let snappedY = worldY;

	if (selected.clickedVertex) {
		snappedX = selected.clickedVertex.x;
		snappedY = selected.clickedVertex.y;
	} else if (selected.clickedSegment) {
		const seg = selected.clickedSegment;
		const closestPoint = getClosestPointOnLineSegment(worldX, worldY, seg.startPoint.x, seg.startPoint.y, seg.endPoint.x, seg.endPoint.y);
		snappedX = closestPoint.x;
		snappedY = closestPoint.y;
	}

	return {
		entity: selected.entity,
		clickedX: snappedX,
		clickedY: snappedY,
		selectionType: selected.selectionType,
		clickedVertex: selected.clickedVertex,
		clickedSegment: selected.clickedSegment
	};
}
// Helper function to get interpolation parameter (0 to 1) for Z interpolation
function getInterpolationParameter(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;

	if (Math.abs(dx) > Math.abs(dy)) {
		return (px - x1) / dx;
	} else if (dy !== 0) {
		return (py - y1) / dy;
	} else {
		return 0; // Line segment is a point
	}
}
// Enhanced helper function to get closest point on line segment (add Z support)
function getClosestPointOnLineSegment(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		return {
			x: x1,
			y: y1,
			z: z1
		};
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const result = {
		x: x1 + t * C,
		y: y1 + t * D
	};

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		result.z = z1 + t * (z2 - z1);
	}

	return result;
}
//Add this helper function for point-in-polygon detection
function isPointInPolygonVertices(x, y, vertices) {
	let inside = false;
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		if (vertices[i].y > y !== vertices[j].y > y && x < ((vertices[j].x - vertices[i].x) * (y - vertices[i].y)) / (vertices[j].y - vertices[i].y) + vertices[i].x) {
			inside = !inside;
		}
	}
	return inside;
}
// Add this new function to detect clicked lines
function getClickedLine(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	if (allKADDrawingsMap.size === 0) return null;

	// Check each line entity
	for (const entity of allKADDrawingsMap.values()) {
		const linePoints = entity.data;
		if (linePoints.length < 2) continue; // Need at least 2 points for a line

		// Check each line segment
		for (let i = 0; i < linePoints.length - 1; i++) {
			const p1 = linePoints[i];
			const p2 = linePoints[i + 1];

			// Calculate distance from click point to line segment
			const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

			if (distance <= tolerance) {
				console.log("Found line:", entity);
				return {
					entity: entity,
					points: linePoints,
					segmentIndex: i,
					startPoint: {
						x: p1.pointXLocation,
						y: p1.pointYLocation
					},
					endPoint: {
						x: p2.pointXLocation,
						y: p2.pointYLocation
					}
				};
			}
		}
	}

	return null;
}
// Enhanced helper function for point-to-line-segment distance (add Z support)
function pointToLineSegmentDistance(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		// Line segment is actually a point
		return Math.sqrt(A * A + B * B);
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const projection_x = x1 + t * C;
	const projection_y = y1 + t * D;

	const dx = px - projection_x;
	const dy = py - projection_y;

	const distance = Math.sqrt(dx * dx + dy * dy);

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		const interpolatedZ = z1 + t * (z2 - z1);
		return {
			distance: distance,
			z: interpolatedZ
		};
	}

	return distance;
}

// Add this new function for the pattern in polygon popup
function showPatternInPolygonPopup() {
	let blastNameValue = "PolygonPattern_" + Date.now();
	// Retrieve the last entered values from local storage
	let savedPatternInPolygonSettings = JSON.parse(localStorage.getItem("savedPatternInPolygonSettings")) || {};
	let lastValues = {
		blastName: savedPatternInPolygonSettings.blastName || blastNameValue,
		burden: savedPatternInPolygonSettings.burden || 3.0,
		spacing: savedPatternInPolygonSettings.spacing || 3.3,
		spacingOffset: savedPatternInPolygonSettings.spacingOffset || 0.5,
		collarZ: savedPatternInPolygonSettings.collarZ || 0,
		gradeZ: savedPatternInPolygonSettings.gradeZ || -10,
		subdrill: savedPatternInPolygonSettings.subdrill || 1,
		angle: savedPatternInPolygonSettings.angle || 0,
		bearing: savedPatternInPolygonSettings.bearing || 180,
		diameter: savedPatternInPolygonSettings.diameter || 115,
		type: savedPatternInPolygonSettings.type || "Production",
		startNumber: savedPatternInPolygonSettings.startNumber || 1,
		nameTypeIsNumerical: savedPatternInPolygonSettings.nameTypeIsNumerical || true,
		useGradeZ: savedPatternInPolygonSettings.useGradeZ !== undefined ? savedPatternInPolygonSettings.useGradeZ : true,
		length: savedPatternInPolygonSettings.length || 10
	};

	// Calculate default length if using grade Z
	const defaultLength = lastValues.useGradeZ ? Math.abs((lastValues.collarZ - lastValues.gradeZ + lastValues.subdrill) / Math.cos(lastValues.angle * (Math.PI / 180))) : lastValues.length;

	// Calculate default grade if using length
	const defaultGradeZ = !lastValues.useGradeZ ? lastValues.collarZ - (lastValues.length - lastValues.subdrill) * Math.cos(lastValues.angle * (Math.PI / 180)) : lastValues.gradeZ;

	//! REDO with the FloatingDialog class
	// Show loading spinner while the popup is created
	Swal.showLoading();
	//! REDO with the FloatingDialog class
	// Create the SweetAlert popup
	Swal.fire({
		title: "Generate Pattern in Polygon",
		showCancelButton: true,
		confirmButtonText: "OK",
		cancelButtonText: "Cancel",
		html: `
        <div class="button-container-2col">
          <label class="labelWhite18" for="blastName">Blast Name</label>
          <input type="text3" id="blastName" name="blastName" placeholder="Blast Name" value="${lastValues.blastName}"/>
          <label class="labelWhite18" for="nameTypeIsNumerical">Numerical Names</label>
          <input type="checkbox" id="nameTypeIsNumerical" name="nameTypeIsNumerical" ${lastValues.nameTypeIsNumerical ? "checked" : ""}>
          <label class="labelWhite18" for="startNumber">Starting Hole Number</label>
          <input type="number3" id="startNumber" name="startNumber" placeholder="Start Number" value="${lastValues.startNumber}" step="1" min="1" max="9999" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="burden">Burden (m)</label>
          <input type="number3" id="burden" name="burden" placeholder="Burden" value="${lastValues.burden}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacing">Spacing (m)</label>
          <input type="number3" id="spacing" name="spacing" placeholder="Spacing" value="${lastValues.spacing}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacingOffset">Offset</label>
          <input type="number3" id="spacingOffset" name="spacingOffset" placeholder="SpacingOffset" value="${lastValues.spacingOffset}" step="0.1" min="-1.0" max="1.0" inputmode="decimal" pattern="[0-9]*"/>
          <div class="labelWhite12" id="infolabel1" name="infolabel1">Offset Information: </div> 
          <div class="labelWhite12" id="infolabel2" name="infolabel2">Staggered = -0.5 or 0.5, Square = -1, 0, 1</div>
          <label class="labelWhite18" for="collarZ">Collar Elevation (m)</label>
          <input type="number3" id="collarZ" name="collarZ" placeholder="Collar Z" value="${lastValues.collarZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="useGradeZ">Use Grade Z</label>
          <input type="checkbox" id="useGradeZ" name="useGradeZ" ${lastValues.useGradeZ ? "checked" : ""}>
          <label class="labelWhite18" for="gradeZ">Grade Elevation (m)</label>
          <input type="number3" id="gradeZ" name="gradeZ" placeholder="Grade Z" value="${defaultGradeZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*" ${!lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="length">Length (m)</label>
          <input type="number3" id="length" name="length" placeholder="Length" value="${defaultLength}" step="0.1" min="0.1" max="1000" inputmode="decimal" pattern="[0-9]*" ${lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="subdrill">Subdrill (m)</label>
          <input type="number3" id="subdrill" name="subdrill" placeholder="Subdrill" value="${lastValues.subdrill}" step="0.1" min="-50" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="angle">Hole Angle (° from vertical)</label>
          <input type="number3" id="angle" name="angle" placeholder="Angle" value="${lastValues.angle}" step="1" min="0" max="60" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="bearing">Hole Bearing (°)</label>
          <input type="number3" id="bearing" name="bearing" placeholder="Bearing" value="${lastValues.bearing}" step="0.1" min="0" max="359.999" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="diameter">Diameter (mm)</label>
          <input type="number3" id="diameter" name="diameter" placeholder="Diameter" value="${lastValues.diameter}" step="1" min="1" max="1000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="type">Hole Type</label>
          <input type="text3" id="type" name="type" placeholder="Type" value="${lastValues.type}"/>
        </div>
      `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		},
		didOpen: () => {
			//! REDO with the FloatingDialog class
			// Add event listeners after the popup is opened
			const useGradeZCheckbox = document.getElementById("useGradeZ");
			const gradeZInput = document.getElementById("gradeZ");
			const lengthInput = document.getElementById("length");
			const collarZInput = document.getElementById("collarZ");
			const angleInput = document.getElementById("angle");
			const subdrillInput = document.getElementById("subdrill");

			//! REDO with the FloatingDialog class
			// Function to update fields based on checkbox state
			function updateFieldsBasedOnUseGradeZ() {
				const useGradeZ = useGradeZCheckbox.checked;

				// Enable/disable fields
				gradeZInput.disabled = !useGradeZ;
				lengthInput.disabled = useGradeZ;

				// Update calculations
				if (useGradeZ) {
					// Calculate length from grade
					const collarZ = parseFloat(collarZInput.value) || 0;
					const gradeZ = parseFloat(gradeZInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedLength = Math.abs((collarZ - gradeZ + subdrill) / Math.cos(angleRad));
					lengthInput.value = calculatedLength.toFixed(2);
				} else {
					// Calculate grade from length
					const collarZ = parseFloat(collarZInput.value) || 0;
					const length = parseFloat(lengthInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedGradeZ = collarZ - (length - subdrill) * Math.cos(angleRad);
					gradeZInput.value = calculatedGradeZ.toFixed(2);
				}
			}

			// Add event listeners for changes
			useGradeZCheckbox.addEventListener("change", updateFieldsBasedOnUseGradeZ);
			gradeZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			lengthInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			collarZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			angleInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			subdrillInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);

			// Initial update
			updateFieldsBasedOnUseGradeZ();
		}
	})
		.then((result) => {
			if (result.isConfirmed) {
				// Retrieve values from the input fields
				const blastName = document.getElementById("blastName").value;
				const nameTypeIsNumerical = document.getElementById("nameTypeIsNumerical").checked;
				const useGradeZ = document.getElementById("useGradeZ").checked;
				const startNumber = parseInt(document.getElementById("startNumber").value);
				const burden = parseFloat(document.getElementById("burden").value);
				const spacing = parseFloat(document.getElementById("spacing").value);
				const spacingOffset = parseFloat(document.getElementById("spacingOffset").value);
				const collarZ = parseFloat(document.getElementById("collarZ").value);
				const gradeZ = parseFloat(document.getElementById("gradeZ").value);
				const length = parseFloat(document.getElementById("length").value);
				const subdrill = parseFloat(document.getElementById("subdrill").value);
				const angle = parseFloat(document.getElementById("angle").value);
				const bearing = parseFloat(document.getElementById("bearing").value);
				const diameter = parseFloat(document.getElementById("diameter").value);
				const type = document.getElementById("type").value;

				// Validation checks
				if (!blastName || blastName.trim() === "") {
					showModalMessage("Invalid Blast Name", "Please enter a Blast Name.", "warning");
					return;
				}

				if (isNaN(spacingOffset) || spacingOffset < -1 || spacingOffset > 1) {
					showModalMessage("Invalid Offset", "Please enter an offset between -1 and 1.", "warning");
					return;
				}

				if (isNaN(burden) || burden < 0.1 || burden > 50) {
					showModalMessage("Invalid Burden", "Please enter burden between 0.1 and 50 meters.", "warning");
					return;
				}

				if (isNaN(spacing) || spacing < 0.1 || spacing > 50) {
					showModalMessage("Invalid Spacing", "Please enter spacing between 0.1 and 50 meters.", "warning");
					return;
				}

				// Save values to localStorage
				const newValues = {
					blastName: blastName,
					nameTypeIsNumerical: nameTypeIsNumerical,
					startNumber: startNumber,
					burden: burden,
					spacing: spacing,
					spacingOffset: spacingOffset,
					collarZ: collarZ,
					gradeZ: gradeZ,
					length: length,
					subdrill: subdrill,
					angle: angle,
					bearing: bearing,
					diameter: diameter,
					type: type,
					useGradeZ: useGradeZ
				};
				localStorage.setItem("savedPatternInPolygonSettings", JSON.stringify(newValues));

				// Initialize allBlastHoles array if it's null
				if (allBlastHoles === null) {
					allBlastHoles = [];
				}

				// Generate the pattern
				generatePatternInPolygon({
					blastName: blastName,
					nameTypeIsNumerical: nameTypeIsNumerical,
					useGradeZ: useGradeZ,
					startNumber: startNumber,
					burden: burden,
					spacing: spacing,
					spacingOffset: spacingOffset,
					collarZ: collarZ,
					gradeZ: gradeZ,
					length: length,
					subdrill: subdrill,
					angle: angle,
					bearing: bearing,
					diameter: diameter,
					type: type,
					patternType: spacingOffset === 0 ? "square" : "staggered"
				});
			}
		})
		.finally(() => {
			// Hide the loading spinner when the popup is closed
			Swal.hideLoading();
			debouncedUpdateTreeView(); // Use debounced version
			// Reset tool
			patternInPolygonTool.checked = false;
			patternInPolygonTool.dispatchEvent(new Event("change"));
		});
}

function drawPatternInPolygonVisual() {
	if (!isPatternInPolygonActive) return;

	// Draw selected polygon outline in bright color
	if (selectedPolygon) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		const polygonPoints = selectedPolygon.data; // ← Just use .data, not .points || .data
		if (polygonPoints && polygonPoints.length > 0) {
			ctx.beginPath();
			polygonPoints.forEach((point, index) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);

				if (index === 0) {
					ctx.moveTo(canvasX, canvasY);
				} else {
					ctx.lineTo(canvasX, canvasY);
				}
			});
			ctx.closePath();
			ctx.stroke();

			// Draw vertices as small circles
			polygonPoints.forEach((point) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);
				ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
				ctx.beginPath();
				ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
				ctx.fill();
			});
		}
	}

	// Draw start point (bright green)
	if (patternStartPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = strokeColor; // Use strokeColor instead of hardcoded color
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("START", startX + 12, startY - 8);
		// Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!patternEndPoint) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);
			// Show preview distance
			const dx = currentMouseWorldX - patternStartPoint.x;
			const dy = currentMouseWorldY - patternStartPoint.y;
			const previewLength = Math.sqrt(dx * dx + dy * dy);

			const midX = (startX + currentMouseCanvasX) / 2;
			const midY = (startY + currentMouseCanvasY) / 2;

			//const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
			const [mouseX, mouseY] = [currentMouseCanvasX, currentMouseCanvasY];

			// Draw preview line (already in your code)
			// ...
			const lineLength = Math.sqrt(dx * dx + dy * dy);

			if (lineLength > 5) {
				const midX = (startX + currentMouseCanvasX) / 2;
				const midY = (startY + currentMouseCanvasY) / 2;

				// Normalized line direction vector
				const dirX = dx / lineLength;
				const dirY = -dy / lineLength;

				// Perpendicular vector (-90° from line direction)
				const perpX = dirY;
				const perpY = -dirX;

				const arrowLength = 50;
				const arrowWidth = 24;
				const arrowOffset = 40;

				// Base point of the arrow (center of base)
				const baseX = midX + perpX * arrowOffset;
				const baseY = midY + perpY * arrowOffset;

				// Tip of the arrow (move further left)
				const tipX = baseX + perpX * arrowLength;
				const tipY = baseY + perpY * arrowLength;

				// Perpendicular to arrow direction (same as line dir!)
				const sideX = dirX * (arrowWidth / 2);
				const sideY = dirY * (arrowWidth / 2);

				// Base left/right points
				const leftX = baseX + sideX;
				const leftY = baseY + sideY;
				const rightX = baseX - sideX;
				const rightY = baseY - sideY;

				// Draw arrow
				ctx.beginPath();
				ctx.moveTo(tipX, tipY); // Tip
				ctx.lineTo(leftX, leftY); // Left corner of base
				ctx.lineTo(rightX, rightY); // Right corner of base
				ctx.closePath();

				ctx.fillStyle = "#00ff00";
				ctx.globalAlpha = 0.3;
				ctx.fill();
				ctx.lineWidth = 2;
				ctx.strokeStyle = "#009900";
				ctx.globalAlpha = 1.0;
				ctx.stroke();
			}

			ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
			ctx.fillRect(midX - 30, midY - 15, 60, 20);
			ctx.strokeStyle = strokeColor;
			ctx.lineWidth = 1;
			ctx.strokeRect(midX - 30, midY - 15, 60, 20);

			ctx.fillStyle = strokeColor;
			ctx.font = "12px Arial";
			ctx.fontWeight = "bold";
			ctx.textAlign = "center";
			ctx.fillText(previewLength.toFixed(2) + "m", midX, midY);
			ctx.textAlign = "left";
		}
	}

	// Draw end point (bright red)
	if (patternEndPoint) {
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = strokeColor; // Use strokeColor instead of hardcoded color
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("END", endX + 12, endY - 8);
	}

	// Draw reference point (magenta)
	if (patternReferencePoint) {
		const [refX, refY] = worldToCanvas(patternReferencePoint.x, patternReferencePoint.y);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.beginPath();
		ctx.arc(refX, refY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = strokeColor; // Use strokeColor instead of hardcoded color
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("REF", refX + 12, refY - 8);
	}

	// Draw line from start to end to show spacing direction
	if (patternStartPoint && patternEndPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);

		// Draw the main line
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 1;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Calculate and display line length
		const dx = patternEndPoint.x - patternStartPoint.x;
		const dy = patternEndPoint.y - patternStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		// Display length at midpoint of line
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;

		ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
		ctx.fillRect(midX - 30, midY - 15, 60, 20);
		ctx.strokeStyle = strokeColor;
		ctx.lineWidth = 1;
		ctx.strokeRect(midX - 30, midY - 15, 60, 20);

		ctx.fillStyle = strokeColor;
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.textAlign = "center";
		ctx.fillText(lineLength.toFixed(2) + "m", midX, midY);
		ctx.textAlign = "left"; // Reset text alignment
	}

	// Show snap preview when hovering (if mouse position is available)
	// This would need mouse tracking which could be added as an enhancement
}
// Add this function to draw poly line selection visuals
function drawPatternOnPolylineVisual() {
	if (!isHolesAlongPolyLineActive) return;

	// Add safety checks
	if (!selectedPolyline || !selectedPolyline.vertices || !Array.isArray(selectedPolyline.vertices)) {
		console.log("Can't draw along Polyline as there is no selectedPolyline, vertices or array");
		return;
	}

	// Draw selected polyline in bright color
	if (selectedPolyline) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		ctx.beginPath();
		selectedPolyline.vertices.forEach((vertex, index) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});

		// Close polygon if it's a polygon type
		if (selectedPolyline.type === "polygon") {
			ctx.closePath();
		}

		ctx.stroke();

		// Draw vertices as small circles
		selectedPolyline.vertices.forEach((vertex) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});
	}

	// Draw start point (bright blue)
	if (polylineStartPoint) {
		const [startX, startY] = worldToCanvas(polylineStartPoint.x, polylineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.6)";
		ctx.beginPath();
		ctx.arc(startX, startY, 3, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = "rgba(0, 255, 0, 1)";
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("START", startX + 12, startY - 8);
	}

	// Draw end point (bright red)
	if (polylineEndPoint) {
		const [endX, endY] = worldToCanvas(polylineEndPoint.x, polylineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.6)";
		ctx.beginPath();
		ctx.arc(endX, endY, 3, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = "rgba(255, 0, 0,1)";
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("END", endX + 12, endY - 8);
	}
}
// Function to draw KAD polygon selection visuals
function drawKADPolygonHighlightSelectedVisuals() {
	if (!selectedKADPolygon || !isSelectionPointerActive) return;

	// Draw selected polygon outline in bright color
	ctx.strokeStyle = "#00FF00"; // Bright green like pattern tool
	ctx.lineWidth = 3;
	ctx.setLineDash([]);

	const polygonPoints = selectedKADPolygon.points || selectedKADPolygon.data;
	if (polygonPoints && polygonPoints.length > 0) {
		ctx.beginPath();
		polygonPoints.forEach((point, index) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);

			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});
		ctx.closePath();
		ctx.stroke();

		// Draw vertices as small red circles like pattern tool
		polygonPoints.forEach((point) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});
	}
}
// NEW: Helper function to calculate exact text dimensions (matches drawKADTexts)
function calculateTextDimensions(text) {
	if (!text)
		return {
			width: 0,
			height: 0,
			lines: []
		};

	// Set the same font as drawKADTexts
	ctx.font = parseInt(currentFontSize - 2) + "px Arial";

	const lines = text.split("\n");
	const lineHeight = currentFontSize; // Same as drawMultilineText

	// Calculate the width of the widest line (same logic as drawMultilineText)
	let maxWidth = 0;
	for (let i = 0; i < lines.length; i++) {
		const lineWidth = ctx.measureText(lines[i]).width;
		if (lineWidth > maxWidth) {
			maxWidth = lineWidth;
		}
	}

	const totalHeight = lines.length * lineHeight;

	return {
		width: maxWidth,
		height: totalHeight,
		lineHeight: lineHeight,
		lines: lines,
		numLines: lines.length
	};
}
// ENHANCED: Fix segment highlighting to show only the clicked segment
function drawKADHighlightSelectionVisuals() {
	if (!selectedKADObject && (!selectedMultipleKADObjects || selectedMultipleKADObjects.length === 0)) return;

	if (developerModeEnabled) {
		console.log("=== DRAWING FUNCTION DEBUG ===");
		console.log("selectedKADObject:", selectedKADObject);
		console.log("isSelectionPointerActive:", isSelectionPointerActive);
		console.log("selectedMultipleKADObjects:", selectedMultipleKADObjects);
		console.log("selectedMultipleKADObjects.length:", selectedMultipleKADObjects?.length);
	}

	//colours
	const selectedSegmentColor = "rgba(255, 68, 255, 0.8)";
	const nonSelectedSegmentColor = "#00FF00"; // Green for non-selected segments
	const nonSelectedPointColor = "rgba(0, 255, 0, 0.5)"; // Green for non-selected points
	const verticesColor = "rgba(255,0,0,0.5)";

	if (selectedKADObject && isSelectionPointerActive) {
		const tolerance = 5;
		const entity = getEntityFromKADObject(selectedKADObject);
		if (!entity) return;

		// Common selection styling
		ctx.strokeStyle = nonSelectedSegmentColor; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);
		ctx.fillStyle = verticesColor || "rgba(255,0,0,0.5)"; // Red for vertices/points

		switch (selectedKADObject.entityType) {
			case "point":
				// Highlight the selected point with extra emphasis
				const [px, py] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);

				ctx.strokeStyle = selectedSegmentColor;
				ctx.lineWidth = 4;
				ctx.beginPath();
				ctx.arc(px, py, tolerance + 3, 0, 2 * Math.PI);
				ctx.stroke();

				// Draw all other points in the entity with standard highlighting
				ctx.strokeStyle = nonSelectedSegmentColor;
				ctx.lineWidth = 5;
				entity.data.forEach((point, index) => {
					if (index !== selectedKADObject.elementIndex) {
						const [opx, opy] = worldToCanvas(point.pointXLocation, point.pointYLocation);
						ctx.beginPath();
						ctx.arc(opx, opy, tolerance, 0, 2 * Math.PI);
						ctx.stroke();
					}
				});
				break;

			case "line":
				// Draw ALL segments first with standard highlighting
				entity.data.forEach((point, index) => {
					if (index > 0) {
						const [prevX, prevY] = worldToCanvas(entity.data[index - 1].pointXLocation, entity.data[index - 1].pointYLocation);
						const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);

						ctx.strokeStyle = nonSelectedSegmentColor; // Green for non-selected segments
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo(prevX, prevY);
						ctx.lineTo(x, y);
						ctx.stroke();
					}
				});

				// Then highlight ONLY the selected segment
				if (selectedKADObject.selectionType === "segment") {
					const segmentIndex = selectedKADObject.segmentIndex;
					if (segmentIndex < entity.data.length - 1) {
						const point1 = entity.data[segmentIndex];
						const point2 = entity.data[segmentIndex + 1];
						const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
						const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

						ctx.strokeStyle = selectedSegmentColor;
						ctx.lineWidth = 5;
						ctx.beginPath();
						ctx.moveTo(x1, y1);
						ctx.lineTo(x2, y2);
						ctx.stroke();
					}
				}

				// Draw all vertices
				entity.data.forEach((point) => {
					const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);
					ctx.fillStyle = verticesColor;
					ctx.beginPath();
					ctx.arc(x, y, 4, 0, 2 * Math.PI);
					ctx.fill();
				});
				break;

			case "poly":
				const polygonPoints = entity.data;

				// Draw ALL segments first with standard highlighting
				for (let i = 0; i < polygonPoints.length; i++) {
					const point1 = polygonPoints[i];
					const point2 = polygonPoints[(i + 1) % polygonPoints.length];
					const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
					const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

					ctx.strokeStyle = nonSelectedSegmentColor; // Green for non-selected segments
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.stroke();
				}

				// Then highlight ONLY the selected segment
				if (selectedKADObject.selectionType === "segment") {
					const segmentIndex = selectedKADObject.segmentIndex;
					const point1 = polygonPoints[segmentIndex];
					const point2 = polygonPoints[(segmentIndex + 1) % polygonPoints.length];

					// Step #) Check if points exist before accessing properties
					if (point1 && point2 && point1.pointXLocation !== undefined && point2.pointXLocation !== undefined) {
						const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
						const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

						ctx.strokeStyle = selectedSegmentColor;
						ctx.lineWidth = 5;
						ctx.beginPath();
						ctx.moveTo(x1, y1);
						ctx.lineTo(x2, y2);
						ctx.stroke();
					}
				}

				// Draw all vertices
				polygonPoints.forEach((point) => {
					// Step #) Check if point exists before accessing properties
					if (point && point.pointXLocation !== undefined) {
						const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);
						ctx.fillStyle = verticesColor;
						ctx.beginPath();
						ctx.arc(x, y, 4, 0, 2 * Math.PI);
						ctx.fill();
					}
				});
				break;

			case "circle":
				// [Circle highlighting code remains the same]
				const [cx, cy] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);

				ctx.strokeStyle = selectedSegmentColor;
				ctx.lineWidth = 4;
				const radiusCanvas = selectedKADObject.radius * currentScale;
				ctx.beginPath();
				ctx.arc(cx, cy, radiusCanvas, 0, 2 * Math.PI);
				ctx.stroke();

				ctx.fillStyle = verticesColor;
				ctx.beginPath();
				ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
				ctx.fill();

				// Other circles...
				ctx.strokeStyle = nonSelectedSegmentColor;
				ctx.lineWidth = 2;
				entity.data.forEach((circle, index) => {
					if (index !== selectedKADObject.elementIndex) {
						const [ocx, ocy] = worldToCanvas(circle.pointXLocation, circle.pointYLocation);
						const oradiusCanvas = circle.radius * currentScale;
						ctx.beginPath();
						ctx.arc(ocx, ocy, oradiusCanvas + 5, 0, 2 * Math.PI);
						ctx.stroke();
					}
				});
				break;

			case "text":
				// [Text highlighting code from previous fix]
				const [tx, ty] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);
				const textDimensions = calculateTextDimensions(selectedKADObject.text || "Text");

				ctx.strokeStyle = selectedSegmentColor;
				ctx.lineWidth = 4;

				const rectX = tx - 5;
				const rectY = ty - textDimensions.lineHeight + 2;
				const rectWidth = textDimensions.width + 10;
				const rectHeight = textDimensions.height + 6;

				ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);

				ctx.fillStyle = verticesColor;
				ctx.beginPath();
				ctx.arc(tx, ty, 4, 0, 2 * Math.PI);
				ctx.fill();

				// Other text elements...
				ctx.strokeStyle = nonSelectedSegmentColor;
				ctx.lineWidth = 2;
				entity.data.forEach((textData, index) => {
					if (index !== selectedKADObject.elementIndex) {
						const [otx, oty] = worldToCanvas(textData.pointXLocation, textData.pointYLocation);
						const otherTextDimensions = calculateTextDimensions(textData.text || "Text");

						const otherRectX = otx - 5;
						const otherRectY = oty - otherTextDimensions.lineHeight + 2;
						const otherRectWidth = otherTextDimensions.width + 10;
						const otherRectHeight = otherTextDimensions.height + 6;

						ctx.strokeRect(otherRectX, otherRectY, otherRectWidth, otherRectHeight);
					}
				});
				break;
		}
	}

	// Handle multiple selections - reuse the single selection drawing code
	if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		if (developerModeEnabled) {
			console.log("Drawing multiple selections:", selectedMultipleKADObjects.length, "objects");
		}

		selectedMultipleKADObjects.forEach((kadObj, index) => {
			if (developerModeEnabled) {
				console.log("=== DRAWING OBJECT " + index + " ==="); // Fixed to use concatenation
				console.log("kadObj:", kadObj);
			}

			// Temporarily replace selectedKADObject with this one
			const temp = selectedKADObject;
			selectedKADObject = kadObj;

			// DECLARE VARIABLES FIRST (before the switch statement)
			const tolerance = 5;
			const entity = getEntityFromKADObject(selectedKADObject);

			if (developerModeEnabled) {
				console.log("Entity found by getEntityFromKADObject:", entity);
				console.log("Entity type check:", selectedKADObject.entityType);
			}

			if (entity) {
				if (developerModeEnabled) {
					console.log("Entity found - proceeding with drawing for:", selectedKADObject.entityType);
				}

				// Common selection styling
				ctx.strokeStyle = nonSelectedSegmentColor; // Bright green
				ctx.lineWidth = 3;
				ctx.setLineDash([]);
				ctx.fillStyle = verticesColor;

				switch (selectedKADObject.entityType) {
					case "point":
						// Highlight the selected point with extra emphasis
						const [px, py] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);

						ctx.strokeStyle = selectedSegmentColor; // Orange for selected element
						ctx.lineWidth = 4;
						ctx.beginPath();
						ctx.arc(px, py, tolerance + 3, 0, 2 * Math.PI);
						ctx.stroke();

						// Draw all other points in the entity with standard highlighting
						ctx.strokeStyle = nonSelectedSegmentColor;
						ctx.lineWidth = 2;
						entity.data.forEach((point, index) => {
							if (index !== selectedKADObject.elementIndex) {
								const [opx, opy] = worldToCanvas(point.pointXLocation, point.pointYLocation);
								ctx.beginPath();
								ctx.arc(opx, opy, tolerance, 0, 2 * Math.PI);
								ctx.stroke();
							}
						});
						break;

					case "line":
						// Draw ALL segments first with standard highlighting
						entity.data.forEach((point, index) => {
							if (index > 0) {
								const [prevX, prevY] = worldToCanvas(entity.data[index - 1].pointXLocation, entity.data[index - 1].pointYLocation);
								const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);

								ctx.strokeStyle = nonSelectedSegmentColor; // Green for non-selected segments
								ctx.lineWidth = 2;
								ctx.beginPath();
								ctx.moveTo(prevX, prevY);
								ctx.lineTo(x, y);
								ctx.stroke();
							}
						});

						// Then highlight ONLY the selected segment
						if (selectedKADObject.selectionType === "segment") {
							const segmentIndex = selectedKADObject.segmentIndex;
							if (segmentIndex < entity.data.length - 1) {
								const point1 = entity.data[segmentIndex];
								const point2 = entity.data[segmentIndex + 1];
								const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
								const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

								ctx.strokeStyle = selectedSegmentColor; // Orange for selected segment
								ctx.lineWidth = 5;
								ctx.beginPath();
								ctx.moveTo(x1, y1);
								ctx.lineTo(x2, y2);
								ctx.stroke();
							}
						}

						// Draw all vertices
						entity.data.forEach((point) => {
							const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);
							ctx.fillStyle = verticesColor;
							ctx.beginPath();
							ctx.arc(x, y, 4, 0, 2 * Math.PI);
							ctx.fill();
						});
						break;

					case "poly":
						const polygonPoints = entity.data;

						// Draw ALL segments first with standard highlighting
						for (let i = 0; i < polygonPoints.length; i++) {
							const point1 = polygonPoints[i];
							const point2 = polygonPoints[(i + 1) % polygonPoints.length];
							const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
							const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

							ctx.strokeStyle = nonSelectedSegmentColor; // Green for non-selected segments
							ctx.lineWidth = 2;
							ctx.beginPath();
							ctx.moveTo(x1, y1);
							ctx.lineTo(x2, y2);
							ctx.stroke();
						}

						// Then highlight ONLY the selected segment
						if (selectedKADObject.selectionType === "segment") {
							const segmentIndex = selectedKADObject.segmentIndex;
							const point1 = polygonPoints[segmentIndex];
							const point2 = polygonPoints[(segmentIndex + 1) % polygonPoints.length];
							const [x1, y1] = worldToCanvas(point1.pointXLocation, point1.pointYLocation);
							const [x2, y2] = worldToCanvas(point2.pointXLocation, point2.pointYLocation);

							ctx.strokeStyle = selectedSegmentColor; // Orange for selected segment
							ctx.lineWidth = 5;
							ctx.beginPath();
							ctx.moveTo(x1, y1);
							ctx.lineTo(x2, y2);
							ctx.stroke();
						}

						// Draw all vertices
						polygonPoints.forEach((point) => {
							const [x, y] = worldToCanvas(point.pointXLocation, point.pointYLocation);
							ctx.fillStyle = verticesColor;
							ctx.beginPath();
							ctx.arc(x, y, 4, 0, 2 * Math.PI);
							ctx.fill();
						});
						break;

					case "circle":
						// [Circle highlighting code remains the same]
						const [cx, cy] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);

						ctx.strokeStyle = selectedSegmentColor; // Orange for selected segment
						ctx.lineWidth = 4;
						const radiusCanvas = selectedKADObject.radius * currentScale;
						ctx.beginPath();
						ctx.arc(cx, cy, radiusCanvas, 0, 2 * Math.PI);
						ctx.stroke();

						ctx.fillStyle = verticesColor;
						ctx.beginPath();
						ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
						ctx.fill();

						// Other circles...
						ctx.strokeStyle = nonSelectedSegmentColor;
						ctx.lineWidth = 2;
						entity.data.forEach((circle, index) => {
							if (index !== selectedKADObject.elementIndex) {
								const [ocx, ocy] = worldToCanvas(circle.pointXLocation, circle.pointYLocation);
								const oradiusCanvas = circle.radius * currentScale;
								ctx.beginPath();
								ctx.arc(ocx, ocy, oradiusCanvas + 5, 0, 2 * Math.PI);
								ctx.stroke();
							}
						});
						break;

					case "text":
						// [Text highlighting code from previous fix]
						const [tx, ty] = worldToCanvas(selectedKADObject.pointXLocation, selectedKADObject.pointYLocation);
						const textDimensions = calculateTextDimensions(selectedKADObject.text || "Text");

						ctx.strokeStyle = selectedSegmentColor; // Orange for selected segment
						ctx.lineWidth = 4;

						const rectX = tx - 5;
						const rectY = ty - textDimensions.lineHeight + 2;
						const rectWidth = textDimensions.width + 10;
						const rectHeight = textDimensions.height + 6;

						ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);

						ctx.fillStyle = verticesColor;
						ctx.beginPath();
						ctx.arc(tx, ty, 4, 0, 2 * Math.PI);
						ctx.fill();

						// Other text elements...
						ctx.strokeStyle = nonSelectedSegmentColor;
						ctx.lineWidth = 2;
						entity.data.forEach((textData, index) => {
							if (index !== selectedKADObject.elementIndex) {
								const [otx, oty] = worldToCanvas(textData.pointXLocation, textData.pointYLocation);
								const otherTextDimensions = calculateTextDimensions(textData.text || "Text");

								const otherRectX = otx - 5;
								const otherRectY = oty - otherTextDimensions.lineHeight + 2;
								const otherRectWidth = otherTextDimensions.width + 10;
								const otherRectHeight = otherTextDimensions.height + 6;

								ctx.strokeRect(otherRectX, otherRectY, otherRectWidth, otherRectHeight);
							}
						});
						break;
				}
			} else {
				console.log("ERROR: No entity found for:", selectedKADObject.entityName);
				console.log("Available entities in allKADDrawingsMap:");
				for (const [name, ent] of allKADDrawingsMap.entries()) {
					console.log("  -", name, "type:", ent.entityType);
				}
			}

			// Restore original
			selectedKADObject = temp;
		});
	}
}

function getEntityFromKADObject(kadObject) {
	// Everything is now in the unified map
	return allKADDrawingsMap.get(kadObject.entityName);
}

function drawHolesAlongLineVisuals() {
	// Only draw visuals if holes along line tool is active
	if (!isHolesAlongLineActive) return;

	// Draw start point (bright blue) when selected
	if (lineStartPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 5, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = "rgba(0, 255, 0, 1)";
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("START", startX + 10, startY - 10);

		// Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!lineEndPoint && holesLineStep === 1) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);

			// Show preview distance
			const dx = currentMouseWorldX - lineStartPoint.x;
			const dy = currentMouseWorldY - lineStartPoint.y;
			const previewLength = Math.sqrt(dx * dx + dy * dy);

			const midX = (startX + currentMouseCanvasX) / 2;
			const midY = (startY + currentMouseCanvasY) / 2;

			ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
			ctx.fillRect(midX - 30, midY - 15, 60, 20);
			ctx.strokeStyle = strokeColor;
			ctx.lineWidth = 1;
			ctx.strokeRect(midX - 30, midY - 15, 60, 20);

			ctx.fillStyle = strokeColor;
			ctx.font = "12px Arial";
			ctx.fontWeight = "bold";
			ctx.textAlign = "center";
			ctx.fillText(previewLength.toFixed(2) + "m", midX, midY);
			ctx.textAlign = "left";
		}
	}

	// Draw end point (bright red/orange) when selected
	if (lineEndPoint) {
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
		ctx.beginPath();
		ctx.arc(endX, endY, 5, 0, 2 * Math.PI);
		ctx.fill();

		// Add label
		ctx.fillStyle = "rgba(255, 0, 0, 1)";
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.fillText("END", endX + 10, endY - 10);
	}

	// Draw line connecting start and end points when both are selected
	if (lineStartPoint && lineEndPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);

		// Draw the main line
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 1;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Calculate and display line length
		const dx = lineEndPoint.x - lineStartPoint.x;
		const dy = lineEndPoint.y - lineStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		// Display length at midpoint of line
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;

		ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
		ctx.fillRect(midX - 30, midY - 15, 60, 20);
		ctx.strokeStyle = strokeColor;
		ctx.lineWidth = 1;
		ctx.strokeRect(midX - 30, midY - 15, 60, 20);

		ctx.fillStyle = strokeColor;
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.textAlign = "center";
		ctx.fillText(lineLength.toFixed(2) + "m", midX, midY);
		ctx.textAlign = "left"; // Reset text alignment
	}
}
// Add this new function to generate holes along a polyline or polygon edge
// ADDED ROWID AND POSID
function generateHolesAlongPolyline(params, vertices) {
	if (!vertices || vertices.length < 2) {
		console.error("Not enough vertices to generate holes");
		return;
	}

	console.log("Generating holes along polyline with", vertices.length, "vertices");
	console.log("Parameters:", params);

	// Initialize points array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	const entityName = params.blastName || "PolylinePattern_" + Date.now();
	const originalPointsCount = allBlastHoles.length;
	let holeCounter = params.startNumber || 1;
	let currentLetter = "A";

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for polyline pattern");

	// Calculate total length of the polyline for progress tracking
	let totalLength = 0;
	for (let i = 0; i < vertices.length - 1; i++) {
		const dx = vertices[i + 1].x - vertices[i].x;
		const dy = vertices[i + 1].y - vertices[i].y;
		totalLength += Math.sqrt(dx * dx + dy * dy);
	}

	// Process each segment of the polyline
	let accumulatedLength = 0;
	let nextHoleDistance = 0;
	let positionCounter = 1; // Track position within the row

	for (let i = 0; i < vertices.length - 1; i++) {
		const startPoint = vertices[i];
		const endPoint = vertices[i + 1];

		// Calculate segment properties
		const dx = endPoint.x - startPoint.x;
		const dy = endPoint.y - startPoint.y;
		const segmentLength = Math.sqrt(dx * dx + dy * dy);
		const unitX = dx / segmentLength;
		const unitY = dy / segmentLength;

		// Calculate segment bearing in world coordinates
		const segmentBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;

		// Calculate hole bearing based on user preference
		const holeBearing = params.useLineBearing ? (segmentBearing + 90) % 360 : params.bearing;

		// Place holes along this segment
		let distanceAlongSegment = nextHoleDistance;

		while (distanceAlongSegment < segmentLength) {
			// Calculate hole position
			const holeX = startPoint.x + unitX * distanceAlongSegment;
			const holeY = startPoint.y + unitY * distanceAlongSegment;

			// Calculate hole ID
			let holeID;
			if (params.nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				// Use alphabetical naming like A1, A2, etc.
				const number = holeCounter % 26 || 26;
				if (number === 1 && holeCounter > 1) {
					// Increment letter when we wrap around
					if (currentLetter === "Z") {
						currentLetter = "AA";
					} else if (currentLetter.endsWith("Z")) {
						currentLetter = currentLetter.substring(0, currentLetter.length - 1) + "AA";
					} else {
						currentLetter = String.fromCharCode(currentLetter.charCodeAt(currentLetter.length - 1) + 1);
					}
				}
				holeID = currentLetter + number;
				holeCounter++;
			}

			// Add hole with rowID and posID
			addHole(
				true, // useCustomHoleID
				params.useGradeZ, // useGradeZ
				entityName,
				holeID,
				holeX,
				holeY,
				params.collarZ,
				params.gradeZ,
				params.diameter,
				params.type,
				params.length,
				params.subdrill,
				params.angle,
				holeBearing,
				rowID, // All holes in this polyline get the same rowID
				positionCounter, // Sequential position along the polyline
				params.burden, // burden TODO: Add to the show dialog popup for every hole add.
				params.spacing // spacing TODO: Add to the show dialog popup for every hole add.
			);

			positionCounter++; // Increment position counter
			// Move to next hole position
			distanceAlongSegment += params.spacing;
		}

		// Calculate remaining distance for the next segment
		nextHoleDistance = distanceAlongSegment - segmentLength;
		accumulatedLength += segmentLength;
	}

	// Redraw
	drawData(allBlastHoles, selectedHole);
	saveHolesToLocalStorage(allBlastHoles);

	const holesAdded = allBlastHoles.length - originalPointsCount;
	console.log("Generated " + holesAdded + " holes along polyline with rowID " + rowID);

	// Show success/failure message with custom styling
	if (holesAdded === 0) {
		showModalMessage("No Holes Generated", "No holes were generated along the polyline. Please check your settings.", "warning");
	} else {
		showModalMessage("Polyline Pattern Generated", `Successfully generated ${holesAdded} holes along the polyline (Row ${rowID}).`, "success");
	}
}
// SHOW HOLES ALONG POLYLINE POPUP
// Add this function to show the popup for polyline hole generation
function showHolesAlongPolylinePopup(vertices) {
	let blastNameValue = "PolylinePattern_" + Date.now();
	// Retrieve the last entered values from local storage
	let savedHolesAlongPolylineSettings = JSON.parse(localStorage.getItem("savedHolesAlongPolylineSettings")) || {};
	let lastValues = {
		blastName: savedHolesAlongPolylineSettings.blastName || blastNameValue,
		spacing: savedHolesAlongPolylineSettings.spacing || 3.0,
		collarZ: savedHolesAlongPolylineSettings.collarZ || 0,
		gradeZ: savedHolesAlongPolylineSettings.gradeZ || -10,
		subdrill: savedHolesAlongPolylineSettings.subdrill || 1,
		angle: savedHolesAlongPolylineSettings.angle || 0,
		bearing: savedHolesAlongPolylineSettings.bearing || 180,
		diameter: savedHolesAlongPolylineSettings.diameter || 115,
		type: savedHolesAlongPolylineSettings.type || "Production",
		startNumber: savedHolesAlongPolylineSettings.startNumber || 1,
		nameTypeIsNumerical: savedHolesAlongPolylineSettings.nameTypeIsNumerical !== undefined ? savedHolesAlongPolylineSettings.nameTypeIsNumerical : true,
		useGradeZ: savedHolesAlongPolylineSettings.useGradeZ !== undefined ? savedHolesAlongPolylineSettings.useGradeZ : true,
		useLineBearing: savedHolesAlongPolylineSettings.useLineBearing !== undefined ? savedHolesAlongPolylineSettings.useLineBearing : true,
		length: savedHolesAlongPolylineSettings.length || 10,
		reverseDirection: savedHolesAlongPolylineSettings.reverseDirection !== undefined ? savedHolesAlongPolylineSettings.reverseDirection : false
	};

	// Calculate default length if using grade Z
	const defaultLength = lastValues.useGradeZ ? Math.abs((lastValues.collarZ - lastValues.gradeZ + lastValues.subdrill) / Math.cos(lastValues.angle * (Math.PI / 180))) : lastValues.length;

	// Calculate default grade if using length
	const defaultGradeZ = !lastValues.useGradeZ ? lastValues.collarZ - (lastValues.length - lastValues.subdrill) * Math.cos(lastValues.angle * (Math.PI / 180)) : lastValues.gradeZ;

	// Show loading spinner while the popup is created
	Swal.showLoading();

	// Create the SweetAlert popup
	Swal.fire({
		title: "Generate Holes Along Polyline",
		showCancelButton: true,
		confirmButtonText: "OK",
		cancelButtonText: "Cancel",
		html: `
        <div class="button-container-2col">
          <label class="labelWhite18" for="blastName">Blast Name</label>
          <input type="text3" id="blastName" placeholder="Blast Name" value="${lastValues.blastName}"/>
          <label class="labelWhite18" for="nameTypeIsNumerical">Numerical Names</label>
          <input type="checkbox" id="nameTypeIsNumerical" name="nameTypeIsNumerical" ${lastValues.nameTypeIsNumerical ? "checked" : ""}>
          <label class="labelWhite18" for="startNumber">Starting Hole Number</label>
          <input type="number3" id="startNumber" name="startNumber" placeholder="Start Number" value="${lastValues.startNumber}" step="1" min="1" max="9999" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="spacing">Spacing (m)</label>
          <input type="number3" id="spacing" name="spacing" placeholder="Spacing" value="${lastValues.spacing}" step="0.1" min="0.1" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="collarZ">Collar Elevation (m)</label>
          <input type="number3" id="collarZ" name="collarZ" placeholder="Collar Z" value="${lastValues.collarZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="useGradeZ">Use Grade Z</label>
          <input type="checkbox" id="useGradeZ" name="useGradeZ" ${lastValues.useGradeZ ? "checked" : ""}>
          <label class="labelWhite18" for="gradeZ">Grade Elevation (m)</label>
          <input type="number3" id="gradeZ" name="gradeZ" placeholder="Grade Z" value="${defaultGradeZ}" step="0.1" min="-1000" max="5000" inputmode="decimal" pattern="[0-9]*" ${!lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="length">Length (m)</label>
          <input type="number3" id="length" name="length" placeholder="Length" value="${defaultLength}" step="0.1" min="0.1" max="1000" inputmode="decimal" pattern="[0-9]*" ${lastValues.useGradeZ ? "disabled" : ""}>
          <label class="labelWhite18" for="subdrill">Subdrill (m)</label>
          <input type="number3" id="subdrill" name="subdrill" placeholder="Subdrill" value="${lastValues.subdrill}" step="0.1" min="-50" max="50" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="angle">Hole Angle (° from vertical)</label>
          <input type="number3" id="angle" name="angle" placeholder="Angle" value="${lastValues.angle}" step="1" min="0" max="60" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="useLineBearing">Bearings are 90° to Segment</label>
          <input type="checkbox" id="useLineBearing" name="useLineBearing" ${lastValues.useLineBearing ? "checked" : ""}>
          <label class="labelWhite18" for="bearing">Hole Bearing (°)</label>
          <input type="number3" id="bearing" name="bearing" placeholder="Bearing" value="${lastValues.bearing}" step="0.1" min="0" max="359.999" inputmode="decimal" pattern="[0-9]*" ${lastValues.useLineBearing ? "disabled" : ""}>
          <div class="labelWhite12" style="text-align: center;">Selected ${vertices.length} points</div>
          <div class="labelWhite12" style="text-align: right;">Directions: N=0°, E=90°, S=180°, W=270°</div>
          <label class="labelWhite18" for="diameter">Diameter (mm)</label>
          <input type="number3" id="diameter" name="diameter" placeholder="Diameter" value="${lastValues.diameter}" step="1" min="1" max="1000" inputmode="decimal" pattern="[0-9]*"/>
          <label class="labelWhite18" for="type">Hole Type</label>
		  <input type="text3" id="type" name="type" placeholder="Type" value="${lastValues.type}"/>
          <label class="labelWhite18" for="reverseDirection">Reverse Direction</label>
          <input type="checkbox" id="reverseDirection" name="reverseDirection">
    	</div>
      `,
		customClass: {
			container: "custom-popup-container",
			popup: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		},
		didOpen: () => {
			// Add event listeners after the popup is opened
			const useGradeZCheckbox = document.getElementById("useGradeZ");
			const gradeZInput = document.getElementById("gradeZ");
			const lengthInput = document.getElementById("length");
			const collarZInput = document.getElementById("collarZ");
			const angleInput = document.getElementById("angle");
			const subdrillInput = document.getElementById("subdrill");
			const useLineBearingCheckbox = document.getElementById("useLineBearing");
			const bearingInput = document.getElementById("bearing");

			// Function to update fields based on checkbox state
			function updateFieldsBasedOnUseGradeZ() {
				const useGradeZ = useGradeZCheckbox.checked;

				// Enable/disable fields
				gradeZInput.disabled = !useGradeZ;
				lengthInput.disabled = useGradeZ;

				// Update calculations
				if (useGradeZ) {
					// Calculate length from grade
					const collarZ = parseFloat(collarZInput.value) || 0;
					const gradeZ = parseFloat(gradeZInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedLength = Math.abs((collarZ - gradeZ + subdrill) / Math.cos(angleRad));
					lengthInput.value = calculatedLength.toFixed(2);
				} else {
					// Calculate grade from length
					const collarZ = parseFloat(collarZInput.value) || 0;
					const length = parseFloat(lengthInput.value) || 0;
					const subdrill = parseFloat(subdrillInput.value) || 0;
					const angle = parseFloat(angleInput.value) || 0;
					const angleRad = angle * (Math.PI / 180);

					const calculatedGradeZ = collarZ - (length - subdrill) * Math.cos(angleRad);
					gradeZInput.value = calculatedGradeZ.toFixed(2);
				}
			}

			// Function to handle line bearing checkbox
			function updateBearingField() {
				bearingInput.disabled = useLineBearingCheckbox.checked;
			}

			// Add event listeners for changes
			useGradeZCheckbox.addEventListener("change", updateFieldsBasedOnUseGradeZ);
			gradeZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			lengthInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			collarZInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			angleInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			subdrillInput.addEventListener("input", updateFieldsBasedOnUseGradeZ);
			useLineBearingCheckbox.addEventListener("change", updateBearingField);

			// Initial update
			updateFieldsBasedOnUseGradeZ();
			updateBearingField();

			// Hide the loading spinner when the popup is ready
			Swal.hideLoading();
		}
	}).then((result) => {
		if (result.isConfirmed) {
			// Retrieve values from the input fields
			const params = {
				blastName: document.getElementById("blastName").value,
				nameTypeIsNumerical: document.getElementById("nameTypeIsNumerical").checked,
				useGradeZ: document.getElementById("useGradeZ").checked,
				useLineBearing: document.getElementById("useLineBearing").checked,
				startNumber: parseInt(document.getElementById("startNumber").value),
				spacing: parseFloat(document.getElementById("spacing").value),
				collarZ: parseFloat(document.getElementById("collarZ").value),
				gradeZ: parseFloat(document.getElementById("gradeZ").value),
				length: parseFloat(document.getElementById("length").value),
				subdrill: parseFloat(document.getElementById("subdrill").value),
				angle: parseFloat(document.getElementById("angle").value),
				bearing: parseFloat(document.getElementById("bearing").value),
				diameter: parseFloat(document.getElementById("diameter").value),
				type: document.getElementById("type").value,
				reverseDirection: document.getElementById("reverseDirection").checked
			};
			// Reverse the vertices if checkbox is checked
			let finalVertices = vertices;
			if (params.reverseDirection) {
				finalVertices = [...vertices].reverse(); // Create a reversed copy
			}
			// Save values to localStorage
			localStorage.setItem("savedHolesAlongPolylineSettings", JSON.stringify(params));

			// Generate the holes along the polyline
			generateHolesAlongPolyline(params, finalVertices);
		}

		// Clear selection
		selectedVertices = [];
		debouncedUpdateTreeView(); // Use debounced version
		drawData(allBlastHoles, selectedHole);
		// Add tool deactivation here if it's missing:
		holesAlongPolyLineTool.checked = false;
		holesAlongPolyLineTool.dispatchEvent(new Event("change"));
	});
}

///----------------- ASSIGN HOLE START Z TO A SURFACE TOOL and ASSIGN HOLE GRADE Z to a surface -----------------///
// WITH this multi-surface system:
let loadedSurfaces = new Map(); // Map<surfaceId, {id, name, points, triangles, visible, gradient}>

const assignSurfaceToHolesTool = document.getElementById("assignSurfaceTool");
const assignGradeTool = document.getElementById("assignGradeTool");
let showSurfaceLegend = true; // Add legend visibility control
let currentGradient = "default"; // Default gradient
// Add these variables near your other surface variables
let surfaceTransparency = 1.0; // Default fully opaque (same as image.transparency pattern)

//IMPORTANT - THIS IS THE FUNCTION THAT ASSIGNS THE HOLE TO THE SURFACE
function assignHoleToSurface(hole) {
	const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation);
	if (surfaceZ !== null) {
		hole.startZLocation = surfaceZ;
		hole.gradeZLocation = surfaceZ + hole.length; // Adjust grade accordingly
		// console.log("Assigned hole: " + hole.holeID + " to surface elevation: " + surfaceZ.toFixed(2) + "m");
	}
}
// NEW: Check if click point is actually on a surface triangle
function isPointInSurface(x, y) {
	// Check all loaded surfaces
	if (loadedSurfaces.size === 0) {
		return null; // Changed from false to null
	}

	// Convert canvas coordinates to world coordinates
	const worldX = (x - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(y - canvas.height / 2) / currentScale + centroidY;

	// Check if point is inside any triangle of any visible surface
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		// Check if point is inside any triangle
		for (let triangle of surface.triangles) {
			if (isPointInTriangle(worldX, worldY, triangle.vertices)) {
				return surfaceId; // Return the specific surface ID
			}
		}
	}

	return null; // Changed from false to null
}
// Determines if a point is inside a triangle using barycentric coordinates.
function isPointInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a >= 0 && b >= 0 && c >= 0;
}
// Interpolates the Z value of a point inside a triangle using barycentric coordinates.
function interpolateZInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a * v0.z + b * v1.z + c * v2.z;
}

// Interpolates the Z value of a point on the surface.
function interpolateZFromSurface(x, y, surfaceId = null) {
	// If surfaceId is specified, only check that surface
	if (surfaceId) {
		const surface = loadedSurfaces.get(surfaceId);
		if (surface && surface.visible && surface.triangles && surface.triangles.length > 0) {
			for (const triangle of surface.triangles) {
				if (isPointInTriangle(x, y, triangle.vertices)) {
					return interpolateZInTriangle(x, y, triangle.vertices);
				}
			}
		}
		return null; // Point not on specified surface
	}

	// Original behavior: Find triangle containing point (x, y) from all loaded surfaces
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		for (const triangle of surface.triangles) {
			if (isPointInTriangle(x, y, triangle.vertices)) {
				return interpolateZInTriangle(x, y, triangle.vertices);
			}
		}
	}
	return null; // Point not on surface
}

// Loads a point cloud file and processes it.
function loadPointCloudFile(file) {
	const reader = new FileReader();

	// Show loading progress
	updateStatusMessage("Loading surface file: " + file.name + "...");

	reader.onload = function (e) {
		const content = e.target.result;
		const fileExtension = file.name.split(".").pop().toLowerCase();

		let points;

		try {
			switch (fileExtension) {
				case "obj":
					points = parseOBJFile(content);
					break;
				case "xyz":
					points = parseXYZFile(content);
					break;
				case "asc":
					points = parseASCFile(content);
					break;
				case "txt":
					points = parseTXTFile(content);
					break;
				case "csv":
					points = parseCSVPointCloud(content);
					break;
				case "ply":
					points = parsePLYFile(content);
					break;
				case "pts":
					points = parsePTSFile(content);
					break;
				default:
					// Default to the existing parser for backward compatibility
					points = parsePointCloudData(content);
			}

			if (points && points.length > 0) {
				// Check if decimation is needed for performance
				if (points.length > 10000) {
					showDecimationWarning(points, file.name);
				} else {
					processSurfacePoints(points, file.name);
				}
			} else {
				updateStatusMessage("No valid points found in: " + file.name);
			}
		} catch (error) {
			console.error("Error parsing surface file:", error);
			updateStatusMessage("Error loading surface file: " + error.message);
		}
	};
	reader.readAsText(file);
}

// Process surface points with progress indication
function processSurfacePoints(points, fileName) {
	updateStatusMessage("Creating surface from " + points.length.toLocaleString() + " points...");

	// Use setTimeout to allow UI update before processing
	setTimeout(async () => {
		// Make this async
		try {
			createSurfaceFromPoints(points, fileName, false);

			// ADD SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName || "surface_" + Date.now());
				// console.log("✅ Surface saved from processSurfacePoints:", fileName);
			} catch (saveError) {
				console.error("❌ Failed to save surface from processSurfacePoints:", saveError);
			}

			updateStatusMessage("Surface loaded: " + fileName + " (" + points.length.toLocaleString() + " points)");
		} catch (error) {
			console.error("Error creating surface:", error);
			updateStatusMessage("Error creating surface: " + error.message);
		}
	}, 100);
}
// Enhanced OBJ parser
function parseOBJFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		const trimmedLine = line.trim();
		if (trimmedLine.startsWith("v ")) {
			// Only vertex lines
			const parts = trimmedLine.split(/\s+/);
			if (parts.length >= 4) {
				const x = parseFloat(parts[1]);
				const y = parseFloat(parts[2]);
				const z = parseFloat(parts[3]);

				if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
					points.push({
						x,
						y,
						z
					});
				}
			}
		}
	});

	return points;
}
// XYZ parser (space-delimited X Y Z format)
function parseXYZFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		const parts = line.trim().split(/\s+/);
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z
				});
			}
		}
	});

	return points;
}
// ASC parser (ASCII grid format, commonly used in GIS)
function parseASCFile(content) {
	const lines = content.split("\n");
	const points = [];

	// Parse header information
	let ncols, nrows, xllcorner, yllcorner, cellsize, nodata_value;
	let headerLines = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim().toLowerCase();
		if (line.startsWith("ncols")) {
			ncols = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nrows")) {
			nrows = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("xllcorner") || line.startsWith("xllcenter")) {
			xllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("yllcorner") || line.startsWith("yllcenter")) {
			yllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("cellsize")) {
			cellsize = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nodata_value")) {
			nodata_value = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.length > 0 && !isNaN(parseFloat(line.split(/\s+/)[0]))) {
			break; // End of header, start of data
		}
	}

	// Parse elevation data
	for (let row = 0; row < nrows; row++) {
		const lineIndex = headerLines + row;
		if (lineIndex < lines.length) {
			const values = lines[lineIndex].trim().split(/\s+/);
			for (let col = 0; col < ncols && col < values.length; col++) {
				const z = parseFloat(values[col]);
				if (!isNaN(z) && z !== nodata_value) {
					const x = xllcorner + col * cellsize;
					const y = yllcorner + (nrows - 1 - row) * cellsize; // Flip Y coordinate
					points.push({
						x,
						y,
						z
					});
				}
			}
		}
	}

	return points;
}
// PLY parser (ASCII format)
function parsePLYFile(content) {
	const lines = content.split("\n");
	const points = [];
	let inHeader = true;
	let vertexCount = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim();

		if (inHeader) {
			if (line.startsWith("element vertex")) {
				vertexCount = parseInt(line.split(" ")[2]);
			} else if (line === "end_header") {
				inHeader = false;
			}
		} else if (vertexCount > 0) {
			const parts = line.split(/\s+/);
			if (parts.length >= 3) {
				const x = parseFloat(parts[0]);
				const y = parseFloat(parts[1]);
				const z = parseFloat(parts[2]);

				if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
					points.push({
						x,
						y,
						z
					});
					vertexCount--;
				}
			}
		}
	}

	return points;
}
// PTS parser (point count + XYZ + intensity)
function parsePTSFile(content) {
	const lines = content.split("\n");
	const points = [];

	// First line might be point count
	let startIndex = 0;
	if (lines[0] && !isNaN(parseInt(lines[0].trim()))) {
		startIndex = 1;
	}

	for (let i = startIndex; i < lines.length; i++) {
		const parts = lines[i].trim().split(/\s+/);
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z
				});
			}
		}
	}

	return points;
}
// TXT parser (flexible text format)
function parseTXTFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		// Skip comment lines and empty lines
		const trimmedLine = line.trim();
		if (trimmedLine.length === 0 || trimmedLine.startsWith("#") || trimmedLine.startsWith("//")) {
			return;
		}

		// Try different delimiters: space, tab, comma
		let parts = trimmedLine.split(/\s+/);
		if (parts.length < 3) {
			parts = trimmedLine.split("\t");
		}
		if (parts.length < 3) {
			parts = trimmedLine.split(",");
		}

		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z
				});
			}
		}
	});

	return points;
}
// CSV parser specifically for point clouds
function parseCSVPointCloud(content) {
	const lines = content.split("\n");
	const points = [];
	let hasHeader = false;

	// Check if first line looks like a header
	const firstLine = lines[0].trim();
	if (firstLine.toLowerCase().includes("x") || firstLine.toLowerCase().includes("y") || firstLine.toLowerCase().includes("z")) {
		hasHeader = true;
	}

	const startIndex = hasHeader ? 1 : 0;

	for (let i = startIndex; i < lines.length; i++) {
		const parts = lines[i].trim().split(",");
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z
				});
			}
		}
	}

	return points;
}
// Add this to track the current surface name
window.currentSurfaceName = null;

function createSurfaceFromPoints(points, surfaceName = null, autoSave = true) {
	const surfaceId = surfaceName || "surface_" + Date.now();

	// Create triangles in LOCAL variable (not global)
	const triangles = [];
	const coords = points.flatMap((p) => [p.x, p.y]);
	const delaunay = new Delaunator(coords);

	for (let i = 0; i < delaunay.triangles.length; i += 3) {
		const p1 = points[delaunay.triangles[i]];
		const p2 = points[delaunay.triangles[i + 1]];
		const p3 = points[delaunay.triangles[i + 2]];

		// ✅ Push to LOCAL triangles array
		triangles.push({
			vertices: [p1, p2, p3],
			minZ: Math.min(p1.z, p2.z, p3.z),
			maxZ: Math.max(p1.z, p2.z, p3.z)
		});
	}

	// ✅ Add complete surface to the Map
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: surfaceName || surfaceId,
		points: points,
		triangles: triangles,
		visible: true,
		gradient: "default"
	});

	updateCentroids();
	drawData(allBlastHoles, selectedHole);

	if (autoSave) {
		saveSurfaceToDB(surfaceId).catch((err) => console.error("Failed to save surface:", err));
	}
}
// Keep the decimation warning (optional enhancement)
function showDecimationWarning(points, fileName) {
	const pointCount = points.length;

	Swal.fire({
		title: "Large Point Cloud Detected",
		showCancelButton: true,
		confirmButtonText: "Load All",
		cancelButtonText: "Decimate",
		icon: "warning",
		html: `
            <div style="text-align: center;">
                <label class="labelWhite16"><strong>${fileName}</strong></label><br>
                <label class="labelWhite14">Contains ${pointCount.toLocaleString()} points</label><br><br>
                <label class="labelWhite12">⚠️ Large point clouds may cause performance issues</label><br>
                <label class="labelWhite12">Recommended: Decimate to ~5,000 points for better performance</label>
            </div>
        `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon"
		}
	}).then(async (result) => {
		// Make this async
		if (result.isConfirmed) {
			createSurfaceFromPoints(points, fileName, false);

			// ADD SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName || "surface_full_" + Date.now());
				// console.log("✅ Full surface saved from decimation dialog:", fileName);
			} catch (saveError) {
				console.error("❌ Failed to save full surface:", saveError);
			}
		} else if (result.dismiss === Swal.DismissReason.cancel) {
			const decimatedPoints = decimatePointCloud(points, 5000);
			createSurfaceFromPoints(decimatedPoints, fileName, false);

			// ADD DECIMATED SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName ? fileName + "_decimated" : "surface_decimated_" + Date.now());
				// console.log("✅ Decimated surface saved from decimation dialog:", fileName);
			} catch (saveError) {
				console.error("❌ Failed to save decimated surface:", saveError);
			}
		}
	});
}

function decimatePointCloud(points, targetCount) {
	if (points.length <= targetCount) return points;

	const step = Math.floor(points.length / targetCount);
	const decimatedPoints = [];

	for (let i = 0; i < points.length; i += step) {
		decimatedPoints.push(points[i]);
	}

	return decimatedPoints;
}
// Add this simple canvasToWorld function (without snapping)
function canvasToWorld(canvasX, canvasY) {
	const worldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;
	return [worldX, worldY];
}
// Load a specific image into the multi-image system
async function loadImageIntoMemory(imageId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.get(imageId);

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const imageData = request.result;
				if (imageData) {
					// Convert blob back to canvas
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					img.onload = () => {
						canvas.width = img.width;
						canvas.height = img.height;
						ctx.drawImage(img, 0, 0);

						loadedImages.set(imageId, {
							id: imageId,
							name: imageData.name,
							canvas: canvas,
							bbox: imageData.bbox,
							type: imageData.type,
							visible: imageData.visible !== false,
							transparency: imageData.transparency || 1.0
						});

						// console.log("✅ Image " + imageData.name + " loaded into memory");
						resolve(imageData);
					};

					img.src = URL.createObjectURL(imageData.blob);
				} else {
					resolve(null);
				}
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading image into memory:", error);
		return null;
	}
}

// Image visibility management
function setImageVisibility(imageId, visible) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = visible;
		// console.log("👁️ Image " + image.name + " visibility: " + visible);
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleImageVisibility(imageId) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = !image.visible;
		setImageVisibility(imageId, image.visible);
	}
}

function drawSurface() {
	// console.log("🎨 drawSurface called");
	// console.log("🎨 surfacesGroupVisible:", surfacesGroupVisible);
	// console.log("🎨 loadedSurfaces.size:", loadedSurfaces.size);

	if (!surfacesGroupVisible) return; // ✅ ADD: Check surfaces group visibility
	if (loadedSurfaces.size === 0) return;

	loadedSurfaces.forEach((surface, surfaceId) => {
		// console.log("🎨 Processing surface:", surfaceId, surface);
		// console.log("🎨 Surface visible:", surface.visible);
		// console.log("🎨 Surface triangles count:", surface.triangles?.length);
		// console.log("🎨 Surface transparency:", surface.transparency);

		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) return;

		// Calculate THIS surface's elevation range only
		let surfaceMinZ = Infinity;
		let surfaceMaxZ = -Infinity;

		surface.points.forEach((point) => {
			if (point.z < surfaceMinZ) surfaceMinZ = point.z;
			if (point.z > surfaceMaxZ) surfaceMaxZ = point.z;
		});

		// console.log("🎨 Surface Z range:", surfaceMinZ, "to", surfaceMaxZ);
		// console.log("🎨 Drawing", surface.triangles.length, "triangles");

		// CRITICAL: Pass surface-specific min/max, transparency, AND gradient
		surface.triangles.forEach((triangle, i) => {
			// if (i === 0) {
			// 	console.log("🎨 First triangle structure:", triangle);
			// 	console.log("🎨 First triangle vertices:", triangle.vertices);
			// }
			// Fix line 20344 - Surface drawing function
			drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, ctx, surface.transparency || 1.0, surface.gradient || "default", gradientMethod, lightBearing, lightElevation);
		});
	});
}
// FIXED: Enhanced drawSurfaceLegend function to use surface-specific gradients
function drawSurfaceLegend() {
	// Check if any surfaces are visible and have legend enabled
	if (!showSurfaceLegend || loadedSurfaces.size === 0) return;

	// Get all visible surfaces
	const visibleSurfaces = Array.from(loadedSurfaces.values()).filter((surface) => surface.visible && surface.points && surface.points.length > 0);

	if (visibleSurfaces.length === 0) return;

	// Group surfaces by gradient type
	const surfacesByGradient = {};
	visibleSurfaces.forEach((surface) => {
		const gradient = surface.gradient || "default";
		if (!surfacesByGradient[gradient]) {
			surfacesByGradient[gradient] = [];
		}
		surfacesByGradient[gradient].push(surface);
	});

	// Legend dimensions and base position
	const legendWidth = 20;
	const legendHeight = 200;
	const legendSpacing = 140; // Space between multiple legends
	let legendIndex = 0;

	// Draw a legend for each unique gradient
	Object.entries(surfacesByGradient).forEach(([gradientType, surfaces]) => {
		// Calculate combined elevation range for all surfaces using this gradient
		let minZ = Infinity;
		let maxZ = -Infinity;

		surfaces.forEach((surface) => {
			surface.points.forEach((point) => {
				if (point.z < minZ) minZ = point.z;
				if (point.z > maxZ) maxZ = point.z;
			});
		});

		if (maxZ - minZ < 0.001) return; // Skip legend for flat surfaces

		// Position this legend
		const legendX = canvas.width - legendWidth - 60 - legendIndex * legendSpacing;
		const legendY = 50;
		const steps = 50;

		// Draw color gradient using the specific gradient type
		for (let i = 0; i < steps; i++) {
			const ratio = i / (steps - 1);
			const y = legendY + legendHeight - (i * legendHeight) / steps;
			const height = legendHeight / steps + 1;

			// FIXED: Pass the gradient parameter
			ctx.fillStyle = elevationToColor(minZ + ratio * (maxZ - minZ), minZ, maxZ, gradientType);
			ctx.fillRect(legendX, y, legendWidth, height);
		}

		// Draw elevation labels
		ctx.fillStyle = strokeColor;
		ctx.font = "12px Arial";
		ctx.fontWeight = "bold";
		ctx.textAlign = "left";

		const labelCount = 5;
		for (let i = 0; i < labelCount; i++) {
			const ratio = i / (labelCount - 1);
			const elevation = minZ + ratio * (maxZ - minZ);
			const y = legendY + legendHeight - ratio * legendHeight;

			// Draw tick mark
			ctx.beginPath();
			ctx.moveTo(legendX + legendWidth, y);
			ctx.lineTo(legendX + legendWidth + 5, y);
			ctx.stroke();

			// Draw elevation text
			ctx.fillText(parseFloat(elevation).toFixed(2) + "m", legendX + legendWidth + 8, y + 4);
		}

		// Draw title
		ctx.font = "14px Arial";
		ctx.textAlign = "center";
		ctx.fillText("Elevation", legendX + legendWidth / 2, legendY - 20);

		// Draw gradient name and surface info
		ctx.font = "10px Arial";
		const gradientNames = {
			default: "Default",
			viridis: "Viridis",
			turbo: "Turbo",
			parula: "Parula",
			cividis: "Cividis",
			terrain: "Terrain"
		};

		// FIXED: Use the surface's gradient instead of global currentGradient
		const gradientName = gradientNames[gradientType] || "Default";
		ctx.fillText(gradientName, legendX + legendWidth / 2, legendY + legendHeight + 20);

		// If multiple surfaces, show which surfaces use this gradient
		if (Object.keys(surfacesByGradient).length > 1) {
			ctx.font = "9px Arial";
			const surfaceNames = surfaces.map((s) => s.name || s.id).join(", ");
			const maxNameLength = 20;
			const displayName = surfaceNames.length > maxNameLength ? surfaceNames.substring(0, maxNameLength) + "..." : surfaceNames;
			ctx.fillText(displayName, legendX + legendWidth / 2, legendY + legendHeight + 35);
		}

		legendIndex++;
	});

	// Reset text alignment
	ctx.textAlign = "left";
}
// Color gradient functions
function getViridisColor(ratio) {
	const colors = [
		[68, 1, 84], // Dark purple
		[59, 82, 139], // Blue-purple
		[33, 144, 140], // Teal
		[92, 200, 99], // Green
		[253, 231, 37] // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getTurboColor(ratio) {
	const colors = [
		[48, 18, 59], // Dark purple
		[50, 136, 189], // Blue
		[94, 201, 98], // Green
		[253, 231, 37], // Yellow
		[240, 21, 22] // Red
	];
	return interpolateColors(colors, ratio);
}

function getParulaColor(ratio) {
	const colors = [
		[53, 42, 135], // Dark blue
		[15, 92, 221], // Blue
		[18, 125, 216], // Light blue
		[7, 156, 207], // Cyan
		[21, 177, 180], // Teal
		[89, 189, 140], // Green
		[170, 194, 97], // Yellow-green
		[249, 251, 14] // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getCividisColor(ratio) {
	const colors = [
		[0, 32, 76], // Dark blue
		[0, 52, 102], // Blue
		[39, 90, 129], // Light blue
		[92, 125, 147], // Gray-blue
		[150, 159, 157], // Gray
		[206, 187, 158], // Beige
		[254, 230, 206] // Light yellow
	];
	return interpolateColors(colors, ratio);
}

function getTerrainColor(ratio) {
	const colors = [
		[0, 68, 27], // Dark green (low elevation)
		[35, 132, 67], // Green
		[65, 174, 118], // Light green
		[120, 198, 121], // Pale green
		[186, 228, 179], // Very pale green
		[120, 85, 45], // Brown (mid elevation)
		[160, 118, 74], // Light brown
		[200, 200, 200], // Gray (high elevation)
		[255, 255, 255] // White (peaks)
	];
	return interpolateColors(colors, ratio);
}

function interpolateColors(colors, ratio) {
	const scaledRatio = ratio * (colors.length - 1);
	const index = Math.floor(scaledRatio);
	const localRatio = scaledRatio - index;

	if (index >= colors.length - 1) {
		const [r, g, b] = colors[colors.length - 1];
		return `rgb(${r}, ${g}, ${b})`;
	}

	const [r1, g1, b1] = colors[index];
	const [r2, g2, b2] = colors[index + 1];

	const r = Math.round(r1 + (r2 - r1) * localRatio);
	const g = Math.round(g1 + (g2 - g1) * localRatio);
	const b = Math.round(b1 + (b2 - b1) * localRatio);

	return `rgb(${r}, ${g}, ${b})`;
}

// Updated elevationToColor function to accept gradient parameter
function elevationToColor(z, minZ, maxZ, gradient = "default") {
	// Check if the surface is flat (no elevation variation)
	if (maxZ - minZ < 0.001) {
		// Very small tolerance for floating point comparison
		return "rgb(255, 165, 0)"; // Orange for flat surfaces
	}

	const ratio = (z - minZ) / (maxZ - minZ);

	// Apply selected gradient (now surface-specific)
	switch (gradient) {
		case "hillshade":
			// For hillshade, we'll handle coloring in drawTriangleWithGradient
			// This is just a fallback
			return "rgb(127, 127, 127)";
		case "viridis":
			return getViridisColor(ratio);
		case "turbo":
			return getTurboColor(ratio);
		case "parula":
			return getParulaColor(ratio);
		case "cividis":
			return getCividisColor(ratio);
		case "terrain":
			return getTerrainColor(ratio);
		default:
			// Original blue->cyan->green->yellow->red spectrum
			if (ratio < 0.25) {
				return `rgb(0, ${Math.floor(ratio * 4 * 255)}, 255)`;
			} else if (ratio < 0.5) {
				return `rgb(0, 255, ${Math.floor(255 - (ratio - 0.25) * 4 * 255)})`;
			} else if (ratio < 0.75) {
				return `rgb(${Math.floor((ratio - 0.5) * 4 * 255)}, 255, 0)`;
			} else {
				return `rgb(255, ${Math.floor(255 - (ratio - 0.75) * 4 * 255)}, 0)`;
			}
	}
}

// // Add new hillshading functions
// function getTriangleAspect(triangle) {
// 	const [p1, p2, p3] = triangle.vertices;

// 	// Calculate two edge vectors
// 	const v1X = p2.x - p1.x;
// 	const v1Y = p2.y - p1.y;
// 	const v1Z = p2.z - p1.z;

// 	const v2X = p3.x - p1.x;
// 	const v2Y = p3.y - p1.y;
// 	const v2Z = p3.z - p1.z;

// 	// Cross product to get surface normal
// 	const normalX = v1Y * v2Z - v1Z * v2Y;
// 	const normalY = v1Z * v2X - v1X * v2Z;
// 	const normalZ = v1X * v2Y - v1Y * v2X;

// 	// Handle flat triangles
// 	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
// 	if (horizontalMagnitude < 1e-6) {
// 		return {
// 			aspect: 0,
// 			slope: 0,
// 			isFlat: true
// 		};
// 	}

// 	// Calculate aspect (direction the slope faces)
// 	// 0° = North, 90° = East, 180° = South, 270° = West
// 	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

// 	// Calculate slope angle (steepness)
// 	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
// 	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

// 	return {
// 		aspect,
// 		slope,
// 		isFlat: false
// 	};
// }

// function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 90) {
// 	// Convert to radians
// 	const aspectRad = (aspect * Math.PI) / 180;
// 	const slopeRad = (slope * Math.PI) / 180;
// 	const lightBearingRad = (lightBearing * Math.PI) / 180;
// 	const lightElevationRad = (lightElevation * Math.PI) / 180;

// 	// Calculate illumination using standard hillshade formula
// 	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

// 	// Normalize to 0-1 range
// 	return Math.max(0, Math.min(1, illumination));
// }

// function getHillshadeColor(aspect, slope, isFlat = false) {
// 	if (isFlat) {
// 		// Flat triangles = 50% grey
// 		return "rgb(127, 127, 127)";
// 	}

// 	// Calculate illumination with light source from North (bearing 0°)
// 	const illumination = calculateHillshade(aspect, slope, 0, 45);

// 	// Your proposed color scheme:
// 	// 30% grey (dark) to 70% grey (light)
// 	const minGrey = 30; // 30% grey = rgb(76, 76, 76)
// 	const maxGrey = 70; // 70% grey = rgb(178, 178, 178)

// 	// Map illumination (0-1) to your grey range
// 	const greyPercent = minGrey + (maxGrey - minGrey) * illumination;
// 	const greyValue = Math.round((greyPercent * 255) / 100);

// 	return "rgb(" + greyValue + ", " + greyValue + ", " + greyValue + ")";
// }

// Step 1) Enhanced drawTriangleWithGradient function with unified gradient methods and hillshade controls

let gradientMethod = "default";
let lightBearing = 135;
let lightElevation = 15;

// Step #) Add event listener for gradient style dropdown
document.getElementById("gradientStyle").addEventListener("change", function () {
	changeGradientStyle();
});

// Step #) Function to handle gradient style changes
function changeGradientStyle() {
	gradientMethod = document.getElementById("gradientStyle").value;
	if (developerModeEnabled) {
		console.log("Gradient style changed to: " + gradientMethod);
	}
	drawData(allBlastHoles, selectedHole);
}

// Step #) Add event listener for light bearing slider
document.getElementById("lightBearingSlider").addEventListener("input", function () {
	lightBearing = parseInt(document.getElementById("lightBearingSlider").value);
	// change the slider labelto u
	document.getElementById("lightBearingLabel").textContent = "Light Bearing (deg): " + lightBearing + "°";
	if (developerModeEnabled) {
		console.log("Light bearing changed to: " + lightBearing);
	}
	drawData(allBlastHoles, selectedHole);
});

// Step #) Add event listener for light elevation slider
document.getElementById("lightElevationSlider").addEventListener("input", function () {
	lightElevation = parseInt(document.getElementById("lightElevationSlider").value);
	// change the slider labelto use the new value
	document.getElementById("lightElevationLabel").textContent = "Light Elevation (deg): " + lightElevation + "°";
	if (developerModeEnabled) {
		console.log("Light elevation changed to: " + lightElevation);
	}
	drawData(allBlastHoles, selectedHole);
});

function drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, targetCtx = ctx, alpha = 1.0, gradient = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45) {
	const showWireFrame = false;
	const [p1, p2, p3] = triangle.vertices;

	// Step 2) Convert to canvas coordinates - handle both object and array formats
	const [x1, y1] = worldToCanvas(p1.x !== undefined ? p1.x : p1[0], p1.y !== undefined ? p1.y : p1[1]);
	const [x2, y2] = worldToCanvas(p2.x !== undefined ? p2.x : p2[0], p2.y !== undefined ? p2.y : p2[1]);
	const [x3, y3] = worldToCanvas(p3.x !== undefined ? p3.x : p3[0], p3.y !== undefined ? p3.y : p3[1]);

	// Step 3) Get Z values for elevation calculations
	const z1 = p1.z !== undefined ? p1.z : p1[2];
	const z2 = p2.z !== undefined ? p2.z : p2[2];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 4) Save context state
	targetCtx.save();

	// Step 5) Set transparency for THIS surface only
	targetCtx.globalAlpha = alpha;

	// Step 6) Check if we have texture data (future enhancement)
	if (surfaceTextureData && surfaceTextureData.hasTextures) {
		// For now, use a different color scheme for textured surfaces
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();

		// Use elevation coloring but with different palette for textured surfaces
		const avgZ = (z1 + z2 + z3) / 3;
		targetCtx.fillStyle = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient);
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.051;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 7) Handle hillshade gradient specially with configurable lighting
	if (gradient === "hillshade") {
		const { aspect, slope, isFlat } = getTriangleAspect(triangle);
		const hillshadeColor = getHillshadeColor(aspect, slope, isFlat, lightBearing, lightElevation);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = hillshadeColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.05;
			targetCtx.stroke();
		}

		targetCtx.restore();
		return;
	}

	// Step 8) Check if THIS surface is flat (using surface-specific min/max)
	if (surfaceMaxZ - surfaceMinZ < 0.001) {
		// Flat surface - use solid orange color
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = "rgba(255, 165, 0, 0.7)"; // Semi-transparent orange
		targetCtx.fill();

		// Add wireframe edges
		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 9) Apply gradient method based on gradientMethod parameter
	switch (gradientMethod) {
		case "radial":
			drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame);
			break;
		case "barycentric":
			drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame);
			break;
		case "default":
		default:
			drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame);
			break;
	}

	// Step 10) Restore context state
	targetCtx.restore();
}

// Step 11) Linear gradient method (improved default)
function drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame) {
	// Step 12) Find vertices with min and max Z values for better gradient orientation
	const vertices = [
		{ x: x1, y: y1, z: z1, index: 0 },
		{ x: x2, y: y2, z: z2, index: 1 },
		{ x: x3, y: y3, z: z3, index: 2 }
	];

	// Step 13) Sort vertices by elevation to find min and max Z points
	vertices.sort((a, b) => a.z - b.z);
	const minZVertex = vertices[0]; // Lowest elevation
	const maxZVertex = vertices[2]; // Highest elevation
	const midZVertex = vertices[1]; // Middle elevation

	// Step 14) Check if there's significant elevation difference
	const elevationDiff = maxZVertex.z - minZVertex.z;
	if (elevationDiff < 0.001) {
		// Essentially flat triangle - use average color
		const avgZ = (z1 + z2 + z3) / 3;
		const flatColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = flatColor;
		targetCtx.fill();
	} else {
		// Step 15) Create gradient from min elevation point to max elevation point
		const canvasGradient = targetCtx.createLinearGradient(minZVertex.x, minZVertex.y, maxZVertex.x, maxZVertex.y);

		// Step 16) Map Z values to colors using THIS surface's elevation range AND gradient
		const minColor = elevationToColor(minZVertex.z, surfaceMinZ, surfaceMaxZ, gradient);
		const maxColor = elevationToColor(maxZVertex.z, surfaceMinZ, surfaceMaxZ, gradient);

		// Step 17) Add color stops - more natural gradient flow
		canvasGradient.addColorStop(0, minColor);
		canvasGradient.addColorStop(1, maxColor);

		// Step 18) If middle vertex has significantly different elevation, add it as intermediate stop
		const midElevationRatio = (midZVertex.z - minZVertex.z) / elevationDiff;
		if (midElevationRatio > 0.1 && midElevationRatio < 0.9) {
			// Step 19) Calculate position of middle vertex along the gradient line
			const gradientLength = Math.sqrt(Math.pow(maxZVertex.x - minZVertex.x, 2) + Math.pow(maxZVertex.y - minZVertex.y, 2));

			if (gradientLength > 0) {
				// Project middle vertex onto gradient line
				const dx = maxZVertex.x - minZVertex.x;
				const dy = maxZVertex.y - minZVertex.y;
				const midDx = midZVertex.x - minZVertex.x;
				const midDy = midZVertex.y - minZVertex.y;

				// Calculate projection ratio
				const projectionRatio = (midDx * dx + midDy * dy) / (dx * dx + dy * dy);
				const clampedRatio = Math.max(0.1, Math.min(0.9, projectionRatio));

				const midColor = elevationToColor(midZVertex.z, surfaceMinZ, surfaceMaxZ, gradient);
				canvasGradient.addColorStop(clampedRatio, midColor);
			}
		}

		// Step 20) Draw triangle with improved gradient
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = canvasGradient;
		targetCtx.fill();
	}

	// Step 21) Add wireframe edges if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 22) Radial gradient method for natural elevation flow
function drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame) {
	// Step 23) Calculate triangle centroid
	const centerX = (x1 + x2 + x3) / 3;
	const centerY = (y1 + y2 + y3) / 3;
	const centerZ = (z1 + z2 + z3) / 3;

	// Step 24) Calculate triangle radius (distance to farthest vertex)
	const radius = Math.max(Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(y1 - centerY, 2)), Math.sqrt(Math.pow(x2 - centerX, 2) + Math.pow(y2 - centerY, 2)), Math.sqrt(Math.pow(x3 - centerX, 2) + Math.pow(y3 - centerY, 2)));

	// Step 25) Create radial gradient from center
	const radialGradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

	// Step 26) Determine inner and outer colors based on elevation variation
	const minZ = Math.min(z1, z2, z3);
	const maxZ = Math.max(z1, z2, z3);
	const elevationRange = maxZ - minZ;

	let innerColor, outerColor;

	if (elevationRange < 0.001) {
		// Flat triangle - use single color
		const flatColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient);
		innerColor = flatColor;
		outerColor = flatColor;
	} else {
		// Step 27) Use center elevation for inner, highest elevation for outer (creates peak effect)
		const highestZ = Math.max(z1, z2, z3);
		innerColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient);
		outerColor = elevationToColor(highestZ, surfaceMinZ, surfaceMaxZ, gradient);
	}

	radialGradient.addColorStop(0, innerColor);
	radialGradient.addColorStop(1, outerColor);

	// Step 28) Draw triangle with radial gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = radialGradient;
	targetCtx.fill();

	// Step 29) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 30) Barycentric gradient method for smooth color interpolation
function drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame) {
	// Step 31) For small triangles or minimal elevation difference, use single color
	const elevationRange = Math.max(z1, z2, z3) - Math.min(z1, z2, z3);
	if (elevationRange < 0.001) {
		const avgZ = (z1 + z2 + z3) / 3;
		const solidColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = solidColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		return;
	}

	// Step 32) Create multiple gradient segments for smoother appearance
	// This approach creates overlapping gradients to simulate barycentric interpolation

	// Step 33) Calculate triangle bounds
	const minX = Math.min(x1, x2, x3);
	const maxX = Math.max(x1, x2, x3);
	const minY = Math.min(y1, y2, y3);
	const maxY = Math.max(y1, y2, y3);

	// Step 34) Create gradient across the triangle's bounding box oriented by elevation
	const vertices = [
		{ x: x1, y: y1, z: z1 },
		{ x: x2, y: y2, z: z2 },
		{ x: x3, y: y3, z: z3 }
	];

	// Step 35) Sort by elevation to determine gradient direction
	vertices.sort((a, b) => a.z - b.z);
	const lowVertex = vertices[0];
	const highVertex = vertices[2];

	const linearGradient = targetCtx.createLinearGradient(lowVertex.x, lowVertex.y, highVertex.x, highVertex.y);

	// Step 36) Sample colors at key points
	const color1 = elevationToColor(z1, surfaceMinZ, surfaceMaxZ, gradient);
	const color2 = elevationToColor(z2, surfaceMinZ, surfaceMaxZ, gradient);
	const color3 = elevationToColor(z3, surfaceMinZ, surfaceMaxZ, gradient);

	// Step 37) Create blended gradient based on vertex positions and elevations
	const sortedByElevation = [
		{ z: z1, color: color1 },
		{ z: z2, color: color2 },
		{ z: z3, color: color3 }
	].sort((a, b) => a.z - b.z);

	linearGradient.addColorStop(0, sortedByElevation[0].color);
	linearGradient.addColorStop(0.5, sortedByElevation[1].color);
	linearGradient.addColorStop(1, sortedByElevation[2].color);

	// Step 38) Draw triangle with enhanced gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = linearGradient;
	targetCtx.fill();

	// Step 39) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 40) Enhanced hillshade functions with configurable light source
function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 45) {
	// Step 41) Convert to radians
	const aspectRad = (aspect * Math.PI) / 180;
	const slopeRad = (slope * Math.PI) / 180;
	const lightBearingRad = (lightBearing * Math.PI) / 180;
	const lightElevationRad = (lightElevation * Math.PI) / 180;

	// Step 42) Calculate illumination using standard hillshade formula
	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

	// Step 43) Normalize to 0-1 range and apply contrast enhancement
	return Math.max(0, Math.min(1, illumination));
}

// Step 44) Enhanced hillshade color function with configurable lighting
function getHillshadeColor(aspect, slope, isFlat = false, lightBearing = 315, lightElevation = 45) {
	if (isFlat) {
		// Step 45) Flat triangles = neutral grey
		return "rgb(127, 127, 127)";
	}

	// Step 46) Calculate illumination with configurable light source
	const illumination = calculateHillshade(aspect, slope, lightBearing, lightElevation);

	// Step 47) Enhanced color range - from dark shadow to bright highlight
	const minGrey = 20; // 20% grey for deep shadows = rgb(51, 51, 51)
	const maxGrey = 80; // 80% grey for bright highlights = rgb(204, 204, 204)

	// Step 48) Apply contrast curve for more dramatic shading
	const contrastIllumination = Math.pow(illumination, 0.8); // Gamma correction for better contrast

	// Step 49) Map illumination to grey range
	const greyPercent = minGrey + (maxGrey - minGrey) * contrastIllumination;
	const greyValue = Math.round((greyPercent * 255) / 100);

	return "rgb(" + greyValue + ", " + greyValue + ", " + greyValue + ")";
}

// Step 50) Enhanced triangle aspect calculation with improved normal computation
function getTriangleAspect(triangle) {
	const [p1, p2, p3] = triangle.vertices;

	// Step 51) Handle both object and array formats
	const x1 = p1.x !== undefined ? p1.x : p1[0];
	const y1 = p1.y !== undefined ? p1.y : p1[1];
	const z1 = p1.z !== undefined ? p1.z : p1[2];

	const x2 = p2.x !== undefined ? p2.x : p2[0];
	const y2 = p2.y !== undefined ? p2.y : p2[1];
	const z2 = p2.z !== undefined ? p2.z : p2[2];

	const x3 = p3.x !== undefined ? p3.x : p3[0];
	const y3 = p3.y !== undefined ? p3.y : p3[1];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 52) Calculate two edge vectors
	const v1X = x2 - x1;
	const v1Y = y2 - y1;
	const v1Z = z2 - z1;

	const v2X = x3 - x1;
	const v2Y = y3 - y1;
	const v2Z = z3 - z1;

	// Step 53) Cross product to get surface normal
	const normalX = v1Y * v2Z - v1Z * v2Y;
	const normalY = v1Z * v2X - v1X * v2Z;
	const normalZ = v1X * v2Y - v1Y * v2X;

	// Step 54) Handle flat triangles
	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
	if (horizontalMagnitude < 1e-6) {
		return {
			aspect: 0,
			slope: 0,
			isFlat: true
		};
	}

	// Step 55) Calculate aspect (direction the slope faces)
	// 0° = North, 90° = East, 180° = South, 270° = West
	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

	// Step 56) Calculate slope angle (steepness)
	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

	return {
		aspect,
		slope,
		isFlat: false
	};
}

// Step 57) Utility function to create surfaces with enhanced gradient options
function createSurfaceWithGradientOptions(surfaceName, gradientType = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45) {
	// Example of how to create a surface with the new gradient options
	const surface = {
		name: surfaceName,
		gradient: gradientType,
		gradientMethod: gradientMethod,
		lightBearing: lightBearing,
		lightElevation: lightElevation
		// ... other surface properties
	};

	console.log("Created surface with gradient options:");
	console.log("- Gradient Type: " + gradientType);
	console.log("- Gradient Method: " + gradientMethod);
	console.log("- Light Bearing: " + lightBearing + "°");
	console.log("- Light Elevation: " + lightElevation + "°");

	return surface;
}
// ADD: Global variable for texture data
let surfaceTextureData = null;
// Add this function near other surface-related functions
function getAllVisibleSurfaces() {
	const visibleSurfaces = [];
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				visibleSurfaces.push({
					id: surfaceId,
					name: surface.name || `Surface ${surfaceId}`
				});
			}
		}
	}
	return visibleSurfaces;
}
// Helper function to assign holes to surface elevation (with proper geometry calculation)
function assignHoleToSurfaceElevation(hole, targetElevation, type) {
	if (type === "collar") {
		// Keep toe fixed, adjust collar to target elevation
		// Calculate the required vertical drop from collar to toe
		const verticalDrop = targetElevation - hole.gradeZLocation;

		// For angled holes, calculate the required hole length
		const radAngle = hole.holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			const newLength = Math.abs(verticalDrop) / cosAngle;
			hole.startZLocation = targetElevation;

			// Use calculateHoleGeometry to properly recalculate all geometry
			calculateHoleGeometry(hole, newLength, 1); // mode 1 = Length
			console.log("hole assigned to surface", hole);
		}
	} else if (type === "grade") {
		// Keep collar fixed, adjust toe to target elevation
		// Calculate the required bench height
		const newBenchHeight = hole.startZLocation - targetElevation;

		// Update bench height and recalculate geometry
		hole.benchHeight = newBenchHeight;

		// Calculate new hole length based on bench height and subdrill
		const radAngle = hole.holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			const newLength = (newBenchHeight + hole.subdrillAmount) / cosAngle;

			// Use calculateHoleGeometry to properly recalculate all geometry
			calculateHoleGeometry(hole, newLength, 1); // mode 1 = Length
			console.log("hole assigned to grade", hole);
		}
	}
}

// Updated surface assignment functions - NO NEW FUNCTIONS
//! REDO with the FloatingDialog class
//! REDO with the FloatingDialog class
assignSurfaceTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("assignSurfaceTool");

		// Check if surface is available
		const visibleSurfaces = getAllVisibleSurfaces();
		if (visibleSurfaces.length === 0) {
			// No surface available - show dialog with proper styling
			Swal.fire({
				title: "No Surface Loaded",
				html: `
					<div class="button-container-2col">
						<div class="labelWhite12">No surface is loaded or visible.</div>
						<div></div>
						<div class="labelWhite12">Set collar elevation to:</div>
						<input type="number" id="surfaceElevation" value="286" step="0.1" class="swal2-input" style="width: 80px; text-align: center;"> mZ
					</div>
				`,
				showCancelButton: true,
				confirmButtonText: "OK",
				cancelButtonText: "Cancel",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				},
				preConfirm: () => {
					const elevation = parseFloat(document.getElementById("surfaceElevation").value);
					if (isNaN(elevation)) {
						Swal.showValidationMessage("Please enter a valid elevation");
						return false;
					}
					return elevation;
				}
			}).then((result) => {
				if (result.isConfirmed) {
					assignHolesToFixedElevation(result.value, "collar");
				}
				// Deselect tool
				this.checked = false;
				resetFloatingToolbarButtons("none");
			});
			return;
		}

		// Multiple surfaces available - ask which one to use
		if (visibleSurfaces.length > 1) {
			const surfaceOptions = visibleSurfaces.map((surface) => `<option value="${surface.id}">${surface.name}</option>`).join("");

			Swal.fire({
				title: "Select Surface",
				html: `
					<div class="button-container-2col">
						<div class="labelWhite12">Multiple surfaces are visible. Select which surface to use:</div>
						<div></div>
						<select id="surfaceSelect" class="dropdown-80">
							${surfaceOptions}
						</select>
						<div></div>
					</div>
				`,
				showCancelButton: true,
				confirmButtonText: "Use",
				cancelButtonText: "Cancel",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				},
				preConfirm: () => {
					return document.getElementById("surfaceSelect").value;
				}
			}).then((result) => {
				if (result.isConfirmed) {
					const selectedSurfaceId = result.value;

					// Surface is available - proceed with surface assignment
					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						let assignedCount = 0;
						selectedMultipleHoles.forEach((hole) => {
							const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
								assignedCount++;
							}
						});

						// Show success message
						const surface = loadedSurfaces.get(selectedSurfaceId);
						const surfaceName = surface ? surface.name || `Surface ${selectedSurfaceId}` : "selected surface";

						Swal.fire({
							title: "Surface Assignment Complete",
							text: `Successfully adjusted ${assignedCount} holes to ${surfaceName} elevation.`,
							icon: "success",
							showCancelButton: false,
							showConfirmButton: true,
							confirmButtonText: "OK",
							customClass: {
								container: "custom-popup-container",
								popup: "custom-popup-container",
								title: "swal2-title",
								content: "swal2-content",
								confirmButton: "confirm",
								cancelButton: "cancel"
							}
						});

						updateStatusMessage("Select next tool\n to continue");
					} else {
						updateStatusMessage("Click on holes to assign surface elevation.");
						canvas.addEventListener("click", handleAssignSurfaceClick);
					}
				}
				// Deselect tool
				this.checked = false;
				resetFloatingToolbarButtons("none");
			});
			return;
		}

		// Single surface available - proceed directly with first surface
		const surfaceId = visibleSurfaces[0].id;
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			let assignedCount = 0;
			selectedMultipleHoles.forEach((hole) => {
				const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, surfaceId);
				if (surfaceZ !== null) {
					assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
					assignedCount++;
				}
			});

			// Show success message
			Swal.fire({
				title: "Surface Assignment Complete",
				text: `Successfully adjusted ${assignedCount} holes to surface elevation.`,
				icon: "success",
				showCancelButton: false,
				showConfirmButton: true,
				confirmButtonText: "OK",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				}
			});

			// Deselect tool
			this.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("Select next tool\n to continue");
		} else {
			updateStatusMessage("Click on holes to assign surface elevation.");
			canvas.addEventListener("click", handleAssignSurfaceClick);
		}
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignSurfaceClick);
	}
});

assignGradeTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("assignGradeTool");

		const visibleSurfaces = getAllVisibleSurfaces();
		if (visibleSurfaces.length === 0) {
			// No surface available - show dialog for manual entry
			Swal.fire({
				title: "No Surface Loaded",
				html: `
					<div class="button-container-2col">
						<div class="labelWhite12">No surface is loaded or visible.</div>
						<div></div>
						<div class="labelWhite12">Set toe elevation to:</div>
						<input type="number" id="gradeElevation" value="274" step="0.1" class="swal2-input" style="width: 80px; text-align: center;"> mZ
					</div>
				`,
				showCancelButton: true,
				confirmButtonText: "OK",
				cancelButtonText: "Cancel",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				},
				preConfirm: () => {
					const elevation = parseFloat(document.getElementById("gradeElevation").value);
					if (isNaN(elevation)) {
						Swal.showValidationMessage("Please enter a valid elevation");
						return false;
					}
					return elevation;
				}
			}).then((result) => {
				if (result.isConfirmed) {
					assignHolesToFixedElevation(result.value, "grade");
				}
				this.checked = false;
				resetFloatingToolbarButtons("none");
			});
			return;
		}

		// Multiple surfaces available - ask which one to use
		if (visibleSurfaces.length > 1) {
			// Consistent with your rule - no template literals
			// Consistent with your rule - no template literals
			const surfaceOptions = visibleSurfaces.map((surface) => '<option value="' + surface.id + '">' + surface.name + "</option>").join("");
			Swal.fire({
				title: "Select Surface",
				html: `
					<div class="button-container-2col">
						<div class="labelWhite12">Multiple surfaces are visible. Select which surface to use:</div>
						<div></div>
						<select id="surfaceSelect" class="dropdown-80">
							${surfaceOptions}
						</select>
						<div></div>
					</div>
				`,
				showCancelButton: true,
				confirmButtonText: "Use",
				cancelButtonText: "Cancel",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				},
				preConfirm: () => {
					return document.getElementById("surfaceSelect").value;
				}
			}).then((result) => {
				if (result.isConfirmed) {
					const selectedSurfaceId = result.value;
					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						let assignedCount = 0;
						selectedMultipleHoles.forEach(function (hole) {
							const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								assignHoleToSurfaceElevation(hole, surfaceZ, "grade");
								assignedCount++;
							}
						});
						const surface = loadedSurfaces.get(selectedSurfaceId);
						const surfaceName = surface ? surface.name || "Surface " + selectedSurfaceId : "selected surface";
						Swal.fire({
							title: "Grade Assignment Complete",
							text: "Successfully adjusted " + assignedCount + " hole grades to " + surfaceName + " elevation.",
							icon: "success",
							showCancelButton: false,
							showConfirmButton: true,
							confirmButtonText: "OK",
							customClass: {
								container: "custom-popup-container",
								popup: "custom-popup-container",
								title: "swal2-title",
								content: "swal2-content",
								confirmButton: "confirm",
								cancelButton: "cancel"
							}
						});
						updateStatusMessage("Select next tool\n to continue");
					} else {
						updateStatusMessage("Click on holes to assign grade elevation to surface.");
						canvas.addEventListener("click", handleAssignGradeClick);
					}
				}
				this.checked = false;
				resetFloatingToolbarButtons("none");
			});
			return;
		}

		// Single surface available - proceed directly
		const surfaceId = visibleSurfaces[0].id;
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			let assignedCount = 0;
			selectedMultipleHoles.forEach(function (hole) {
				const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, surfaceId);
				if (surfaceZ !== null) {
					assignHoleToSurfaceElevation(hole, surfaceZ, "grade");
					assignedCount++;
				}
			});
			Swal.fire({
				title: "Grade Assignment Complete",
				text: "Successfully adjusted " + assignedCount + " hole grades to surface elevation.",
				icon: "success",
				showCancelButton: false,
				showConfirmButton: true,
				confirmButtonText: "OK",
				customClass: {
					container: "custom-popup-container",
					popup: "custom-popup-container",
					title: "swal2-title",
					content: "swal2-content",
					confirmButton: "confirm",
					cancelButton: "cancel"
				}
			});
			this.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("Select next tool\n to continue");
		} else {
			updateStatusMessage("Click on holes to assign grade elevation to surface.");
			canvas.addEventListener("click", handleAssignGradeClick);
		}
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignGradeClick);
	}
});
// Helper function to assign holes to a fixed elevation (updated)
function assignHolesToFixedElevation(elevation, type) {
	let assignedCount = 0;

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach((hole) => {
			assignHoleToSurfaceElevation(hole, elevation, type);
			assignedCount++;
		});

		// Show success message with proper styling
		//! REDO with the FloatingDialog class
		Swal.fire({
			title: "Elevation Assignment Complete",
			text: `Successfully adjusted ${assignedCount} holes to ${elevation}mZ ${type} elevation.`,
			icon: "success",
			showCancelButton: false,
			showConfirmButton: true,
			confirmButtonText: "OK",
			customClass: {
				container: "custom-popup-container",
				popup: "custom-popup-container",
				title: "swal2-title",
				content: "swal2-content",
				confirmButton: "confirm",
				cancelButton: "cancel"
			}
		});
	} else {
		updateStatusMessage("No holes selected for elevation assignment.");
	}

	drawData(allBlastHoles, selectedHole);
}

// Update click handlers - simplified version
function handleAssignSurfaceClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// Find clicked hole using canvas coordinates
	const clickedHole = getClickedHole(clickX, clickY);
	if (clickedHole) {
		const surfaceZ = interpolateZFromSurface(clickedHole.startXLocation, clickedHole.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHole, surfaceZ, "collar");
			updateStatusMessage("Adjusted hole " + clickedHole.holeID + "\nCollar at " + surfaceZ.toFixed(2) + "m, length now " + clickedHole.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHole.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

function handleAssignGradeClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// Find clicked hole using canvas coordinates
	const clickedHole = getClickedHole(clickX, clickY);
	if (clickedHole) {
		const surfaceZ = interpolateZFromSurface(clickedHole.startXLocation, clickedHole.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHole, surfaceZ, "grade");
			updateStatusMessage("Adjusted hole " + clickedHole.holeID + "\nToe at " + surfaceZ.toFixed(2) + "m, length now " + clickedHole.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHole.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

// Fixed save function (around line 18158)
function saveViewControlsSliderValues() {
	// View control sliders
	localStorage.setItem("fontSize", fontSlider.value);
	localStorage.setItem("fontLock", fontLock.checked);
	localStorage.setItem("connSize", connSlider.value);
	localStorage.setItem("toeSize", toeSlider.value);
	localStorage.setItem("holeSize", holeSlider.value);
	localStorage.setItem("intervalSize", intervalSlider.value);
	localStorage.setItem("firstMovementSize", firstMovementSlider.value);

	// Connection controls
	localStorage.setItem("delay", connectorDelay.value);
	localStorage.setItem("connectorColor", connectorColor.jscolor.toHEXString());
	localStorage.setItem("connectSlider", connectSlider.value);
	localStorage.setItem("floatingDelay", floatingDelay.value);
	localStorage.setItem("floatingConnectorColor", floatingConnectorColor.jscolor.toHEXString());

	// Drawing controls
	localStorage.setItem("drawingColor", drawingColor.jscolor.toHEXString());
	localStorage.setItem("lineThickness", lineThickness.value);
	localStorage.setItem("drawingRadius", circleRadius.value);
	localStorage.setItem("drawingText", drawingText.value);
	localStorage.setItem("drawingPolygonRadius", polygonRadius.value);
	localStorage.setItem("radiiSteps", radiiSteps.value);
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);

	// Lightning and Gradient Controls
	localStorage.setItem("lightBearing", lightBearingSlider.value);
	localStorage.setItem("lightElevation", lightElevationSlider.value);
	localStorage.setItem("gradientStyle", gradientStyle.value);

	console.log("View controls saved to localStorage");
}

// Fixed load function with null checks
function loadViewControlsSliderValues() {
	// View control sliders with defaults
	if (localStorage.getItem("fontSize")) fontSlider.value = localStorage.getItem("fontSize");
	if (localStorage.getItem("fontLock")) fontLock.checked = localStorage.getItem("fontLock");
	if (localStorage.getItem("connSize")) connSlider.value = localStorage.getItem("connSize");
	if (localStorage.getItem("toeSize")) toeSlider.value = localStorage.getItem("toeSize");
	if (localStorage.getItem("holeSize")) holeSlider.value = localStorage.getItem("holeSize");
	if (localStorage.getItem("intervalSize")) intervalSlider.value = localStorage.getItem("intervalSize");
	if (localStorage.getItem("firstMovementSize")) firstMovementSlider.value = localStorage.getItem("firstMovementSize");
	if (localStorage.getItem("snapRadiusPixels")) snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
	// Connection controls
	if (localStorage.getItem("delay")) connectorDelay.value = localStorage.getItem("delay");
	if (localStorage.getItem("connectorColor")) connectorColor.jscolor.fromString(localStorage.getItem("connectorColor"));
	if (localStorage.getItem("connectSlider")) connectSlider.value = localStorage.getItem("connectSlider");
	if (localStorage.getItem("floatingDelay")) floatingDelay.value = localStorage.getItem("floatingDelay");
	if (localStorage.getItem("floatingConnectorColor")) floatingConnectorColor.jscolor.fromString(localStorage.getItem("floatingConnectorColor"));
	// Drawing controls
	if (localStorage.getItem("drawingColor")) drawingColor.jscolor.fromString(localStorage.getItem("drawingColor"));
	if (localStorage.getItem("drawingRadius")) circleRadius.value = localStorage.getItem("drawingRadius");
	if (localStorage.getItem("drawingText")) drawingText.value = localStorage.getItem("drawingText");
	if (localStorage.getItem("drawingPolygonRadius")) polygonRadius.value = localStorage.getItem("drawingPolygonRadius");
	if (localStorage.getItem("radiiSteps")) radiiSteps.value = localStorage.getItem("radiiSteps");
	if (localStorage.getItem("lineThickness")) lineThickness.value = localStorage.getItem("lineThickness");
	// Lightning and Gradient Controls
	if (localStorage.getItem("lightBearing")) lightBearingSlider.value = localStorage.getItem("lightBearing");
	if (localStorage.getItem("lightElevation")) lightElevationSlider.value = localStorage.getItem("lightElevation");
	if (localStorage.getItem("gradientStyle")) gradientStyle.value = localStorage.getItem("gradientStyle");

	console.log("View controls loaded from localStorage");
}
// Auto-save when any control changes (add after the load function)
function setupAutoSavePreferences() {
	// View control sliders
	fontSlider.addEventListener("input", saveViewControlsSliderValues);
	connSlider.addEventListener("input", saveViewControlsSliderValues);
	toeSlider.addEventListener("input", saveViewControlsSliderValues);
	holeSlider.addEventListener("input", saveViewControlsSliderValues);
	intervalSlider.addEventListener("input", saveViewControlsSliderValues);
	firstMovementSlider.addEventListener("input", saveViewControlsSliderValues);
	snapToleranceSlider.addEventListener("input", saveViewControlsSliderValues);
	// Connection controls
	connectorDelay.addEventListener("input", saveViewControlsSliderValues);
	connectSlider.addEventListener("input", saveViewControlsSliderValues);
	floatingConnectorColor.addEventListener("input", saveViewControlsSliderValues);
	floatingDelay.addEventListener("input", saveViewControlsSliderValues);

	// Drawing controls
	circleRadius.addEventListener("input", saveViewControlsSliderValues);
	drawingText.addEventListener("input", saveViewControlsSliderValues);
	polygonRadius.addEventListener("input", saveViewControlsSliderValues);
	radiiSteps.addEventListener("input", saveViewControlsSliderValues);

	// Color pickers (these need special handling)
	connectorColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	drawingColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	lineThickness.addEventListener("input", saveViewControlsSliderValues);
}

//--------------------GLOBAL SNAPPING SNAP SELECT ------------------------//
// Global snapping configuration
let snapRadiusPixels = 10; // Default value in pixels
let snapEnabled = true; // Global snap toggle
let snapHighlight = null; // Store the current snap target for visual feedback

// Initialize snap radius from localStorage
if (localStorage.getItem("snapRadiusPixels")) {
	snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
} else if (localStorage.getItem("snapRadius") || localStorage.getItem("snapTolerance")) {
	// Migrate old meter-based snap to pixel-based (convert 1m to ~10 pixels as default)
	snapRadiusPixels = 10;
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
}

// Update slider to match loaded value
if (document.getElementById("snapToleranceSlider")) {
	document.getElementById("snapToleranceSlider").min = 2; // Minimum 2 pixels
	document.getElementById("snapToleranceSlider").max = 50; // Maximum 50 pixels
	document.getElementById("snapToleranceSlider").step = 1; // 1 pixel increments
	document.getElementById("snapToleranceSlider").value = snapRadiusPixels;
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";
}

// Single event listener for snap tolerance
document.getElementById("snapToleranceSlider")?.addEventListener("input", function () {
	snapRadiusPixels = parseFloat(this.value);
	// console.log("Snap Tolerance updated: " + snapRadiusPixels + "px");
	updateStatusMessage("Snap Tolerance: " + snapRadiusPixels + "px");
	setTimeout(() => updateStatusMessage(""), 1500);

	// Update all labels consistently
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

	// Save to localStorage
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
});

// Helper function to convert pixel tolerance to world coordinates for current zoom
function getSnapToleranceInWorldUnits() {
	return snapRadiusPixels / currentScale;
}

// All possible snap targets and their priorities
const SNAP_PRIORITIES = {
	HOLE_COLLAR: 1, // Highest priority
	HOLE_GRADE: 2,
	HOLE_TOE: 3,
	KAD_POINT: 4,
	KAD_LINE_VERTEX: 5,
	KAD_POLYGON_VERTEX: 6,
	KAD_CIRCLE_CENTER: 7,
	KAD_TEXT_POSITION: 8,
	KAD_LINE_SEGMENT: 9, // Segments get lower priority
	KAD_POLYGON_SEGMENT: 10, // Segments get lower priority
	SURFACE_POINT: 11,
	SURFACE_FACE: 12 // Lowest priority
};
// Add this new function before snapToNearestPoint
// Add this new function before snapToNearestPoint
function snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, excludeEntityName, excludeElementIndex, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar"
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade"
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe"
				});
			}
		});
	}

	// 2. Search KAD Objects but exclude the moving point and its segments
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip if this is the entity being moved
			const isMovingEntity = entityName === excludeEntityName;

			// Check vertices
			entity.data.forEach((dataPoint, index) => {
				// Skip the actual point being moved
				if (isMovingEntity && index === excludeElementIndex) {
					return;
				}

				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`
					});
				}
			});

			// Check segments but exclude adjacent ones
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						// Skip segments adjacent to the moving point
						if (isMovingEntity) {
							const nextIndex = (i + 1) % points.length;
							if (i === excludeElementIndex || nextIndex === excludeElementIndex) {
								continue; // Skip this segment
							}
						}

						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t
								}
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null
	};
}

// Enhanced global snapping function with segment support
function snapToNearestPoint(rawWorldX, rawWorldY, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar"
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade"
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe"
				});
			}
		});
	}

	// 2. Search ALL KAD Objects in unified map
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity) => {
			// First, check vertices (existing behavior)
			entity.data.forEach((dataPoint) => {
				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`
					});
				}
			});

			// NEW: Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							// OLD CODE (problematic):
							// const priority = entity.entityType === "line" ? SNAP_PRIORITIES.KAD_LINE_VERTEX - 0.5 : SNAP_PRIORITIES.KAD_POLYGON_VERTEX - 0.5;

							// NEW CODE (fixed):
							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : entity.entityType === "poly" ? "KAD_POLYGON_SEGMENT" : "KAD_LINE_SEGMENT"; // fallback
							const priority = SNAP_PRIORITIES[segmentType]; // Use explicit segment priorities

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t
								}
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null
	};
}

// Convert canvas coordinates to world coordinates with snapping
function canvasToWorldWithSnap(canvasX, canvasY) {
	// Convert to raw world coordinates first
	const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

	// Apply snapping
	return snapToNearestPoint(rawWorldX, rawWorldY);
}

// Enhanced mouse move handler with snap preview
function handleMouseMoveWithSnap(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;
	const mouseZ = drawingZValue || document.getElementById("drawingElevation").value || 0;

	// Update global mouse tracking
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;
	currentMouseCanvasZ = mouseZ;

	// Get snapped coordinates for preview
	const snapResult = canvasToWorldWithSnap(mouseX, mouseY, mouseZ);
	currentMouseWorldX = snapResult.worldX;
	currentMouseWorldY = snapResult.worldY;
	currentMouseWorldZ = snapResult.worldZ;

	// Store snap target for visual feedback
	snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;
	// Update elevation field when snapping to a Z value
	if (snapResult.snapped && snapResult.worldZ !== undefined) {
		document.getElementById("drawingElevation").value = snapResult.worldZ;
		drawingZValue = snapResult.worldZ;
		currentMouseWorldZ = snapResult.worldZ;
	}
	// Existing mouse move logic...
	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	// ... rest of existing mouse move logic ...
	drawData(allBlastHoles, selectedHole);
}

// Visual feedback for snap highlights
//TODO Need to call this in the DrawData() function.
//TODO got fix this
function drawSnapHighlight() {
	if (!snapHighlight || !snapEnabled) return;

	// Convert world coordinates to canvas
	const [snapX, snapY] = worldToCanvas(snapHighlight.point.x, snapHighlight.point.y);

	// Draw snap indicator
	ctx.save();
	ctx.strokeStyle = "#00ff00"; // Bright green
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(0, 255, 0, 0.3)";

	// Draw crosshair
	const size = 8;
	ctx.beginPath();
	ctx.moveTo(snapX - size, snapY);
	ctx.lineTo(snapX + size, snapY);
	ctx.moveTo(snapX, snapY - size);
	ctx.lineTo(snapX, snapY + size);
	ctx.stroke();

	// Draw circle
	ctx.beginPath();
	ctx.arc(snapX, snapY, size * 0.7, 0, 2 * Math.PI);
	ctx.stroke();

	// Enhanced tooltip with Z value
	ctx.font = "10px Arial";
	ctx.fillStyle = "#00ff00";
	const zText = snapHighlight.point.z ? " (" + snapHighlight.point.z.toFixed(2) + "m RL)" : "";
	ctx.fillText(snapHighlight.description + zText, snapX + 12, snapY - 8);

	ctx.restore();
}

// Settings for snap configuration
function addSnapSettings() {
	// Add to the UI settings panel
	const snapSettings = `
        <div class="setting-group">
            <label class="labelWhite12">Snap Settings:</label>
            <div class="setting-row">
                <label class="labelWhite10">Enable Snapping:</label>
                <input type="checkbox" id="snapEnabled" ${snapEnabled ? "checked" : ""}>
            </div>
            <div class="setting-row">
                <label class="labelWhite10">Snap Radius:</label>
                <input type="number" id="snapRadius" value="${snapRadius}" min="1" max="50" step="0.5">
                <label class="labelWhite10">meters</label>
            </div>
        </div>
    `;

	// Add event listeners for snap settings
	document.getElementById("snapEnabled")?.addEventListener("change", (e) => {
		snapEnabled = e.target.checked;
		localStorage.setItem("snapEnabled", snapEnabled);
	});

	document.getElementById("snapRadius")?.addEventListener("change", (e) => {
		snapRadius = parseFloat(e.target.value);
		localStorage.setItem("snapRadius", snapRadius);
	});
}

///------------  GEOTIFF STUFF GOES HERE ------------///

// NEW: Interpolate elevation from GeoTIFF raster data
function interpolateZFromRaster(worldX, worldY, rasterSurface) {
	const bbox = rasterSurface.bbox;
	const width = rasterSurface.width;
	const height = rasterSurface.height;
	const elevationData = rasterSurface.rasterData;

	// Check if point is within raster bounds
	if (worldX < bbox[0] || worldX > bbox[2] || worldY < bbox[1] || worldY > bbox[3]) {
		return null;
	}

	// Convert world coordinates to pixel coordinates
	const pixelX = ((worldX - bbox[0]) / (bbox[2] - bbox[0])) * width;
	const pixelY = ((bbox[3] - worldY) / (bbox[3] - bbox[1])) * height; // Y is flipped

	// Get integer pixel coordinates for bilinear interpolation
	const x1 = Math.floor(pixelX);
	const y1 = Math.floor(pixelY);
	const x2 = Math.min(x1 + 1, width - 1);
	const y2 = Math.min(y1 + 1, height - 1);

	// Get the four surrounding elevation values
	const z11 = elevationData[y1 * width + x1];
	const z12 = elevationData[y2 * width + x1];
	const z21 = elevationData[y1 * width + x2];
	const z22 = elevationData[y2 * width + x2];

	// Check for nodata values
	if (z11 === -9999 || z12 === -9999 || z21 === -9999 || z22 === -9999) {
		return null;
	}

	// Bilinear interpolation
	const fx = pixelX - x1;
	const fy = pixelY - y1;

	const z1 = z11 * (1 - fx) + z21 * fx;
	const z2 = z12 * (1 - fx) + z22 * fx;
	const z = z1 * (1 - fy) + z2 * fy;

	return z;
}

// Enhanced loadGeoTIFF function
async function loadGeoTIFF(file) {
	try {
		updateStatusMessage("Reading GeoTIFF file...");

		const arrayBuffer = await file.arrayBuffer();
		const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
		const image = await tiff.getImage();
		const rasters = await image.readRasters();

		// Get geospatial info
		const bbox = image.getBoundingBox();
		const width = image.getWidth();
		const height = image.getHeight();
		const bandCount = image.getSamplesPerPixel();

		// console.log(`GeoTIFF Info: ${width}x${height}, ${bandCount} bands`);

		// Check if coordinates are in WGS84 (lat/lon)
		if (isLikelyWGS84(bbox)) {
			// Ask user for projection
			const result = await promptForProjection(bbox);
			if (result.transformed) {
				// Use transformed bbox
				await processGeoTIFF(rasters, result.bbox, width, height, bandCount, file.name);
			} else {
				updateStatusMessage("Coordinate transformation cancelled. GeoTIFF not loaded.");
			}
		} else {
			// Use original bbox
			await processGeoTIFF(rasters, bbox, width, height, bandCount, file.name);
		}
	} catch (error) {
		console.error("Error loading GeoTIFF:", error);
		updateStatusMessage("Error loading GeoTIFF: " + error.message);
	}
}

// Function to process GeoTIFF based on bbox type
async function processGeoTIFF(rasters, bbox, width, height, bandCount, surfaceName) {
	// Determine if this is imagery (RGB) or elevation data
	if (bandCount >= 3) {
		// RGB/RGBA imagery - create background image
		await createImageSurface(rasters, bbox, width, height, bandCount, surfaceName);
	} else {
		// Single band - likely elevation data
		await createElevationSurface(rasters[0], bbox, width, height, surfaceName);
	}
}
// NEW: Create elevation surface with raster data for interpolation
async function createElevationSurface(elevationData, bbox, width, height, surfaceName) {
	try {
		const imageId = imageName || "image_" + Date.now();
		loadedImages.set(imageId, {
			id: imageId,
			name: imageName || imageId,
			canvas: canvas,
			bbox: bbox,
			type: "elevation", // or whatever type
			visible: true,
			transparency: 0.7
		});

		// Then save to DB:
		saveSurfaceToDB(imageId);

		// Also create point cloud for visualization (sampled)
		const points = [];
		const sampleRate = Math.max(1, Math.floor(Math.sqrt(width * height) / 1000));

		for (let y = 0; y < height; y += sampleRate) {
			for (let x = 0; x < width; x += sampleRate) {
				const elevation = elevationData[y * width + x];
				if (elevation !== null && !isNaN(elevation) && elevation !== -9999) {
					const worldX = bbox[0] + (x / width) * (bbox[2] - bbox[0]);
					const worldY = bbox[3] - (y / height) * (bbox[3] - bbox[1]);

					points.push({
						x: worldX,
						y: worldY,
						z: elevation
					});
				}
			}
		}

		// Create triangulated surface for visualization using existing function
		createSurfaceFromPoints(points, surfaceName, true);

		updateStatusMessage("Elevation surface loaded: " + points.length + " points + full raster interpolation");
	} catch (error) {
		console.error("Error creating elevation surface:", error);
		updateStatusMessage("Error creating elevation surface: " + error.message);
	}
}

// NEW: Create image surface (background imagery)
// Fix the createImageSurface function
async function createImageSurface(rasters, bbox, width, height, bandCount, surfaceName) {
	try {
		// Create canvas for the image
		const imageCanvas = document.createElement("canvas");
		imageCanvas.width = width;
		imageCanvas.height = height;
		const imageCtx = imageCanvas.getContext("2d");

		// Create ImageData
		const imageData = imageCtx.createImageData(width, height);
		const data = imageData.data;

		// Convert raster data to RGBA
		for (let i = 0; i < width * height; i++) {
			const pixelIndex = i * 4;

			// RGB bands
			data[pixelIndex] = rasters[0][i]; // Red
			data[pixelIndex + 1] = rasters[1][i]; // Green
			data[pixelIndex + 2] = rasters[2][i]; // Blue
			data[pixelIndex + 3] = bandCount >= 4 ? rasters[3][i] : 255; // Alpha
		}

		// Put image data on canvas
		imageCtx.putImageData(imageData, 0, 0);

		// Generate unique ID for this image
		const imageId = "image_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);

		// Store in the new loadedImages Map instead of backgroundImage global
		loadedImages.set(imageId, {
			id: imageId,
			name: surfaceName || imageId,
			canvas: imageCanvas,
			bbox: bbox,
			type: "imagery",
			visible: true,
			transparency: 1.0
		});

		// CRITICAL: Update centroids to include GeoTIFF extents
		updateCentroidsWithBBox(bbox);

		// Update display
		drawData(allBlastHoles, selectedHole);

		// SAVE TO DATABASE - Pass the imageId instead of name
		try {
			await saveImageToDB(imageId);
			// console.log("✅ Image saved to database:", surfaceName);
		} catch (saveError) {
			console.error("❌ Failed to save image to database:", saveError);
		}

		// Update tree view to show new image
		debouncedUpdateTreeView();

		setTimeout(() => {
			updateStatusMessage("Background image loaded: " + surfaceName + " (" + width + "x" + height + ")");
			setTimeout(() => {
				updateStatusMessage("");
			}, 3000);
		}, 0);
	} catch (error) {
		console.error("Error creating image surface:", error);
		updateStatusMessage("Error creating image surface: " + error.message);
	}
}

// Add this new helper function
function updateCentroidsWithBBox(bbox) {
	// Call regular updateCentroids first
	updateCentroids();

	// If there's no data yet, use the bbox directly
	if (centroidX === 0 && centroidY === 0) {
		centroidX = (bbox[0] + bbox[2]) / 2;
		centroidY = (bbox[1] + bbox[3]) / 2;
		// console.log("Centering view on GeoTIFF extent:", { centroidX, centroidY });
	}
}

// NEW: Background image support
// WITH this multi-image system:
let loadedImages = new Map(); // Map<imageId, {id, name, canvas, bbox, type, visible, transparency}>

function drawBackgroundImage() {
	if (!imagesGroupVisible) return; // ✅ ADD: Check images group visibility
	if (loadedImages.size === 0) return;

	loadedImages.forEach((image) => {
		if (!image.visible || !image.canvas) return;

		// Draw this image
		const bbox = image.bbox;
		if (bbox && bbox.length >= 4) {
			// Convert world coordinates to canvas coordinates
			const [x1, y1] = worldToCanvas(bbox[0], bbox[3]); // Top-left
			const [x2, y2] = worldToCanvas(bbox[2], bbox[1]); // Bottom-right

			ctx.save();
			// Fix line 21643 in drawBackgroundImage function
			ctx.globalAlpha = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;

			ctx.drawImage(image.canvas, x1, y1, x2 - x1, y2 - y1);
			ctx.restore();
			// Debug rectangle - FIX: Use canvas.width and canvas.height
			ctx.strokeStyle = "red";
			ctx.lineWidth = 1;
			ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));

			ctx.restore();
		}
	});
}

// Context menu for the GeoTIFF image
function showImageContextMenu(x, y, imageId = null) {
	// Get the specific image if ID provided, otherwise first visible image
	const image = imageId ? loadedImages.get(imageId) : Array.from(loadedImages.values()).find((img) => img.visible);

	if (!image) return;

	if (!image) return;
	const menu = document.createElement("div");
	menu.className = "context-menu";
	menu.style.position = "absolute";
	menu.style.left = x + "px";
	menu.style.top = y + "px";

	// Use dynamic colors based on current theme
	const isDarkMode = document.body.classList.contains("dark-mode") || window.matchMedia("(prefers-color-scheme: dark)").matches;

	const backgroundColor = isDarkMode ? "#2d2d2d" : "#ffffff";
	const borderColor = isDarkMode ? "#555555" : "#cccccc";
	const textColor = isDarkMode ? "#ffffff" : "#000000";
	const hoverColor = isDarkMode ? "#ff0000" : "#ff0000";

	menu.style.backgroundColor = backgroundColor;
	menu.style.border = "1px solid " + borderColor;
	menu.style.borderRadius = "8px";
	menu.style.padding = "4px";
	menu.style.boxShadow = isDarkMode ? "0 2px 8px rgba(0,0,0,0.5)" : "0 2px 8px rgba(0,0,0,0.15)";
	menu.style.zIndex = "10000";
	menu.style.color = textColor;
	menu.style.minWidth = "180px";

	// Toggle visibility option
	const toggleOption = document.createElement("div");
	toggleOption.textContent = image.visible ? "Hide Image" : "Show Image";
	toggleOption.style.padding = "8px 12px";
	toggleOption.style.cursor = "pointer";
	toggleOption.style.color = textColor;
	toggleOption.onmouseover = () => {
		toggleOption.style.backgroundColor = hoverColor;
	};
	toggleOption.onmouseout = () => {
		toggleOption.style.backgroundColor = backgroundColor;
	};
	//Update visibility toggle to only affect the clicked image
	toggleOption.onclick = (e) => {
		e.stopPropagation();

		// FIXED: Toggle visibility of ONLY the clicked image
		if (imageId && loadedImages.has(imageId)) {
			const targetImage = loadedImages.get(imageId);
			if (targetImage) {
				targetImage.visible = !targetImage.visible;
				// console.log("Toggled visibility for image '" + (targetImage.name || imageId) + "' to: " + targetImage.visible);
			}
		} else {
			// Fallback: Toggle the image object we already have
			image.visible = !image.visible;
			// console.log("Toggled visibility for image '" + (image.name || "unknown") + "' to: " + image.visible);
		}

		drawData(allBlastHoles, selectedHole);
		safeRemoveMenu(menu);
	};

	// Remove image option
	const removeOption = document.createElement("div");
	removeOption.textContent = "Remove Image";
	removeOption.style.padding = "8px 12px";
	removeOption.style.cursor = "pointer";
	removeOption.style.color = textColor;
	removeOption.onmouseover = () => {
		removeOption.style.backgroundColor = hoverColor;
	};
	removeOption.onmouseout = () => {
		removeOption.style.backgroundColor = backgroundColor;
	};

	//Update remove option to only remove the clicked image
	removeOption.onclick = async (e) => {
		e.stopPropagation();

		try {
			// FIXED: Remove ONLY the clicked image
			if (imageId && loadedImages.has(imageId)) {
				await deleteImageFromDB(imageId);
				loadedImages.delete(imageId);
				// console.log("✅ Removed specific image:", imageId);
			} else {
				// Fallback: Remove the image object we already have
				const fallbackImageId = Array.from(loadedImages.entries()).find(([id, img]) => img === image)?.[0];
				if (fallbackImageId) {
					await deleteImageFromDB(fallbackImageId);
					loadedImages.delete(fallbackImageId);
					// console.log("✅ Removed fallback image:", fallbackImageId);
				}
			}

			drawData(allBlastHoles, selectedHole);
		} catch (error) {
			console.error("Error removing image:", error);
			drawData(allBlastHoles, selectedHole);
		}

		// Now safely remove menu
		safeRemoveMenu(menu);
	};
	//delere all images from DB
	const deleteOption = document.createElement("div");
	deleteOption.textContent = "Delete All Images";
	deleteOption.style.padding = "8px 12px";
	deleteOption.style.cursor = "pointer";
	deleteOption.style.color = textColor;
	deleteOption.onmouseover = () => {
		deleteOption.style.backgroundColor = hoverColor;
	};
	deleteOption.onmouseout = () => {
		deleteOption.style.backgroundColor = backgroundColor;
	};
	// Fix the "Delete All Images" context menu option
	deleteOption.onclick = async (e) => {
		e.stopPropagation();

		try {
			// Clear database AND memory
			await deleteAllImagesFromDB();

			// CRITICAL FIX: Clear the loadedImages Map
			loadedImages.clear();

			// Update tree view and redraw
			debouncedUpdateTreeView();
			drawData(allBlastHoles, selectedHole);

			// console.log("✅ All images deleted from database and memory");
		} catch (error) {
			console.error("Error deleting all images:", error);
		}

		safeRemoveMenu(menu);
	};

	// Try simplifying to just a slider first to see if that works
	const transparencyOption = document.createElement("div");
	transparencyOption.textContent = "Transparency:";
	transparencyOption.appendChild(document.createElement("br")); // Add line break here
	transparencyOption.style.padding = "8px 12px";

	// Create slider
	const slider = document.createElement("input");
	slider.type = "range";
	slider.min = "0";
	slider.max = "100";
	slider.value = Math.round((image.transparency || 1) * 100);
	slider.style.width = "95%"; // Make it take up most of the width
	slider.style.margin = "8px auto 0"; // Add space above
	slider.style.display = "block"; // Make it block level

	slider.onclick = (e) => e.stopPropagation();
	// UPDATE Update transparency slider to only affect the clicked image
	slider.oninput = () => {
		const newTransparency = slider.value / 100;

		// FIXED: Apply to ONLY the specific image, not all images
		if (imageId && loadedImages.has(imageId)) {
			const targetImage = loadedImages.get(imageId);
			if (targetImage) {
				targetImage.transparency = newTransparency;
				//console.log("Updated transparency for image '" + (targetImage.name || imageId) + "' to: " + newTransparency);
			}
		} else {
			// Fallback: Apply to the image object we already have
			image.transparency = newTransparency;
			//console.log("Updated transparency for image '" + (image.name || "unknown") + "' to: " + newTransparency);
		}

		drawData(allBlastHoles, selectedHole);
	};

	transparencyOption.appendChild(slider);
	menu.appendChild(toggleOption);
	menu.appendChild(removeOption);
	menu.appendChild(deleteOption);
	menu.appendChild(transparencyOption);
	document.body.appendChild(menu);

	// Remove menu when clicking elsewhere
	setTimeout(() => {
		document.addEventListener("click", function removeMenu() {
			if (document.body.contains(menu)) {
				document.body.removeChild(menu);
			}
			document.removeEventListener("click", removeMenu);
		});
	}, 0);
}
// REPLACE this function to accept image parameter:
function isPointInBackgroundImage(canvasX, canvasY, image = null) {
	// If no specific image provided, check all visible images
	if (!image) {
		return Array.from(loadedImages.values()).some((img) => img.visible && isPointInBackgroundImage(canvasX, canvasY, img));
	}

	if (!image || !image.canvas || !image.visible) return false;

	const bbox = image.bbox;
	if (!bbox || bbox.length < 4) return false;

	// Convert canvas coordinates to world coordinates
	const [worldX, worldY] = canvasToWorld(canvasX, canvasY);

	// Check if point is within image bounds
	return worldX >= bbox[0] && worldX <= bbox[2] && worldY >= bbox[1] && worldY <= bbox[3];
}

///------------  GEOTIFF STUFF ENDS HERE ------------///

///------------ PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///
// For future conversions using PROJ4. That is if a user uploads a latlon geotiff ask them to convert.
// Convert should allow aeither a custom proj4 or one from the epsg.io site.
async function loadEPSGCode(epsgCode) {
	try {
		const url = `https://epsg.io/${epsgCode}.proj4`;
		const response = await fetch(url);
		if (!response.ok) throw new Error("Failed to fetch EPSG definition");

		const proj4def = await response.text();
		proj4.defs(`EPSG:${epsgCode}`, proj4def.trim());

		console.log(`Loaded EPSG:${epsgCode} →`, proj4def.trim());
	} catch (err) {
		console.error("Error loading EPSG:", err);
	}
}
// Top 100 most commonly used EPSG codes worldwide
const top100EPSGCodes = [
	{
		code: "4326",
		name: "WGS 84"
	},
	{
		code: "3857",
		name: "WGS 84 / Pseudo-Mercator"
	},
	{
		code: "4269",
		name: "NAD83"
	},
	{
		code: "4267",
		name: "NAD27"
	},
	{
		code: "32633",
		name: "WGS 84 / UTM zone 33N"
	},
	{
		code: "32634",
		name: "WGS 84 / UTM zone 34N"
	},
	{
		code: "32635",
		name: "WGS 84 / UTM zone 35N"
	},
	{
		code: "32636",
		name: "WGS 84 / UTM zone 36N"
	},
	{
		code: "32637",
		name: "WGS 84 / UTM zone 37N"
	},
	{
		code: "32638",
		name: "WGS 84 / UTM zone 38N"
	},
	{
		code: "32639",
		name: "WGS 84 / UTM zone 39N"
	},
	{
		code: "32640",
		name: "WGS 84 / UTM zone 40N"
	},
	{
		code: "32641",
		name: "WGS 84 / UTM zone 41N"
	},
	{
		code: "32642",
		name: "WGS 84 / UTM zone 42N"
	},
	{
		code: "32643",
		name: "WGS 84 / UTM zone 43N"
	},
	{
		code: "32644",
		name: "WGS 84 / UTM zone 44N"
	},
	{
		code: "32645",
		name: "WGS 84 / UTM zone 45N"
	},
	{
		code: "32646",
		name: "WGS 84 / UTM zone 46N"
	},
	{
		code: "32647",
		name: "WGS 84 / UTM zone 47N"
	},
	{
		code: "32648",
		name: "WGS 84 / UTM zone 48N"
	},
	{
		code: "32649",
		name: "WGS 84 / UTM zone 49N"
	},
	{
		code: "32650",
		name: "WGS 84 / UTM zone 50N"
	},
	{
		code: "32651",
		name: "WGS 84 / UTM zone 51N"
	},
	{
		code: "32652",
		name: "WGS 84 / UTM zone 52N"
	},
	{
		code: "32653",
		name: "WGS 84 / UTM zone 53N"
	},
	{
		code: "32654",
		name: "WGS 84 / UTM zone 54N"
	},
	{
		code: "32655",
		name: "WGS 84 / UTM zone 55N"
	},
	{
		code: "32656",
		name: "WGS 84 / UTM zone 56N"
	},
	{
		code: "32657",
		name: "WGS 84 / UTM zone 57N"
	},
	{
		code: "32658",
		name: "WGS 84 / UTM zone 58N"
	},
	{
		code: "32659",
		name: "WGS 84 / UTM zone 59N"
	},
	{
		code: "32660",
		name: "WGS 84 / UTM zone 60N"
	},
	{
		code: "32701",
		name: "WGS 84 / UTM zone 1S"
	},
	{
		code: "32702",
		name: "WGS 84 / UTM zone 2S"
	},
	{
		code: "32703",
		name: "WGS 84 / UTM zone 3S"
	},
	{
		code: "32704",
		name: "WGS 84 / UTM zone 4S"
	},
	{
		code: "32705",
		name: "WGS 84 / UTM zone 5S"
	},
	{
		code: "32706",
		name: "WGS 84 / UTM zone 6S"
	},
	{
		code: "32707",
		name: "WGS 84 / UTM zone 7S"
	},
	{
		code: "32708",
		name: "WGS 84 / UTM zone 8S"
	},
	{
		code: "32709",
		name: "WGS 84 / UTM zone 9S"
	},
	{
		code: "32710",
		name: "WGS 84 / UTM zone 10S"
	},
	{
		code: "32711",
		name: "WGS 84 / UTM zone 11S"
	},
	{
		code: "32712",
		name: "WGS 84 / UTM zone 12S"
	},
	{
		code: "32713",
		name: "WGS 84 / UTM zone 13S"
	},
	{
		code: "32714",
		name: "WGS 84 / UTM zone 14S"
	},
	{
		code: "32715",
		name: "WGS 84 / UTM zone 15S"
	},
	{
		code: "32716",
		name: "WGS 84 / UTM zone 16S"
	},
	{
		code: "32717",
		name: "WGS 84 / UTM zone 17S"
	},
	{
		code: "32718",
		name: "WGS 84 / UTM zone 18S"
	},
	{
		code: "32719",
		name: "WGS 84 / UTM zone 19S"
	},
	{
		code: "32720",
		name: "WGS 84 / UTM zone 20S"
	},
	{
		code: "32721",
		name: "WGS 84 / UTM zone 21S"
	},
	{
		code: "32722",
		name: "WGS 84 / UTM zone 22S"
	},
	{
		code: "32723",
		name: "WGS 84 / UTM zone 23S"
	},
	{
		code: "32724",
		name: "WGS 84 / UTM zone 24S"
	},
	{
		code: "32725",
		name: "WGS 84 / UTM zone 25S"
	},
	{
		code: "32726",
		name: "WGS 84 / UTM zone 26S"
	},
	{
		code: "32727",
		name: "WGS 84 / UTM zone 27S"
	},
	{
		code: "32728",
		name: "WGS 84 / UTM zone 28S"
	},
	{
		code: "32729",
		name: "WGS 84 / UTM zone 29S"
	},
	{
		code: "32730",
		name: "WGS 84 / UTM zone 30S"
	},
	{
		code: "32731",
		name: "WGS 84 / UTM zone 31S"
	},
	{
		code: "32732",
		name: "WGS 84 / UTM zone 32S"
	},
	{
		code: "32733",
		name: "WGS 84 / UTM zone 33S"
	},
	{
		code: "32734",
		name: "WGS 84 / UTM zone 34S"
	},
	{
		code: "32735",
		name: "WGS 84 / UTM zone 35S"
	},
	{
		code: "32736",
		name: "WGS 84 / UTM zone 36S"
	},
	{
		code: "32737",
		name: "WGS 84 / UTM zone 37S"
	},
	{
		code: "32738",
		name: "WGS 84 / UTM zone 38S"
	},
	{
		code: "32739",
		name: "WGS 84 / UTM zone 39S"
	},
	{
		code: "32740",
		name: "WGS 84 / UTM zone 40S"
	},
	{
		code: "32741",
		name: "WGS 84 / UTM zone 41S"
	},
	{
		code: "32742",
		name: "WGS 84 / UTM zone 42S"
	},
	{
		code: "32743",
		name: "WGS 84 / UTM zone 43S"
	},
	{
		code: "32744",
		name: "WGS 84 / UTM zone 44S"
	},
	{
		code: "32745",
		name: "WGS 84 / UTM zone 45S"
	},
	{
		code: "32746",
		name: "WGS 84 / UTM zone 46S"
	},
	{
		code: "32747",
		name: "WGS 84 / UTM zone 47S"
	},
	{
		code: "32748",
		name: "WGS 84 / UTM zone 48S"
	},
	{
		code: "32749",
		name: "WGS 84 / UTM zone 49S"
	},
	{
		code: "32750",
		name: "WGS 84 / UTM zone 50S"
	},
	{
		code: "32751",
		name: "WGS 84 / UTM zone 51S"
	},
	{
		code: "32752",
		name: "WGS 84 / UTM zone 52S"
	},
	{
		code: "32753",
		name: "WGS 84 / UTM zone 53S"
	},
	{
		code: "32754",
		name: "WGS 84 / UTM zone 54S"
	},
	{
		code: "32755",
		name: "WGS 84 / UTM zone 55S"
	},
	{
		code: "32756",
		name: "WGS 84 / UTM zone 56S"
	},
	{
		code: "32757",
		name: "WGS 84 / UTM zone 57S"
	},
	{
		code: "32758",
		name: "WGS 84 / UTM zone 58S"
	},
	{
		code: "32759",
		name: "WGS 84 / UTM zone 59S"
	},
	{
		code: "32760",
		name: "WGS 84 / UTM zone 60S"
	},
	{
		code: "2154",
		name: "RGF93 / Lambert-93"
	},
	{
		code: "25832",
		name: "ETRS89 / UTM zone 32N"
	},
	{
		code: "25833",
		name: "ETRS89 / UTM zone 33N"
	},
	{
		code: "3035",
		name: "ETRS89 / LAEA Europe"
	},
	{
		code: "3395",
		name: "WGS 84 / World Mercator"
	},
	{
		code: "4277",
		name: "OSGB 1936"
	},
	{
		code: "27700",
		name: "OSGB 1936 / British National Grid"
	},
	{
		code: "2180",
		name: "ETRS89 / Poland CS92"
	},
	{
		code: "3003",
		name: "Monte Mario / Italy zone 1"
	},
	{
		code: "3004",
		name: "Monte Mario / Italy zone 2"
	},
	{
		code: "31370",
		name: "Belge 1972 / Belgian Lambert 72"
	},
	{
		code: "28992",
		name: "Amersfoort / RD New"
	},
	{
		code: "2056",
		name: "CH1903+ / LV95"
	},
	{
		code: "5514",
		name: "S-JTSK / Krovak East North"
	},
	{
		code: "102100",
		name: "WGS 1984 Web Mercator Auxiliary Sphere"
	}
];
//function to cache a list of common world EPSG codes.
// NOT IN USE - USE THE TOP100EPSGCodes ARRAY ABOVE
function getTop100EPSGCodesFromWeb(codesEPSG) {
	// Cache for storing EPSG codes to avoid repeated API calls
	const epsgCache = new Map();

	// Function to fetch EPSG definitions from web and cache them
	function fetchEPSGDefinitions() {
		return new Promise(function (resolve, reject) {
			updateStatusMessage("Loading coordinate system definitions...");

			let loadedCount = 0;
			const totalCount = codesEPSG.length;

			codesEPSG.forEach(function (epsg) {
				if (!epsgCache.has(epsg.code)) {
					const url = "https://epsg.io/" + epsg.code + ".proj4";
					fetch(url)
						.then(function (response) {
							if (response.ok) {
								return response.text();
							}
							throw new Error("Failed to fetch EPSG:" + epsg.code);
						})
						.then(function (proj4def) {
							epsgCache.set(epsg.code, proj4def.trim());
							proj4.defs("EPSG:" + epsg.code, proj4def.trim());
						})
						.catch(function (error) {
							console.warn("Failed to load EPSG:" + epsg.code, error);
						})
						.finally(function () {
							loadedCount++;
							if (loadedCount === totalCount) {
								updateStatusMessage("Coordinate system definitions loaded");
								resolve(codesEPSG);
							}
						});
				} else {
					loadedCount++;
					if (loadedCount === totalCount) {
						updateStatusMessage("Coordinate system definitions loaded");
						resolve(top100EPSGCodes);
					}
				}
			});
		});
	}

	// Return the cached list or fetch if needed
	if (epsgCache.size === 0) {
		return fetchEPSGDefinitions();
	} else {
		return Promise.resolve(top100EPSGCodes);
	}
}

// Add this function to detect if coordinates are likely WGS84
function isLikelyWGS84(bbox) {
	// WGS84 coordinates typically range from -180 to 180 for longitude
	// and -90 to 90 for latitude
	return bbox[0] >= -180 && bbox[0] <= 180 && bbox[2] >= -180 && bbox[2] <= 180 && bbox[1] >= -90 && bbox[1] <= 90 && bbox[3] >= -90 && bbox[3] <= 90;
}

// Prompt user for projection details
async function promptForProjection(bbox) {
	// Common Australian UTM zones
	const commonEPSGCodes = top100EPSGCodes;

	// Build dropdown options
	const dropdownOptions = commonEPSGCodes.map((item) => `<option value="${item.code}">${item.code} - ${item.name}</option>`).join("");

	return new Promise((resolve) => {
		Swal.fire({
			title: "Coordinate System Conversion Required",
			html: `
                <div style="text-align: left; margin-bottom: 15px;">
                    <p class="labelWhite15">The GeoTIFF appears to use WGS84 (latitude/longitude) coordinates:</p>
                    <pre style="background:#ccc; padding:5px; border-radius:3px; color:#444; font-size:12px;">${bbox[0].toFixed(6) + ", " + bbox[1].toFixed(6) + " to " + bbox[2].toFixed(6) + ", " + bbox[3].toFixed(6)}</pre>
                    <p class="labelWhite15">Kirra2D uses meters East(X)/North(Y). Please select a target coordinate system:</p>
                </div>
                <div class="button-container-2col">
                    <div class="labelWhite15">EPSG Code:</div>
                    <select id="epsgCode" class="swal2-select">
                        <option value="">Select EPSG Code</option>
                        ${dropdownOptions}
                    </select>
                    
                    <div class="labelWhite15">Or Custom Proj4:</div>
                    <textarea id="customProj4" class="swal2-input" placeholder="+proj=utm +zone=50 +south +datum=WGS84 +units=m +no_defs" style="height:60px; width:50%;"></textarea>
                </div>
            `,
			showCancelButton: true,
			focusConfirm: false,
			confirmButtonText: "Transform",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				popup: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container"
			},
			preConfirm: async () => {
				const epsgCode = document.getElementById("epsgCode").value;
				const customProj4 = document.getElementById("customProj4").value;

				try {
					let sourceDef = "+proj=longlat +datum=WGS84 +no_defs";
					let targetDef = "";

					if (epsgCode) {
						await loadEPSGCode(epsgCode);
						targetDef = `EPSG:${epsgCode}`;
					} else if (customProj4) {
						targetDef = customProj4;
					} else {
						Swal.showValidationMessage("Please select an EPSG code or provide a custom Proj4 definition");
						return false;
					}

					// Transform the bounding box
					const ll = proj4(sourceDef, targetDef, [bbox[0], bbox[1]]);
					const ur = proj4(sourceDef, targetDef, [bbox[2], bbox[3]]);

					console.log("Transformed coordinates:", {
						ll,
						ur
					});

					return {
						transformed: true,
						bbox: [ll[0], ll[1], ur[0], ur[1]],
						epsgCode: epsgCode || null,
						customProj4: customProj4 || null
					};
				} catch (error) {
					Swal.showValidationMessage(`Transformation error: ${error.message}`);
					return false;
				}
			}
		}).then((result) => {
			if (result.isConfirmed && result.value) {
				resolve(result.value);
			} else {
				resolve({
					transformed: false
				});
			}
		});
	});
}

///------------ END OF PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///

//----REPLACEMENT OPTION FOR PRINTING----///

///------------------ PRINT TEMPLATE SYSTEM ------------------///
// #region PRINT

//KEEP
// Print template configuration
let printMode = false;
let printOrientation = "landscape"; // 'landscape' or 'portrait'
let printPaperSize = "A4"; // 'A4', 'A3', 'A2', 'A1', 'A0'
let currentBlastName = allBlastHoles.length > 0 ? [...new Set(allBlastHoles.map((p) => p.entityName))].join(", ") : "Unnamed Blast";
let isPrinting = false;
//KEEP
// Paper size ratios (width:height)
const paperRatios = {
	A4: {
		width: 297,
		height: 210
	},
	A3: {
		width: 420,
		height: 297
	},
	A2: {
		width: 594,
		height: 420
	},
	A1: {
		width: 841,
		height: 594
	},
	A0: {
		width: 1189,
		height: 841
	}
};
//KEEP
// Add this with your other event listeners
document.getElementById("addPrintPreviewToggle").addEventListener("change", function () {
	togglePrintMode();
});
//KEEP
function changePaperSize() {
	const paperSizeSelect = document.getElementById("paperSize");
	if (paperSizeSelect) {
		printPaperSize = paperSizeSelect.value;
		if (printMode) {
			drawData(allBlastHoles, selectedHole); // Redraw with new paper size
		}
	}
}
//KEEP
function changeOrientation() {
	const orientationSelect = document.getElementById("orientation");
	if (orientationSelect) {
		printOrientation = orientationSelect.value;
		if (printMode) {
			drawData(allBlastHoles, selectedHole); // Redraw with new orientation
		}
	}
}
//KEEP
function togglePrintMode() {
	printMode = !printMode;

	// Sync the checkbox state
	const toggle = document.getElementById("addPrintPreviewToggle");
	if (toggle) toggle.checked = printMode;

	if (printMode) {
		updateStatusMessage("Print Preview Mode ON - Position elements within the print boundary");
	} else {
		updateStatusMessage("Print Preview Mode OFF");
	}

	drawData(allBlastHoles, selectedHole); // Redraw with/without print boundary
	// After your drawData call, add:
}
//KEEP
// Calculate print-safe boundary on canvas
function getPrintBoundary() {
	if (!printMode) return null;

	const paper = paperRatios[printPaperSize];
	const aspectRatio = printOrientation === "landscape" ? paper.width / paper.height : paper.height / paper.width;

	// Calculate boundary that fits in canvas with margins
	const canvasMargin = 30; // pixels
	const availableWidth = canvas.width - canvasMargin * 2;
	const availableHeight = canvas.height - canvasMargin * 2;

	let boundaryWidth, boundaryHeight;

	if (availableWidth / availableHeight > aspectRatio) {
		// Canvas is wider than needed - fit by height
		boundaryHeight = availableHeight;
		boundaryWidth = boundaryHeight * aspectRatio;
	} else {
		// Canvas is taller than needed - fit by width
		boundaryWidth = availableWidth;
		boundaryHeight = boundaryWidth / aspectRatio;
	}

	return {
		x: (canvas.width - boundaryWidth) / 2,
		y: (canvas.height - boundaryHeight) / 2,
		width: boundaryWidth,
		height: boundaryHeight,
		marginPercent: 0.02 // 2% margin inside boundary
	};
}
//KEEP
function drawPrintBoundary(ctx) {
	if (!printMode) return;

	const boundary = getPrintBoundary();
	if (!boundary) return;

	ctx.save();

	// Only draw boundaries in preview mode, not when actually printing
	if (!isPrinting) {
		// Add this flag
		// Draw outer boundary (paper edge)
		ctx.strokeStyle = "#ff0000";
		ctx.lineWidth = 2;
		ctx.setLineDash([10, 5]);
		ctx.strokeRect(boundary.x, boundary.y, boundary.width, boundary.height);

		// Draw inner boundary (print-safe area)
		const margin = boundary.width * boundary.marginPercent;
		ctx.strokeStyle = "#0066cc";
		ctx.lineWidth = 1;
		ctx.setLineDash([5, 3]);
		ctx.strokeRect(boundary.x + margin, boundary.y + margin, boundary.width - margin * 2, boundary.height - margin * 2);
	}

	ctx.restore();
}

function printToPDF() {
	printCanvasHiRes();
}

// These are now declared with 'let' in the global scope to allow resizing.
let printCanvas = document.createElement("canvas");
let printCtx = printCanvas.getContext("2d");

// This is the complete, robust printing system.
function printCanvasHiRes() {
	// Step 1) Fix the condition to allow printing if there are KAD drawings/surfaces/images even without blast holes
	if ((!allBlastHoles || allBlastHoles.length === 0) && (!allKADDrawingsMap || allKADDrawingsMap.size === 0) && (!allAvailableSurfaces || allAvailableSurfaces.length === 0)) {
		showModalMessage("No Data", "No data available for printing (no blast holes, KAD drawings, surfaces, or images)", "warning");
		return;
	}

	// Step 1) Create progress content with optional progress bar
	const progressContent = document.createElement("div");
	progressContent.style.textAlign = "center";
	progressContent.innerHTML = `
		<p>Generating High-Resolution PDF</p>
		<p>Please wait, this may take a moment...</p>
		<div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;">
			<div id="pdfProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div>
		</div>
		<p id="pdfProgressText">Starting...</p>
	`;

	// Step 2) Show FloatingDialog with progress indicator
	const progressDialog = new FloatingDialog({
		title: "PDF Generation",
		content: progressContent,
		layoutType: "standard",
		width: 350,
		height: 200,
		showConfirm: false,
		showCancel: false,
		allowOutsideClick: false
	});

	progressDialog.show();

	// Step 1: Get the bar and text elements
	const bar = document.getElementById("pdfProgressBar");
	const text = document.getElementById("pdfProgressText");
	// Use a short delay to ensure the browser has time to process before we
	// try to convert the canvas to an image. This avoids race conditions.
	setTimeout(() => {
		try {
			const dpi = 300;
			const mmToPx = dpi / 25.4;

			const paperSizes = {
				A4: {
					width: 210,
					height: 297
				},
				A3: {
					width: 297,
					height: 420
				},
				A2: {
					width: 420,
					height: 594
				},
				A1: {
					width: 594,
					height: 841
				},
				A0: {
					width: 841,
					height: 1189
				}
			};

			const paperSize = paperSizes[printPaperSize] || paperSizes["A4"];
			const isLandscape = printOrientation === "landscape";

			const pageWidth = isLandscape ? paperSize.height : paperSize.width;
			const pageHeight = isLandscape ? paperSize.width : paperSize.height;

			// Safety check for maximum canvas size to prevent browser errors
			const MAX_CANVAS_SIDE = 16384; // Most browsers support up to 16384px
			if (pageWidth * mmToPx > MAX_CANVAS_SIDE || pageHeight * mmToPx > MAX_CANVAS_SIDE) {
				throw new Error("The selected paper size (" + printPaperSize + ") creates an image too large for the browser to handle.");
			}

			// Resize the canvas and get a new context (resizing wipes the old one)
			printCanvas.width = pageWidth * mmToPx;
			printCanvas.height = pageHeight * mmToPx;
			printCtx = printCanvas.getContext("2d");

			printCtx.imageSmoothingEnabled = true;
			printCtx.imageSmoothingQuality = "high";
			printCtx.fillStyle = "white";
			printCtx.fillRect(0, 0, printCanvas.width, printCanvas.height);

			const margin = pageWidth * mmToPx * 0.02;
			// const headerHeight = pageHeight * mmToPx * 0.1;
			// const footerHeight = pageHeight * mmToPx * 0.05;

			// For WYSIWYG printing, use the FULL canvas area (no header/footer)
			const printArea = {
				x: 0, // + margin,
				y: 0, // + margin,
				width: printCanvas.width, // - margin / 2,
				height: printCanvas.height // - margin / 2
			};

			setTimeout(() => {
				try {
					// Step 1: Drawing header
					printHeader(printCtx, margin, margin, printCanvas.width - 2 * margin);
					bar.style.width = "20%";
					text.textContent = "Drawing header...";

					setTimeout(() => {
						// Step 2: Drawing footer
						printFooter(printCtx, margin, printCanvas.height - margin, printCanvas.width - 2 * margin);
						bar.style.width = "40%";
						text.textContent = "Drawing footer...";

						setTimeout(() => {
							// Step 3: Drawing data
							drawDataForPrinting(printCtx, printArea);
							bar.style.width = "60%";
							text.textContent = "Drawing data...";

							setTimeout(() => {
								// Step 4: Generating image
								const imgData = printCanvas.toDataURL("image/png", 1.0);
								bar.style.width = "80%";
								text.textContent = "Generating image...";

								if (!imgData || imgData.length < 100 || imgData === "data:,") {
									throw new Error("The browser failed to generate the canvas image. This can happen if the image is too large or memory is low.");
								}

								setTimeout(() => {
									// Step 5: Saving PDF
									const { jsPDF } = window.jspdf;
									const orientation = isLandscape ? "l" : "p";
									const pdf = new jsPDF(orientation, "mm", printPaperSize.toLowerCase());
									pdf.addImage(imgData, "PNG", 0, 0, pageWidth, pageHeight);
									pdf.save("kirra-2d-PDF" + new Date().toISOString().split("T")[0] + ".pdf");
									bar.style.width = "100%";
									text.textContent = "Saving PDF...";

									setTimeout(() => {
										progressDialog.close();
									}, 300);
								}, 100);
							}, 100);
						}, 100);
					}, 100);
				} catch (error) {
					progressDialog.close();
					console.error("PDF Generation Error:", error);
					showModalMessage("PDF Creation Failed", "Could not generate the PDF. <br><small>Error: " + error.message + "</small>", "error");
				}
			}, 250);
		} catch (error) {
			progressDialog.close();
			console.error("PDF Generation Error:", error);
		}
	}, 250); // 250ms delay
}

// Replace your existing drawDataForPrinting function with this one.

function drawDataForPrinting(printCtx, printArea) {
	// --- WYSIWYG LOGIC: Render exactly what's in the BLUE dashed boundary (print-safe area) ---

	// 1. Get the on-screen print preview boundary (red dashed box)
	const screenBoundary = getPrintBoundary();
	if (!screenBoundary) {
		throw new Error("Print Preview Mode must be active to generate a WYSIWYG print.");
	}

	// 2. Calculate the INNER boundary (blue dashed lines - print-safe area)
	// This is what should actually be printed
	const margin = screenBoundary.width * screenBoundary.marginPercent;
	const innerBoundary = {
		x: screenBoundary.x + margin,
		y: screenBoundary.y + margin,
		width: screenBoundary.width - margin * 2,
		height: screenBoundary.height - margin * 2
	};

	// 3. Convert the BLUE boundary (inner boundary) to world coordinates
	// This represents exactly what the user sees within the blue dashed lines
	const world_x1 = (innerBoundary.x - canvas.width / 2) / currentScale + centroidX;
	const world_y1 = -(innerBoundary.y + innerBoundary.height - canvas.height / 2) / currentScale + centroidY;
	const world_x2 = (innerBoundary.x + innerBoundary.width - canvas.width / 2) / currentScale + centroidX;
	const world_y2 = -(innerBoundary.y - canvas.height / 2) / currentScale + centroidY;

	const minX = world_x1;
	const maxX = world_x2;
	const minY = world_y1;
	const maxY = world_y2;

	// 4. Calculate the scale to fit this world view into the PDF's printArea
	const dataWidth = maxX - minX;
	const dataHeight = maxY - minY;
	if (dataWidth <= 0 || dataHeight <= 0) return;

	const scaleX = printArea.width / dataWidth;
	const scaleY = printArea.height / dataHeight;
	const printScale = Math.min(scaleX, scaleY);

	const scaledWidth = dataWidth * printScale;
	const scaledHeight = dataHeight * printScale;
	const offsetX = printArea.x + (printArea.width - scaledWidth) / 2;
	const offsetY = printArea.y + (printArea.height - scaledHeight) / 2;

	const printCentroidX = minX + dataWidth / 2;
	const printCentroidY = minY + dataHeight / 2;

	// 5. Create coordinate transformation function
	function worldToPrint(worldX, worldY) {
		const x = (worldX - printCentroidX) * printScale + offsetX + scaledWidth / 2;
		const y = -(worldY - printCentroidY) * printScale + offsetY + scaledHeight / 2;
		return [x, y];
	}

	// --- TEMPORARY GLOBAL OVERRIDES ---
	const original_currentScale = currentScale;
	const original_centroidX = centroidX;
	const original_centroidY = centroidY;
	const original_canvas_width = canvas.width;
	const original_canvas_height = canvas.height;
	const original_worldToCanvas = window.worldToCanvas;
	const original_imageVisible = imageVisible;
	const original_surfaceVisible = surfaceVisible;

	// Set globals to print-specific values
	currentScale = printScale;
	centroidX = printCentroidX;
	centroidY = printCentroidY;
	canvas.width = printCanvas.width;
	canvas.height = printCanvas.height;
	window.worldToCanvas = worldToPrint;
	imageVisible = false;
	surfaceVisible = false;

	// --- RENDER EVERYTHING (NO FILTERING) ---
	// The coordinate transformation will handle what's visible
	printData(allBlastHoles, selectedHole);

	// --- RESTORE GLOBALS ---
	currentScale = original_currentScale;
	centroidX = original_centroidX;
	centroidY = original_centroidY;
	canvas.width = original_canvas_width;
	canvas.height = original_canvas_height;
	window.worldToCanvas = original_worldToCanvas;
	imageVisible = original_imageVisible;
	surfaceVisible = original_surfaceVisible;
}

const magnifyFont = 1.7;

//----------------- REPLICATION OF THE UX Canvas but for High Resolution Printing ------------------///
function printVoronoiMetric(metrics, metricName, getColorForMetric) {
	for (let cell of metrics) {
		// Skip if the cell doesn't have a polygon or the metric is null/undefined
		if (!cell.polygon || cell[metricName] == null) continue;

		const color = getColorForMetric(cell[metricName]);

		printCtx.beginPath();
		printCtx.moveTo(cell.polygon[0][0], cell.polygon[0][1]);
		for (let j = 1; j < cell.polygon.length; j++) {
			printCtx.lineTo(cell.polygon[j][0], cell.polygon[j][1]);
		}
		printCtx.closePath();
		printCtx.fillStyle = color;
		printCtx.fill();
	}
}
// Fix printBlastBoundary function
function printBlastBoundary(polygon, color) {
	// FIX: Use window.worldToCanvas instead of manual coordinate transformation
	const screenCoords = polygon.map((point) => {
		const [x, y] = window.worldToCanvas(point.x, point.y);
		return {
			x,
			y
		};
	});

	printCtx.beginPath();
	printCtx.moveTo(screenCoords[0].x, screenCoords[0].y);
	for (let i = 1; i < screenCoords.length; i++) {
		printCtx.lineTo(screenCoords[i].x, screenCoords[i].y);
	}
	printCtx.closePath();
	printCtx.strokeStyle = color;
	printCtx.lineWidth = 2;
	printCtx.stroke();
}

function printKADPoints(x, y, z, color) {
	printCtx.beginPath();
	printCtx.arc(x, y, 2, 0, 2 * Math.PI);
	printCtx.strokeStyle = color;
	printCtx.fillStyle = color;
	printCtx.stroke();
	printCtx.fill();
}

function printKADLines(sx, sy, ex, ey, sz, ez, lineWidth, color) {
	printCtx.beginPath();
	printCtx.moveTo(sx, sy);
	printCtx.lineTo(ex, ey);
	printCtx.strokeStyle = color;
	printCtx.lineWidth = lineWidth;
	printCtx.stroke();
}

function printKADPolys(sx, sy, ex, ey, sz, ez, lineWidth, color, isClosed) {
	printCtx.beginPath();
	printCtx.moveTo(sx, sy);
	printCtx.lineTo(ex, ey);
	printCtx.strokeStyle = color;
	printCtx.lineWidth = lineWidth;
	printCtx.stroke();
	if (isClosed) {
		printCtx.closePath();
	}
}

function printKADCircles(x, y, z, radius, lineWidth, strokeColor) {
	printCtx.strokeStyle = strokeColor;
	printCtx.beginPath();
	// Convert radius from world units to screen pixels
	const radiusInPixels = radius * currentScale;
	printCtx.arc(x, y, radiusInPixels, 0, 2 * Math.PI);
	printCtx.lineWidth = lineWidth;
	printCtx.stroke();
}

function printKADTexts(x, y, z, text, color) {
	//printCtx.fillStyle = color;
	printCtx.font = parseInt(currentFontSize * magnifyFont - 2) + "px Arial";
	printMultilineText(printCtx, text, x, y, currentFontSize * magnifyFont, "left", color, color, false);
}

function printTrack(lineStartX, lineStartY, lineEndX, lineEndY, gradeX, gradeY, color, subdrillAmount) {
	printCtx.lineWidth = 1;
	const printColor = "black";

	if (subdrillAmount < 0) {
		// NEGATIVE SUBDRILL: Draw only from start to toe (bypass grade)
		// Use 20% opacity for the entire line since it represents "over-drilling"
		printCtx.beginPath();
		printCtx.strokeStyle = printColor;
		printCtx.moveTo(lineStartX, lineStartY);
		printCtx.lineTo(lineEndX, lineEndY);
		printCtx.stroke();
		// Draw from grade to toe (subdrill portion - red)
		printCtx.beginPath();
		printCtx.strokeStyle = "rgba(255, 0, 0, 0.2)"; // Red line (full opacity)
		printCtx.moveTo(lineEndX, lineEndY);
		printCtx.lineTo(gradeX, gradeY);
		printCtx.stroke();
		// Draw grade marker with 20% opacity
		printCtx.beginPath();
		printCtx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
		printCtx.fillStyle = `rgba(255, 0, 0, 0.2)`; // Red marker with 20% opacity
		printCtx.fill();
	} else {
		// POSITIVE SUBDRILL: Draw from start to grade (dark), then grade to toe (red)

		// Draw from start to grade point (bench drill portion - dark)
		printCtx.beginPath();
		printCtx.strokeStyle = printColor; // Dark line (full opacity)
		printCtx.moveTo(lineStartX, lineStartY);
		printCtx.lineTo(gradeX, gradeY);
		printCtx.stroke();

		// Draw from grade to toe (subdrill portion - red)
		printCtx.beginPath();
		printCtx.strokeStyle = "rgba(255, 0, 0, 1.0)"; // Red line (full opacity)
		printCtx.moveTo(gradeX, gradeY);
		printCtx.lineTo(lineEndX, lineEndY);
		printCtx.stroke();

		// Draw grade marker (full opacity)
		printCtx.beginPath();
		printCtx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
		printCtx.fillStyle = "rgba(255, 0, 0, 1.0)"; // Red marker (full opacity)
		printCtx.fill();
	}
}

function printHoleToe(x, y, fillColor, strokeColor, radius) {
	printCtx.beginPath();
	// Use the toeSizeInMeters directly to set the radius
	printCtx.lineWidth = 1;
	printCtx.arc(x, y, radius, 0, 2 * Math.PI);
	printCtx.fillStyle = fillColor;
	printCtx.strokeStyle = "black";
	printCtx.stroke();
	printCtx.fill();
}

function printHole(x, y, radius, strokeColor) {
	printCtx.strokeStyle = "black";
	printCtx.fillStyle = "black";
	printCtx.lineWidth = 1;
	printCtx.beginPath();
	const minRadius = 1.5;
	const drawRadius = radius > minRadius ? radius : minRadius;
	printCtx.arc(x, y, drawRadius, 0, 2 * Math.PI);
	printCtx.fill(); // fill the circle with the fill color
	printCtx.stroke(); // draw the circle border with the stroke color
}

function printDummy(x, y, radius, strokeColor) {
	printCtx.strokeStyle = "black";
	printCtx.lineWidth = 2; // Adjust the line width as needed
	printCtx.beginPath();
	printCtx.moveTo(x - radius, y - radius);
	printCtx.lineTo(x + radius, y + radius);
	printCtx.moveTo(x - radius, y + radius);
	printCtx.lineTo(x + radius, y - radius);
	printCtx.stroke();
}

function printNoDiameterHole(x, y, sideLength, strokeColor) {
	printCtx.strokeStyle = "black";
	printCtx.lineWidth = 2; // Adjust the line width as needed
	const halfSide = sideLength / 2;
	printCtx.beginPath();
	printCtx.moveTo(x - halfSide, y - halfSide);
	printCtx.lineTo(x + halfSide, y - halfSide);
	printCtx.lineTo(x + halfSide, y + halfSide);
	printCtx.lineTo(x - halfSide, y + halfSide);
	printCtx.closePath(); // Close the path to form a square
	printCtx.stroke();
}

function printHiHole(x, y, radius, fillColor, strokeColor) {
	printCtx.strokeStyle = strokeColor;
	printCtx.beginPath();
	printCtx.arc(x, y, radius, 0, 2 * Math.PI);
	printCtx.fillStyle = fillColor;
	printCtx.fill(); // fill the circle with the fill color
	printCtx.lineWidth = 5;
	printCtx.stroke(); // draw the circle border with the stroke color
}

function printText(x, y, text, color) {
	printCtx.font = parseInt(currentFontSize * magnifyFont - 2) + "px Arial";
	printCtx.fillStyle = color;
	printCtx.fillText(text, x, y);
}

function printRightAlignedText(x, y, text, color) {
	printCtx.font = parseInt(currentFontSize * magnifyFont - 2) + "px Arial";
	const textWidth = printCtx.measureText(text).width;
	printCtx.fillStyle = color;
	// Draw the text at an x position minus the text width for right alignment
	printText(x - textWidth, y, text, color);
}

function printMultilineText(printCtx, text, x, y, lineHeight = 16, alignment = "left", textColor, boxColor, showBox = false) {
	if (!text) return; //if no text, return
	if (!printCtx) return; //if no context, return
	const lines = text.split("\n");
	//calculate the text width of the widest line NOT the the entire sting.
	let textWidth = 0;
	for (let i = 0; i < lines.length; i++) {
		const lineWidth = printCtx.measureText(lines[i]).width;
		if (lineWidth > textWidth) {
			textWidth = lineWidth;
		}
	}
	//colorise the text
	printCtx.fillStyle = textColor;
	for (let i = 0; i < lines.length; i++) {
		if (alignment == "left") {
			printCtx.fillText(lines[i], x, y + i * lineHeight);
		} else if (alignment == "right") {
			printCtx.fillText(lines[i], x - textWidth, y + i * lineHeight);
		} else if (alignment == "center") {
			// Center each line individually based on its own width
			const lineWidth = printCtx.measureText(lines[i]).width;
			printCtx.fillText(lines[i], x - lineWidth / 2, y + i * lineHeight);
		}
	}

	if (showBox) {
		printCtx.strokeStyle = boxColor;
		printCtx.lineWidth = 1;
		printCtx.beginPath();
		printCtx.roundRect(x - 5 - textWidth / 2, y - 6 - lineHeight / 2, textWidth + 10, lines.length * lineHeight + 6, 4);
		printCtx.stroke();
	}
}

function printDirectionArrow(startX, startY, endX, endY, fillColor, strokeColor, connScale) {
	try {
		// Set up the arrow parameters
		var arrowWidth = (firstMovementSize / 4) * currentScale; // Width of the arrowhead
		var arrowLength = 2 * (firstMovementSize / 4) * currentScale; // Length of the arrowhead
		var tailWidth = arrowWidth * 0.7; // Width of the tail (adjust as needed)
		const angle = Math.atan2(endY - startY, endX - startX); // Angle of the arrow

		// Set the stroke and fill colors
		printCtx.strokeStyle = "black"; // Stroke color (black outline)
		printCtx.fillStyle = fillColor; // Fill color (goldenrod)

		// Begin drawing the arrow as a single path
		printCtx.beginPath();

		// Move to the start point of the arrow
		printCtx.moveTo(startX + (tailWidth / 2) * Math.sin(angle), startY - (tailWidth / 2) * Math.cos(angle)); // Top-left corner of the tail

		// Draw to the end point of the tail (top-right corner)
		printCtx.lineTo(endX - arrowLength * Math.cos(angle) + (tailWidth / 2) * Math.sin(angle), endY - arrowLength * Math.sin(angle) - (tailWidth / 2) * Math.cos(angle));

		// Draw the right base of the arrowhead
		printCtx.lineTo(endX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle), endY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle));

		// Draw the tip of the arrowhead
		printCtx.lineTo(endX, endY);

		// Draw the left base of the arrowhead
		printCtx.lineTo(endX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle), endY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle));

		// Draw back to the bottom-right corner of the tail
		printCtx.lineTo(endX - arrowLength * Math.cos(angle) - (tailWidth / 2) * Math.sin(angle), endY - arrowLength * Math.sin(angle) + (tailWidth / 2) * Math.cos(angle));

		// Draw to the bottom-left corner of the tail
		printCtx.lineTo(startX - (tailWidth / 2) * Math.sin(angle), startY + (tailWidth / 2) * Math.cos(angle));

		printCtx.closePath();
		printCtx.fill(); // Fill the arrow with color
		printCtx.stroke(); // Outline the arrow with a stroke
	} catch (error) {
		console.error("Error while drawing arrow:", error);
	}
}

function printArrow(startX, startY, endX, endY, color, connScale, connectorCurve = 0) {
	//console.log("Drawing arrow from (" + startX + ", " + startY + ") to (" + endX + ", " + endY + ") with color " + color);
	try {
		// Step 1) Set up the arrow parameters
		var arrowWidth = (connScale / 4) * currentScale;
		var arrowLength = 2 * (connScale / 4) * currentScale;

		printCtx.strokeStyle = color;
		printCtx.fillStyle = color;
		printCtx.lineWidth = 2;

		// Step 2) Handle straight arrow (0 degrees)
		if (connectorCurve === 0) {
			// Draw straight line
			printCtx.beginPath();
			printCtx.moveTo(parseInt(startX), parseInt(startY));
			printCtx.lineTo(parseInt(endX), parseInt(endY));
			printCtx.stroke();

			// Calculate angle for arrowhead
			const angle = Math.atan2(startX - endX, startY - endY);
		} else {
			// Step 3) Draw curved arrow
			const midX = (startX + endX) / 2;
			const midY = (startY + endY) / 2;
			const dx = endX - startX;
			const dy = endY - startY;
			const distance = Math.sqrt(dx * dx + dy * dy);

			// Step 4) Calculate control point based on angle in degrees
			const radians = (connectorCurve * Math.PI) / 180;
			const curveFactor = (connectorCurve / 90) * distance * 0.5; // Linear scaling instead of sine

			// Perpendicular vector for curve direction
			const perpX = -dy / distance;
			const perpY = dx / distance;

			const controlX = midX + perpX * curveFactor;
			const controlY = midY + perpY * curveFactor;

			// Step 5) Draw curved line using quadratic bezier
			printCtx.beginPath();
			printCtx.moveTo(parseInt(startX), parseInt(startY));
			printCtx.quadraticCurveTo(parseInt(controlX), parseInt(controlY), parseInt(endX), parseInt(endY));
			printCtx.stroke();
		}

		// Step 6) Draw arrowhead
		if (endX == startX && endY == startY) {
			// Draw house shape for self-referencing
			var size = (connScale / 4) * currentScale;
			printCtx.fillStyle = color;
			printCtx.beginPath();
			printCtx.moveTo(endX, endY);
			printCtx.lineTo(endX - size / 2, endY + size);
			printCtx.lineTo(endX - size / 2, endY + 1.5 * size);
			printCtx.lineTo(endX + size / 2, endY + 1.5 * size);
			printCtx.lineTo(endX + size / 2, endY + size);
			printCtx.closePath();
			printCtx.stroke();
		} else {
			// Step 7) Calculate arrowhead angle for curved or straight arrows
			let angle;
			if (connectorCurve !== 0) {
				// For curved arrows, calculate angle at the end point
				const dx = endX - startX;
				const dy = endY - startY;
				const distance = Math.sqrt(dx * dx + dy * dy);
				const curveFactor = (connectorCurve / 90) * distance * 0.5;
				const perpX = -dy / distance;
				const perpY = dx / distance;
				const controlX = (startX + endX) / 2 + perpX * curveFactor;
				const controlY = (startY + endY) / 2 + perpY * curveFactor;

				// Calculate tangent at end point (derivative of quadratic bezier at t=1)
				const tangentX = 2 * (endX - controlX);
				const tangentY = 2 * (endY - controlY);
				angle = Math.atan2(tangentY, tangentX);

				// Draw arrowhead for curved arrows
				printCtx.beginPath();
				printCtx.moveTo(parseInt(endX), parseInt(endY));
				printCtx.lineTo(endX - arrowLength * Math.cos(angle - Math.PI / 6), endY - arrowLength * Math.sin(angle - Math.PI / 6));
				printCtx.lineTo(endX - arrowLength * Math.cos(angle + Math.PI / 6), endY - arrowLength * Math.sin(angle + Math.PI / 6));
				printCtx.closePath();
				printCtx.fill();
			} else {
				// For straight arrows - use the original working calculation
				angle = Math.atan2(startX - endX, startY - endY);

				// Draw arrowhead for straight arrows (original working method)
				printCtx.beginPath();
				printCtx.moveTo(parseInt(endX), parseInt(endY));
				printCtx.lineTo(endX - arrowLength * Math.cos((Math.PI / 2) * 3 - angle) - arrowWidth * Math.sin((Math.PI / 2) * 3 - angle), endY - arrowLength * Math.sin((Math.PI / 2) * 3 - angle) + arrowWidth * Math.cos((Math.PI / 2) * 3 - angle));
				printCtx.lineTo(endX - arrowLength * Math.cos((Math.PI / 2) * 3 - angle) + arrowWidth * Math.sin((Math.PI / 2) * 3 - angle), endY - arrowLength * Math.sin((Math.PI / 2) * 3 - angle) - arrowWidth * Math.cos((Math.PI / 2) * 3 - angle));
				printCtx.closePath();
				printCtx.fill();
			}
		}
	} catch (error) {
		console.error("Error while printing arrow:", error);
	}
}

function printArrowDelayText(startX, startY, endX, endY, color, text, connectorCurve = 0) {
	// Step 1) Calculate text position and angle
	let textX, textY, textAngle;

	if (connectorCurve === 0) {
		// Straight arrow - use midpoint
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		textAngle = Math.atan2(endY - startY, endX - startX);

		// Calculate perpendicular offset to move text above the line
		const perpAngle = textAngle - Math.PI / 2; // 90 degrees counterclockwise
		const offsetDistance = (currentFontSize * magnifyFont - 2) * 0.1; // Much smaller offset

		textX = midX + Math.cos(perpAngle) * offsetDistance;
		textY = midY + Math.sin(perpAngle) * offsetDistance;
	} else {
		// Step 2) Curved arrow - calculate actual point on curve at t=0.5
		const dx = endX - startX;
		const dy = endY - startY;
		const distance = Math.sqrt(dx * dx + dy * dy);
		const curveFactor = (connectorCurve / 90) * distance * 0.5;

		const perpX = -dy / distance;
		const perpY = dx / distance;

		// Control point
		const controlX = (startX + endX) / 2 + perpX * curveFactor;
		const controlY = (startY + endY) / 2 + perpY * curveFactor;

		// Calculate actual point on quadratic bezier curve at t=0.5 (midpoint)
		const t = 0.5;
		const oneMinusT = 1 - t;
		const curveX = oneMinusT * oneMinusT * startX + 2 * oneMinusT * t * controlX + t * t * endX;
		const curveY = oneMinusT * oneMinusT * startY + 2 * oneMinusT * t * controlY + t * t * endY;

		// Calculate tangent angle at t=0.5 for proper text rotation
		const tangentX = 2 * oneMinusT * (controlX - startX) + 2 * t * (endX - controlX);
		const tangentY = 2 * oneMinusT * (controlY - startY) + 2 * t * (endY - controlY);
		textAngle = Math.atan2(tangentY, tangentX);

		// Calculate perpendicular offset to move text above the curve
		const perpAngle = textAngle - Math.PI / 2; // 90 degrees counterclockwise from tangent
		const offsetDistance = (currentFontSize * magnifyFont - 2) * 0.1; // Much smaller offset

		textX = curveX + Math.cos(perpAngle) * offsetDistance;
		textY = curveY + Math.sin(perpAngle) * offsetDistance;
	}

	// Step 3) Draw the text above the curve/line
	printCtx.save();
	printCtx.translate(textX, textY);
	printCtx.rotate(textAngle);

	printCtx.fillStyle = color;
	printCtx.font = parseInt(currentFontSize * magnifyFont - 2) + "px Arial";

	// Center the text horizontally and position baseline properly
	const textWidth = printCtx.measureText(text).width;
	printCtx.fillText(text, -textWidth / 2, 0); // y=0 puts baseline at the translated position

	printCtx.restore();
}
// Fix printDelauanySlopeMap function
function printDelauanySlopeMap(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	printCtx.strokeStyle = "black";
	printCtx.fillStyle = fillColor;
	printCtx.lineWidth = 1;
	console.log("drawDelauanySlopeMap: " + triangles.length);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		let maxSlopeAngle = getDipAngle(triangle);

		// FIX: Use window.worldToCanvas instead of manual coordinate transformation
		const [aAX, aAY] = window.worldToCanvas(tAX, tAY);
		const [aBX, aBY] = window.worldToCanvas(tBX, tBY);
		const [aCX, aCY] = window.worldToCanvas(tCX, tCY);

		// ... rest of color calculation code stays the same ...

		// Define the color ranges and corresponding RGB values
		let triangleFillColor;
		if (maxSlopeAngle >= 0 && maxSlopeAngle < 5) {
			triangleFillColor = "rgb(51, 139, 255)";
		} else if (maxSlopeAngle >= 5 && maxSlopeAngle < 7) {
			triangleFillColor = "rgb(0, 102, 204)";
		} else if (maxSlopeAngle >= 7 && maxSlopeAngle < 9) {
			triangleFillColor = "rgb(0, 204, 204)";
		} else if (maxSlopeAngle >= 9 && maxSlopeAngle < 12) {
			triangleFillColor = "rgb(102, 204, 0)";
		} else if (maxSlopeAngle >= 12 && maxSlopeAngle < 15) {
			triangleFillColor = "rgb(204, 204, 0)";
		} else if (maxSlopeAngle >= 15 && maxSlopeAngle < 17) {
			triangleFillColor = "rgb(255, 128, 0)";
		} else if (maxSlopeAngle >= 17 && maxSlopeAngle < 20) {
			triangleFillColor = "rgb(255, 0, 0)";
		} else {
			triangleFillColor = "rgb(153, 0, 76)";
		}

		printCtx.fillStyle = triangleFillColor;
		printCtx.lineWidth = 1;

		printCtx.beginPath();
		printCtx.moveTo(aAX, aAY);
		printCtx.lineTo(aBX, aBY);
		printCtx.lineTo(aCX, aCY);
		printCtx.closePath();
		printCtx.stroke();
		printCtx.fill();
	}
}

// Fix printDelauanyBurdenRelief function
function printDelauanyBurdenRelief(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	printCtx.strokeStyle = "black";
	printCtx.lineWidth = 1;

	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		// ... burden relief calculation code stays the same ...
		const earliestTime = Math.min(tAZ, tBZ, tCZ);
		const latestTime = Math.max(tAZ, tBZ, tCZ);
		const timeDifference = latestTime - earliestTime;

		let p1, p2;
		if (earliestTime === tAZ) {
			p1 = {
				x: tAX,
				y: tAY
			};
		} else if (earliestTime === tBZ) {
			p1 = {
				x: tBX,
				y: tBY
			};
		} else {
			p1 = {
				x: tCX,
				y: tCY
			};
		}

		if (latestTime === tAZ) {
			p2 = {
				x: tAX,
				y: tAY
			};
		} else if (latestTime === tBZ) {
			p2 = {
				x: tBX,
				y: tBY
			};
		} else {
			p2 = {
				x: tCX,
				y: tCY
			};
		}

		const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
		const burdenRelief = timeDifference / distance;

		// Color mapping based on timing relief
		let triangleFillColor;
		if (burdenRelief < 4) {
			triangleFillColor = "rgb(75, 20, 20)";
		} else if (burdenRelief < 7) {
			triangleFillColor = "rgb(255, 40, 40)";
		} else if (burdenRelief < 10) {
			triangleFillColor = "rgb(255, 120, 50)";
		} else if (burdenRelief < 13) {
			triangleFillColor = "rgb(255, 255, 50)";
		} else if (burdenRelief < 16) {
			triangleFillColor = "rgb(50, 255, 70)";
		} else if (burdenRelief < 19) {
			triangleFillColor = "rgb(50, 255, 200)";
		} else if (burdenRelief < 22) {
			triangleFillColor = "rgb(50, 230, 255)";
		} else if (burdenRelief < 25) {
			triangleFillColor = "rgb(50, 180, 255)";
		} else if (burdenRelief < 30) {
			triangleFillColor = "rgb(50, 100, 255)";
		} else if (burdenRelief < 40) {
			triangleFillColor = "rgb(50, 0, 255)";
		} else {
			triangleFillColor = "rgb(75, 0, 150)";
		}

		printCtx.fillStyle = triangleFillColor;

		// FIX: Use window.worldToCanvas instead of manual coordinate transformation
		const [aAX, aAY] = window.worldToCanvas(tAX, tAY);
		const [aBX, aBY] = window.worldToCanvas(tBX, tBY);
		const [aCX, aCY] = window.worldToCanvas(tCX, tCY);

		printCtx.beginPath();
		printCtx.moveTo(aAX, aAY);
		printCtx.lineTo(aBX, aBY);
		printCtx.lineTo(aCX, aCY);
		printCtx.closePath();
		printCtx.stroke();
		printCtx.fill();
	}
}

function printReliefLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function

	const legend0to4 = "rgb(75, 20, 20)"; // fast
	const legend4to7 = "rgb(255, 40, 40)";
	const legend7to10 = "rgb(255, 120, 50)"; //
	const legend10to13 = "rgb(255, 255, 50)"; //
	const legend13to16 = "rgb(50, 255, 70)"; //
	const legend16to19 = "rgb(50, 255, 200)"; //
	const legend19to22 = "rgb(50, 230, 255)"; //
	const legend22to25 = "rgb(50, 180, 255)"; //
	const legend25to30 = "rgb(50, 100, 255)"; //
	const legend30to40 = "rgb(50, 0, 255)"; //
	const legend40above = "rgb(75, 0, 150)"; // slow

	//draw the legend
	printCtx.beginPath();
	printCtx.fill();

	printCtx.font = "14px Arial";
	printCtx.fontWeight = "bold";
	printCtx.fillStyle = "black";
	printCtx.fillText("Legend Relief", 10, printCanvas.height / 2 - 70);
	printCtx.fillText("0ms/m - 4ms/m", 10, printCanvas.height / 2 - 40);
	printCtx.fillText("4ms/m - 7ms/m", 10, printCanvas.height / 2 - 10);
	printCtx.fillText("7ms/m - 10ms/m", 10, printCanvas.height / 2 + 20);
	printCtx.fillText("10ms/m - 13ms/m", 10, printCanvas.height / 2 + 50);
	printCtx.fillText("13ms/m - 16ms/m", 10, printCanvas.height / 2 + 80);
	printCtx.fillText("16ms/m - 19ms/m", 10, printCanvas.height / 2 + 110);
	printCtx.fillText("19ms/m - 22ms/m", 10, printCanvas.height / 2 + 140);
	printCtx.fillText("22ms/m - 25ms/m", 10, printCanvas.height / 2 + 170);
	printCtx.fillText("25ms/m - 30ms/m", 10, printCanvas.height / 2 + 200);
	printCtx.fillText("30ms/m - 40ms/m", 10, printCanvas.height / 2 + 230);
	printCtx.fillText("40ms/m above", 10, printCanvas.height / 2 + 260);
	printCtx.fillStyle = legend0to4;
	printCtx.fillRect(130, printCanvas.height / 2 - 55, 20, 20);
	printCtx.fillStyle = legend4to7;
	printCtx.fillRect(130, printCanvas.height / 2 - 25, 20, 20);
	printCtx.fillStyle = legend7to10;
	printCtx.fillRect(130, printCanvas.height / 2 + 5, 20, 20);
	printCtx.fillStyle = legend10to13;
	printCtx.fillRect(130, printCanvas.height / 2 + 35, 20, 20);
	printCtx.fillStyle = legend13to16;
	printCtx.fillRect(130, printCanvas.height / 2 + 65, 20, 20);
	printCtx.fillStyle = legend16to19;
	printCtx.fillRect(130, printCanvas.height / 2 + 95, 20, 20);
	printCtx.fillStyle = legend19to22;
	printCtx.fillRect(130, printCanvas.height / 2 + 125, 20, 20);
	printCtx.fillStyle = legend22to25;
	printCtx.fillRect(130, printCanvas.height / 2 + 155, 20, 20);
	printCtx.fillStyle = legend25to30;
	printCtx.fillRect(130, printCanvas.height / 2 + 185, 20, 20);
	printCtx.fillStyle = legend30to40;
	printCtx.fillRect(130, printCanvas.height / 2 + 215, 20, 20);
	printCtx.fillStyle = legend40above;
	printCtx.fillRect(130, printCanvas.height / 2 + 245, 20, 20);
	printCtx.stroke();
}

function printTriangleAngleText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let maxSlopeAngle = getDipAngle(triangle);

	// FIX: Use worldToCanvas and printText to draw on the correct (print) canvas
	const [x, y] = worldToCanvas(triangleCentroid.x, triangleCentroid.y);
	printText(x, y, parseFloat(maxSlopeAngle).toFixed(1), "black");
}

function printTriangleBurdenReliefText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let burdenRelief = getBurdenRelief(triangle);

	// FIX: Use worldToCanvas and printText to draw on the correct (print) canvas
	const [x, y] = worldToCanvas(triangleCentroid.x, triangleCentroid.y);
	printText(x, y, parseFloat(burdenRelief).toFixed(1), "black");
}

function printLegend(strokecolor) {
	const legend0to5 = "rgb(51, 139, 255)";
	const legend5to7 = "rgb(0, 102, 204)";
	const legend7to9 = "rgb(0, 204, 204)";
	const legend9to12 = "rgb(102, 204, 0)";
	const legend12to15 = "rgb(204, 204, 0)";
	const legend15to17 = "rgb(255, 128, 0)";
	const legend17to20 = "rgb(255, 0, 0)";
	const legend20above = "rgb(153, 0, 76)";
	//draw the legend
	printCtx.beginPath();
	printCtx.fill();
	printCtx.font = "14px Arial";
	printCtx.fontWeight = "bold";
	printCtx.fillStyle = strokecolor;
	printCtx.fillText("Legend Slope", 10, printCanvas.height / 2 - 70);
	printCtx.fillText("0\u00B0-5\u00B0", 10, printCanvas.height / 2 - 40);
	printCtx.fillText("5\u00B0-7\u00B0", 10, printCanvas.height / 2 - 10);
	printCtx.fillText("7\u00B0-9\u00B0", 10, printCanvas.height / 2 + 20);
	printCtx.fillText("9\u00B0-12\u00B0", 10, printCanvas.height / 2 + 50);
	printCtx.fillText("12\u00B0-15\u00B0", 10, printCanvas.height / 2 + 80);
	printCtx.fillText("15\u00B0-17\u00B0", 10, printCanvas.height / 2 + 110);
	printCtx.fillText("17\u00B0-20\u00B0", 10, printCanvas.height / 2 + 140);
	printCtx.fillText("20\u00B0+", 10, printCanvas.height / 2 + 170);
	printCtx.fillStyle = legend0to5;
	printCtx.fillRect(60, printCanvas.height / 2 - 55, 20, 20);
	printCtx.fillStyle = legend5to7;
	printCtx.fillRect(60, printCanvas.height / 2 - 25, 20, 20);
	printCtx.fillStyle = legend7to9;
	printCtx.fillRect(60, printCanvas.height / 2 + 5, 20, 20);
	printCtx.fillStyle = legend9to12;
	printCtx.fillRect(60, printCanvas.height / 2 + 35, 20, 20);
	printCtx.fillStyle = legend12to15;
	printCtx.fillRect(60, printCanvas.height / 2 + 65, 20, 20);
	printCtx.fillStyle = legend15to17;
	printCtx.fillRect(60, printCanvas.height / 2 + 95, 20, 20);
	printCtx.fillStyle = legend17to20;
	printCtx.fillRect(60, printCanvas.height / 2 + 125, 20, 20);
	printCtx.fillStyle = legend20above;
	printCtx.fillRect(60, printCanvas.height / 2 + 155, 20, 20);
	printCtx.stroke();
}
//ENGINE
// Replace your existing printData function with this one
function printData(allBlastHoles, selectedHole) {
	// This resizing logic can cause issues, we handle it in the print setup.
	// if (printCanvas) {
	// 	if (printCanvas.width !== printCanvas.clientWidth || printCanvas.height !== printCanvas.clientHeight) {
	// 		printCanvas.width = printCanvas.clientWidth;
	// 		printCanvas.height = printCanvas.clientHeight;
	// 	}
	// }

	if (printCtx) {
		// FIX: Do NOT clear the canvas here. The print setup already prepared it with a
		// white background. This function was likely clearing the main screen canvas by mistake.
		// clearCanvas();

		printCtx.imageSmoothingEnabled = false;
		const displayOptions = getDisplayOptions();
		let holeMap = new Map();
		if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			holeMap = buildHoleMap(allBlastHoles);
		}

		//drawPrintBoundary(printCtx);
		// Draw background image FIRST (bottom layer)
		printBackgroundImage();
		// Draw surface triangles SECOND
		printSurface();

		// In printData function, replace the printing logic with:
		for (const [name, entity] of allKADDrawingsMap.entries()) {
			if (developerModeEnabled && entity.entityType === "point") {
				// Draw allBlastHoles - FIX: Remove extra parameters
				entity.data.forEach((point) => {
					const screenX = (point.pointXLocation - centroidX) * currentScale + printCanvas.width / 2;
					const screenY = -(point.pointYLocation - centroidY) * currentScale + printCanvas.height / 2;
					let lineWidthForDisplay = point.lineWidth;
					if (point.lineWidth < 2) {
						lineWidthForDisplay = 4;
					}
					printKADPoints(screenX, screenY, point.pointZLocation, lineWidthForDisplay, point.color); // ← Remove pointDiameter and 1
				});
			} else if (entity.entityType === "point") {
				// Apply pixel distance simplification to points for performance
				const originalPoints = entity.data;
				const simplifiedPoints = simplifyByPxDist(originalPoints, 3); // Slightly smaller threshold for points

				for (const pointData of simplifiedPoints) {
					const [x, y] = worldToCanvas(pointData.pointXLocation, pointData.pointYLocation);
					let lineWidthForDisplay = pointData.lineWidth;
					if (pointData.lineWidth < 2) {
						lineWidthForDisplay = 4;
					}
					printKADPoints(x, y, pointData.pointZLocation, lineWidthForDisplay, pointData.color);
				}
			} else if (entity.entityType === "circle") {
				// Draw circles
				entity.data.forEach((circle) => {
					const screenX = (circle.pointXLocation - centroidX) * currentScale + printCanvas.width / 2;
					const screenY = -(circle.pointYLocation - centroidY) * currentScale + printCanvas.height / 2;
					printKADCircles(screenX, screenY, circle.pointZLocation, circle.radius, circle.lineWidth, circle.color);
				});
			} else if (entity.entityType === "text") {
				// Draw text - Fix the property name
				entity.data.forEach((textData) => {
					if (textData && textData.text) {
						// ← Change from textValue to text
						const screenX = (textData.pointXLocation - centroidX) * currentScale + printCanvas.width / 2;
						const screenY = -(textData.pointYLocation - centroidY) * currentScale + printCanvas.height / 2;
						printKADTexts(screenX, screenY, textData.pointZLocation, textData.text, textData.color); // ← Change textValue to text and strokeColor to color
					}
				});
			} else if (developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
				// --- Developer Mode: Full quality, no simplification ---
				const points = entity.data;
				if (points.length < 2) continue;

				// Draw all segments without any simplification
				for (let i = 0; i < points.length - 1; i++) {
					const currentPoint = points[i]; // FIRST point of segment
					const nextPoint = points[i + 1]; // SECOND point of segment

					const [sx, sy] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
					const [ex, ey] = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);

					// Use FIRST point properties
					printKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, currentPoint.lineWidth, currentPoint.color, false);
				}

				// Handle closing segment for polygons
				const isClosed = entity.entityType === "poly";
				if (isClosed && points.length > 2) {
					const firstPoint = points[0];
					const lastPoint = points[points.length - 1];
					const [sx, sy] = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
					const [ex, ey] = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);

					// Use last point properties for closing segment
					printKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, lastPoint.lineWidth, lastPoint.color, false);
				}
			} else if (!developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
				// --- Pixel-distance simplification for performance ---
				const originalPoints = entity.data;
				if (originalPoints.length < 2) continue;

				// Simplify by pixel distance
				let pointThreshold = 2;
				if (currentScale > 1) {
					pointThreshold = 2;
				} else {
					pointThreshold = 1;
				}

				const simplifiedPoints = simplifyByPxDist(originalPoints, pointThreshold);

				// Draw the simplified line/polygon
				for (let i = 0; i < simplifiedPoints.length - 1; i++) {
					const currentPoint = simplifiedPoints[i];
					const nextPoint = simplifiedPoints[i + 1];

					const [sx, sy] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
					const [ex, ey] = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);

					// Use FIRST point properties
					printKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, currentPoint.lineWidth, currentPoint.color, false);
				}

				// Handle closing segment for polygons
				const isClosed = entity.entityType === "poly";
				if (isClosed && simplifiedPoints.length > 2) {
					const firstPoint = simplifiedPoints[0];
					const lastPoint = simplifiedPoints[simplifiedPoints.length - 1];
					const [sx, sy] = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
					const [ex, ey] = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);

					// Use last point properties for closing segment
					printKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, lastPoint.lineWidth, lastPoint.color, false);
				}
			}
		}

		// VORONOI PF & OVERLAYS
		const tri = delaunayTriangles(allBlastHoles, maxEdgeLength);
		const blastBoundaryPolygon = createBlastBoundaryPolygon(tri.resultTriangles);
		const offsetBoundaryPolygon = offsetPolygonClipper(blastBoundaryPolygon, getAverageDistance(allBlastHoles) / 2);

		// Voronoi Powder Factor
		if (displayOptions.voronoiPF) {
			// console.log("DEBUG: VORONOI PF");
			switch (selectedVoronoiMetric) {
				case "powderFactor":
					// console.log("Drawing Powder Factor");
					//get the min and max values for the PF if isVoronoiLegendFixed is false
					let minPF, maxPF, intervalPF, deltaPF;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI PF NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.powderFactor).filter((v) => v != null && !isNaN(v));
						minPF = 0; //values.length > 0 ? Math.min(...values) : 0;
						maxPF = values.length > 0 ? Math.max(...values) : 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF / 4;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI PF FIXED");
						minPF = 0;
						maxPF = 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF > 0 ? Math.ceil(deltaPF / 10) : 0.5;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getPFColor(value, minPF, maxPF), "Legend Powder Factor", minPF, maxPF, intervalPF);
					break;
				case "mass":
					// console.log("Drawing Mass");
					let minMass, maxMass, intervalMass, deltaMass;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI MASS NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.mass).filter((v) => v != null && !isNaN(v));
						minMass = values.length > 0 ? Math.min(...values) : 0;
						maxMass = values.length > 0 ? Math.max(...values) : 500;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass / 4;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI MASS FIXED");
						minMass = 0;
						maxMass = 1000;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass > 0 ? Math.ceil(deltaMass / 10) : 250;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getMassColor(value, minMass, maxMass), "Legend Mass", minMass, maxMass, intervalMass);
					break;
				case "volume": {
					// console.log("Drawing Volume");
					let minVol, maxVol, intervalVol, deltaVol;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.volume).filter((v) => v != null && !isNaN(v));
						minVol = values.length > 0 ? Math.min(...values) : 0;
						maxVol = values.length > 0 ? Math.max(...values) : 100;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = deltaVol / 10;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					} else {
						minVol = 0;
						maxVol = 5000;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = 500;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getVolumeColor(value, minVol, maxVol), "Legend Volume", minVol, maxVol, intervalVol);
					break;
				}
				case "area": {
					// console.log("Drawing Area");
					let minArea, maxArea, intervalArea, deltaArea;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.area).filter((v) => v != null && !isNaN(v));
						minArea = values.length > 0 ? Math.min(...values) : 0;
						maxArea = values.length > 0 ? Math.max(...values) : 100;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = deltaArea / 10;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					} else {
						minArea = 0;
						maxArea = 500;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = 50;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getAreaColor(value, minArea, maxArea), "Legend Area", minArea, maxArea, intervalArea);
					break;
				}
				case "measuredLength": {
					// console.log("Drawing Measured Length");
					let minMLen, maxMLen, intervalMLen, deltaMLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.measuredLength).filter((v) => v != null && !isNaN(v));
						minMLen = values.length > 0 ? Math.min(...values) : 0;
						maxMLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = deltaMLen / 10;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					} else {
						minMLen = 0;
						maxMLen = 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = 5;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minMLen, maxMLen), "Legend Measured Length", minMLen, maxMLen, intervalMLen);
					break;
				}
				case "designedLength": {
					// console.log("Drawing Designed Length");
					let minDLen, maxDLen, intervalDLen, deltaDLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.designedLength).filter((v) => v != null && !isNaN(v));
						minDLen = values.length > 0 ? Math.min(...values) : 0;
						maxDLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = deltaDLen / 10;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					} else {
						minDLen = 0;
						maxDLen = 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = 5;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minDLen, maxDLen), "Legend Designed Length", minDLen, maxDLen, intervalDLen);
					break;
				}
				case "holeFiringTime": {
					// console.log("Drawing Hole Firing Time");
					let minHTime, maxHTime, intervalHTime, deltaHTime;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const holeTimes = clippedCells.map((c) => c.holeFiringTime).filter((t) => t != null && !isNaN(t));
						minHTime = holeTimes.length > 0 ? Math.min(...holeTimes) : 0;
						maxHTime = holeTimes.length > 0 ? Math.max(...holeTimes) : 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime / 10;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					} else {
						minHTime = 0;
						maxHTime = 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime > 0 ? Math.ceil(deltaHTime / 10) : 1000;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					}
					printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getHoleFiringTimeColor(value, minHTime, maxHTime), "Legend Hole Firing Time", minHTime, maxHTime, intervalHTime);
					break;
				}
			}
		}

		// Slope Map
		if (displayOptions.slopeMap) {
			const centroid = {
				x: centroidX,
				y: centroidY
			};
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			printDelauanySlopeMap(resultTriangles, centroid, strokeColor);
			for (const triangle of resultTriangles) {
				printTriangleAngleText(triangle, centroid, "black");
			}
			printLegend("black");
		}

		// Burden Relief
		if (displayOptions.burdenRelief) {
			const centroid = {
				x: centroidX,
				y: centroidY
			};
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			printDelauanyBurdenRelief(reliefTriangles, centroid, strokeColor);
			for (const triangle of reliefTriangles) {
				printTriangleBurdenReliefText(triangle, centroid, "black");
			}
			printReliefLegend("black");
		}

		// First Movement Direction Arrows
		if (displayOptions.firstMovement) {
			connScale = document.getElementById("connSlider").value;
			for (const arrow of directionArrows) {
				const [startX, startY] = worldToCanvas(arrow[0], arrow[1]);
				const [endX, endY] = worldToCanvas(arrow[2], arrow[3]);
				printDirectionArrow(startX, startY, endX, endY, arrow[4], "black", arrow[5]);
			}
		}

		// Contour Lines
		//TODO: use the webworker for contour lines.
		if (displayOptions.contour) {
			printCtx.lineWidth = 3;
			printCtx.strokeStyle = "magenta";
			for (const contourLines of contourLinesArray) {
				for (const line of contourLines) {
					const [startX, startY] = worldToCanvas(line[0].x, line[0].y);
					const [endX, endY] = worldToCanvas(line[1].x, line[1].y);
					printCtx.beginPath();
					printCtx.moveTo(startX, startY);
					printCtx.lineTo(endX, endY);
					printCtx.stroke();
				}
			}
		}

		// Main hole loop
		printCtx.lineWidth = 1;
		printCtx.strokeStyle = "black";
		printCtx.font = parseInt(currentFontSize * magnifyFont) + "px Arial";
		if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			for (const hole of allBlastHoles) {
				const [x, y] = worldToCanvas(hole.startXLocation, hole.startYLocation);
				const [gradeX, gradeY] = worldToCanvas(hole.gradeXLocation, hole.gradeYLocation);
				const [lineEndX, lineEndY] = worldToCanvas(hole.endXLocation, hole.endYLocation);

				toeSizeInMeters = document.getElementById("toeSlider").value;
				connScale = document.getElementById("connSlider").value;

				// Draw collar-to-toe track if angled
				if (hole.holeAngle > 0) {
					printTrack(x, y, lineEndX, lineEndY, gradeX, gradeY, "black", hole.subdrillAmount);
				}

				// FIX: Do not draw UI-specific highlights on the print version
				// handleHoleHighlighting(point, x, y);

				// Draw toe if hole length is not zero
				if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
					const radiusInPixels = toeSizeInMeters * currentScale;
					printHoleToe(lineEndX, lineEndY, transparentFillColor, "black", radiusInPixels);
				}

				// Calculate text offsets
				const textOffset = parseInt((hole.holeDiameter / 1000) * holeScale * currentScale);
				const leftSideToe = parseInt(lineEndX) - textOffset;
				const rightSideToe = parseInt(lineEndX) + textOffset;
				const leftSideCollar = parseInt(x) - textOffset;
				const rightSideCollar = parseInt(x) + textOffset;
				const topSideToe = parseInt(lineEndY - textOffset);
				const middleSideToe = parseInt(lineEndY + textOffset + parseInt((currentFontSize * magnifyFont) / 4));
				const bottomSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize * magnifyFont));
				const topSideCollar = parseInt(y - textOffset);
				const middleSideCollar = parseInt(y + parseInt((currentFontSize * magnifyFont) / 2));
				const bottomSideCollar = parseInt(y + textOffset + parseInt(currentFontSize * magnifyFont));

				// Draw text/labels based on displayOptions
				printHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, {
					leftSideToe,
					rightSideToe,
					leftSideCollar,
					rightSideCollar,
					topSideToe,
					middleSideToe,
					bottomSideToe,
					topSideCollar,
					middleSideCollar,
					bottomSideCollar,
					holeMap,
					displayOptions
				});

				// Draw main hole geometry, with selection highlight logic
				printHoleMainShape(hole, x, y, selectedHole);

				// Font slider/label only needs to be updated once, after loop
			}
		}

		// Holes Displayed Count
		printCtx.fillStyle = "black";
		printCtx.font = "16px Arial";
		if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length < 1) {
			printCtx.fillText("Holes Displayed: 0", 10, printCanvas.height - 85);
		} else {
			printCtx.fillText("Holes Displayed: " + allBlastHoles.length, 10, printCanvas.height - 85);
		}
		printCtx.fillText("Scale [ 1:" + currentScale.toFixed(4) + " ]", 10, printCanvas.height - 70);
		printCtx.fillStyle = "blue";
		printCtx.fillText("Version Build: " + buildVersion, 10, printCanvas.height - 55);
		const now = new Date();
		const dateNow = now.toLocaleDateString("en-AU", { year: "numeric", month: "long", day: "numeric" }) + " " + now.toLocaleTimeString("en-AU", { hour: "2-digit", minute: "2-digit" });
		printCtx.fillStyle = "black";
		printCtx.fillText("Date: " + dateNow, 10, printCanvas.height - 35);

		// These are DOM manipulations and should not be in a print function
		// fontSlider.value = (currentFontSize * magnifyFont);
		// fontLabel.textContent = "Font Size: " + parseFloat((currentFontSize * magnifyFont)).toFixed(1) + "px";
	} else {
		// Handle missing context
		return;
	}
}

function printVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, getColorForMetric, legendLabel, minValue, maxValue, step) {
	const legendX = 10,
		legendY = printCanvas.height / 2 - 70,
		gradientWidth = 20,
		gradientHeight = 160;
	printCtx.fillStyle = "black";
	printCtx.font = "14px Arial";
	printCtx.fontWeight = "bold";
	printCtx.fillText(legendLabel || "Legend " + selectedVoronoiMetric, legendX, legendY - 15);

	// Create gradient for legend
	const gradient = printCtx.createLinearGradient(0, legendY, 0, legendY + gradientHeight);
	const stops = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0];
	stops.forEach(function (stop) {
		const value = minValue + stop * (maxValue - minValue);
		const color = getColorForMetric(value);
		if (typeof color !== "string" || color.includes("NaN")) {
			// fallback or skip this color stop
		} else {
			gradient.addColorStop(stop, color);
		}
	});
	printCtx.fillStyle = gradient;
	printCtx.fillRect(legendX + 50, legendY, gradientWidth, gradientHeight);

	printCtx.fillStyle = "black";
	printCtx.textAlign = "left";
	printCtx.textBaseline = "middle";
	// Draw tick marks and labels
	for (let v = minValue; v <= maxValue; v += step) {
		const y = legendY + ((v - minValue) / (maxValue - minValue)) * gradientHeight;
		printCtx.strokeStyle = "black";
		printCtx.beginPath();
		printCtx.moveTo(legendX + 50 + gradientWidth, y);
		printCtx.lineTo(legendX + 50 + gradientWidth + 8, y);
		printCtx.stroke();
		printCtx.fillText(v.toFixed(1), legendX, y);
	}

	const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
	//modes available: min, max, average, mode

	const clippedCells = clipVoronoiCells(voronoiMetrics);

	for (const cell of clippedCells) {
		const value = cell[selectedVoronoiMetric];
		if (!cell.polygon || value == null) continue;
		printCtx.beginPath();
		for (let j = 0; j < cell.polygon.length; j++) {
			const pt = cell.polygon[j];
			const [x, y] = worldToCanvas(pt.x !== undefined ? pt.x : pt[0], pt.y !== undefined ? pt.y : pt[1]);
			if (j === 0) printCtx.moveTo(x, y);
			else printCtx.lineTo(x, y);
		}
		printCtx.closePath();
		printCtx.fillStyle = getColorForMetric(value);
		printCtx.fill();
		printCtx.strokeStyle = "black";
		printCtx.lineWidth = 1;
		printCtx.stroke();
	}
}

function printHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, printCtxObj) {
	const { leftSideToe, rightSideToe, leftSideCollar, rightSideCollar, topSideToe, middleSideToe, bottomSideToe, topSideCollar, middleSideCollar, bottomSideCollar, holeMap, displayOptions } = printCtxObj;

	if (displayOptions.holeID) {
		printText(rightSideCollar, topSideCollar, hole.holeID, "black");
	}
	if (displayOptions.holeDia) {
		printText(rightSideCollar, middleSideCollar, parseFloat(hole.holeDiameter).toFixed(0), "rgb(0, 50, 0)");
	}
	if (displayOptions.holeLen) {
		printText(rightSideCollar, bottomSideCollar, parseFloat(hole.holeLengthCalculated).toFixed(1), "rgb(0, 0, 67)");
	}
	if (displayOptions.holeAng) {
		printRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.holeAngle).toFixed(0) + "°", "rgb(67, 30, 0)");
	}
	if (displayOptions.holeDip) {
		printRightAlignedText(leftSideToe, topSideToe, 90 - parseFloat(hole.holeAngle).toFixed(0) + "°", "rgb(67, 30, 0)");
	}
	if (displayOptions.holeBea) {
		printRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.holeBearing).toFixed(1) + "°", "red");
	}
	if (displayOptions.holeSubdrill) {
		printRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.subdrillAmount).toFixed(1), "blue");
	}
	if (displayOptions.initiationTime) {
		printRightAlignedText(leftSideCollar, middleSideCollar, hole.holeTime, "red");
	}
	if (displayOptions.connector && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			const curve = hole.connectorCurve;
			try {
				printArrow(startX, startY, x, y, connColor, connScale, curve);
			} catch (error) {
				console.error("Error printing arrow:", error);
			}
		}
	}
	if (displayOptions.delayValue && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			const holeDelay = hole.timingDelayMilliseconds;
			const curve = hole.connectorCurve;
			printArrowDelayText(startX, startY, x, y, connColor, holeDelay, curve);
		}
	}
	if (displayOptions.xValue) {
		printRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.startXLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.yValue) {
		printRightAlignedText(leftSideCollar, middleSideCollar, parseFloat(hole.startYLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.zValue) {
		printRightAlignedText(leftSideCollar, bottomSideCollar, parseFloat(hole.startZLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.holeType) {
		printText(rightSideCollar, middleSideCollar, hole.holeType, "rgb(53, 0, 72)");
	}
	if (displayOptions.measuredLength) {
		printRightAlignedText(leftSideCollar, bottomSideToe, hole.measuredLength, "rgb(70, 0, 0)");
	}
	if (displayOptions.measuredMass) {
		printRightAlignedText(leftSideCollar, topSideToe, hole.measuredMass, "rgb(70, 0, 0)");
	}
	if (displayOptions.measuredComment) {
		printText(rightSideCollar, middleSideCollar, hole.measuredComment, "rgb(70, 0, 0)");
	}
}

function printHoleMainShape(hole, x, y, selectedHole) {
	const diameterPx = parseInt((hole.holeDiameter / 1000) * currentScale * holeScale);

	let highlightType = null;
	let highlightColor1 = null,
		highlightColor2 = null,
		highlightText = null;

	// Check if we're in connector mode
	if (isAddingConnector || isAddingMultiConnector) {
		// First selected hole in connector mode (using fromHoleStore)
		if (fromHoleStore && fromHoleStore === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)";
		}
		// Second selected hole in connector mode (using firstSelectedHole/secondSelectedHole)
		else if (firstSelectedHole && firstSelectedHole === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName;
		} else if (secondSelectedHole && secondSelectedHole === hole) {
			highlightType = "second";
			highlightColor1 = "rgba(255, 255, 0, 0.2)";
			highlightColor2 = "rgba(255, 200, 0, .8)";
			highlightText = "2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)";
		}
	}
	// Regular selection highlighting (NOT in connector mode)
	else if (selectedHole != null && selectedHole === hole) {
		highlightType = "selected";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		highlightText = "Editing Selected Hole: " + selectedHole.holeID + " in: " + selectedHole.entityName + " with Single Selection Mode \nEscape key to clear Selection";
	}
	// Multiple selection highlighting
	else if (selectedMultipleHoles != null && selectedMultipleHoles.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		highlightType = "multi";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		if (hole === selectedMultipleHoles[0]) {
			highlightText = "Editing Selected Holes: {" + selectedMultipleHoles.map((h) => h.holeID).join(",") + "} \nEscape key to clear Selection";
		} else {
			highlightText = "";
		}
	}

	// Draw main hole/track shape (dummy, missing, or real)
	printCtx.lineWidth = 1;

	printCtx.strokeStyle = strokeColor;

	if (parseFloat(hole.holeLengthCalculated).toFixed(1) == 0.0) {
		printDummy(x, y, parseInt(0.2 * holeScale * currentScale), "black");
	} else if (hole.holeDiameter == 0) {
		printNoDiameterHole(x, y, 10, "black");
	} else {
		printHole(x, y, diameterPx, "black", "black");
	}
}
//Update printSurface function (around line 23909)
function printSurface() {
	// Check if any surfaces are visible
	let hasSurfaces = false;
	let allMinZ = Infinity;
	let allMaxZ = -Infinity;

	// Check all loaded surfaces for visibility and calculate global Z range
	for (const [surfaceId, surface] of loadedSurfaces.entries()) {
		if (surface.visible && surface.points && surface.points.length > 0) {
			hasSurfaces = true;

			// Find Z range for this surface
			surface.points.forEach((point) => {
				if (point.z < allMinZ) allMinZ = point.z;
				if (point.z > allMaxZ) allMaxZ = point.z;
			});
		}
	}

	if (!hasSurfaces) return;

	// Draw all visible surfaces with their individual gradients
	for (const [surfaceId, surface] of loadedSurfaces.entries()) {
		if (surface.visible && surface.triangles && surface.triangles.length > 0) {
			surface.triangles.forEach((triangle) => {
				printTriangleWithGradient(triangle, allMinZ, allMaxZ, printCtx, surface.transparency || 1.0, surface.gradient || "default");
			});
		}
	}

	// Draw legend after all surfaces
	printSurfaceLegend();
}

function printSurfaceLegend() {
	if (!showSurfaceLegend || loadedSurfaces.size === 0) return;

	// Get first visible surface for legend
	const visibleSurface = Array.from(loadedSurfaces.values()).find((s) => s.visible);
	if (!visibleSurface || !visibleSurface.triangles || visibleSurface.triangles.length === 0) return;

	// Calculate elevation range
	let minZ = Infinity;
	let maxZ = -Infinity;

	visibleSurface.points.forEach((point) => {
		if (point.z < minZ) minZ = point.z;
		if (point.z > maxZ) maxZ = point.z;
	});

	// Legend dimensions and position
	const legendWidth = 20;
	const legendHeight = 200;
	const legendX = printCanvas.width - legendWidth - 60;
	const legendY = 50;
	const steps = 50;

	// Draw color gradient
	for (let i = 0; i < steps; i++) {
		const ratio = i / (steps - 1);
		const y = legendY + legendHeight - (i * legendHeight) / steps;
		const height = legendHeight / steps + 1;

		printCtx.fillStyle = elevationToColor(minZ + ratio * (maxZ - minZ), minZ, maxZ);
		printCtx.fillRect(legendX, y, legendWidth, height);
	}

	// Draw elevation labels
	printCtx.fillStyle = strokeColor;
	printCtx.font = "12px Arial";
	printCtx.fontWeight = "bold";
	printCtx.textAlign = "left";

	const labelCount = 5;
	for (let i = 0; i < labelCount; i++) {
		const ratio = i / (labelCount - 1);
		const elevation = minZ + ratio * (maxZ - minZ);
		const y = legendY + legendHeight - ratio * legendHeight;

		// Draw tick mark
		printCtx.beginPath();
		printCtx.moveTo(legendX + legendWidth, y);
		printCtx.lineTo(legendX + legendWidth + 5, y);
		printCtx.stroke();

		// Draw elevation text
		printCtx.fillText(elevation.toFixed(1) + "m", legendX + legendWidth + 8, y + 4);
	}

	// Draw title
	printCtx.font = "14px Arial";
	printCtx.textAlign = "center";
	printCtx.fillText("Elevation", legendX + legendWidth / 2, legendY - 20);

	// Draw gradient name
	printCtx.font = "10px Arial";
	const gradientNames = {
		default: "Default",
		viridis: "Viridis",
		turbo: "Turbo",
		parula: "Parula",
		cividis: "Cividis",
		terrain: "Terrain"
	};
	printCtx.fillText(gradientNames[currentGradient] || "Default", legendX + legendWidth / 2, legendY + legendHeight + 30);

	// Reset text alignment
	printCtx.textAlign = "left";
}

function printTriangleWithGradient(triangle, globalMinZ, globalMaxZ, targetCtx = printCtx, alpha = 1.0, gradient = "default") {
	const showWireFrame = false;
	const [p1, p2, p3] = triangle.vertices;

	// Convert to printCanvas coordinates
	const [x1, y1] = worldToCanvas(p1.x, p1.y);
	const [x2, y2] = worldToCanvas(p2.x, p2.y);
	const [x3, y3] = worldToCanvas(p3.x, p3.y);

	// Save context state
	targetCtx.save();

	// Set transparency
	targetCtx.globalAlpha = alpha;

	// Check if we have texture data (future enhancement)
	if (surfaceTextureData && surfaceTextureData.hasTextures) {
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();

		const avgZ = (p1.z + p2.z + p3.z) / 3;
		targetCtx.fillStyle = elevationToColor(avgZ, globalMinZ, globalMaxZ, gradient);
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.05)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		targetCtx.restore(); // <-- FIX: restore before return
		return;
	}

	// Check if surface is flat
	if (globalMaxZ - globalMinZ < 0.001) {
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = "rgba(255, 165, 0, 0.7)";
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		targetCtx.restore(); // <-- FIX: restore before return
		return;
	}

	// Create gradient based on elevation for non-flat surfaces
	const canvasGradient = targetCtx.createLinearGradient(x1, y1, x3, y3);

	const color1 = elevationToColor(p1.z, globalMinZ, globalMaxZ, gradient);
	const color2 = elevationToColor(p2.z, globalMinZ, globalMaxZ, gradient);
	const color3 = elevationToColor(p3.z, globalMinZ, globalMaxZ, gradient);

	canvasGradient.addColorStop(0, color1);
	canvasGradient.addColorStop(0.5, color2);
	canvasGradient.addColorStop(1, color3);

	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = canvasGradient;
	targetCtx.fill();

	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
	targetCtx.restore();
}

function printBackgroundImage() {
	if (loadedImages.size === 0) return;

	loadedImages.forEach((image) => {
		if (!image.visible || !image.canvas) return;

		const bbox = image.bbox;
		if (bbox && bbox.length >= 4) {
			// FIX: Use window.worldToCanvas instead of non-existent worldToPrintCanvas
			const [x1, y1] = window.worldToCanvas(bbox[0], bbox[3]);
			const [x2, y2] = window.worldToCanvas(bbox[2], bbox[1]);

			printCtx.save();
			printCtx.globalAlpha = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;

			// Calculate proper dimensions for the image
			const width = Math.abs(x2 - x1);
			const height = Math.abs(y2 - y1);

			printCtx.drawImage(image.canvas, Math.min(x1, x2), Math.min(y1, y2), width, height);
			printCtx.restore();
		}
	});
}

function drawCompleteBlastDataForPrint(printCtx, printArea) {
	if (!allBlastHoles || allBlastHoles.length === 0) return;

	// Calculate data bounds locally
	let minX = Math.min(...allBlastHoles.map((p) => p.startXLocation));
	let maxX = Math.max(...allBlastHoles.map((p) => p.startXLocation));
	let minY = Math.min(...allBlastHoles.map((p) => p.startYLocation));
	let maxY = Math.max(...allBlastHoles.map((p) => p.startYLocation));

	const padding = Math.max(maxX - minX, maxY - minY) * 0.05;
	minX -= padding;
	maxX += padding;
	minY -= padding;
	maxY += padding;

	// Calculate scale locally
	const dataWidth = maxX - minX;
	const dataHeight = maxY - minY;
	const scaleX = printArea.width / dataWidth;
	const scaleY = printArea.height / dataHeight;
	const printScale = Math.min(scaleX, scaleY) * 0.9;

	// Center data
	const scaledWidth = dataWidth * printScale;
	const scaledHeight = dataHeight * printScale;
	const offsetX = printArea.x + (printArea.width - scaledWidth) / 2;
	const offsetY = printArea.y + (printArea.height - scaledHeight) / 2;

	// Local coordinate conversion function
	function worldToPrintCanvas(worldX, worldY) {
		const printCentroidX = minX + dataWidth / 2;
		const printCentroidY = minY + dataHeight / 2;
		const x = (worldX - printCentroidX) * printScale + offsetX + scaledWidth / 2;
		const y = -(worldY - printCentroidY) * printScale + offsetY + scaledHeight / 2;
		return [x, y];
	}

	// Get display options
	const displayOptions = getDisplayOptions();
	const printHoleScale = parseFloat(document.getElementById("holeSize")?.value || 3);
	const printFontSize = Math.max(8, Math.min(24, (12 * printScale) / 50));

	printCtx.save();

	// Draw KAD objects first
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		for (const [name, entity] of allKADDrawingsMap.entries()) {
			if (entity.entityType === "point") {
				entity.data.forEach((point) => {
					const [x, y] = worldToPrintCanvas(point.pointXLocation, point.pointYLocation);
					printCtx.beginPath();
					printCtx.arc(x, y, 2, 0, 2 * Math.PI);
					printCtx.fillStyle = point.color || "black";
					printCtx.fill();
				});
			} else if (entity.entityType === "line" || entity.entityType === "poly") {
				const entityPoints = entity.data;
				if (entityPoints.length < 2) continue;

				printCtx.strokeStyle = entityPoints[0].color || "black";
				printCtx.lineWidth = entityPoints[0].lineWidth || 1;
				printCtx.beginPath();

				for (let i = 0; i < entityPoints.length - 1; i++) {
					const [sx, sy] = worldToPrintCanvas(entityPoints[i].pointXLocation, entityPoints[i].pointYLocation);
					const [ex, ey] = worldToPrintCanvas(entityPoints[i + 1].pointXLocation, entityPoints[i + 1].pointYLocation);

					if (i === 0) printCtx.moveTo(sx, sy);
					printCtx.lineTo(ex, ey);
				}

				// Close polygon if needed
				if (entity.entityType === "poly" && entityPoints.length > 2) {
					printCtx.closePath();
				}

				printCtx.stroke();
			}
		}
	}

	// Draw holes
	printCtx.lineWidth = 1;
	printCtx.strokeStyle = strokeColor;
	printCtx.font = parseInt(printFontSize) + "px Arial";

	for (const hole of allBlastHoles) {
		const [x, y] = worldToPrintCanvas(hole.startXLocation, hole.startYLocation);
		const [gradeX, gradeY] = worldToPrintCanvas(hole.gradeXLocation, hole.gradeYLocation);
		const [lineEndX, lineEndY] = worldToPrintCanvas(hole.endXLocation, hole.endYLocation);

		// Draw collar-to-toe track if angled
		if (hole.holeAngle > 0) {
			printCtx.lineWidth = 1;

			if (hole.subdrillAmount < 0) {
				// Negative subdrill
				printCtx.beginPath();
				printCtx.strokeStyle = strokeColor;
				printCtx.moveTo(x, y);
				printCtx.lineTo(lineEndX, lineEndY);
				printCtx.stroke();

				printCtx.beginPath();
				printCtx.strokeStyle = "rgba(255, 0, 0, 0.2)";
				printCtx.moveTo(lineEndX, lineEndY);
				printCtx.lineTo(gradeX, gradeY);
				printCtx.stroke();

				printCtx.beginPath();
				printCtx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
				printCtx.fillStyle = "rgba(255, 0, 0, 0.2)";
				printCtx.fill();
			} else {
				// Positive subdrill
				printCtx.beginPath();
				printCtx.strokeStyle = strokeColor;
				printCtx.moveTo(x, y);
				printCtx.lineTo(gradeX, gradeY);
				printCtx.stroke();

				printCtx.beginPath();
				printCtx.strokeStyle = "rgba(255, 0, 0, 1.0)";
				printCtx.moveTo(gradeX, gradeY);
				printCtx.lineTo(lineEndX, lineEndY);
				printCtx.stroke();

				printCtx.beginPath();
				printCtx.arc(gradeX, gradeY, 3, 0, 2 * Math.PI);
				printCtx.fillStyle = "rgba(255, 0, 0, 1.0)";
				printCtx.fill();
			}
		}

		// Draw toe if hole length is not zero
		if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
			const radiusInPixels = (document.getElementById("toeSlider")?.value || 3) * printScale;
			printCtx.beginPath();
			printCtx.lineWidth = 1;
			printCtx.arc(lineEndX, lineEndY, radiusInPixels, 0, 2 * Math.PI);
			printCtx.fillStyle = transparentFillColor;
			printCtx.strokeStyle = strokeColor;
			printCtx.stroke();
			printCtx.fill();
		}

		// Calculate text positions
		const textOffset = parseInt((point.holeDiameter / 1000) * printHoleScale * printScale);
		const leftSideCollar = parseInt(x) - textOffset;
		const rightSideCollar = parseInt(x) + textOffset;
		const leftSideToe = parseInt(lineEndX) - textOffset;
		const topSideCollar = parseInt(y - textOffset);
		const middleSideCollar = parseInt(y + parseInt(printFontSize / 2));
		const bottomSideCollar = parseInt(y + textOffset + parseInt(printFontSize));
		const topSideToe = parseInt(lineEndY - textOffset);
		const bottomSideToe = parseInt(lineEndY + textOffset + parseInt(printFontSize));

		// Draw text labels based on display options
		printCtx.font = parseInt(printFontSize - 2) + "px Arial";

		if (displayOptions.holeID) {
			printCtx.fillStyle = textFillColor;
			printCtx.fillText(hole.holeID, rightSideCollar, topSideCollar);
		}
		if (displayOptions.holeDia) {
			printCtx.fillStyle = "green";
			printCtx.fillText(parseFloat(hole.holeDiameter).toFixed(0), rightSideCollar, middleSideCollar);
		}
		if (displayOptions.holeLen) {
			printCtx.fillStyle = depthColor;
			printCtx.fillText(parseFloat(hole.holeLengthCalculated).toFixed(1), rightSideCollar, bottomSideCollar);
		}
		if (displayOptions.holeAng) {
			printCtx.fillStyle = angleDipColor;
			const text = parseFloat(hole.holeAngle).toFixed(0);
			const textWidth = printCtx.measureText(text).width;
			printCtx.fillText(text, leftSideCollar - textWidth, topSideCollar);
		}
		if (displayOptions.holeDip) {
			printCtx.fillStyle = angleDipColor;
			const text = (90 - parseFloat(hole.holeAngle)).toFixed(0);
			const textWidth = printCtx.measureText(text).width;
			printCtx.fillText(text, leftSideToe - textWidth, topSideToe);
		}
		if (displayOptions.holeBea) {
			printCtx.fillStyle = "red";
			const text = parseFloat(hole.holeBearing).toFixed(1);
			const textWidth = printCtx.measureText(text).width;
			printCtx.fillText(text, leftSideToe - textWidth, bottomSideToe);
		}
		if (displayOptions.initiationTime) {
			printCtx.fillStyle = "red";
			const text = hole.holeTime;
			const textWidth = printCtx.measureText(text).width;
			printCtx.fillText(text, leftSideCollar - textWidth, middleSideCollar);
		}

		// Draw main hole shape
		const diameterPx = parseInt((hole.holeDiameter / 1000) * printScale * printHoleScale);

		printCtx.lineWidth = 1;
		printCtx.strokeStyle = strokeColor;

		if (parseFloat(hole.holeLengthCalculated).toFixed(1) == 0.0) {
			// Draw dummy (X shape)
			printCtx.lineWidth = 2;
			const radius = parseInt(0.2 * printHoleScale * printScale);
			printCtx.beginPath();
			printCtx.moveTo(x - radius, y - radius);
			printCtx.lineTo(x + radius, y + radius);
			printCtx.moveTo(x - radius, y + radius);
			printCtx.lineTo(x + radius, y - radius);
			printCtx.stroke();
		} else if (hole.holeDiameter == 0) {
			// Draw square for no diameter
			printCtx.lineWidth = 2;
			const halfSide = 5;
			printCtx.beginPath();
			printCtx.rect(x - halfSide, y - halfSide, halfSide * 2, halfSide * 2);
			printCtx.stroke();
		} else {
			// Draw normal hole (black filled circle)
			printCtx.beginPath();
			const minRadius = 1.5;
			const drawRadius = diameterPx > minRadius ? diameterPx : minRadius;
			printCtx.arc(x, y, drawRadius, 0, 2 * Math.PI);
			printCtx.fillStyle = fillColor;
			printCtx.fill();
			printCtx.stroke();
		}
	}

	printCtx.restore();
}

function printHeader(printCtx, x, y, width, height) {
	printCtx.save();

	printCtx.fillStyle = "black";
	printCtx.font = "bold 30px Arial";
	printCtx.textAlign = "left";
	printCtx.textBaseline = "top";

	// Title
	const title = "Kirra 2D";
	printCtx.fillText(title, x, y + 10);

	//QR code from icons/ folder "icons/kirra2d-qr-code.png"
	const qrCode = new Image();
	qrCode.onload = function () {
		printCtx.drawImage(qrCode, x, y + 35, 110, 110);
		// If this is the last thing to draw, you can now continue with PDF generation
	};
	qrCode.src = "icons/kirra2d-qr-code.png";

	printCtx.fillStyle = "black";
	printCtx.font = "18px Arial";
	printCtx.textAlign = "left";
	printCtx.textBaseline = "top";
	const url = "https://blastingapps.com/kirra.html";
	printCtx.fillText(url, x, y + 155);

	// Statistics
	if (allBlastHoles && allBlastHoles.length > 0) {
		printCtx.textAlign = "left";
		printCtx.font = "18px Arial";
		let statsX = x + 10;
		let statsY = y + 175;

		printBlastStats(statsX, statsY);
	}

	printCtx.restore();
}

function printFooter(printCtx, x, y, width, height) {
	printCtx.save();
	printCtx.fillStyle = "black";
	printCtx.font = "12px Arial";
	printCtx.textAlign = "center";
	printCtx.textBaseline = "middle";

	printCtx.fillText("Generated by KIRRA Blast Design Software", x + width / 2, y + height / 2);

	printCtx.restore();
}

function printBlastStats(xPos, yPos) {
	const stats = getBlastStatisticsPerEntity();
	xPos = xPos || 10;
	yPos = yPos || 150;

	Object.keys(stats).forEach((entity) => {
		const s = stats[entity];
		let line = 0;

		// --- Print main blast stats ---
		printCtx.fillText("Blast Entity: " + entity, xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Common Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Common Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
		line++;
		printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
		line++;

		// --- Setup for delays table ---
		const tableX = xPos;
		const tableY = yPos + line * 20 + 20; // Position table below stats
		const rowHeight = 24;
		const col1Width = 80; // Delay label column width
		const col2Width = 50; // Count column width

		// --- Draw table header ---
		printCtx.save();
		printCtx.font = "bold 16px Arial";
		printCtx.fillStyle = "#fff";
		printCtx.fillRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header background
		printCtx.strokeRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header border
		printCtx.fillStyle = "#000";
		printCtx.fillText("Delays:", tableX + 5, tableY + 4); // Header text
		printCtx.restore();

		// --- Draw each delay group as a table row ---
		// --- Draw each delay group as a table row ---
		let row = 1;
		Object.keys(s.delayGroups)
			.sort((a, b) => {
				// Sort numerically, unknown last
				if (a === "Unknown") return 1;
				if (b === "Unknown") return -1;
				return parseFloat(a) - parseFloat(b);
			})
			.forEach((delay) => {
				const group = s.delayGroups[delay];
				const count = group.count;
				const color = group.color || (delay === "Unknown" ? "#000" : "#fff");

				printCtx.save();

				// --- Draw background for delay label cell ---
				printCtx.fillStyle = color;
				printCtx.fillRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);

				// --- Draw cell borders ---
				printCtx.strokeRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);
				printCtx.strokeRect(tableX + col1Width, tableY + row * rowHeight, col2Width, rowHeight);

				// --- Determine text color for delay label (white on dark, black on light) ---
				let labelTextColor = "#000";
				let countTextColor = "#000";
				function hexToRgb(hex) {
					hex = hex.replace("#", "");
					if (hex.length === 3) {
						hex = hex
							.split("")
							.map((x) => x + x)
							.join("");
					}
					const num = parseInt(hex, 16);
					return [num >> 16, (num >> 8) & 0xff, num & 0xff];
				}
				function getLuminance(hex) {
					const [r, g, b] = hexToRgb(hex);
					return 0.299 * r + 0.587 * g + 0.114 * b;
				}
				// For the label cell
				if (color.startsWith("#") && getLuminance(color) < 128) {
					labelTextColor = "#fff";
				}
				if (color.toLowerCase() === "black" || color === "#000" || color === "#222" || color === "#2d2d2d") {
					labelTextColor = "#fff";
				}
				// For the count cell, always check against white background
				countTextColor = "#000"; // Always black for count cell (white cell background)

				// --- Draw delay label (left cell) ---
				printCtx.fillStyle = labelTextColor;
				printCtx.font = "16px Arial";
				printCtx.fillText((delay === "Unknown" ? "Unknown" : delay + "ms") + ":", tableX + 5, tableY + row * rowHeight + 4);

				// --- Draw count (right cell) ---
				printCtx.fillStyle = countTextColor;
				printCtx.fillText(count, tableX + col1Width + 10, tableY + row * rowHeight + 4);

				printCtx.restore();
				row++;
			});
	});
}

function printBlastStatsSimple(xPos, yPos) {
	const stats = getBlastStatisticsPerEntity();
	xPos = xPos || 10;
	yPos = yPos || 150;
	Object.keys(stats).forEach((entity) => {
		const s = stats[entity];
		printCtx.fillText("Entity: " + entity, xPos, yPos);
		printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + 20);
		printCtx.fillText("Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + 40);
		printCtx.fillText("Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + 60);
		printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + 80);
		printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + 100);
		printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + 120);
		printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + 140);
		printCtx.fillText("Delays: " + JSON.stringify(s.delayGroups), xPos, yPos + 160);
		printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + 180);
		printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + 200);
		yPos += 240; // Space between entities
	});
}
// #endregion PRINT
//----------------- REPLICATION OF THE UX Canvas but for High Resolution Printing ------------------///
///------------------ STATISTICS CALCULATIONS HERE ------------------///

//#region STATS

// Helper: Get mode with tolerance
function getModeWithTolerance(values, tolerance) {
	const bins = {};
	values.forEach((val) => {
		const bin = Math.round(val / tolerance) * tolerance;
		bins[bin] = (bins[bin] || 0) + 1;
	});
	let mode = null,
		maxCount = 0;
	for (let bin in bins) {
		if (bins[bin] > maxCount) {
			maxCount = bins[bin];
			mode = parseFloat(bin);
		}
	}
	return mode;
}

// Helper: Group holes by entityName
function groupHolesByEntity(holes) {
	const groups = {};
	holes.forEach((hole) => {
		const key = hole.entityName || "Unknown";
		if (!groups[key]) groups[key] = [];
		groups[key].push(hole);
	});
	return groups;
}

// Helper: Group holes by rowID
function groupHolesByRow(holes) {
	const rows = {};
	holes.forEach((hole) => {
		const key = hole.rowID || "Unknown";
		if (!rows[key]) rows[key] = [];
		rows[key].push(hole);
	});
	return rows;
}

// Helper: Group holes by delay, and get most common color for each delay group
function groupHolesByDelay(holes) {
	const groups = {};
	holes.forEach((hole) => {
		const key = hole.timingDelayMilliseconds !== undefined && hole.timingDelayMilliseconds !== null ? hole.timingDelayMilliseconds : "Unknown";
		if (!groups[key]) {
			groups[key] = { count: 0, colors: {} };
		}
		groups[key].count++;
		const color = hole.colorHexDecimal || "#fff";
		groups[key].colors[color] = (groups[key].colors[color] || 0) + 1;
	});
	// Now, for each group, pick the most common color
	const result = {};
	Object.keys(groups).forEach((delay) => {
		const colorCounts = groups[delay].colors;
		let mostCommonColor = "#fff";
		let maxCount = 0;
		for (let color in colorCounts) {
			if (colorCounts[color] > maxCount) {
				maxCount = colorCounts[color];
				mostCommonColor = color;
			}
		}
		result[delay] = {
			count: groups[delay].count,
			color: mostCommonColor
		};
	});
	return result;
}

// Main: Calculate statistics per entityName
function getBlastStatisticsPerEntity() {
	const tolerance = 0.1; // 100mm
	const holes = allBlastHoles || [];
	const entityGroups = groupHolesByEntity(holes);
	const statsPerEntity = {};

	Object.keys(entityGroups).forEach((entityName) => {
		const entityHoles = entityGroups[entityName];

		// Group by rows for burden/spacing
		const rows = Object.values(groupHolesByRow(entityHoles));
		const rowCentroids = rows.map((rowHoles) => {
			const avgY = rowHoles.reduce((sum, h) => sum + h.startYLocation, 0) / rowHoles.length;
			const avgX = rowHoles.reduce((sum, h) => sum + h.startXLocation, 0) / rowHoles.length;
			return { x: avgX, y: avgY };
		});
		const burdens = [];
		for (let i = 1; i < rowCentroids.length; i++) {
			const dx = rowCentroids[i].x - rowCentroids[i - 1].x;
			const dy = rowCentroids[i].y - rowCentroids[i - 1].y;
			burdens.push(Math.sqrt(dx * dx + dy * dy));
		}
		const spacings = [];
		rows.forEach((rowHoles) => {
			rowHoles.sort((a, b) => a.posID - b.posID);
			for (let i = 1; i < rowHoles.length; i++) {
				const dx = rowHoles[i].startXLocation - rowHoles[i - 1].startXLocation;
				const dy = rowHoles[i].startYLocation - rowHoles[i - 1].startYLocation;
				spacings.push(Math.sqrt(dx * dx + dy * dy));
			}
		});

		// Drill length
		const drillMetres = entityHoles.reduce((sum, h) => sum + (parseFloat(h.holeLengthCalculated) || 0), 0);

		// Explosive mass
		const expMass = entityHoles.reduce((sum, h) => sum + (parseFloat(h.measuredMass) || 0), 0);

		// Voronoi metrics (volume, area, firing time)
		const voronoiMetrics = getVoronoiMetrics(entityHoles, false);
		const volume = voronoiMetrics.reduce((sum, cell) => sum + (cell.volume || 0), 0);
		const surfaceArea = voronoiMetrics.reduce((sum, cell) => sum + (cell.area || 0), 0);

		// Delay grouping
		const delayGroups = groupHolesByDelay(entityHoles);

		// Firing times
		const firingTimes = voronoiMetrics.map((cell) => cell.holeFiringTime).filter((t) => t !== undefined && t !== null && !isNaN(t));
		const minFiringTime = firingTimes.length ? Math.min(...firingTimes) : null;
		const maxFiringTime = firingTimes.length ? Math.max(...firingTimes) : null;

		statsPerEntity[entityName] = {
			holeCount: entityHoles.length,
			burden: getModeWithTolerance(burdens, tolerance) || 0,
			spacing: getModeWithTolerance(spacings, tolerance) || 0,
			drillMetres: drillMetres,
			expMass: expMass,
			volume: volume,
			surfaceArea: surfaceArea,
			delayGroups: delayGroups,
			minFiringTime: minFiringTime,
			maxFiringTime: maxFiringTime
		};
	});
	return statsPerEntity;
}

//#endregion STATS

//===========================
// End of the STATS SECTION
//===========================

//----------------- Floating Tree View for File interactions ------------------///

// Tree View System
class TreeView {
	constructor(containerId) {
		this.container = document.getElementById(containerId);
		this.selectedNodes = new Set();
		this.expandedNodes = new Set();
		this.dragData = {
			isDragging: false,
			startX: 0,
			startY: 0
		};
		this.isCollapsed = false;
		this.isSyncing = false; // Flag to prevent infinite loops

		this.init();
	}

	init() {
		this.setupEventListeners();
		//this.makeResizable();
		this.updateTreeData();
	}

	setupEventListeners() {
		// Panel dragging
		const header = document.getElementById("treePanelHeader");
		header.addEventListener("mousedown", this.startDrag.bind(this));

		// Panel controls
		document.getElementById("treeCollapseBtn").addEventListener("click", this.toggleCollapse.bind(this));
		document.getElementById("treeCloseBtn").addEventListener("click", this.hide.bind(this));

		// Tree interactions
		const treeView = document.getElementById("treeView");
		treeView.addEventListener("click", this.handleTreeClick.bind(this));
		treeView.addEventListener("contextmenu", this.handleContextMenu.bind(this));

		// Context menu
		// Hide context menu on startup
		document.getElementById("treeContextMenu").style.display = "none";
		const contextMenu = document.getElementById("treeContextMenu");
		contextMenu.addEventListener("click", this.handleContextAction.bind(this));

		// Hide context menu on outside click
		document.addEventListener("click", this.hideContextMenu.bind(this));

		// Keyboard shortcuts
		document.addEventListener("keydown", this.handleKeyboard.bind(this));

		// Replace the color swatch event delegation around line 25989
		this.container.addEventListener("click", (e) => {
			if (e.target.classList.contains("color-swatch")) {
				e.stopPropagation(); // Prevent tree node selection

				// ADD DEBUGGING
				console.log("🎨 Color swatch clicked!");
				console.log("Element:", e.target);
				console.log("Entity name:", e.target.dataset.entityName);
				console.log("Point ID:", e.target.dataset.pointId);
				console.log("All datasets:", e.target.dataset);

				const entityName = e.target.dataset.entityName;
				const pointID = parseInt(e.target.dataset.pointId);

				// ADD MORE DEBUGGING
				console.log("Parsed entity name:", entityName);
				console.log("Parsed point ID:", pointID);
				console.log("Is NaN?", isNaN(pointID));

				// Call the color picker function
				if (entityName && !isNaN(pointID)) {
					console.log("✅ Calling openColorPickerForElement");
					openColorPickerForElement(e.target, entityName, pointID);
				} else {
					console.log("❌ NOT calling openColorPickerForElement - missing data");
				}
			}
		});
	}

	selectRange(startNodeId, endNodeId) {
		// Get all visible tree items in DOM order
		const allTreeItems = Array.from(this.container.querySelectorAll(".tree-item"));
		const allNodeIds = allTreeItems.map((item) => item.dataset.nodeId);

		// Find the indices of start and end nodes
		const startIndex = allNodeIds.indexOf(startNodeId);
		const endIndex = allNodeIds.indexOf(endNodeId);

		if (startIndex === -1 || endIndex === -1) return;

		// Determine the range (handle both directions)
		const minIndex = Math.min(startIndex, endIndex);
		const maxIndex = Math.max(startIndex, endIndex);

		// Clear current selection
		this.clearSelection();

		// Select all nodes in the range
		for (let i = minIndex; i <= maxIndex; i++) {
			const nodeId = allNodeIds[i];
			const treeItem = allTreeItems[i];

			this.selectedNodes.add(nodeId);
			treeItem.classList.add("multi-selected");
		}
	}

	clearSelection() {
		this.selectedNodes.clear();
		this.container.querySelectorAll(".tree-item").forEach((item) => {
			item.classList.remove("selected", "multi-selected");
		});
	}

	startDrag(e) {
		this.dragData.isDragging = true;
		this.dragData.startX = e.clientX - this.container.offsetLeft;
		this.dragData.startY = e.clientY - this.container.offsetTop;

		document.addEventListener("mousemove", this.drag.bind(this));
		document.addEventListener("mouseup", this.stopDrag.bind(this));
		e.preventDefault();
	}

	drag(e) {
		if (!this.dragData.isDragging) return;

		const x = e.clientX - this.dragData.startX;
		const y = e.clientY - this.dragData.startY;

		this.container.style.left = x + "px";
		this.container.style.top = y + "px";
	}

	stopDrag() {
		this.dragData.isDragging = false;
		document.removeEventListener("mousemove", this.drag);
		document.removeEventListener("mouseup", this.stopDrag);
	}

	toggleCollapse() {
		this.isCollapsed = !this.isCollapsed;
		this.container.classList.toggle("collapsed", this.isCollapsed);

		const btn = document.getElementById("treeCollapseBtn");
		btn.textContent = this.isCollapsed ? "+" : "−";
	}

	hide() {
		this.container.style.display = "none";
	}

	show() {
		this.container.style.display = "flex";
	}

	// New method to highlight nodes from canvas selection
	highlightNodes(nodeIds) {
		this.isSyncing = true;
		this.clearSelection();

		nodeIds.forEach((nodeId) => {
			const element = this.container.querySelector(`[data-node-id="${nodeId}"]`);
			if (element) {
				this.selectedNodes.add(nodeId);
				element.classList.add("selected");
			}
		});

		this.isSyncing = false;
	}

	handleTreeClick(e) {
		const treeItem = e.target.closest(".tree-item");
		if (!treeItem) return;

		const expandBtn = e.target.closest(".tree-expand");
		if (expandBtn && !expandBtn.classList.contains("leaf")) {
			this.toggleNode(treeItem);
			return;
		}

		// Handle selection
		const nodeId = treeItem.dataset.nodeId;

		if (e.shiftKey && this.lastClickedNode) {
			// Shift-click: Select range from last clicked to current
			this.selectRange(this.lastClickedNode, nodeId);
		} else if (e.ctrlKey || e.metaKey) {
			// Ctrl/Cmd-click: Multi-select
			if (this.selectedNodes.has(nodeId)) {
				this.selectedNodes.delete(nodeId);
				treeItem.classList.remove("selected", "multi-selected");
			} else {
				this.selectedNodes.add(nodeId);
				treeItem.classList.add("multi-selected");
			}
			this.lastClickedNode = nodeId;
		} else {
			// Single select
			this.clearSelection();
			this.selectedNodes.add(nodeId);
			treeItem.classList.add("selected");
			this.lastClickedNode = nodeId;
		}

		this.onSelectionChange();
	}

	toggleNode(treeItem) {
		const nodeId = treeItem.dataset.nodeId;
		const children = treeItem.parentNode.querySelector(".tree-children");
		const expandBtn = treeItem.querySelector(".tree-expand");

		if (!children) return;

		if (this.expandedNodes.has(nodeId)) {
			this.expandedNodes.delete(nodeId);
			children.classList.remove("expanded");
			expandBtn.classList.remove("expanded");
		} else {
			this.expandedNodes.add(nodeId);
			children.classList.add("expanded");
			expandBtn.classList.add("expanded");
		}
	}

	clearSelection() {
		this.selectedNodes.clear();
		this.container.querySelectorAll(".tree-item").forEach((item) => {
			item.classList.remove("selected", "multi-selected");
		});
	}

	handleContextMenu(e) {
		const treeItem = e.target.closest(".tree-item");
		if (!treeItem) return;

		e.preventDefault();

		// If right-clicked item is not selected, select it
		const nodeId = treeItem.dataset.nodeId;
		if (!this.selectedNodes.has(nodeId)) {
			this.clearSelection();
			this.selectedNodes.add(nodeId);
			treeItem.classList.add("selected");
		}

		this.showContextMenu(e.clientX, e.clientY);
	}

	showContextMenu(x, y) {
		const menu = document.getElementById("treeContextMenu");

		// Get the selected node to determine what options to show
		const selectedNodeIds = Array.from(this.selectedNodes);
		const isTopLevelParent = selectedNodeIds.some((nodeId) => nodeId === "blast" || nodeId === "drawings" || nodeId === "surfaces" || nodeId === "images");
		// Determine what type of nodes are selected
		const hasHoles = selectedNodeIds.some((nodeId) => nodeId.startsWith("hole⣿"));

		const isSubGroup = selectedNodeIds.some((nodeId) => nodeId.startsWith("drawings⣿") && nodeId.split("⣿").length === 2);

		// Show/hide menu items based on selection
		const renameItem = menu.querySelector('[data-action="rename"]');
		const resetConnectionsItem = menu.querySelector('[data-action="reset-connections"]');
		const propertiesItem = menu.querySelector('[data-action="properties"]');
		const deleteItem = menu.querySelector('[data-action="delete"]');

		// Reset Connections only for hole nodes
		if (resetConnectionsItem) {
			resetConnectionsItem.style.display = hasHoles ? "flex" : "none";
		}

		if (deleteItem) {
			deleteItem.style.display = isTopLevelParent || isSubGroup ? "none" : "flex";
		}

		if (propertiesItem) {
			propertiesItem.style.display = isTopLevelParent || isSubGroup ? "none" : "flex";
		}
		// Only show "Rename" for entity/group nodes (not for elements or folders)
		let showRename = false;
		if (selectedNodeIds.length === 1) {
			const nodeId = selectedNodeIds[0];
			const parts = nodeId.split("⣿");
			// Only allow rename for group/entity nodes (not element nodes or folders)
			if ((parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
				showRename = true;
			}
			// ADD THIS: allow rename for blast entity nodes
			if (parts[0] === "entity" && parts.length === 2) {
				showRename = true;
			}
		}

		if (renameItem) {
			renameItem.style.display = showRename ? "flex" : "none";
		}

		menu.style.left = x + "px";
		menu.style.top = y + "px";
		menu.style.display = "block";
	}

	hideContextMenu() {
		document.getElementById("treeContextMenu").style.display = "none";
	}

	handleContextAction(e) {
		const action = e.target.closest(".tree-context-item")?.dataset.action;
		if (!action) return;

		this.hideContextMenu();

		switch (action) {
			case "rename":
				this.renameEntity();
				break;
			case "delete":
				this.deleteSelected();
				break;
			case "hide":
				this.hideSelected();
				break;
			case "show":
				this.showSelected(); // Make sure the "show" action is handled
				break;
			case "reset-connections":
				this.resetConnections();
				break;
			case "properties":
				this.showProperties();
				break;
		}
		// Hide context menu
		document.getElementById("treeContextMenu").style.display = "none";
	}
	// TODO future Development
	renumberSelected() {
		if (this.selectedNodes.size === 0) return;

		const nodeIds = Array.from(this.selectedNodes);
		const entities = new Set();

		// Collect all affected entities
		nodeIds.forEach((nodeId) => {
			const parts = nodeId.split("⣿");
			if (parts[0] === "hole") {
				const holeId = parts.slice(1).join("⣿");
				const hole = allBlastHoles.find((h) => h.holeID === holeId);
				if (hole) entities.add(hole.entityName);
			} else if (parts[0] === "entity") {
				const entityName = parts.slice(1).join("⣿");
				entities.add(entityName);
			}
		});

		if (entities.size === 0) return;
		//!REDO in the FloatingDialog
		Swal.fire({
			title: "Renumber Holes",
			html: `
    		<div style="text-align: left; margin-bottom: 15px;">
    			<p>Renumber holes in ${entities.size} blast(s)?</p>
    			<label for="renumberStart" style="display: block; margin-bottom: 5px; font-weight: bold;">Starting Number:</label>
    			<input type="text" id="renumberStart" value="${deleteRenumberStart}"
    				   style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;"
    				   placeholder="e.g. 1, A1, B5, 100">
    			<small style="color: #666; display: block; margin-top: 5px;">
    				Enter a number (e.g. 1, 100) for numerical naming<br>
    				or letter+number (e.g. A1, B5) for row-based naming
    			</small>
    		</div>
    	`,
			icon: "question",
			showCancelButton: true,
			confirmButtonText: "Renumber",
			cancelButtonText: "Cancel",
			focusConfirm: false,
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel"
			},
			preConfirm: () => {
				const startValue = document.getElementById("renumberStart").value;
				if (!startValue || startValue.trim() === "") {
					Swal.showValidationMessage("Please enter a starting number");
					return false;
				}
				return startValue.trim();
			}
		}).then((result) => {
			if (result.isConfirmed) {
				const newStartValue = result.value;

				// Update the global deleteRenumberStart value
				deleteRenumberStart = newStartValue;

				// Also update the original input field if it exists
				const renumberStartInput = document.querySelector('#renumberStartListener, input[name="renumberStart"]');
				if (renumberStartInput) {
					renumberStartInput.value = newStartValue;
				}

				entities.forEach((entityName) => {
					renumberHolesFunction(newStartValue, entityName);
				});

				this.updateTreeData();
				drawData(allBlastHoles, selectedHole);

				Swal.fire({
					title: "Complete",
					text: "Renumbered holes in " + entities.size + " blast(s) starting from " + newStartValue,
					icon: "success",
					timer: 3000,
					showConfirmButton: false
				});
			}
		});
	}

	resetConnections() {
		if (this.selectedNodes.size === 0) return;

		const nodeIds = Array.from(this.selectedNodes);
		const holeNodeIds = nodeIds.filter((nodeId) => nodeId.startsWith("hole⣿"));

		if (holeNodeIds.length === 0) return;

		// Find the holes to reset
		const holesToReset = [];
		holeNodeIds.forEach((nodeId) => {
			const holeId = nodeId.substring(5); // Remove "hole⣿" prefix
			const hole = allBlastHoles.find((h) => h.holeID === holeId);
			if (hole) {
				holesToReset.push(hole);
			}
		});

		if (holesToReset.length === 0) return;

		// Show confirmation dialog
		Swal.fire({
			title: "Reset Connections",
			text: "This will reset the selected holes to connect to themselves. Continue?",
			icon: "question",
			showCancelButton: true,
			confirmButtonText: "Reset",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				popup: "custom-popup-container",
				title: "swal2-title",
				content: "swal2-content",
				confirmButton: "confirm",
				cancelButton: "cancel"
			}
		}).then((result) => {
			if (result.isConfirmed) {
				// Reset connections for each hole
				holesToReset.forEach((hole) => {
					hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
				});

				// Recalculate timing and redraw
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, 0, 0);
				if (result) {
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}

				drawData(allBlastHoles, selectedHole);

				// Show success message
				Swal.fire({
					title: "Connections Reset",
					text: "Successfully reset " + holesToReset.length + " hole connections.",
					icon: "success",
					timer: 2000,
					showConfirmButton: false,
					customClass: {
						container: "custom-popup-container",
						popup: "custom-popup-container",
						title: "swal2-title",
						content: "swal2-content"
					}
				});
			}
		});
	}

	deleteSelected() {
		if (this.selectedNodes.size === 0) return;

		const nodeIds = Array.from(this.selectedNodes);

		// Determine what types we're deleting
		const hasHoles = nodeIds.some((nodeId) => nodeId.split("⣿")[0] === "hole");
		const hasEntities = nodeIds.some((nodeId) => nodeId.split("⣿")[0] === "entity");
		const hasDrawingElements = nodeIds.some((nodeId) => nodeId.includes("⣿element"));

		if (hasDrawingElements) {
			// Deleting individual drawing elements (allBlastHoles, lines, circles, text)
			Swal.fire({
				title: "Delete Elements",
				html: nodeIds.length === 1 ? "Delete this element?" : `Delete ${nodeIds.length} elements?`,
				icon: "warning",
				showCancelButton: true,
				confirmButtonText: "Delete",
				cancelButtonText: "Cancel",
				confirmButtonColor: "#d33",
				customClass: {
					container: "custom-popup-container",
					title: "swal2-title",
					confirmButton: "confirm",
					cancelButton: "cancel"
				}
			}).then((result) => {
				if (result.isConfirmed) {
					const entitiesToRenumber = new Set(); // Track entities that need renumbering

					nodeIds.forEach((nodeId) => {
						const parts = nodeId.split("⣿");
						// Robust parsing for element nodes
						if (parts.length >= 4 && parts[2] === "element") {
							const entityType = parts[0];
							const entityName = parts[1];
							const elementId = parts[3];

							const entity = allKADDrawingsMap.get(entityName);
							if (entity && entity.data) {
								// Find and remove the specific element
								const elementIndex = entity.data.findIndex((el) => el.pointID == elementId);
								if (elementIndex !== -1) {
									entity.data.splice(elementIndex, 1);

									// ✅ ADD: Track this entity for renumbering
									entitiesToRenumber.add(entityName);

									// If no elements left, delete the entire entity
									if (entity.data.length === 0) {
										allKADDrawingsMap.delete(entityName);
										entitiesToRenumber.delete(entityName); // No need to renumber if deleted
									}
								}
							}
						}
					});

					// ✅ ADD: Renumber all affected entities
					entitiesToRenumber.forEach((entityName) => {
						const entity = allKADDrawingsMap.get(entityName);
						if (entity) {
							renumberEntityPoints(entity);
						}
					});

					if (typeof debouncedSaveKAD === "function") {
						debouncedSaveKAD();
					}

					this.updateTreeData();
					drawData(allBlastHoles, selectedHole);
				}
			});
		} else if (hasEntities) {
			// Deleting blast entities (which deletes all holes in that blast)
			Swal.fire({
				title: "Delete Blast",
				html: nodeIds.length === 1 ? "Delete this entire blast and all its holes?" : `Delete ${nodeIds.length} blasts and all their holes?`,
				icon: "warning",
				showCancelButton: true,
				confirmButtonText: "Delete",
				cancelButtonText: "Cancel",
				confirmButtonColor: "#d33",
				customClass: {
					container: "custom-popup-container",
					title: "swal2-title",
					confirmButton: "confirm",
					cancelButton: "cancel"
				}
			}).then((result) => {
				if (result.isConfirmed) {
					nodeIds.forEach((nodeId) => {
						const type = nodeId.split("⣿")[0];
						const itemId = nodeId.split("⣿").slice(1).join("⣿");

						if (type === "entity") {
							// Delete all holes with this entity name
							const entityName = itemId;
							allBlastHoles = allBlastHoles.filter((hole) => hole.entityName !== entityName);
							console.log(`Deleted all holes in blast: ${entityName}`);
						} else if (type === "surface") {
							deleteSurfaceFromDB(itemId).then(() => {
								loadedSurfaces.delete(surfaceId);
							});
						} else if (type === "image") {
							deleteImageFromDB(itemId).then(() => {
								loadedImages.delete(imageId);
							});
						} else {
							this.deleteNode(nodeId);
						}
					});
					this.updateTreeData();
					drawData(allBlastHoles, selectedHole);
				}
			});
		} else if (hasHoles) {
			// Deleting individual holes with renumber option
			Swal.fire({
				title: "Delete Holes",
				html: `
			<p>${nodeIds.length === 1 ? "Delete this hole?" : "Delete " + nodeIds.length + " holes?"}</p>
			<div id="renumberSection" style="margin-top: 15px; display: none;">
				<label class="labelWhite18" for="deleteRenumberStart">Starting Number:</label>
				<input type="text3" id="deleteRenumberStart" value="${deleteRenumberStart}" placeholder="e.g. 1, A1, B5, 100">
				<div class="labelWhite12">Enter number (1, 100) for numerical or letter+number (A1, B5) for row-based naming</div>
			</div>
		`,
				icon: "warning",
				showCancelButton: true,
				showDenyButton: true,
				confirmButtonText: "Delete",
				denyButtonText: "Renumber",
				cancelButtonText: "Cancel",
				confirmButtonColor: "#d33",
				denyButtonColor: "#ff6b35",
				focusConfirm: false,
				customClass: {
					container: "custom-popup-container",
					title: "swal2-title",
					confirmButton: "confirm",
					denyButton: "deny",
					cancelButton: "cancel"
				},
				didOpen: () => {
					// Show/hide renumber section based on button clicks
					const renumberSection = document.getElementById("renumberSection");
					const denyButton = document.querySelector(".swal2-deny");
					const confirmButton = document.querySelector(".swal2-confirm");

					if (denyButton) {
						denyButton.addEventListener("mouseenter", () => {
							renumberSection.style.display = "block";
						});
						denyButton.addEventListener("click", () => {
							renumberSection.style.display = "block";
						});
					}

					if (confirmButton) {
						confirmButton.addEventListener("mouseenter", () => {
							renumberSection.style.display = "none";
						});
					}
				},
				preConfirm: () => {
					// No validation needed for delete only
					return true;
				},
				preDeny: () => {
					// Validate renumber input
					const startValue = document.getElementById("deleteRenumberStart").value;
					if (!startValue || startValue.trim() === "") {
						Swal.showValidationMessage("Please enter a starting number for renumbering");
						return false;
					}
					return startValue.trim();
				}
			}).then((result) => {
				if (result.isConfirmed || result.isDenied) {
					const shouldRenumber = result.isDenied;
					const newStartValue = result.isDenied ? result.value : null;
					const affectedEntities = new Set();

					// Update global deleteRenumberStart if renumbering
					if (shouldRenumber && newStartValue) {
						deleteRenumberStart = newStartValue;

						// Also update the original input field if it exists
						const renumberStartInput = document.querySelector('#renumberStartListener, input[name="renumberStart"]');
						if (renumberStartInput) {
							renumberStartInput.value = newStartValue;
						}
					}

					nodeIds.forEach((nodeId) => {
						const type = nodeId.split("⣿")[0];
						const itemId = nodeId.split("⣿").slice(1).join("⣿");

						if (type === "hole") {
							const holeIndex = allBlastHoles.findIndex((hole) => hole.holeID === itemId);
							if (holeIndex !== -1) {
								const entityName = allBlastHoles[holeIndex].entityName;
								const holeToDelete = allBlastHoles[holeIndex];
								affectedEntities.add(entityName);

								// Use smart deletion for alphanumeric holes
								if (shouldRenumber) {
									deleteHoleAndRenumber(holeToDelete);
								} else {
									allBlastHoles.splice(holeIndex, 1);
								}
							}
						}
					});

					// Do full renumber for numerical holes or when explicitly requested
					if (shouldRenumber && newStartValue) {
						affectedEntities.forEach((entityName) => {
							// Check if any remaining holes in this entity are numerical
							const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);
							const hasNumericalHoles = entityHoles.some((hole) => /^\d+$/.test(hole.holeID));

							if (hasNumericalHoles) {
								renumberHolesFunction(newStartValue, entityName);
							}
						});
					}

					this.updateTreeData();
					drawData(allBlastHoles, selectedHole);

					// Show success message
					if (shouldRenumber && newStartValue) {
						Swal.fire({
							title: "Complete",
							text: "Deleted holes and renumbered starting from " + newStartValue,
							icon: "success",
							timer: 3000,
							showConfirmButton: false
						});
					}
				}
			});
		} else {
			// Standard confirmation for other items (surfaces, images, drawings, etc.)
			Swal.fire({
				title: "Delete Items",
				html: nodeIds.length === 1 ? "Delete this item?" : "Delete " + nodeIds.length + " items?",
				icon: "warning",
				showCancelButton: true,
				confirmButtonText: "Delete",
				cancelButtonText: "Cancel",
				confirmButtonColor: "#d33",
				customClass: {
					container: "custom-popup-container",
					title: "swal2-title",
					confirmButton: "confirm",
					cancelButton: "cancel"
				}
			}).then((result) => {
				if (result.isConfirmed) {
					nodeIds.forEach((nodeId) => {
						const type = nodeId.split("⣿")[0];
						const itemId = nodeId.split("⣿").slice(1).join("⣿");
						if (type === "surface") {
							deleteSurfaceFromDB(itemId).then(() => {
								loadedSurfaces.delete(itemId);
								drawData(allBlastHoles, selectedHole);
							});
						} else if (type === "image") {
							deleteImageFromDB(itemId).then(() => {
								loadedImages.delete(itemId);
								drawData(allBlastHoles, selectedHole);
							});
						} else if (type === "points" || type === "line" || type === "poly" || type === "circle" || type === "text") {
							// Delete drawing objects from allKADDrawingsMap
							const entityName = itemId;
							if (allKADDrawingsMap && allKADDrawingsMap.has(entityName)) {
								allKADDrawingsMap.delete(entityName);
								console.log(`Deleted drawing object: ${entityName}`);

								if (typeof debouncedSaveKAD === "function") {
									debouncedSaveKAD();
								}

								drawData(allBlastHoles, selectedHole);
							}
						} else {
							this.deleteNode(nodeId);
						}
					});
					this.updateTreeData();
				}
			});
		}
	}

	hideSelected() {
		this.selectedNodes.forEach((nodeId) => {
			const element = this.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				element.style.opacity = "0.5";
				element.classList.add("hidden-node");

				const type = nodeId.split("⣿")[0];
				const itemId = nodeId.split("⣿").slice(1).join("⣿");

				// ✅ ADD: Handle main group nodes
				if (nodeId === "blast") {
					setBlastGroupVisibility(false);
				} else if (nodeId === "drawings") {
					setDrawingsGroupVisibility(false);
				} else if (nodeId === "surfaces") {
					setSurfacesGroupVisibility(false);
				} else if (nodeId === "images") {
					setImagesGroupVisibility(false);
				}
				// ✅ ADD: Handle drawing sub-group nodes
				else if (nodeId === "drawings⣿points") {
					setPointsGroupVisibility(false);
				} else if (nodeId === "drawings⣿lines") {
					setLinesGroupVisibility(false);
				} else if (nodeId === "drawings⣿polygons") {
					setPolygonsGroupVisibility(false);
				} else if (nodeId === "drawings⣿circles") {
					setCirclesGroupVisibility(false);
				} else if (nodeId === "drawings⣿texts") {
					setTextsGroupVisibility(false);
				}
				// Existing individual item handling
				else if (type === "surface") {
					setSurfaceVisibility(itemId, false);
				} else if (type === "image") {
					setImageVisibility(itemId, false);
				} else if (type === "hole") {
					setHoleVisibility(itemId, false);
				} else if (type === "entity") {
					setEntityVisibility(itemId, false);
				} else if (type === "points" || type === "line" || type === "poly" || type === "circle" || type === "text") {
					setKADEntityVisibility(itemId, false);
				} else if (nodeId.includes("⣿element⣿")) {
					const parts = nodeId.split("⣿");
					if (parts.length >= 4 && parts[2] === "element") {
						const entityName = parts[1];
						const elementId = parts[3];
						setKADElementVisibility(entityName, elementId, false);
					}
				}
			}
		});

		this.clearSelection();
		// ✅ ADD: Update all tree visual states to cascade visibility indicators
		updateTreeViewVisibilityStates();
	}

	showSelected() {
		this.selectedNodes.forEach((nodeId) => {
			const element = this.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				element.style.opacity = "1";
				element.classList.remove("hidden-node");

				const type = nodeId.split("⣿")[0];
				const itemId = nodeId.split("⣿").slice(1).join("⣿");

				// ✅ ADD: Handle main group nodes
				if (nodeId === "blast") {
					setBlastGroupVisibility(true);
				} else if (nodeId === "drawings") {
					setDrawingsGroupVisibility(true);
				} else if (nodeId === "surfaces") {
					setSurfacesGroupVisibility(true);
				} else if (nodeId === "images") {
					setImagesGroupVisibility(true);
				}
				// ✅ ADD: Handle drawing sub-group nodes
				else if (nodeId === "drawings⣿points") {
					setPointsGroupVisibility(true);
				} else if (nodeId === "drawings⣿lines") {
					setLinesGroupVisibility(true);
				} else if (nodeId === "drawings⣿polygons") {
					setPolygonsGroupVisibility(true);
				} else if (nodeId === "drawings⣿circles") {
					setCirclesGroupVisibility(true);
				} else if (nodeId === "drawings⣿texts") {
					setTextsGroupVisibility(true);
				}
				// Existing individual item handling
				else if (type === "surface") {
					setSurfaceVisibility(itemId, true);
				} else if (type === "image") {
					setImageVisibility(itemId, true);
				} else if (type === "hole") {
					setHoleVisibility(itemId, true);
				} else if (type === "entity") {
					setEntityVisibility(itemId, true);
				} else if (type === "points" || type === "line" || type === "poly" || type === "circle" || type === "text") {
					setKADEntityVisibility(itemId, true);
				} else if (nodeId.includes("⣿element⣿")) {
					const parts = nodeId.split("⣿");
					if (parts.length >= 4 && parts[2] === "element") {
						const entityName = parts[1];
						const elementId = parts[3];
						setKADElementVisibility(entityName, elementId, true);
					}
				}
			}
		});

		this.clearSelection();
		// ✅ ADD: Update all tree visual states to cascade visibility indicators
		updateTreeViewVisibilityStates();
	}

	showProperties() {
		if (this.selectedNodes.size === 1) {
			const nodeId = Array.from(this.selectedNodes)[0];
			const type = nodeId.split("⣿")[0];

			try {
				if (type === "surface") {
					// Check if the function exists in global scope
					if (typeof showSurfaceContextMenu === "function") {
						const canvas = document.getElementById("canvas") || document.querySelector("canvas");
						if (canvas) {
							const rect = canvas.getBoundingClientRect();
							const centerX = rect.left + rect.width / 2;
							const centerY = rect.top + rect.height / 2;

							// Call the function in the global scope
							window.showSurfaceContextMenu(centerX, centerY);
						} else {
							console.warn("Canvas not found for surface context menu");
							// Fallback position
							window.showSurfaceContextMenu(window.innerWidth / 2, window.innerHeight / 2);
						}
					} else {
						console.error("showSurfaceContextMenu function not found");
					}
				} else if (type === "image") {
					// Check if the function exists in global scope
					if (typeof showImageContextMenu === "function") {
						const canvas = document.getElementById("canvas") || document.querySelector("canvas");
						if (canvas) {
							const rect = canvas.getBoundingClientRect();
							const centerX = rect.left + rect.width / 2;
							const centerY = rect.top + rect.height / 2;

							// Call the function in the global scope
							window.showImageContextMenu(centerX, centerY);
						} else {
							console.warn("Canvas not found for image context menu");
							// Fallback position
							window.showImageContextMenu(window.innerWidth / 2, window.innerHeight / 2);
						}
					} else {
						console.error("showImageContextMenu function not found");
					}
				} else {
					// For other node types
					this.showNodeProperties(nodeId);
				}
			} catch (error) {
				console.error("Error showing properties:", error);
			}
		}
	}

	handleKeyboard(e) {
		if (!this.container.style.display === "none") return;

		switch (e.key) {
			case "Delete":
				this.deleteSelected();
				break;
			case "Escape":
				this.clearSelection();
				break;
		}
	}

	// Data management
	updateTreeData() {
		const treeData = this.buildTreeData();
		const html = this.renderTree(treeData);
		document.getElementById("treeView").innerHTML = html;
	}

	buildTreeData() {
		// Build tree structure from your data
		const tree = [
			{
				id: "blast",
				type: "blast",
				label: "Blast",
				expanded: true,
				children: this.buildBlastData()
			},
			{
				id: "drawings",
				type: "drawing",
				label: "Drawings",
				expanded: true,
				children: this.buildDrawingData()
			},
			{
				id: "surfaces",
				type: "surface",
				label: "Surfaces",
				expanded: true,
				children: this.buildSurfaceData()
			},
			{
				id: "images",
				type: "image",
				label: "Images",
				expanded: true,
				children: this.buildImageData()
			}
		];

		return tree;
	}

	buildBlastData() {
		if (!allBlastHoles || allBlastHoles.length === 0) return [];

		// Group holes by entity name
		const entities = {};
		allBlastHoles.forEach((hole) => {
			const entityName = hole.entityName || "Unknown";
			if (!entities[entityName]) {
				entities[entityName] = [];
			}
			entities[entityName].push(hole);
		});

		return Object.keys(entities).map((entityName) => {
			const holes = entities[entityName];

			// Replace the sorting in buildBlastData
			holes.sort((a, b) => {
				// Convert null/undefined to large numbers so they sort last
				const aRow = a.rowID && a.rowID > 0 ? a.rowID : 999999;
				const bRow = b.rowID && b.rowID > 0 ? b.rowID : 999999;

				if (aRow !== bRow) {
					return aRow - bRow; // Sort by row first
				}

				// Within same row, sort by position
				const aPos = a.posID && a.posID > 0 ? a.posID : 999999;
				const bPos = b.posID && b.posID > 0 ? b.posID : 999999;

				return aPos - bPos;
			});

			const totalLength = holes.reduce((sum, hole) => sum + (hole.holeLengthCalculated || 0), 0);
			const metrics = getVoronoiMetrics(holes);
			// ✅ FIX: Calculate total volume from metrics array
			const volume = metrics && metrics.length > 0 ? metrics.reduce((sum, cell) => sum + (cell.volume || 0), 0) : 0;

			return {
				id: "entity⣿" + entityName,
				type: "entity",
				label: entityName,
				meta: "(" + holes.length + ", " + parseFloat(totalLength).toFixed(1) + "m, " + parseFloat(volume).toFixed(1) + "m³)",
				children: holes.map((hole, index) => ({
					id: "hole⣿" + (hole.holeID || index),
					type: "hole",
					label: hole.holeID || "Hole " + (index + 1),
					meta: "L:" + (hole.holeLengthCalculated || 0).toFixed(2) + "m, S:" + (hole.subdrillAmount || 0).toFixed(2) + "m, R:" + (hole.rowID || "?") + ", P:" + (hole.posID || "?"),
					children: [
						{
							id: (hole.holeID || index) + "⣿startx",
							type: "property",
							label: "Start X",
							meta: (hole.startXLocation || 0).toFixed(3)
						},
						{
							id: (hole.holeID || index) + "⣿starty",
							type: "property",
							label: "Start Y",
							meta: (hole.startYLocation || 0).toFixed(3)
						},
						{
							id: (hole.holeID || index) + "⣿startz",
							type: "property",
							label: "Start Z",
							meta: (hole.startZLocation || 0).toFixed(3)
						},
						{
							id: (hole.holeID || index) + "⣿gradez",
							type: "property",
							label: "Grade Z",
							meta: (hole.gradeZLocation || 0).toFixed(3)
						},
						{
							id: (hole.holeID || index) + "⣿diameter",
							type: "property",
							label: "Diameter",
							meta: (hole.holeDiameter || 115) + "mm"
						},
						{
							id: (hole.holeID || index) + "⣿angle",
							type: "property",
							label: "Angle",
							meta: (hole.holeAngle || 0).toFixed(0) + "°"
						},
						{
							id: (hole.holeID || index) + "⣿bearing",
							type: "property",
							label: "Bearing",
							meta: (hole.holeBearing || 0).toFixed(2) + "°"
						},
						{
							id: (hole.holeID || index) + "⣿length",
							type: "property",
							label: "Length",
							meta: (hole.holeLengthCalculated || 0).toFixed(2) + "m"
						},
						{
							id: (hole.holeID || index) + "⣿subdrill",
							type: "property",
							label: "Subdrill",
							meta: (hole.subdrillAmount || 0).toFixed(2) + "m"
						},
						{
							id: (hole.holeID || index) + "⣿type",
							type: "property",
							label: "Hole Type",
							meta: hole.holeType || "Undefined"
						},
						{
							id: (hole.holeID || index) + "⣿rowid",
							type: "property",
							label: "Row ID",
							meta: hole.rowID || "?"
						},
						{
							id: (hole.holeID || index) + "⣿posid",
							type: "property",
							label: "Position ID",
							meta: hole.posID || "?"
						}
					]
				}))
			};
		});
	}

	// Enhanced buildDrawingData() - with Z values and color swatches
	buildDrawingData() {
		const drawingChildren = [];
		const pointsChildren = [];
		const linesChildren = [];
		const polysChildren = [];
		const circlesChildren = [];
		const textsChildren = [];

		if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
			for (const [entityName, entity] of allKADDrawingsMap.entries()) {
				// Create individual element children for each entity
				//  update the elementChildren mapping:
				const elementChildren = entity.data.map((element, index) => ({
					id: entity.entityType + "⣿" + entityName + "⣿element⣿" + (element.pointID || index + 1),
					type: entity.entityType + "⣿element",
					label: entity.entityType === "text" ? element.text || "Text " + (element.pointID || index + 1) : entity.entityType === "circle" ? "Circle " + (element.pointID || index + 1) : "Point " + (element.pointID || index + 1),
					// FIX: Add safety checks before calling toFixed()
					meta: entity.entityType === "circle" ? "R:" + (Number(element.radius) || 0).toFixed(1) : "(" + (Number(element.pointXLocation) || 0).toFixed(1) + "," + (Number(element.pointYLocation) || 0).toFixed(1) + "," + (Number(element.pointZLocation) || 0).toFixed(1) + ")",
					// FIX: Add entityName to the elementData object
					elementData: {
						...element,
						entityName: entityName // ✅ Add the entityName here!
					}
				}));

				// Group by entity type with children
				switch (entity.entityType) {
					case "point":
						pointsChildren.push({
							id: "points⣿" + entityName,
							type: "points-group",
							label: entityName,
							meta: "(" + entity.data?.length || 0 + " points)",
							children: elementChildren
						});
						break;
					case "line":
						linesChildren.push({
							id: "line⣿" + entityName,
							type: "line-group",
							label: entityName,
							meta: "(" + (entity.data?.length || 0) + " points)",
							children: elementChildren
						});
						break;
					case "poly":
						polysChildren.push({
							id: "poly⣿" + entityName,
							type: "polygon-group",
							label: entityName,
							meta: "(" + (entity.data?.length || 0) + " points)",
							children: elementChildren
						});
						break;
					case "circle":
						circlesChildren.push({
							id: "circle⣿" + entityName,
							type: "circle-group",
							label: entityName,
							meta: "(" + (entity.data?.length || 0) + " points)",
							children: elementChildren
						});
						break;
					case "text":
						textsChildren.push({
							id: "text⣿" + entityName,
							type: "text-group",
							label: entityName,
							meta: "(" + (entity.data?.length || 0) + " points)",
							children: elementChildren
						});
						break;
				}
			}
		}

		// Add categories with children to the drawing tree (same as before)
		if (pointsChildren.length > 0) {
			drawingChildren.push({
				id: "drawings⣿points",
				type: "points-folder",
				label: "Points",
				children: pointsChildren
			});
		}

		if (linesChildren.length > 0) {
			drawingChildren.push({
				id: "drawings⣿lines",
				type: "lines-folder",
				label: "Lines",
				children: linesChildren
			});
		}

		if (polysChildren.length > 0) {
			drawingChildren.push({
				id: "drawings⣿polygons",
				type: "polygons-folder",
				label: "Polygons",
				children: polysChildren
			});
		}

		if (circlesChildren.length > 0) {
			drawingChildren.push({
				id: "drawings⣿circles",
				type: "circle-folder",
				label: "Circles",
				children: circlesChildren
			});
		}

		if (textsChildren.length > 0) {
			drawingChildren.push({
				id: "drawings⣿texts",
				type: "text-folder",
				label: "Texts",
				children: textsChildren
			});
		}

		return drawingChildren;
	}

	// Instead of using cache arrays, use the Maps:
	buildSurfaceData() {
		const surfaceChildren = [];

		// Use Map directly instead of cache array
		loadedSurfaces.forEach((surface, surfaceId) => {
			surfaceChildren.push({
				id: "surface⣿" + surfaceId,
				type: "surface",
				label: surface.name,
				meta: "(" + (surface.points?.length || 0) + " points | " + (surface.triangles?.length || 0) + " triangles)"
			});
		});

		return surfaceChildren;
	}

	buildImageData() {
		const imageChildren = [];

		// Use Map directly instead of cache array
		loadedImages.forEach((image, imageId) => {
			imageChildren.push({
				id: "image⣿" + imageId,
				type: "image",
				label: image.name,
				meta: image.size ? (image.size / (1024 * 1024)).toFixed(2) + " MB" : "Unknown size"
			});
		});

		return imageChildren;
	}

	// Enhanced renderTree() ⣿ with color swatches
	renderTree(nodes, level = 0) {
		return nodes
			.map((node) => {
				const hasChildren = node.children && node.children.length > 0;
				const isExpanded = this.expandedNodes.has(node.id) || node.expanded;
				const isSelected = this.selectedNodes.has(node.id);

				// Generate color swatch for individual elements
				let colorSwatchHtml = "";
				if (node.elementData && node.type.includes("⣿element")) {
					const color = node.elementData.color || "#777777";
					colorSwatchHtml = `<span class="color-swatch" 
				style="background-color: ${color};" 
				data-element-id="${node.id}"
				data-entity-name="${node.elementData.entityName}"
				data-point-id="${node.elementData.pointID}"></span>`;
				}

				let html = `
            <li class="tree-node">
                <div class="tree-item ${isSelected ? "selected" : ""}" data-node-id="${node.id}">
                    <span class="tree-expand ${hasChildren ? (isExpanded ? "expanded" : "") : "leaf"}"></span>
                    <span class="tree-icon ${node.type}"></span>
                    ${colorSwatchHtml}
                    <span class="tree-label">${node.label}</span>
                    ${node.meta ? `<span class="tree-meta">${node.meta}</span>` : ""}
                </div>
        `;

				if (hasChildren) {
					html += `
                <ul class="tree-children ${isExpanded ? "expanded" : ""}">
                    ${this.renderTree(node.children, level + 1)}
                </ul>
            `;
				}

				html += "</li>";
				return html;
			})
			.join("");
	}

	// Callbacks
	// Add or modify onSelectionChange to sync to canvas
	onSelectionChange() {
		if (this.isSyncing) return;

		// Clear canvas selections
		selectedMultipleHoles = [];
		selectedMultipleKADObjects = [];
		selectedHole = null;
		selectedKADObject = null;

		this.selectedNodes.forEach((nodeId) => {
			const parts = nodeId.split("⣿");
			if (parts[0] === "hole") {
				const holeId = parts.slice(1).join("⣿");
				const hole = allBlastHoles.find((h) => h.holeID === holeId);
				if (hole) selectedMultipleHoles.push(hole);
			} else if (parts[0] === "entity") {
				// Blast entities
				const entityName = parts.slice(1).join("⣿");
				// Select all holes in this blast entity
				allBlastHoles.forEach((hole) => {
					if (hole.entityName === entityName) {
						selectedMultipleHoles.push(hole);
					}
				});
			} else if (["points", "line", "poly", "circle", "text"].includes(parts[0])) {
				// KAD entities
				const entityType = parts[0];
				const entityName = parts.slice(1).join("⣿");
				const entity = allKADDrawingsMap.get(entityName);
				if (entity) {
					selectedMultipleKADObjects.push({
						entityName: entityName,
						entityType: entityType,
						elementIndex: 0,
						selectionType: "entity"
					});
				}
			}
			// Add handling for other types if needed (e.g., individual elements)
		});

		// If single selection, set singular variables
		if (this.selectedNodes.size === 1) {
			if (selectedMultipleHoles.length === 1) {
				selectedHole = selectedMultipleHoles[0];
			} else if (selectedMultipleKADObjects.length === 1) {
				selectedKADObject = selectedMultipleKADObjects[0];
			}
		}

		// Redraw canvas
		drawData(allBlastHoles, selectedHole);
	}

	deleteNode(nodeId) {
		// Override this method to handle node deletion
		console.log("Delete node:", nodeId);
	}

	renameEntity() {
		if (this.selectedNodes.size !== 1) return;
		const nodeId = Array.from(this.selectedNodes)[0];
		const parts = nodeId.split("⣿");
		// 1. Handle blast entity nodes (entity⣿<blastName>)
		if (parts[0] === "entity" && parts.length === 2) {
			const entityName = parts[1];
			const firstHole = allBlastHoles.find((h) => h.entityName === entityName);
			if (firstHole && typeof editBlastNamePopup === "function") {
				editBlastNamePopup(firstHole);
			}
			return;
		}

		// 2. Handle KAD group/entity nodes (points⣿..., line⣿..., etc)
		if ((parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
			const entityType = parts[0];
			const oldEntityName = parts[1];
			const entity = allKADDrawingsMap.get(oldEntityName);
			if (!entity) return;

			renameEntityDialog(entityType, oldEntityName)
				.then((result) => {
					if (result.isConfirmed) {
						const newEntityName = result.value.trim();

						// Step 1) Validate the new name
						if (!newEntityName || newEntityName === oldEntityName) {
							return; // No change needed
						}

						// Step 2) Check if name already exists
						if (allKADDrawingsMap.has(newEntityName)) {
							showModalMessage("Name Error", "Name already exists!", "error");
							return;
						}

						// Step 3) Handle blast entity nodes (special case)
						if (parts[0] === "entity" && parts.length === 2) {
							const entityName = parts[1];
							// Find a hole with this entityName to pass to the popup
							const firstHole = allBlastHoles.find((h) => h.entityName === entityName);
							if (firstHole && typeof editBlastNamePopup === "function") {
								editBlastNamePopup(firstHole);
							}
							return;
						}

						// Step 4) Rename the entity in the KAD drawings map
						allKADDrawingsMap.set(newEntityName, {
							...entity,
							entityName: newEntityName,
							data: entity.data.map((el) => ({
								...el,
								entityName: newEntityName
							}))
						});

						// Step 5) Remove the old entity name from the map
						allKADDrawingsMap.delete(oldEntityName);

						// Step 6) Update all data elements' entityName property
						allKADDrawingsMap.get(newEntityName).data.forEach((el) => {
							el.entityName = newEntityName;
						});

						// Step 7) Save changes to database if available
						if (typeof debouncedSaveKAD === "function") {
							debouncedSaveKAD();
						}

						// Step 8) Update the tree view display
						this.updateTreeData();

						// Step 9) Refresh the canvas drawing
						drawData(allBlastHoles, selectedHole);

						console.log("Successfully renamed " + entityType + " from '" + oldEntityName + "' to '" + newEntityName + "'");
					} else {
						// User cancelled the rename
						console.log("Rename operation cancelled by user");
					}
				})
				.catch((error) => {
					// Handle any errors that might occur
					console.error("Error during rename operation:", error);
					showModalMessage("Rename Error", "An error occurred while renaming: " + error.message, "error");
				});
		}
	}

	showNodeProperties(nodeId) {
		// Handle showing properties for different node types
		const parts = nodeId.split("⣿");
		const nodeType = parts[0];

		try {
			if (parts.length >= 4 && parts[2] === "element") {
				const entityType = parts[0];
				const entityName = parts[1];
				const elementId = parts[3];

				const entity = allKADDrawingsMap.get(entityName);
				if (entity && entity.data) {
					const element = entity.data.find((el) => el.pointID == elementId);
					if (element) {
						const kadObject = {
							...element,
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: entity.data.indexOf(element)
						};
						showKADPropertyEditorPopup(kadObject);
					}
				}
			} else if (nodeType === "hole") {
				// Show properties for individual hole
				const holeId = parts.slice(1).join("⣿");
				const hole = allBlastHoles.find((h) => h.holeID === holeId);
				if (hole) {
					showHolePropertyEditor(hole);
				}
			} else if (nodeType === "entity") {
				// Show properties for blast entity (first hole as representative)
				const entityName = parts.slice(1).join("⣿");
				const firstHole = allBlastHoles.find((h) => h.entityName === entityName);
				if (firstHole) {
					showHolePropertyEditor(firstHole);
				}
			} else if (nodeType === "surface") {
				// Show surface properties
				const surfaceId = parts.slice(1).join("⣿");
				const canvas = document.getElementById("canvas") || document.querySelector("canvas");
				if (canvas && typeof showSurfaceContextMenu === "function") {
					const rect = canvas.getBoundingClientRect();
					const centerX = rect.left + rect.width / 2;
					const centerY = rect.top + rect.height / 2;
					window.showSurfaceContextMenu(centerX, centerY);
				}
			} else if (nodeType === "image") {
				// Show image properties
				const imageId = parts.slice(1).join("⣿");
				const canvas = document.getElementById("canvas") || document.querySelector("canvas");
				if (canvas && typeof showImageContextMenu === "function") {
					const rect = canvas.getBoundingClientRect();
					const centerX = rect.left + rect.width / 2;
					const centerY = rect.top + rect.height / 2;
					window.showImageContextMenu(centerX, centerY);
				}
			} else {
				console.warn("Unknown node type for properties:", nodeType);
			}
		} catch (error) {
			console.error("Error showing node properties:", nodeId, error);
		}
	}
}

// JS COLOR PICKER FOR INSTANT COLOUR CHANGES
function openColorPickerForElement(swatchElement, entityName, pointID) {
	console.log("🎨 openColorPickerForElement called with:", {
		swatchElement,
		entityName,
		pointID
	});

	// Get the entity data
	const entity = allKADDrawingsMap.get(entityName);
	console.log("📊 Entity found:", entity);

	if (!entity) {
		console.log("❌ Entity not found:", entityName);
		return;
	}

	// Debug: Show all pointIDs in the entity
	console.log(
		"🔍 All pointIDs in entity:",
		entity.data.map((el) => ({
			pointID: el.pointID,
			type: typeof el.pointID
		}))
	);

	// ✅ FIX: Use 'let' instead of 'const' so we can reassign
	let element = entity.data.find((el) => el.pointID === pointID);
	console.log("🎯 Element found:", element);

	if (!element) {
		console.log("❌ Element not found with pointID:", pointID);
		// Try converting to string
		element = entity.data.find((el) => el.pointID === pointID.toString());
		console.log("🔄 Trying as string:", element);
		if (!element) {
			// Try converting pointID to string and compare
			element = entity.data.find((el) => el.pointID.toString() === pointID.toString());
			console.log("🔄 Trying both as strings:", element);
		}
		if (!element) {
			console.log("❌ Element still not found after all attempts");
			return;
		}
	}

	// Check if JSColor is already installed and remove it
	if (swatchElement.jscolor) {
		try {
			swatchElement.jscolor.destroy();
		} catch (e) {
			// Ignore errors during cleanup
		}
	}

	// Create JSColor picker directly
	const picker = new JSColor(swatchElement, {
		value: element.color || getJSColorHexDrawing(),
		format: "hex",
		mode: "HSV",
		position: "right",
		onChange: function () {
			// ✅ FIX: Use toHEXString() instead of toString() to avoid double hash
			const newColor = this.toHEXString(); // This already includes the #
			element.color = newColor;
			swatchElement.style.backgroundColor = newColor;

			// Redraw the canvas
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView();

			console.log("✅ Updated " + entityName + " point " + pointID + " color to:", newColor);
		}
	});

	// Show the picker
	picker.show();
}
// Initialize tree view
let treeView;
// Add this debounced version
let updateTreeViewTimeout;

function debouncedUpdateTreeView(delay = 100) {
	if (updateTreeViewTimeout) {
		clearTimeout(updateTreeViewTimeout);
	}
	updateTreeViewTimeout = setTimeout(() => {
		updateTreeView(); // ✅ Call updateTreeView(), not itself!
	}, delay);
}
// ✅ Function to update TreeView visual states based on actual visibility
function updateTreeViewVisibilityStates() {
	if (!treeView) return;

	// Update group visibility states
	const groupNodes = [
		{
			nodeId: "blast",
			visible: blastGroupVisible
		},
		{
			nodeId: "drawings",
			visible: drawingsGroupVisible
		},
		{
			nodeId: "surfaces",
			visible: surfacesGroupVisible
		},
		{
			nodeId: "images",
			visible: imagesGroupVisible
		},
		{
			nodeId: "drawings⣿points",
			visible: pointsGroupVisible && drawingsGroupVisible
		},
		{
			nodeId: "drawings⣿lines",
			visible: linesGroupVisible && drawingsGroupVisible
		},
		{
			nodeId: "drawings⣿polygons",
			visible: polygonsGroupVisible && drawingsGroupVisible
		},
		{
			nodeId: "drawings⣿circles",
			visible: circlesGroupVisible && drawingsGroupVisible
		},
		{
			nodeId: "drawings⣿texts",
			visible: textsGroupVisible && drawingsGroupVisible
		}
	];

	groupNodes.forEach(({ nodeId, visible }) => {
		const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
		if (element) {
			if (visible) {
				element.style.opacity = "1";
				element.classList.remove("hidden-node");
			} else {
				element.style.opacity = "0.5";
				element.classList.add("hidden-node");
			}
		}
	});

	// ✅ FIX: Update entity visibility states (inherit from parent group)
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap) {
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			const nodeId = entity.entityType + "⣿" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check both entity visibility AND parent group visibility
				let isVisible = entity.visible !== false && drawingsGroupVisible;

				// ✅ FIX: Also check specific subgroup visibility with correct entity types
				if (entity.entityType === "point") isVisible = isVisible && pointsGroupVisible;
				else if (entity.entityType === "line") isVisible = isVisible && linesGroupVisible;
				else if (entity.entityType === "poly") isVisible = isVisible && polygonsGroupVisible;
				else if (entity.entityType === "circle") isVisible = isVisible && circlesGroupVisible;
				else if (entity.entityType === "text") isVisible = isVisible && textsGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}

			// ✅ ADD: Update individual element visibility states
			entity.data.forEach((elementData, index) => {
				const elementNodeId = entity.entityType + "⣿" + entityName + "⣿element⣿" + (elementData.pointID || index + 1);
				const elementElement = treeView.container.querySelector('[data-node-id="' + elementNodeId + '"]');
				if (elementElement) {
					// Element inherits from entity and group visibility
					let isElementVisible = entity.visible !== false && drawingsGroupVisible;

					// Check specific subgroup visibility
					if (entity.entityType === "point") isElementVisible = isElementVisible && pointsGroupVisible;
					else if (entity.entityType === "line") isElementVisible = isElementVisible && linesGroupVisible;
					else if (entity.entityType === "poly") isElementVisible = isElementVisible && polygonsGroupVisible;
					else if (entity.entityType === "circle") isElementVisible = isElementVisible && circlesGroupVisible;
					else if (entity.entityType === "text") isElementVisible = isElementVisible && textsGroupVisible;

					// Check individual element visibility
					if (elementData.visible === false) isElementVisible = false;

					if (isElementVisible) {
						elementElement.style.opacity = "1";
						elementElement.classList.remove("hidden-node");
					} else {
						elementElement.style.opacity = "0.5";
						elementElement.classList.add("hidden-node");
					}
				}
			});
		}
	}

	// ✅ FIX: Update hole visibility states with correct node ID pattern
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const nodeId = "hole⣿" + hole.holeID; // ✅ FIX: Correct node ID pattern
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				const isVisible = hole.visible !== false && blastGroupVisible;
				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}

	// ✅ ADD: Update entity (blast) group visibility
	const entityGroups = {};
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const entityName = hole.entityName || "Unknown";
			if (!entityGroups[entityName]) {
				entityGroups[entityName] = [];
			}
			entityGroups[entityName].push(hole);
		});

		Object.keys(entityGroups).forEach((entityName) => {
			const nodeId = "entity⣿" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check if any holes in this entity are visible and blast group is visible
				const entityHoles = entityGroups[entityName];
				const hasVisibleHoles = entityHoles.some((hole) => hole.visible !== false);
				const isVisible = hasVisibleHoles && blastGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}
}

// Update tree when data changes
function updateTreeView() {
	if (treeView) {
		// ✅ Update tree visibility states first
		updateTreeViewVisibilityStates();

		treeView.updateTreeData();
	}
}

//=============================================================
// FLOATING DIALOG SYSTEM
//=============================================================

// Floating Dialog System - Alternative to Swal2 for non-blocking dialogs
// Update the FloatingDialog class to support 4 buttons and proper theme detection
class FloatingDialog {
	constructor(options) {
		this.options = {
			title: "Dialog",
			content: "",
			width: 400,
			height: 300,
			showConfirm: true,
			showCancel: true,
			showDeny: false,
			showOption1: false,
			showOption2: false,
			confirmText: "OK",
			cancelText: "Cancel",
			denyText: "Deny",
			option1Text: "Option 1",
			option2Text: "Option 2",
			layoutType: "default", // default, compact, wide
			draggable: true,
			resizable: true,
			closeOnOutsideClick: false,
			onConfirm: null,
			onCancel: null,
			onDeny: null,
			onOption1: null,
			onOption2: null,
			...options
		};

		this.element = null;
		this.isDragging = false;
		this.isResizing = false;
		this.dragOffset = {
			x: 0,
			y: 0
		};
		this.initialSize = {
			width: 0,
			height: 0
		};

		// Validate layoutType
		const validLayouts = ["default", "compact", "wide"];
		if (!validLayouts.includes(this.options.layoutType)) {
			console.warn("Invalid layoutType '" + this.options.layoutType + "', using 'default'");
			this.options.layoutType = "default";
		}
	}

	show() {
		this.create();
		this.applyLayoutType();
		document.body.appendChild(this.element);
		this.center();
		this.setupEventListeners();

		// Focus first input if any
		setTimeout(() => {
			const firstInput = this.element.querySelector("input:not([type='button']), select, textarea");
			if (firstInput && !firstInput.disabled) firstInput.focus();
		}, 100);
	}

	applyLayoutType() {
		// Remove any existing layout classes
		this.element.classList.remove("floating-dialog-compact", "floating-dialog-wide");

		// Apply the requested layout class
		if (this.options.layoutType === "compact") {
			this.element.classList.add("floating-dialog-compact");
		} else if (this.options.layoutType === "wide") {
			this.element.classList.add("floating-dialog-wide");
		}
		// "default" doesn't need a class - uses base styles
	}

	create() {
		// Create main dialog container
		this.element = document.createElement("div");
		this.element.className = "floating-dialog";
		this.element.style.width = this.options.width + "px";
		this.element.style.height = this.options.height + "px";
		this.element.style.zIndex = "10000";

		// Create header
		const header = this.createHeader();
		this.element.appendChild(header);

		// Create content
		const content = this.createContent();
		this.element.appendChild(content);

		// Create footer with buttons
		if (this.options.showConfirm || this.options.showCancel || this.options.showOption1 || this.options.showOption2) {
			const footer = this.createFooter();
			this.element.appendChild(footer);
		}

		// Add resize handle if resizable
		// if (this.options.resizable) {
		//     this.createResizeHandle();
		// }
	}

	createHeader() {
		const header = document.createElement("div");
		header.className = "floating-dialog-header";

		// Title
		const title = document.createElement("div");
		title.textContent = this.options.title;
		header.appendChild(title);

		// Close button
		const closeBtn = document.createElement("button");
		closeBtn.textContent = "×";
		closeBtn.style.background = "none";
		closeBtn.style.border = "none";
		closeBtn.style.fontSize = "18px";
		closeBtn.style.cursor = "pointer";
		closeBtn.style.padding = "0";
		closeBtn.style.width = "20px";
		closeBtn.style.height = "20px";
		closeBtn.style.display = "flex";
		closeBtn.style.alignItems = "center";
		closeBtn.style.justifyContent = "center";
		closeBtn.style.color = "inherit";

		closeBtn.onmouseover = () => {
			closeBtn.style.color = "#ff0000";
		};
		closeBtn.onmouseout = () => {
			closeBtn.style.color = "inherit";
		};
		closeBtn.onclick = () => this.close();

		header.appendChild(closeBtn);

		return header;
	}

	createContent() {
		const content = document.createElement("div");
		content.className = "floating-dialog-content";

		// Handle different content types
		if (typeof this.options.content === "string") {
			content.innerHTML = this.options.content;
		} else if (this.options.content instanceof HTMLElement) {
			content.appendChild(this.options.content);
		} else if (typeof this.options.content === "function") {
			const contentElement = this.options.content(this);
			if (contentElement) {
				content.appendChild(contentElement);
			}
		}

		return content;
	}

	createFooter() {
		const footer = document.createElement("div");
		footer.className = "floating-dialog-footer";

		// Option2 button (fourth button)
		if (this.options.showOption2) {
			const option2Btn = this.createButton(this.options.option2Text, "option2", () => {
				if (this.options.onOption2) this.options.onOption2();
				this.close();
			});
			footer.appendChild(option2Btn);
		}

		// Option1 button (third button)
		if (this.options.showOption1) {
			const option1Btn = this.createButton(this.options.option1Text, "option1", () => {
				if (this.options.onOption1) this.options.onOption1();
				this.close();
			});
			footer.appendChild(option1Btn);
		}
		// Deny button (before cancel)
		if (this.options.showDeny) {
			const denyBtn = this.createButton(this.options.denyText, "deny", () => {
				if (this.options.onDeny) this.options.onDeny();
				this.close();
			});
			footer.appendChild(denyBtn);
		}
		// Cancel button
		if (this.options.showCancel) {
			const cancelBtn = this.createButton(this.options.cancelText, "cancel", () => {
				if (this.options.onCancel) this.options.onCancel();
				this.close();
			});
			footer.appendChild(cancelBtn);
		}

		// Confirm button
		if (this.options.showConfirm) {
			const confirmBtn = this.createButton(this.options.confirmText, "confirm", () => {
				if (this.options.onConfirm) this.options.onConfirm();
				this.close();
			});
			footer.appendChild(confirmBtn);
		}

		return footer;
	}

	createButton(text, className, onClick) {
		const button = document.createElement("button");
		button.textContent = text;
		button.className = "floating-dialog-btn " + className;
		button.addEventListener("click", onClick);
		return button;
	}

	setupEventListeners() {
		// Dragging functionality
		if (this.options.draggable) {
			const header = this.element.querySelector(".floating-dialog-header");
			header.addEventListener("mousedown", this.startDrag.bind(this));
		}

		// Close on outside click
		if (this.options.closeOnOutsideClick) {
			setTimeout(() => {
				document.addEventListener("click", this.handleOutsideClick.bind(this));
			}, 0);
		}

		// Keyboard shortcuts
		this.handleKeydownBound = this.handleKeydown.bind(this);
		document.addEventListener("keydown", this.handleKeydownBound);
	}

	startDrag(e) {
		if (e.target.tagName === "BUTTON") return;

		this.isDragging = true;
		const rect = this.element.getBoundingClientRect();
		this.dragOffset.x = e.clientX - rect.left;
		this.dragOffset.y = e.clientY - rect.top;

		this.dragBound = this.drag.bind(this);
		this.stopDragBound = this.stopDrag.bind(this);

		document.addEventListener("mousemove", this.dragBound);
		document.addEventListener("mouseup", this.stopDragBound);

		e.preventDefault();
	}

	drag(e) {
		if (!this.isDragging) return;

		const x = e.clientX - this.dragOffset.x;
		const y = e.clientY - this.dragOffset.y;

		// Keep dialog within viewport bounds
		const maxX = window.innerWidth - this.element.offsetWidth;
		const maxY = window.innerHeight - this.element.offsetHeight;

		this.element.style.left = Math.max(0, Math.min(x, maxX)) + "px";
		this.element.style.top = Math.max(0, Math.min(y, maxY)) + "px";
	}

	stopDrag() {
		this.isDragging = false;
		document.removeEventListener("mousemove", this.dragBound);
		document.removeEventListener("mouseup", this.stopDragBound);
	}

	center() {
		const rect = this.element.getBoundingClientRect();
		const x = (window.innerWidth - rect.width) / 2;
		const y = (window.innerHeight - rect.height) / 2;
		this.element.style.left = Math.max(0, x) + "px";
		this.element.style.top = Math.max(0, y) + "px";
	}

	handleOutsideClick(e) {
		if (!this.element.contains(e.target)) {
			this.close();
		}
	}

	handleKeydown(e) {
		if (e.key === "Escape" && this.element) {
			this.close();
		}
	}

	close() {
		if (this.element && this.element.parentNode) {
			this.element.parentNode.removeChild(this.element);
		}

		// Clean up event listeners
		if (this.handleOutsideClickBound) {
			document.removeEventListener("click", this.handleOutsideClickBound);
		}
		if (this.handleKeydownBound) {
			document.removeEventListener("keydown", this.handleKeydownBound);
		}

		this.element = null;
	}

	// Static method to create and show a dialog (similar to Swal.fire)
	static fire(options) {
		const dialog = new FloatingDialog(options);
		dialog.show();
		return dialog;
	}
}

//! FORM CONTENT HELPERS GO HERE
// Updated helper function with proper checkbox handling and layout
function createFormContent(fields, centerCheckboxes = false) {
	const container = document.createElement("div");
	container.style.display = "flex";
	container.style.flexDirection = "column";
	container.style.gap = "6px";
	container.style.width = "100%";
	container.style.marginTop = "4px";

	fields.forEach((field) => {
		// Create row container
		const row = document.createElement("div");

		if (field.type === "checkbox") {
			// Step 1) Special handling for checkboxes - use 2-column layout
			row.className = "checkbox-row";
			row.style.display = "grid";

			// Step 2) Conditionally apply centered layout for checkboxes
			if (centerCheckboxes) {
				// Use same layout as regular inputs for centered alignment
				row.style.gridTemplateColumns = "60% 40%";
				row.style.columnGap = "8px";
				row.style.alignItems = "center";
				row.style.width = "100%";
			} else {
				// Original checkbox layout (60% label, 40% checkbox)
				row.style.gridTemplateColumns = "60% 40%";
				row.style.columnGap = "8px";
				row.style.alignItems = "center";
				row.style.width = "100%";
			}
		} else {
			// Regular input fields
			row.className = "button-container-2col";
			row.style.display = "grid";
			row.style.gridTemplateColumns = "140px 1fr";
			row.style.columnGap = "8px";
			row.style.alignItems = "center";
			row.style.width = "100%";
		}

		// Label
		const label = document.createElement("label");
		label.textContent = field.label;

		// Apply different label classes based on type
		if (field.type === "checkbox") {
			label.className = "labelWhite12";
			label.style.fontSize = "11px";
			label.style.textAlign = "left"; // Left align for checkbox labels
			label.style.paddingRight = "0"; // No padding for checkbox labels
		} else if (field.label.length > 20) {
			label.className = "labelWhite12";
			label.style.fontSize = "11px";
			label.style.textAlign = "right";
			label.style.paddingRight = "4px";
		} else {
			label.className = "labelWhite15";
			label.style.fontSize = "12px";
			label.style.textAlign = "right";
			label.style.paddingRight = "4px";
		}

		label.style.fontFamily = "sans-serif";
		label.style.color = "var(--light-mode-text)";
		label.style.lineHeight = "1.2";
		label.style.margin = "0";
		label.style.whiteSpace = "nowrap";
		label.style.overflow = "hidden";
		label.style.textOverflow = "ellipsis";

		// Input
		const input = document.createElement("input");
		input.type = field.type || "text";
		input.id = field.id || field.name;
		input.name = field.name;
		input.placeholder = field.placeholder || "";
		input.value = field.value || "";

		if (field.type === "number") {
			input.step = field.step || "1";
			input.min = field.min || "";
			input.max = field.max || "";
			input.inputMode = "decimal";
			input.pattern = "[0-9]*";
		}

		if (field.type === "checkbox") {
			input.checked = field.checked || false;
			input.style.width = "14px";
			input.style.height = "14px";
			input.style.margin = "0";
			input.style.padding = "0";
			input.style.border = "1px solid #999";
			input.style.borderRadius = "2px";
			input.style.backgroundColor = "#fff";
			input.style.appearance = "none";
			input.style.webkitAppearance = "none";
			input.style.mozAppearance = "none";
			input.style.position = "relative";
			input.style.cursor = "pointer";
			input.style.justifySelf = "center"; // Center in right column

			// Force the checkbox color update
			const updateCheckboxColor = () => {
				if (input.checked) {
					input.style.backgroundColor = "var(--selected-color)";
					input.style.borderColor = "var(--selected-color)";
				} else {
					input.style.backgroundColor = "#fff";
					input.style.borderColor = "#999";
				}
			};

			// Initial color
			updateCheckboxColor();

			// Update color on change
			input.addEventListener("change", updateCheckboxColor);
		} else {
			// Regular input styling with proper expansion
			input.style.fontSize = "11px";
			input.style.height = "20px";
			input.style.padding = "2px 4px";
			input.style.width = "100%"; // Fill available space
			input.style.minWidth = "80px"; // Minimum width
			input.style.borderRadius = "3px";
			input.style.backgroundColor = "#fff";
			input.style.color = "#000";
			input.style.border = "1px solid #999";
			input.style.appearance = "none";
			input.style.boxSizing = "border-box";
		}

		// Add to row
		row.appendChild(label);
		row.appendChild(input);
		container.appendChild(row);
	});

	return container;
}
// Enhanced form content creator for complex forms with special field types
function createEnhancedFormContent(fields, isMultiple, centerCheckboxes = false) {
	const container = document.createElement("div");
	container.style.display = "flex";
	container.style.flexDirection = "column";
	container.style.gap = "6px";
	container.style.width = "100%";
	container.style.marginTop = "4px";

	fields.forEach((field) => {
		const row = document.createElement("div");

		if (field.type === "checkbox") {
			// Special handling for checkboxes - use 2-column layout
			row.className = "checkbox-row";
			row.style.display = "grid";
			row.style.gridTemplateColumns = "60% 40%"; // More space for long labels
			row.style.columnGap = "8px";
			row.style.alignItems = "center";
			row.style.width = "100%";
		} else {
			// Regular input fields
			row.className = "button-container-2col";
			row.style.display = "grid";
			row.style.gridTemplateColumns = "60% 40%";
			row.style.columnGap = "8px";
			row.style.rowGap = "4px";
			row.style.alignItems = "center";
			row.style.width = "100%";
		}

		// Label
		const label = document.createElement("label");
		label.textContent = field.label;

		// Apply different label classes based on type
		if (field.type === "checkbox") {
			label.className = "labelWhite12";
			label.style.fontSize = "11px";
			label.style.textAlign = "left"; // Left align for checkbox labels
			label.style.paddingRight = "0"; // No padding for checkbox labels
		} else {
			label.className = "labelWhite12";
			label.style.fontSize = "11px";
			label.style.fontFamily = "sans-serif";
			label.style.color = "var(--light-mode-text)";
			label.style.lineHeight = "1.2";
			label.style.margin = "0";
			label.style.whiteSpace = "nowrap";
			label.style.textAlign = "left";
			label.style.overflow = "hidden";
			label.style.textOverflow = "ellipsis";
			label.style.paddingRight = "4px";
		}

		// Input element based on type
		let input;

		if (field.type === "checkbox") {
			input = document.createElement("input");
			input.type = "checkbox";
			input.checked = field.checked || false;
			input.style.width = "14px";
			input.style.height = "14px";
			input.style.margin = "0";
			input.style.padding = "0";
			input.style.border = "1px solid #999";
			input.style.borderRadius = "2px";
			input.style.backgroundColor = "#fff";
			input.style.appearance = "none";
			input.style.webkitAppearance = "none";
			input.style.mozAppearance = "none";
			input.style.position = "relative";
			input.style.cursor = "pointer";
			// Step 3) Conditionally center the checkbox
			if (centerCheckboxes) {
				input.style.justifySelf = "start"; // Align to start of right column (like other inputs)
			} else {
				input.style.justifySelf = "center"; // Center in right column (original behavior)
			}

			// Force the checkbox color update
			const updateCheckboxColor = () => {
				if (input.checked) {
					input.style.backgroundColor = "var(--selected-color)";
					input.style.borderColor = "var(--selected-color)";
				} else {
					input.style.backgroundColor = "#fff";
					input.style.borderColor = "#999";
				}
			};

			// Initial color
			updateCheckboxColor();

			// Update color on change
			input.addEventListener("change", updateCheckboxColor);
		} else if (field.type === "select") {
			input = document.createElement("select");
			input.className = "floating-dialog-select";
			field.options.forEach((option) => {
				const optionElement = document.createElement("option");
				optionElement.value = option.value;
				optionElement.textContent = option.text;
				if (option.value === field.value) {
					optionElement.selected = true;
				}
				input.appendChild(optionElement);
			});

			// Special handling for hole type dropdown
			if (field.name === "holeType") {
				input.addEventListener("change", function () {
					const customTypeRow = container.querySelector('[data-field="customType"]');
					const customTypeInput = customTypeRow.querySelector("input");
					const customTypeLabel = customTypeRow.querySelector("label");

					if (this.value === "__CUSTOM__") {
						customTypeInput.style.opacity = "1";
						customTypeInput.disabled = false;
						customTypeLabel.style.opacity = "1";
						customTypeInput.focus();
					} else {
						customTypeInput.style.opacity = "0.3";
						customTypeInput.disabled = true;
						customTypeLabel.style.opacity = "0.3";
						customTypeInput.value = "";
					}
				});
			}
		} else if (field.type === "color") {
			input = document.createElement("input");
			input.type = "button";
			input.setAttribute("data-jscolor", "{value:'" + field.value + "'}");
			input.title = "Delay Color";
			input.className = "swal2-input";
		} else {
			input = document.createElement("input");
			input.type = field.type || "text";
		}

		input.id = field.name;
		input.name = field.name;
		input.placeholder = field.placeholder || "";

		if (field.type !== "select" && field.type !== "color" && field.type !== "checkbox") {
			input.value = field.value !== undefined && field.value !== null ? field.value : "";
		}
		// Set number input attributes
		if (field.type === "number") {
			if (field.min !== undefined) input.min = field.min;
			if (field.max !== undefined) input.max = field.max;
			if (field.step !== undefined) input.step = field.step;
		}

		if (field.disabled) {
			input.disabled = true;
			input.style.opacity = "0.3";
			label.style.opacity = "0.3";
		}

		// Standard input styling (for non-checkbox inputs)
		if (field.type !== "color" && field.type !== "checkbox") {
			input.style.fontSize = "11px";
			input.style.height = "20px";
			input.style.padding = "2px 4px";
			input.style.width = "100%";
			input.style.minWidth = "80px";
			input.style.borderRadius = "3px";
			input.style.backgroundColor = "#fff";
			input.style.color = "#000";
			input.style.border = "1px solid #999";
			input.style.appearance = "none";
			input.style.boxSizing = "border-box";
		}

		// Mark the row with field name for easy reference
		row.setAttribute("data-field", field.name);

		row.appendChild(label);
		row.appendChild(input);
		container.appendChild(row);
	});

	// Initialize JSColor after adding color inputs with proper z-index
	setTimeout(() => {
		jscolor.install();

		// Force z-index on any JSColor elements
		const colorInputs = container.querySelectorAll("[data-jscolor]");
		colorInputs.forEach((input) => {
			if (input.jscolor) {
				// Set z-index on the JSColor instance
				input.jscolor.option("zIndex", 20000);
			}

			// Also set it when the color picker is shown
			input.addEventListener("click", () => {
				setTimeout(() => {
					const picker = document.querySelector(".jscolor-picker-wrap");
					if (picker) {
						picker.style.zIndex = "20000";
						picker.style.position = "fixed";
					}
					const pickerInner = document.querySelector(".jscolor-picker");
					if (pickerInner) {
						pickerInner.style.zIndex = "20000";
					}
				}, 10);
			});
		});
	}, 100);

	return container;
}
// Helper function to extract form data
function getFormData(formContainer) {
	const data = {};
	const inputs = formContainer.querySelectorAll("input, select");

	inputs.forEach((input) => {
		if (input.name) {
			if (input.type === "button" && input.jscolor) {
				data[input.name] = input.jscolor.toHEXString();
			} else if (input.type === "checkbox") {
				// Handle checkboxes - use checked property instead of value
				data[input.name] = input.checked.toString();
			} else {
				data[input.name] = input.value;
			}
		}
	});

	return data;
}
//* FORM CONTENT HELPERS END HERE

//! CONFIRMATION DIALOG
// Step 1) Create utility function for confirmation dialogs - FIXED VERSION
function showConfirmationDialog(title, message, confirmText = "Confirm", cancelText = "Cancel", onConfirm = null, onCancel = null) {
	console.log("showConfirmationDialog: " + title);

	// Step 2) Create content with warning icon and message using inline styles for dark mode
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";
	const content = '<div style="color: #ff9800; font-size: 24px; margin-bottom: 15px; text-align: center;">⚠️</div>' + '<div style="color: ' + textColor + '; font-size: 16px; line-height: 1.4;">' + message + "</div>";

	// Step 3) Create FloatingDialog with confirm/cancel buttons
	const dialog = new FloatingDialog({
		title: title,
		content: content,
		width: 500,
		height: 350,
		showConfirm: true,
		showCancel: true,
		showDeny: false,
		showOption1: false,
		showOption2: false,
		confirmText: confirmText,
		cancelText: cancelText,
		draggable: true,
		resizable: false,
		closeOnOutsideClick: false, // Modal behavior
		layoutType: "default",
		onConfirm: () => {
			// Step 4) Handle confirm button click
			console.log("Confirmation dialog confirmed: " + title);
			dialog.close();
			if (onConfirm && typeof onConfirm === "function") {
				onConfirm();
			}
		},
		onCancel: () => {
			// Step 5) Handle cancel button click
			console.log("Confirmation dialog cancelled: " + title);
			dialog.close();
			if (onCancel && typeof onCancel === "function") {
				onCancel();
			}
		}
	});

	// Step 6) Show the dialog
	dialog.show();
	return dialog;
}
// Step 1) Create utility function for confirmation dialogs with 3 buttons
function showConfirmationThreeDialog(title, message, confirmText = "Confirm", cancelText = "Cancel", optionText = "Option", onConfirm = null, onCancel = null, onOption = null) {
	console.log("showConfirmationThreeDialog: " + title);

	// Step 2) Create content with warning icon and message using inline styles for dark mode
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";
	const content = '<div style="color: #ff9800; font-size: 24px; margin-bottom: 15px; text-align: center;">⚠️</div>' + '<div style="color: ' + textColor + '; font-size: 16px; line-height: 1.4;">' + message + "</div>";

	// Step 3) Create FloatingDialog with confirm/cancel/option buttons
	const dialog = new FloatingDialog({
		title: title,
		content: content,
		width: 500,
		height: 350,
		showConfirm: true,
		showCancel: true,
		showDeny: false,
		showOption1: true, // Enable the third button
		showOption2: false,
		confirmText: confirmText,
		cancelText: cancelText,
		option1Text: optionText, // Use option1Text for the third button
		draggable: true,
		resizable: false,
		closeOnOutsideClick: false, // Modal behavior
		layoutType: "default",
		onConfirm: () => {
			// Step 4) Handle confirm button click
			console.log("Three-button confirmation dialog confirmed: " + title);
			dialog.close();
			if (onConfirm && typeof onConfirm === "function") {
				onConfirm();
			}
		},
		onCancel: () => {
			// Step 5) Handle cancel button click
			console.log("Three-button confirmation dialog cancelled: " + title);
			dialog.close();
			if (onCancel && typeof onCancel === "function") {
				onCancel();
			}
		},
		onOption1: () => {
			// Step 6) Handle option button click
			console.log("Three-button confirmation dialog option selected: " + title);
			dialog.close();
			if (onOption && typeof onOption === "function") {
				onOption();
			}
		}
	});

	// Step 7) Show the dialog
	dialog.show();
	return dialog;
}
//! WRANING - SUCCESS - ERROR - INFO - QUESTION - ACTION Dialog
// Step 1) Create utility function for modal warning/error/success popups - FIXED VERSION
function showModalMessage(title, message, type = "info", callback = null) {
	console.log("showModalMessage: " + title + " - " + message + " (" + type + ")");

	// Step 2) Determine icon and styling based on type
	let iconHtml = "";
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	if (type === "warning") {
		iconHtml = '<div style="color: #ff9800; font-size: 24px; margin-bottom: 10px; text-align: center;">⚠️</div>';
	} else if (type === "error") {
		iconHtml = '<div style="color: #f44336; font-size: 24px; margin-bottom: 10px; text-align: center;">❌</div>';
	} else if (type === "success") {
		iconHtml = '<div style="color: #4caf50; font-size: 24px; margin-bottom: 10px; text-align: center;">✅</div>';
	} else {
		iconHtml = '<div style="color: #2196f3; font-size: 24px; margin-bottom: 10px; text-align: center;">ℹ️</div>';
	}

	// Step 3) Create content with icon and message using inline styles
	const content = iconHtml + '<div style="color: ' + textColor + '; font-size: 16px; line-height: 1.4; text-align: center;">' + message + "</div>";

	// Step 4) Create modal FloatingDialog
	const dialog = new FloatingDialog({
		title: title,
		content: content,
		width: 400,
		height: 200,
		showConfirm: true,
		showCancel: false,
		showDeny: false,
		showOption1: false,
		showOption2: false,
		confirmText: "OK",
		draggable: true,
		resizable: false,
		closeOnOutsideClick: false, // Modal behavior - must click OK
		layoutType: "compact",
		onConfirm: () => {
			// Step 5) Handle OK button click
			console.log("Modal message acknowledged: " + title);
			dialog.close();
			if (callback && typeof callback === "function") {
				callback();
			}
		}
	});

	// Step 6) Show the dialog
	dialog.show();
	return dialog;
}

//CONTEXT DIALOG FOR HOLE MODIFICATION
function showHolePropertyEditor(hole) {
	// ✅ CHECK VISIBILITY FIRST - Filter out hidden holes
	const visibleHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

	if (visibleHoles.length === 0) {
		console.log("❌ No visible holes to edit");
		return;
	}

	if (visibleHoles.length !== allBlastHoles.length) {
		console.log("⚠️ Some holes are hidden and will not be edited");
	}

	// Determine if we're dealing with single hole or multiple holes
	let candidateHoles;
	if (Array.isArray(hole)) {
		candidateHoles = hole;
	} else if (selectedMultipleHoles && selectedMultipleHoles.length > 1) {
		candidateHoles = selectedMultipleHoles;
	} else {
		candidateHoles = [hole];
	}
	// ✅ Filter candidate holes to only include visible ones
	const holes = candidateHoles.filter((h) => isHoleVisible(h));

	const isMultiple = holes.length > 1;
	const isArrayInput = Array.isArray(hole);

	if (holes.length === 0) return;

	// Calculate current values and averages with proper fallbacks
	let delaySum = 0,
		diameterSum = 0,
		bearingSum = 0,
		angleSum = 0,
		subdrillSum = 0;
	let collarZSum = 0,
		gradeZSum = 0;
	let uniqueDelays = new Set(),
		uniqueDelayColors = new Set(),
		uniqueHoleTypes = new Set();
	let uniqueRowIDs = new Set(),
		uniquePosIDs = new Set();
	let typeCounts = {};
	let connectorCurveSum = 0;
	let burdenSum = 0;
	let spacingSum = 0;

	holes.forEach((h) => {
		// Basic properties
		const currentDelay = h.holeDelay !== undefined ? h.holeDelay : h.timingDelayMilliseconds || 0;
		const currentColor = h.holeDelayColor || h.colorHexDecimal || "#FF0000";
		const currentType = h.holeType || "Production";

		// Geometry properties
		const diameter = h.holeDiameter || 0;
		const bearing = h.holeBearing || 0;
		const angle = h.holeAngle || 0;
		const subdrill = h.subdrillAmount || 0;
		const collarZ = h.startZLocation || 0;
		const gradeZ = h.gradeZLocation || h.endZLocation || 0;
		const rowID = h.rowID || "";
		const posID = h.posID || "";

		// Step 1) Add connectorCurve calculation
		const connectorCurve = h.connectorCurve || 0;
		const burden = h.burden || 0;
		const spacing = h.spacing || 0;

		// Sum for averages
		delaySum += parseFloat(currentDelay);
		diameterSum += parseFloat(diameter);
		bearingSum += parseFloat(bearing);
		angleSum += parseFloat(angle);
		subdrillSum += parseFloat(subdrill);
		collarZSum += parseFloat(collarZ);
		gradeZSum += parseFloat(gradeZ);

		// Step 2) Add new sums

		connectorCurveSum += parseFloat(connectorCurve);
		burdenSum += parseFloat(burden);
		spacingSum += parseFloat(spacing);

		// Track unique values
		uniqueDelays.add(currentDelay);
		uniqueDelayColors.add(currentColor);
		uniqueHoleTypes.add(currentType);
		uniqueRowIDs.add(rowID);
		uniquePosIDs.add(posID);

		// Count hole types for most common
		typeCounts[currentType] = (typeCounts[currentType] || 0) + 1;
	});

	// Calculate averages
	const count = holes.length;
	const avgDelay = delaySum / count;
	const avgDiameter = diameterSum / count;
	const avgBearing = bearingSum / count;
	const avgAngle = angleSum / count;
	const avgSubdrill = subdrillSum / count;
	const avgCollarZ = collarZSum / count;
	const avgGradeZ = gradeZSum / count;

	// Find most common values
	const firstDelayColor = Array.from(uniqueDelayColors)[0];
	const firstRowID = Array.from(uniqueRowIDs)[0];
	const firstPosID = Array.from(uniquePosIDs)[0];

	// Find most common hole type
	let mostCommonType = "Production";
	let maxCount = 0;
	for (const [type, typeCount] of Object.entries(typeCounts)) {
		if (typeCount > maxCount) {
			maxCount = typeCount;
			mostCommonType = type;
		}
	}

	// Create combined hole types list (standard + any custom types from selection)
	const standardHoleTypes = ["Angled", "Batter", "Buffer", "Infill", "Production", "Stab", "Toe", "Trim"];
	const customTypesFromSelection = Array.from(uniqueHoleTypes).filter((type) => !standardHoleTypes.includes(type));
	const allHoleTypes = [...standardHoleTypes, ...customTypesFromSelection].sort();
	// Calculate averages (add after existing averages around line 37240)
	const avgConnectorCurve = connectorCurveSum / count;
	const avgBurden = burdenSum / count;
	const avgSpacing = spacingSum / count;

	// Add to originalValues object around line 37275
	const originalValues = {
		delay: avgDelay.toFixed(1),
		diameter: avgDiameter.toFixed(0),
		bearing: avgBearing.toFixed(1),
		angle: avgAngle.toFixed(0),
		subdrill: avgSubdrill.toFixed(1),
		collarZ: avgCollarZ.toFixed(2),
		gradeZ: avgGradeZ.toFixed(2),
		holeType: mostCommonType,
		delayColor: firstDelayColor,
		rowID: firstRowID,
		posID: firstPosID,
		// Step 3) Add new original values
		connectorCurve: avgConnectorCurve.toFixed(0),
		burden: avgBurden.toFixed(2),
		spacing: avgSpacing.toFixed(2)
	};

	// Add display values around line 37285
	const displayConnectorCurve = isMultiple && new Set(holes.map((h) => h.connectorCurve || 0)).size > 1 ? "varies (avg: " + avgConnectorCurve.toFixed(0) + "°)" : avgConnectorCurve.toFixed(0) + "°";
	const displayBurden = isMultiple && new Set(holes.map((h) => h.burden || 0)).size > 1 ? "varies (avg: " + avgBurden.toFixed(2) + ")" : avgBurden.toFixed(2);
	const displaySpacing = isMultiple && new Set(holes.map((h) => h.spacing || 0)).size > 1 ? "varies (avg: " + avgSpacing.toFixed(2) + ")" : avgSpacing.toFixed(2);

	// Create display values with indicators for varying values
	const displayDelay = isMultiple && uniqueDelays.size > 1 ? "varies (avg: " + avgDelay.toFixed(1) + ")" : avgDelay.toFixed(1);
	const displayDiameter = isMultiple && new Set(holes.map((h) => h.holeDiameter)).size > 1 ? "varies (avg: " + avgDiameter.toFixed(0) + ")" : avgDiameter.toFixed(0);
	const displayBearing = isMultiple && new Set(holes.map((h) => h.holeBearing)).size > 1 ? "varies (avg: " + avgBearing.toFixed(1) + ")" : avgBearing.toFixed(1);
	const displayAngle = isMultiple && new Set(holes.map((h) => h.holeAngle)).size > 1 ? "varies (avg: " + avgAngle.toFixed(0) + ")" : avgAngle.toFixed(0);
	const displaySubdrill = isMultiple && new Set(holes.map((h) => h.subdrillAmount)).size > 1 ? "varies (avg: " + avgSubdrill.toFixed(1) + ")" : avgSubdrill.toFixed(1);
	const displayCollarZ = isMultiple && new Set(holes.map((h) => h.startZLocation)).size > 1 ? "varies (avg: " + avgCollarZ.toFixed(2) + ")" : avgCollarZ.toFixed(2);
	const displayGradeZ = isMultiple && new Set(holes.map((h) => h.gradeZLocation || h.endZLocation)).size > 1 ? "varies (avg: " + avgGradeZ.toFixed(2) + ")" : avgGradeZ.toFixed(2);

	// Create notes for multiple values
	const delayNote = isMultiple && uniqueDelays.size > 1 ? " (varying)" : "";
	const colorNote = isMultiple && uniqueDelayColors.size > 1 ? " (multiple)" : "";
	const typeNote = isMultiple && uniqueHoleTypes.size > 1 ? " (most common: " + mostCommonType + ")" : "";

	const title = isMultiple ? "Edit Multiple Holes (" + holes.length + " selected)" : "Edit Hole " + holes[0].holeID;

	// Define form fields
	const fields = [
		{
			label: "Delay" + delayNote,
			name: "delay",
			type: "text",
			value: originalValues.delay,
			placeholder: displayDelay
		},
		{
			label: "Delay Color" + colorNote,
			name: "delayColor",
			type: "color",
			value: firstDelayColor
		},
		{
			label: "Connector Curve (°)",
			name: "connectorCurve",
			type: "number",
			value: originalValues.connectorCurve,
			placeholder: displayConnectorCurve
		},
		{
			label: "Hole Type",
			name: "holeType",
			type: "select",
			value: mostCommonType,
			options: [
				{
					value: "",
					text: "-- No Change --"
				},
				...allHoleTypes.map((type) => ({
					value: type,
					text: type
				})),
				{
					value: "__CUSTOM__",
					text: "Other (custom)..."
				}
			]
		},
		{
			label: "Custom Type",
			name: "customType",
			type: "text",
			placeholder: "Enter custom hole type",
			disabled: true
		},
		{
			label: "Diameter (mm)",
			name: "diameter",
			type: "text",
			value: originalValues.diameter,
			placeholder: displayDiameter
		},
		{
			label: "Bearing (°)",
			name: "bearing",
			type: "text",
			value: originalValues.bearing,
			placeholder: displayBearing
		},
		{
			label: "Dip/Angle (°)",
			name: "angle",
			type: "text",
			value: originalValues.angle,
			placeholder: displayAngle
		},
		{
			label: "Subdrill (m)",
			name: "subdrill",
			type: "text",
			value: originalValues.subdrill,
			placeholder: displaySubdrill
		},
		{
			label: "Collar Z RL (m)",
			name: "collarZ",
			type: "text",
			value: originalValues.collarZ,
			placeholder: displayCollarZ
		},
		{
			label: "Grade Z RL (m)",
			name: "gradeZ",
			type: "text",
			value: originalValues.gradeZ,
			placeholder: displayGradeZ
		},
		{
			label: "Burden (m)",
			name: "burden",
			type: "text",
			value: originalValues.burden,
			placeholder: displayBurden
		},
		{
			label: "Spacing (m)",
			name: "spacing",
			type: "text",
			value: originalValues.spacing,
			placeholder: displaySpacing
		}
	];

	// Add Row ID and Pos ID fields only for single hole edits
	if (!isMultiple) {
		fields.push(
			{
				label: "Row ID",
				name: "rowID",
				type: "text",
				value: firstRowID,
				placeholder: "Row identifier"
			},
			{
				label: "Pos ID",
				name: "posID",
				type: "text",
				value: firstPosID,
				placeholder: "Position identifier"
			}
		);
	}

	// Create enhanced form content with special handling
	const formContent = createEnhancedFormContent(fields, isMultiple);

	// Add note at the bottom
	const noteDiv = document.createElement("div");
	noteDiv.style.gridColumn = "1 / -1";
	noteDiv.style.marginTop = "10px";
	noteDiv.style.fontSize = "10px";
	noteDiv.style.color = "#888";
	noteDiv.textContent = isMultiple ? "Note: Use +/- for relative changes (e.g., +0.3, -0.2). Only changed values will be applied." : "Note: Use +/- for relative changes (e.g., +0.3, -0.2). Select hole type from dropdown or choose 'Other' for custom. Curved connectors are made by seting connector curve to (45° to 120°, -45° to -120°) Straight connctors are 0°";
	formContent.appendChild(noteDiv);

	const dialog = new FloatingDialog({
		title: title,
		content: formContent,
		layoutType: "compact",
		showConfirm: true,
		showCancel: true,
		showOption1: true, // Add hide button
		confirmText: "Apply",
		cancelText: "Cancel",
		option1Text: "Hide",
		width: 350,
		height: 600,
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			// Process the form data and update holes
			processHolePropertyUpdates(holes, formData, originalValues, isMultiple);

			// Clear any dragging states when dialog closes
			isDragging = false;
			clearTimeout(longPressTimeout);
		},
		onCancel: () => {
			// Clear any dragging states when dialog closes
			isDragging = false;
			clearTimeout(longPressTimeout);
		},
		onOption1: () => {
			// Hide holes - just set visible flag
			holes.forEach((hole) => {
				hole.visible = false;
			});
			drawData(allBlastHoles, selectedHole);
		}
	});

	dialog.show();
}

// Process hole property updates (extracted from original logic)
function processHolePropertyUpdates(holes, formData, originalValues, isMultiple) {
	// Helper function to handle relative/absolute value changes
	function processNumericValue(inputValue, originalValue, currentHoleValue) {
		if (inputValue === "" || inputValue === originalValue) {
			return null; // No change
		}

		if (inputValue.startsWith("+") || inputValue.startsWith("-")) {
			// Relative adjustment
			const delta = parseFloat(inputValue);
			if (!isNaN(delta)) {
				return currentHoleValue + delta;
			}
		} else {
			// Absolute value
			const absoluteValue = parseFloat(inputValue);
			if (!isNaN(absoluteValue)) {
				return absoluteValue;
			}
		}
		return null; // Invalid input
	}

	// ✅ NEW: Track which fields were actually modified by the user
	const modifiedFields = new Set();

	// Check each field to see if it was actually changed from the original average
	if (formData.delay !== originalValues.delay) modifiedFields.add("delay");
	if (formData.delayColor !== originalValues.delayColor) modifiedFields.add("delayColor");
	if (formData.holeType !== originalValues.holeType) modifiedFields.add("holeType");
	if (formData.diameter !== originalValues.diameter) modifiedFields.add("diameter");
	if (formData.bearing !== originalValues.bearing) modifiedFields.add("bearing");
	if (formData.angle !== originalValues.angle) modifiedFields.add("angle");
	if (formData.subdrill !== originalValues.subdrill) modifiedFields.add("subdrill");
	if (formData.collarZ !== originalValues.collarZ) modifiedFields.add("collarZ");
	if (formData.gradeZ !== originalValues.gradeZ) modifiedFields.add("gradeZ");
	if (formData.connectorCurve !== originalValues.connectorCurve) modifiedFields.add("connectorCurve");
	if (formData.burden !== originalValues.burden) modifiedFields.add("burden");
	if (formData.spacing !== originalValues.spacing) modifiedFields.add("spacing");

	// For single hole edits, also check Row ID and Pos ID
	if (!isMultiple) {
		if (formData.rowID !== originalValues.rowID) modifiedFields.add("rowID");
		if (formData.posID !== originalValues.posID) modifiedFields.add("posID");
	}

	// Handle hole type: check if custom or standard
	let newHoleType = formData.holeType;
	if (newHoleType === "__CUSTOM__") {
		newHoleType = formData.customType.trim();
		if (newHoleType !== originalValues.holeType) modifiedFields.add("holeType");
	}

	// Track if any timing-related properties were changed
	let timingChanged = false;
	let geometryChanged = false;

	holes.forEach((h) => {
		// ✅ ONLY process fields that were actually modified
		if (modifiedFields.has("delay")) {
			const processedDelay = processNumericValue(formData.delay, originalValues.delay, h.holeDelay !== undefined ? h.holeDelay : h.timingDelayMilliseconds || 0);
			if (processedDelay !== null) {
				h.holeDelay = processedDelay;
				if (h.timingDelayMilliseconds !== undefined) {
					h.timingDelayMilliseconds = processedDelay;
				}
				timingChanged = true;
			}
		}

		if (modifiedFields.has("delayColor")) {
			h.holeDelayColor = formData.delayColor;
			if (h.colorHexDecimal !== undefined) {
				h.colorHexDecimal = formData.delayColor;
			}
			timingChanged = true;
		}

		if (modifiedFields.has("holeType")) {
			h.holeType = newHoleType;
		}

		// Update geometry properties only if modified
		if (modifiedFields.has("diameter")) {
			const processedDiameter = processNumericValue(formData.diameter, originalValues.diameter, h.holeDiameter || 0);
			if (processedDiameter !== null) {
				calculateHoleGeometry(h, processedDiameter, 7);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("bearing")) {
			const processedBearing = processNumericValue(formData.bearing, originalValues.bearing, h.holeBearing || 0);
			if (processedBearing !== null) {
				calculateHoleGeometry(h, processedBearing, 3);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("angle")) {
			const processedAngle = processNumericValue(formData.angle, originalValues.angle, h.holeAngle || 0);
			if (processedAngle !== null) {
				calculateHoleGeometry(h, processedAngle, 2);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("subdrill")) {
			const processedSubdrill = processNumericValue(formData.subdrill, originalValues.subdrill, h.subdrillAmount || 0);
			if (processedSubdrill !== null) {
				calculateHoleGeometry(h, processedSubdrill, 8);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("collarZ")) {
			const processedCollarZ = processNumericValue(formData.collarZ, originalValues.collarZ, h.startZLocation || 0);
			if (processedCollarZ !== null) {
				h.startZLocation = processedCollarZ;
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("gradeZ")) {
			const processedGradeZ = processNumericValue(formData.gradeZ, originalValues.gradeZ, h.gradeZLocation || h.endZLocation || 0);
			if (processedGradeZ !== null) {
				h.gradeZLocation = processedGradeZ;
				h.endZLocation = processedGradeZ;
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("connectorCurve")) {
			// Step 1) Treat connectorCurve as absolute value only (no relative adjustments)
			const curveValue = parseFloat(formData.connectorCurve);
			if (!isNaN(curveValue)) {
				h.connectorCurve = curveValue;
				timingChanged = true; // Since this affects visual display
			}
		}

		if (modifiedFields.has("burden")) {
			const processedBurden = processNumericValue(formData.burden, originalValues.burden, h.burden || 0);
			if (processedBurden !== null) {
				h.burden = processedBurden;
			}
		}

		if (modifiedFields.has("spacing")) {
			const processedSpacing = processNumericValue(formData.spacing, originalValues.spacing, h.spacing || 0);
			if (processedSpacing !== null) {
				h.spacing = processedSpacing;
			}
		}

		// Only update Row ID and Pos ID for single hole edits and if modified
		if (!isMultiple) {
			if (modifiedFields.has("rowID")) {
				h.rowID = formData.rowID;
			}

			if (modifiedFields.has("posID")) {
				h.posID = formData.posID;
			}
		}
	});

	// ** RECALCULATE TIMING AND CONTOURS **
	if (timingChanged || geometryChanged) {
		// Always recalculate timing calculations after changes
		holeTimes = calculateTimes(allBlastHoles);

		// Update timing chart display
		timeChart();

		// Recalculate contours if they're being displayed
		const result = recalculateContours(allBlastHoles, 0, 0);
		if (result) {
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}

	// Update selection averages and sliders
	if (isMultiple) {
		updateSelectionAveragesAndSliders(holes);
	} else if (selectedHole === holes[0]) {
		updateSelectionAveragesAndSliders([holes[0]]);
	}

	drawData(allBlastHoles, selectedHole); // Redraw

	const statusMessage = isMultiple ? "Updated " + holes.length + " holes" + (timingChanged ? " - Timings recalculated" : "") : "Hole " + holes[0].holeID + " updated" + (timingChanged ? " - Timings recalculated" : "");
	updateStatusMessage(statusMessage);
	setTimeout(() => updateStatusMessage(""), 3000);
}

//For Kad entities
function renameEntityDialog(entityType, oldEntityName) {
	// Create form content using the helper function
	const fields = [
		{
			label: "New name:",
			name: "entityName",
			value: oldEntityName || "",
			placeholder: "Enter new name"
		}
	];

	const formContent = createFormContent(fields);

	// Return a Promise to match the calling pattern
	return new Promise((resolve) => {
		const dialog = new FloatingDialog({
			title: "Rename " + entityType,
			content: formContent,
			layoutType: "default",
			width: 350,
			height: 120,
			showConfirm: true,
			showCancel: true,
			confirmText: "Rename",
			cancelText: "Cancel",
			onConfirm: () => {
				// Get form values
				const formData = getFormData(formContent);

				// Validate input
				if (!formData.entityName || formData.entityName.trim() === "") {
					console.log("Invalid name entered");
					return;
				}

				// Resolve with Swal2-like result object
				resolve({
					isConfirmed: true,
					value: formData.entityName.trim()
				});
			},
			onCancel: () => {
				// Resolve with cancelled result
				resolve({
					isConfirmed: false,
					value: null
				});
			}
		});

		dialog.show();
	});
}

function editBlastNamePopup(selectedHole) {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	if (selectedHole) {
		const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
		if (index !== -1) {
			clickedHole = allBlastHoles[index];
			blastNameValue = clickedHole.entityName;
		}
	}
	let allHoleBlastNamesValue = true;

	// Create form content using the helper function
	const fields = [
		{
			label: "Blast Name",
			name: "blastName",
			value: blastNameValue || "",
			placeholder: "Blast Name"
		},
		{
			label: "Apply to all holes with the same name",
			name: "allHoleBlastNames",
			type: "checkbox",
			checked: true,
			labelInLeftColumn: true
		}
	];

	const formContent = createFormContent(fields, true);

	const dialog = new FloatingDialog({
		title: "Edit Blast Name",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: async () => {
			// Step 1) Get form data - ADD THIS AT THE VERY TOP
			const formData = getFormData(formContent);
			const newBlastName = formData.blastName ? formData.blastName.trim() : "";
			const allHoleBlastNamesFromForm = formData.allHoleBlastNames || false;

			// Step 2) Validate the new blast name
			if (!newBlastName || newBlastName === "") {
				console.log("Invalid blast name entered");
				return;
			}

			const index = allBlastHoles.findIndex((point) => point === selectedHole);
			if (index !== -1) {
				// Get the current entity name before any changes
				let currentEntityName = allBlastHoles[index].entityName;

				// Step 3) FIRST check for duplicates BEFORE making any changes
				if (typeof checkAndResolveDuplicateHoleIDs === "function") {
					// Create a temporary copy to test for duplicates
					const testBlastHoles = JSON.parse(JSON.stringify(allBlastHoles));

					// Apply the rename to the test copy
					if (allHoleBlastNamesFromForm === false) {
						// Test single hole rename
						testBlastHoles[index].entityName = newBlastName;
						const [beforeColon, afterColon] = testBlastHoles[index].fromHoleID.split(":::");
						if (beforeColon === currentEntityName) {
							testBlastHoles[index].fromHoleID = newBlastName + ":::" + afterColon;
						}
					} else {
						// Test all holes rename
						testBlastHoles.forEach((point) => {
							if (point.entityName === currentEntityName) {
								point.entityName = newBlastName;
								const [beforeColon, afterColon] = point.fromHoleID.split(":::");
								if (beforeColon === currentEntityName) {
									point.fromHoleID = newBlastName + ":::" + afterColon;
								}
							}
						});
					}

					// Check for duplicates in test copy
					const duplicateResult = await checkAndResolveDuplicateHoleIDs(testBlastHoles, "rename");

					// If user cancelled, abort the entire operation
					if (duplicateResult && duplicateResult.cancelled) {
						console.log("Rename operation cancelled by user");
						return; // Exit without making any changes
					}

					// ✅ CRITICAL FIX: Apply resolved changes back to original array
					if (duplicateResult && !duplicateResult.cancelled) {
						console.log("🔄 Applying resolved duplicate changes to original data...");

						// Replace the original array with the resolved test copy
						allBlastHoles.length = 0; // Clear original array
						allBlastHoles.push(...testBlastHoles); // Copy resolved data back

						console.log("✅ Applied " + testBlastHoles.length + " resolved holes to original data");

						// Since we already applied all changes (including rename), skip the manual rename section
						// Update tree view and save
						if (typeof updateTreeView === "function") {
							debouncedUpdateTreeView();
						}
						if (typeof savePointsToDB === "function") {
							savePointsToDB();
						}

						drawData(allBlastHoles, selectedHole);
						return; // Exit here since all changes are applied
					}
				}

				// Step 4) If we get here, user approved or no duplicates - proceed with actual rename
				drawData(allBlastHoles, selectedHole);

				if (allHoleBlastNamesFromForm === false) {
					// Update only the selected hole
					console.log("Before:point.fromHoleID : " + allBlastHoles[index].fromHoleID);
					allBlastHoles[index].entityName = newBlastName; // ✅ Use new name

					// Only update fromHoleID if the part before ::: matches the old blast name
					const [beforeColon, afterColon] = allBlastHoles[index].fromHoleID.split(":::");
					if (beforeColon === currentEntityName) {
						allBlastHoles[index].fromHoleID = newBlastName + ":::" + afterColon; // ✅ Use new name
						console.log("Updated fromHoleID for single hole");
					} else {
						console.log("fromHoleID not updated (before ::: doesn't match old blast name)");
					}
					console.log("After:point.fromHoleID : " + allBlastHoles[index].fromHoleID);
				}
				if (allHoleBlastNamesFromForm === true) {
					// Update all holes with the same current entity name
					allBlastHoles.forEach((point) => {
						if (point.entityName === currentEntityName) {
							console.log("Before:point.fromHoleID : " + point.fromHoleID);
							point.entityName = newBlastName; // ✅ Use new name

							// Only update fromHoleID if the part before ::: matches the old blast name
							const [beforeColon, afterColon] = point.fromHoleID.split(":::");
							if (beforeColon === currentEntityName) {
								point.fromHoleID = newBlastName + ":::" + afterColon; // ✅ Use new name
								console.log("Updated fromHoleID for hole: " + point.holeID);
							} else {
								console.log("fromHoleID not updated for hole " + point.holeID + " (before ::: doesn't match old blast name)");
							}
							console.log("After:point.fromHoleID : " + point.fromHoleID);
						}
					});
				}

				// Check for duplicate hole IDs and adjust rowIDs when merging blasts
				if (allHoleBlastNamesFromForm === true && newBlastName !== currentEntityName) {
					// ✅ Use new name
					// Get the max rowID in the target blast (if it exists)
					let maxRowID = 0;
					allBlastHoles.forEach((point) => {
						if (point.entityName === newBlastName && point.rowID) {
							// ✅ Use new name
							maxRowID = Math.max(maxRowID, parseInt(point.rowID) || 0);
						}
					});

					// If merging into an existing blast, adjust rowIDs of the renamed holes
					if (maxRowID > 0) {
						console.log("Merging blast - adjusting rowIDs. Current max rowID in " + newBlastName + ": " + maxRowID); // ✅ Use new name

						// Group renamed holes by their current rowID
						const rowGroups = new Map();
						allBlastHoles.forEach((point) => {
							if (point.entityName === newBlastName && point.fromHoleID && point.fromHoleID.startsWith(currentEntityName + ":::")) {
								// ✅ Use new name
								const currentRow = point.rowID || 1;
								if (!rowGroups.has(currentRow)) {
									rowGroups.set(currentRow, []);
								}
								rowGroups.get(currentRow).push(point);
							}
						});

						// Adjust rowIDs sequentially
						let newRowID = maxRowID;
						Array.from(rowGroups.keys())
							.sort((a, b) => a - b)
							.forEach((oldRowID) => {
								newRowID++;
								rowGroups.get(oldRowID).forEach((point) => {
									console.log("Adjusting hole " + point.holeID + " from row " + oldRowID + " to row " + newRowID);
									point.rowID = newRowID;
								});
							});
					}
				}

				// Update tree view if available
				if (typeof updateTreeView === "function") {
					debouncedUpdateTreeView(); // Use debounced version
				}

				// Save changes to DB if available
				if (typeof savePointsToDB === "function") {
					savePointsToDB();
				}
			}
			drawData(allBlastHoles, selectedHole);
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});
	dialog.show(); // Add this line!
}

function editHoleTypePopup() {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	if (selectedHole) {
		// Use the obtained values to add the hole
		const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
		if (index !== -1) {
			clickedHole = allBlastHoles[index];
		}
	}

	let lastValue = clickedHole.holeType;

	// Create form content using the helper function
	const fields = [
		{
			label: "Type of Hole",
			name: "holeType",
			value: lastValue || "",
			placeholder: "Type"
		}
	];

	const formContent = createFormContent(fields);

	const dialog = new FloatingDialog({
		title: 'Edit the Type of hole "' + selectedHole.holeID + '" ?',
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const holeTypeInput = formContent.querySelector("input[name='holeType']");
			const typeValue = holeTypeInput.value;

			if (selectedHole) {
				// Use the obtained values to add the hole
				const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
				if (index !== -1) {
					clickedHole = allBlastHoles[index];
					//set the pointstype to the new value
					clickedHole.holeType = typeValue;

					drawData(allBlastHoles, selectedHole);
					debouncedUpdateTreeView(); // Use debounced version
				}
			}
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});

	dialog.show();

	// Highlight the input value after dialog shows
	setTimeout(() => {
		const holeTypeInput = formContent.querySelector("input[name='holeType']");
		if (holeTypeInput) {
			holeTypeInput.focus();
			holeTypeInput.select();
		}
	}, 100);
}

function editHoleLengthPopup() {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	if (selectedHole) {
		// Use the obtained values to add the hole
		const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
		if (index !== -1) {
			clickedHole = allBlastHoles[index];
		}
	}

	// Get current calculated hole length
	let currentLength = clickedHole.holeLengthCalculated || 0;

	// Create form content using the helper function
	const fields = [
		{
			label: "Hole Length (m)",
			name: "holeLength",
			type: "number",
			value: currentLength.toFixed(1),
			placeholder: "Length",
			min: "0",
			max: "100",
			step: "0.1"
		}
	];

	const formContent = createFormContent(fields);

	const dialog = new FloatingDialog({
		title: "Edit the length of hole. Hole: " + selectedHole.holeID + " ?",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const lengthInput = formContent.querySelector("input[name='holeLength']");
			const lengthValue = parseFloat(lengthInput.value);

			// Validate input
			if (isNaN(lengthValue) || lengthValue < 0 || lengthValue > 100) {
				// Show error using FloatingDialog
				const errorDialog = new FloatingDialog({
					title: "Invalid Length",
					content: "Please enter a length between 0 and 100 meters.",
					layoutType: "default",
					width: 300,
					height: 120,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false
				});
				errorDialog.show();
				return;
			}

			if (selectedHole) {
				// Use the obtained values to add the hole
				const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
				if (index !== -1) {
					clickedHole = allBlastHoles[index];

					// Update the hole length
					clickedHole.holeLengthCalculated = lengthValue;

					// Calculate endXYZ and draw allBlastHoles
					calculateHoleGeometry(clickedHole, lengthValue, 1);

					// Update the hole length label if it exists
					if (typeof holeLengthLabel !== "undefined" && holeLengthLabel) {
						holeLengthLabel.textContent = "Hole Length : " + lengthValue.toFixed(1) + "m";
					}

					drawData(allBlastHoles, selectedHole);

					// Update tree view if available
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}
				}
			}
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});

	dialog.show();

	// Highlight the input value after dialog shows
	setTimeout(() => {
		const lengthInput = formContent.querySelector("input[name='holeLength']");
		if (lengthInput) {
			lengthInput.focus();
			lengthInput.select();
		}
	}, 100);
}
// measure tool for Length
function measuredLengthPopup() {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	// Create form content using the helper function
	const fields = [
		{
			label: "Length",
			name: "length",
			type: "number",
			value: "0",
			placeholder: "Length"
		}
	];

	const formContent = createFormContent(fields);

	const dialog = new FloatingDialog({
		title: "Record the measured length of hole. Hole: " + selectedHole.holeID + " ?",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const lengthInput = formContent.querySelector("input[name='length']");
			const lengthValue = parseFloat(lengthInput.value);

			if (selectedHole) {
				console.log("selectedHole: " + selectedHole.holeID + " | Hole Length : " + lengthValue + "m");
				const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
				if (index !== -1) {
					clickedHole = allBlastHoles[index];
					//set the pointstype to the new value
					clickedHole.measuredLength = parseFloat(lengthValue);
					clickedHole.measuredLengthTimeStamp = setMeasuredDate();

					console.log("The Hole " + clickedHole.holeID + " Length is : " + clickedHole.measuredLength + " @ " + clickedHole.measuredLengthTimeStamp);

					drawData(allBlastHoles, selectedHole);
				}
			}
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});

	dialog.show();

	// Highlight the input value after dialog shows
	setTimeout(() => {
		const lengthInput = formContent.querySelector("input[name='length']");
		if (lengthInput) {
			lengthInput.focus();
			lengthInput.select();
		}
	}, 100);
}

// measure tool for Mass
function measuredMassPopup() {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	// Create form content using the helper function
	const fields = [
		{
			label: "Mass",
			name: "mass",
			type: "number",
			value: "0",
			placeholder: "Mass"
		}
	];

	const formContent = createFormContent(fields);

	const dialog = new FloatingDialog({
		title: "Record the measured mass of hole (kg/lb) Hole: " + selectedHole.holeID + " ?",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const massInput = formContent.querySelector("input[name='mass']");
			const massValue = massInput.value;

			if (selectedHole) {
				// Use the obtained values to add the hole
				const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
				if (index !== -1) {
					clickedHole = allBlastHoles[index];
					//set the pointstype to the new value
					clickedHole.measuredMass = massValue;
					clickedHole.measuredMassTimeStamp = setMeasuredDate();

					console.log("The Hole " + clickedHole.holeID + " Mass is : " + clickedHole.measuredMass + " @ " + clickedHole.measuredMassTimeStamp);

					drawData(allBlastHoles, selectedHole);
				}
			}
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});

	dialog.show();

	// Highlight the input value after dialog shows
	setTimeout(() => {
		const massInput = formContent.querySelector("input[name='mass']");
		if (massInput) {
			massInput.focus();
			massInput.select();
		}
	}, 100);
}

// measure tool for Comment
function measuredCommentPopup() {
	// ✅ CHECK VISIBILITY FIRST - Don't edit hidden holes
	if (!selectedHole || !isHoleVisible(selectedHole)) {
		console.log("❌ Cannot edit hidden hole: " + (selectedHole ? selectedHole.holeID : "none"));
		return;
	}

	if (selectedHole) {
		// Use the obtained values to add the hole
		const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
		if (index !== -1) {
			clickedHole = allBlastHoles[index];
		}
	}

	let lastValue = clickedHole.measuredComment;

	// Create form content using the helper function
	const fields = [
		{
			label: "Record Comment",
			name: "comment",
			value: lastValue || "",
			placeholder: "Comment"
		}
	];

	const formContent = createFormContent(fields);

	const dialog = new FloatingDialog({
		title: 'Record a comment on the hole "' + selectedHole.holeID + '" ?',
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 160,
		showConfirm: true,
		showCancel: true,
		confirmText: "Confirm",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const commentInput = formContent.querySelector("input[name='comment']");
			const commentValue = commentInput.value;

			if (selectedHole) {
				// Use the obtained values to add the hole
				const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
				if (index !== -1) {
					clickedHole = allBlastHoles[index];
					//set the pointstype to the new value
					clickedHole.measuredComment = commentValue;
					clickedHole.measuredCommentTimeStamp = setMeasuredDate();

					console.log("The Hole " + clickedHole.holeID + " Comment is : " + clickedHole.measuredComment + " @ " + clickedHole.measuredCommentTimeStamp);

					drawData(allBlastHoles, selectedHole);
				}
			}
		},
		onCancel: () => {
			//clear the selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			selectedKADObject = null;
			selectedKADObjects = [];
			selectedMultipleKADObjects = [];
			selectedMultipleKADObjects = [];
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView(); // Use debounced version
		}
	});

	dialog.show();

	// Highlight the input value after dialog shows
	setTimeout(() => {
		const commentInput = formContent.querySelector("input[name='comment']");
		if (commentInput) {
			commentInput.focus();
			commentInput.select();
		}
	}, 100);
}

//===========================================
// FLOATING DIALOG END
//===========================================

//===========================================
// MINIMAL SAFE OVERLAY FOR THE APP
//===========================================

// Global overlay variables
let contourOverlayCanvas = null;
let contourOverlayCtx = null;
let useContourOverlay = false;

// Step 1: Create the contour overlay canvas element
function createContourOverlay() {
	if (contourOverlayCanvas) return;

	const mainCanvas = canvas;
	const container = mainCanvas.parentElement;

	contourOverlayCanvas = document.createElement("canvas");
	contourOverlayCtx = contourOverlayCanvas.getContext("2d");

	contourOverlayCanvas.width = mainCanvas.width;
	contourOverlayCanvas.height = mainCanvas.height;
	contourOverlayCanvas.style.position = "absolute";
	contourOverlayCanvas.style.left = "0";
	contourOverlayCanvas.style.top = "0";
	contourOverlayCanvas.style.zIndex = "10";
	contourOverlayCanvas.style.pointerEvents = "none";
	contourOverlayCanvas.style.width = mainCanvas.style.width;
	contourOverlayCanvas.style.height = mainCanvas.style.height;

	container.appendChild(contourOverlayCanvas);
	console.log("Contour overlay " + "created");
}

// Step 2: Draw contours using the correct data structure (line segments with .x/.y properties)
function drawContoursOnOverlayFixed() {
	if (!contourOverlayCanvas || !useContourOverlay) return;

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (!displayContours.checked || !contourLinesArray) {
		console.log("Contours disabled " + "or no data");
		return;
	}

	//console.log("Drawing overlay contours - " + "levels: " + contourLinesArray.length);
	drawBrightContoursFixed();
}

// Step 3: Draw bright colored contour lines using your actual data structure
function drawBrightContoursFixed() {
	if (!contourLinesArray || contourLinesArray.length === 0) return;

	// Step 3a: Calculate interval
	const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
	let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
	if (typeof intervalAmount !== "undefined") {
		interval = parseInt(intervalAmount);
	}

	// Step 3b: Set up theme-aware contour colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	//console.log("Drawing with interval: " + interval + " (Dark mode: " + darkModeEnabled + ")");

	// Step 3c: Process each contour level
	for (let level = 0; level < contourLinesArray.length; level++) {
		const contourLevel = contourLinesArray[level];
		if (!contourLevel || contourLevel.length === 0) continue;

		const contourTime = level * interval;
		const color = colors[level % colors.length];

		//console.log("Level " + level + " (" + contourTime + "ms): " + contourLevel.length + " lines in " + color);

		// Step 3d: Remove line style settings (handled in drawAlternatingDashLine)
		let linesDrawn = 0;

		// Step 3e: Draw each line segment in this level
		for (let i = 0; i < contourLevel.length; i++) {
			const line = contourLevel[i];
			if (!line || !line[0] || !line[1]) continue;

			// Step 3f: Extract coordinates using your structure (line[0].x, line[0].y, line[1].x, line[1].y)
			const startWorldX = line[0].x;
			const startWorldY = line[0].y;
			const endWorldX = line[1].x;
			const endWorldY = line[1].y;

			// Step 3g: Transform to screen coordinates
			const startScreenX = (startWorldX - centroidX) * currentScale + canvas.width / 2;
			const startScreenY = (-startWorldY + centroidY) * currentScale + canvas.height / 2;
			const endScreenX = (endWorldX - centroidX) * currentScale + canvas.width / 2;
			const endScreenY = (-endWorldY + centroidY) * currentScale + canvas.height / 2;

			// Step 3h: Draw alternating colored dashes
			drawAlternatingDashLine(startScreenX, startScreenY, endScreenX, endScreenY);

			linesDrawn++;

			// Step 3i: Add time labels at 1/3 and 2/3 marks
			const totalLines = contourLevel.length;
			const oneThirdMark = Math.floor(totalLines / 3);
			const twoThirdsMark = Math.floor((totalLines * 2) / 3);

			if (i === oneThirdMark || i === twoThirdsMark) {
				const midX = (startScreenX + endScreenX) / 2;
				const midY = (startScreenY + endScreenY) / 2;
				drawTimeLabelFixed(midX, midY, contourTime + "ms", "#" + "FFFFFF");
			}
		}

		//console.log("Drew " + linesDrawn + " line segments for level " + level);
	}

	//console.log("Bright contours " + "drawn on overlay");
}

// Step 4: Draw alternating colored dash lines (10px magenta, 10px yellow/green)
function drawAlternatingDashLine(x1, y1, x2, y2) {
	// Step 4a: Calculate line properties
	const totalLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	const angle = Math.atan2(y2 - y1, x2 - x1);
	const dashLength = 10; // 10px dashes

	// Step 4b: Theme-aware dash colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	contourOverlayCtx.lineWidth = 3;
	contourOverlayCtx.lineCap = "butt";

	let currentDistance = 0;
	let colorIndex = 0;

	// Step 4b: Draw alternating colored segments
	while (currentDistance < totalLength) {
		const segmentStart = currentDistance;
		const segmentEnd = Math.min(currentDistance + dashLength, totalLength);

		// Step 4c: Calculate segment coordinates
		const startX = x1 + Math.cos(angle) * segmentStart;
		const startY = y1 + Math.sin(angle) * segmentStart;
		const endX = x1 + Math.cos(angle) * segmentEnd;
		const endY = y1 + Math.sin(angle) * segmentEnd;

		// Step 4d: Draw segment with alternating color
		contourOverlayCtx.strokeStyle = colors[colorIndex % colors.length];
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(startX, startY);
		contourOverlayCtx.lineTo(endX, endY);
		contourOverlayCtx.stroke();

		currentDistance += dashLength;
		colorIndex++;
	}
}
// Step 5: Draw time labels with theme-aware colors
function drawTimeLabelFixed(x, y, text, color) {
	// Step 5a: Use theme-aware background color
	const backgroundColor = darkModeEnabled ? "rgba(0, 0, 0,0.6)" : "rgba(255, 255, 255,0.6)";

	contourOverlayCtx.fillStyle = backgroundColor;
	contourOverlayCtx.font = "bold " + "16px Arial";
	const metrics = contourOverlayCtx.measureText(text);
	const padding = 6;
	// Step 5a1: Draw rounded rectangle background
	const rectX = x - metrics.width / 2 - padding;
	const rectY = y - 8 - padding;
	const rectWidth = metrics.width + padding * 2;
	const rectHeight = 16 + padding * 2;
	const radius = 4;

	contourOverlayCtx.beginPath();
	contourOverlayCtx.moveTo(rectX + radius, rectY);
	contourOverlayCtx.lineTo(rectX + rectWidth - radius, rectY);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
	contourOverlayCtx.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
	contourOverlayCtx.lineTo(rectX + radius, rectY + rectHeight);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
	contourOverlayCtx.lineTo(rectX, rectY + radius);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
	contourOverlayCtx.closePath();
	contourOverlayCtx.fill();

	// Step 5b: Use standard text color from your theme system
	contourOverlayCtx.fillStyle = textFillColor; // Uses your global theme variable
	contourOverlayCtx.textAlign = "center";
	contourOverlayCtx.textBaseline = "middle";
	contourOverlayCtx.fillText(text, x, y);
}
// Step 5X: Toggle overlay on/off
function toggleContourOverlayFixed() {
	useContourOverlay = !useContourOverlay;

	if (useContourOverlay) {
		// Step 5a: Create overlay canvas
		createContourOverlay();

		// Step 5b: Enable contours if needed
		if (!displayContours.checked) {
			displayContours.checked = true;
			drawData(allBlastHoles, selectedHole);
		}

		// Step 5c: Draw contours on overlay
		setTimeout(() => {
			drawContoursOnOverlayFixed();
		}, 100);
	} else {
		// Step 5d: Clear overlay when disabled
		if (contourOverlayCanvas) {
			contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
		}
	}
}

// Step 6: Update overlay colors when dark mode changes
function updateOverlayColorsForTheme() {
	if (useContourOverlay) {
		drawContoursOnOverlayFixed(); // Redraw with new colorsß
	}
}

// Step 7: Hook into your existing dark mode system
function hookOverlayIntoThemeSystem() {
	// Step 7a: Hook into your updateColorsForDarkMode function
	const originalUpdateColors = window.updateColorsForDarkMode;
	if (typeof originalUpdateColors === "function") {
		window.updateColorsForDarkMode = function () {
			const result = originalUpdateColors.apply(this, arguments);
			updateOverlayColorsForTheme(); // Update overlay when theme changes
			return result;
		};
		console.log("🎨 Overlay hooked into theme system");
	}

	// Step 7b: Hook into dark mode toggle
	const darkModeToggle = document.getElementById("darkModeToggle");
	if (darkModeToggle) {
		darkModeToggle.addEventListener("change", function () {
			setTimeout(() => {
				updateOverlayColorsForTheme(); // Update overlay after theme change
			}, 50);
		});
	}
}

function debugCorrectVariables() {
	console.log("=== USING YOUR EXACT VARIABLES ===");
	console.log("displayContours.checked: " + (typeof displayContours !== "undefined" ? displayContours.checked : "undefined"));
	console.log("contourLinesArray: " + (typeof contourLinesArray !== "undefined" ? contourLinesArray?.length + " levels" : "undefined"));
	console.log("centroidX: " + (typeof centroidX !== "undefined" ? centroidX : "undefined"));
	console.log("centroidY: " + (typeof centroidY !== "undefined" ? centroidY : "undefined"));
	console.log("currentScale: " + (typeof currentScale !== "undefined" ? currentScale : "undefined"));
	console.log("canvas size: " + (typeof canvas !== "undefined" ? canvas.width + "x" + canvas.height : "undefined"));
}

function testDrawOnOverlay() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	// Step 7a: Draw bright test rectangle
	contourOverlayCtx.fillStyle = "#FF0000";
	contourOverlayCtx.fillRect(100, 100, 200, 200);

	// Step 7b: Draw bright test text
	contourOverlayCtx.fillStyle = "#FFFF00";
	contourOverlayCtx.font = "bold " + "32px Arial";
	contourOverlayCtx.fillText("OVERLAY TEST", 150, 150);

	console.log("Drew test rectangle " + "and text on overlay");
}

function drawTestContourLine() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (allBlastHoles && allBlastHoles.length >= 2) {
		const hole1 = allBlastHoles[0];
		const hole2 = allBlastHoles[1];

		// Step 7c: Use same coordinate transformation as contours
		const x1 = (hole1.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y1 = (-hole1.startYLocation + centroidY) * currentScale + canvas.height / 2;
		const x2 = (hole2.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y2 = (-hole2.startYLocation + centroidY) * currentScale + canvas.height / 2;

		console.log("Drawing test line from " + x1 + "," + y1 + " to " + x2 + "," + y2);

		// Step 7d: Draw bright test line
		contourOverlayCtx.strokeStyle = "#00FF00";
		contourOverlayCtx.lineWidth = 5;
		contourOverlayCtx.setLineDash([]);
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(x1, y1);
		contourOverlayCtx.lineTo(x2, y2);
		contourOverlayCtx.stroke();

		// Step 7e: Add markers at endpoints
		contourOverlayCtx.fillStyle = "#" + "FF0000";
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x1, y1, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x2, y2, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();

		console.log("Drew test line between " + "first two blast holes");
	}
}

// Step 8: Auto-update hooks - Add these to integrate with your existing code
function hookOverlayIntoExistingFunctions() {
	// Step 8a: Hook into drawData function
	if (typeof window.drawData === "function") {
		const originalDrawData = window.drawData;
		window.drawData = function () {
			const result = originalDrawData.apply(this, arguments);
			updateOverlayColorsForTheme(); // Auto-update overlay
			return result;
		};
		console.log("Hooked into drawData");
	}

	// Step 8b: Hook into recalculateContours function
	if (typeof window.recalculateContours === "function") {
		const originalRecalculateContours = window.recalculateContours;
		window.recalculateContours = function () {
			const result = originalRecalculateContours.apply(this, arguments);
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 50); // Small delay for data to update
			}
			return result;
		};
		console.log("Hooked into recalculateContours");
	}

	// Step 8c: Hook into pan/zoom events if canvas has event listeners
	const originalAddEventListener = canvas.addEventListener;
	canvas.addEventListener = function (event, handler) {
		if (event === "wheel" || event === "mousemove") {
			const wrappedHandler = function () {
				const result = handler.apply(this, arguments);
				if (useContourOverlay) {
					updateOverlayColorsForTheme();
				}
				return result;
			};
			return originalAddEventListener.call(this, event, wrappedHandler);
		}
		return originalAddEventListener.call(this, event, handler);
	};

	// Step 8d: Hook into contour checkbox changes
	const contourCheckbox = displayContours;
	if (contourCheckbox && contourCheckbox.addEventListener) {
		contourCheckbox.addEventListener("change", function () {
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 100);
			}
		});
		console.log("Hooked into contour checkbox");
	}
}

// Add after your existing hookOverlayIntoExistingFunctions()
function hookOverlayIntoResize() {
	window.addEventListener("resize", function () {
		if (contourOverlayCanvas && useContourOverlay) {
			// Resize overlay to match main canvas
			contourOverlayCanvas.width = canvas.width;
			contourOverlayCanvas.height = canvas.height;
			contourOverlayCanvas.style.width = canvas.style.width;
			contourOverlayCanvas.style.height = canvas.style.height;

			// Redraw with new size
			setTimeout(() => updateContourOverlay(), 100);
		}
	});
	console.log("Hooked into window resize");
}

// Add this to your enableAutoUpdate() function:
function enableAutoUpdate() {
	hookOverlayIntoExistingFunctions();
	hookOverlayIntoThemeSystem();
	hookOverlayIntoResize(); // Add this line
	console.log("Auto-update enabled - overlay will update automatically");
}

// Step 10: Usage instructions with auto-update
console.log("Complete overlay system ready:");
console.log("1. debugContourStructure() - Check your contour data structure");
console.log("2. debugCorrectVariables() - Check variable availability");
console.log("3. testDrawOnOverlay() - Test overlay with simple shapes");
console.log("4. drawTestContourLine() - Test with blast hole coordinates");
console.log("5. toggleContourOverlayFixed() - Enable bright contour overlay");
console.log("6. enableAutoUpdate() - Enable automatic updates (RECOMMENDED)");
console.log("7. updateOverlayColorsForTheme() - Manual update if needed");
console.log("Theme-aware overlay system ready:");
console.log("- Colors automatically adapt to light/dark mode");
console.log("- Text uses standard theme colors (textFillColor)");
console.log("- Backgrounds use theme-appropriate opacity");
console.log("- Updates automatically when theme changes");

// Auto-enable the hooks when overlay system loads
console.log("Setting up auto-update hooks...");
if (typeof window.drawData === "function") {
	enableAutoUpdate();
}

//===========================================
// END OF MINIMAL SAFE OVERLAY FOR THE APP
//===========================================

//===========================================
// Web worker for Delaunay Contours and Hole Hole Times.
//===========================================

// INLINE WEB WORKER FOR MONOLITH - Add this to your kirra.js file

// FIXED: Replace the contourWorkerCode with this corrected version
const contourWorkerCode = `
// Import D3 for Delaunay triangulation in worker
importScripts('https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js');

self.onmessage = function(e) {
    const { type, data } = e.data;
    
    try {
        switch(type) {
            case 'CALCULATE_CONTOURS':
                const result = calculateContoursInWorker(data);
                self.postMessage({
                    type: 'CONTOURS_RESULT',
                    data: result,
                    success: true
                });
                break;
                
            default:
                throw new Error('Unknown message type: ' + type);
        }
    } catch (error) {
        self.postMessage({
            type: 'ERROR',
            error: error.message,
            success: false
        });
    }
};

// Step 1) Interpolation function - essential for contour crossing points
function interpolate(p1, p2, contourLevel) {
    const t = (contourLevel - p1.z) / (p2.z - p1.z);
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}

// Step 2) Main contour calculation function - fixed to match sync version
function calculateContoursInWorker(workerData) {
    const { 
        contourData, 
        contourLevels,  // Changed: now expects array of levels
        maxEdgeLength,
        displayContours,
        displayFirstMovements,
        displayRelief,
        firstMovementSize = 2
    } = workerData;
    
    // Step 3) Early return if no display options enabled
    if (!displayContours && !displayFirstMovements && !displayRelief) {
        return {
            contourLinesArray: [],
            directionArrows: []
        };
    }

    if (!contourData || !Array.isArray(contourData) || contourData.length === 0) {
        return { contourLinesArray: [], directionArrows: [] };
    }

    const factor = 1.6;
    const minAngleThreshold = 5;
    const surfaceAreaThreshold = 0.1;

    // Step 4) Filter out holes where holeTime is null
    const filteredContourData = contourData.filter(hole => hole.holeTime !== null);
    
    if (filteredContourData.length < 3) {
        return { contourLinesArray: [], directionArrows: [] };
    }

    // Step 5) Helper function for distance calculation
    function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
        const distances = [];

        for (let i = 0; i < allPoints.length; i++) {
            if (allPoints[i] === targetPoint) continue;

            const dx = targetPoint.x - allPoints[i].x;
            const dy = targetPoint.y - allPoints[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            distances.push(distance);
        }

        distances.sort((a, b) => a - b);
        const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

        return nearestDistances.length > 0 ?
            nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length :
            maxEdgeLength;
    }

    // Step 6) Cache for performance
    const localAverageCache = new Map();
    function getCachedLocalAverage(point) {
        if (!localAverageCache.has(point)) {
            localAverageCache.set(point, getLocalAverageDistance(point, filteredContourData, 6));
        }
        return localAverageCache.get(point);
    }

    // Step 7) Compute Delaunay triangulation
    const delaunay = d3.Delaunay.from(filteredContourData.map(hole => [hole.x, hole.y]));
    const triangles = delaunay.triangles;

    if (!triangles || triangles.length === 0) {
        return { contourLinesArray: [], directionArrows: [] };
    }

    const contourLinesArray = [];
    const directionArrows = [];

    // Step 8) Process each contour level
    for (let levelIndex = 0; levelIndex < contourLevels.length; levelIndex++) {
        const contourLevel = contourLevels[levelIndex];
        const contourLines = [];

        // Step 9) Process triangles for this contour level
        for (let i = 0; i < triangles.length; i += 3) {
            const contourLine = [];

            const p1 = contourData[triangles[i]];
            const p2 = contourData[triangles[i + 1]];
            const p3 = contourData[triangles[i + 2]];

            // Step 10) Get cached local average distances for adaptive filtering
            const p1LocalAvg = getCachedLocalAverage(p1);
            const p2LocalAvg = getCachedLocalAverage(p2);
            const p3LocalAvg = getCachedLocalAverage(p3);

            const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;
            const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

            // Step 11) Calculate triangle properties for direction arrows
            const centroidX = (p1.x + p2.x + p3.x) / 3;
            const centroidY = (p1.y + p2.y + p3.y) / 3;

            // Step 12) Calculate edge lengths and check filtering
            const edge1Length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const edge2Length = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
            const edge3Length = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));

            let trianglePassesFilter = true;
            if (edge1Length > adaptiveMaxEdgeLength || edge2Length > adaptiveMaxEdgeLength || edge3Length > adaptiveMaxEdgeLength) {
                trianglePassesFilter = false;
            }

            // Step 13) Check triangle angles to reject acute triangles
            if (trianglePassesFilter) {
                const edge1Squared = edge1Length * edge1Length;
                const edge2Squared = edge2Length * edge2Length;
                const edge3Squared = edge3Length * edge3Length;

                const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2Length * edge3Length)))) * (180 / Math.PI);
                const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1Length * edge3Length)))) * (180 / Math.PI);
                const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1Length * edge2Length)))) * (180 / Math.PI);

                const minAngle = Math.min(angle1, angle2, angle3);
                if (minAngle < minAngleThreshold) {
                    trianglePassesFilter = false;
                }
            }

            // Step 14) Only process triangles that pass filtering
            if (trianglePassesFilter) {
                // Step 15) Create direction arrows for first movement
                if (levelIndex === 0 && displayFirstMovements) {
                    const surfaceArea = Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);
                    
                    if (surfaceArea > surfaceAreaThreshold) {
                        const v1X = p2.x - p1.x;
                        const v1Y = p2.y - p1.y;
                        const v1Z = p2.z - p1.z;

                        const v2X = p3.x - p1.x;
                        const v2Y = p3.y - p1.y;
                        const v2Z = p3.z - p1.z;

                        const slopeX = v1Y * v2Z - v1Z * v2Y;
                        const slopeY = v1Z * v2X - v1X * v2Z;
                        const slopeLength = Math.sqrt(slopeX * slopeX + slopeY * slopeY);
                        
                        if (slopeLength > 0) {
                            const normSlopeX = slopeX / slopeLength;
                            const normSlopeY = slopeY / slopeLength;
                            
                            const arrowEndX = centroidX - normSlopeX * firstMovementSize;
                            const arrowEndY = centroidY - normSlopeY * firstMovementSize;
                            
                            directionArrows.push([centroidX, centroidY, arrowEndX, arrowEndY, "goldenrod", firstMovementSize]);
                        }
                    }
                }

                // Step 16) FIXED: Check each edge for contour level crossings
                for (let j = 0; j < 3; j++) {
                    const edgeP1 = contourData[triangles[i + j]];
                    const edgeP2 = contourData[triangles[i + ((j + 1) % 3)]];

                    // Step 17) Calculate distance between edge points
                    const distance = Math.sqrt(Math.pow(edgeP2.x - edgeP1.x, 2) + Math.pow(edgeP2.y - edgeP1.y, 2));

                    // Step 18) CRITICAL: Only create contour point if level crosses the edge
                    if (distance <= adaptiveMaxEdgeLength && 
                        ((edgeP1.z < contourLevel && edgeP2.z >= contourLevel) || 
                         (edgeP1.z >= contourLevel && edgeP2.z < contourLevel))) {
                        
                        // Step 19) Interpolate to find exact crossing point
                        const point = interpolate(edgeP1, edgeP2, contourLevel);
                        contourLine.push(point);
                    }
                }

                // Step 20) Only add contour line if it has exactly 2 points (proper line segment)
                if (contourLine.length === 2) {
                    contourLines.push(contourLine);
                }
            }
        }

        // Step 21) Add this level's contour lines to the array
        contourLinesArray.push(contourLines);
    }

    // Step 22) Filter direction arrows 
    const interval = 1;
    const filteredArrows = directionArrows.filter((arrow, index) => index % interval === 0);

    return {
        contourLinesArray,
        directionArrows: filteredArrows
    };
}

console.log('Fixed contour worker ready');
`;

// Step 2: Create Blob URL worker
let contourWorker = null;
let contourWorkerBusy = false;

// Step 2a: ADD THE MISSING FUNCTION - Create the worker from the inline code
function createInlineContourWorker() {
	try {
		const blob = new Blob([contourWorkerCode], { type: "application/javascript" });
		const workerUrl = URL.createObjectURL(blob);
		contourWorker = new Worker(workerUrl);

		contourWorker.onmessage = function (e) {
			const { type, data, success, error } = e.data;

			contourWorkerBusy = false;

			if (!success) {
				console.error("Contour worker error:", error);
				return;
			}

			if (type === "CONTOURS_RESULT") {
				// Step 2b: Format result to match your existing data structure
				const formattedResult = formatWorkerResult(data);

				// Step 2c: Update global variables
				contourLinesArray = formattedResult.contourLinesArray;
				directionArrows = formattedResult.directionArrows;

				// Step 2d: Update overlay
				if (typeof updateOverlayColorsForTheme === "function") {
					updateOverlayColorsForTheme();
				}

				// Step 2e: Redraw main canvas
				drawData(allBlastHoles, selectedHole);

				console.log("Worker contour calculation completed:", formattedResult.contourLinesArray.length + " levels");
			}
		};

		contourWorker.onerror = function (error) {
			console.error("Contour worker error:", error);
			contourWorkerBusy = false;
		};

		console.log("Inline contour worker created successfully");
		return true;
	} catch (error) {
		console.error("Failed to create inline worker:", error);
		return false;
	}
}

// Step 2f: FIXED - Format worker result to match your existing structure
function formatWorkerResult(workerResult) {
	// Worker now returns properly formatted contourLinesArray directly
	return {
		contourLinesArray: workerResult.contourLinesArray || [],
		directionArrows: workerResult.directionArrows || []
	};
}

// ... rest of your existing code (delaunayContours function, etc.) ...

// Step 23) FIXED: Update the worker data preparation
function delaunayContours(contourData, contourLevel, maxEdgeLength) {
	if (contourWorker && !contourWorkerBusy) {
		contourWorkerBusy = true;

		// Step 24) Calculate all contour levels like the sync version
		const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
		let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
		if (typeof intervalAmount !== "undefined") {
			interval = parseInt(intervalAmount);
		}

		const numLevels = Math.ceil(maxHoleTime / interval) || 13;
		const contourLevels = [];
		for (let level = 0; level < numLevels; level++) {
			contourLevels.push(level * interval);
		}

		const workerData = {
			contourData: contourData.map((hole) => ({
				x: hole.x,
				y: hole.y,
				z: hole.z || hole.holeTime || 0,
				holeTime: hole.holeTime
			})),
			contourLevels: contourLevels, // Pass all levels
			maxEdgeLength: maxEdgeLength,
			displayContours: displayContours ? displayContours.checked : false,
			displayFirstMovements: displayFirstMovements ? displayFirstMovements.checked : false,
			displayRelief: displayRelief ? displayRelief.checked : false,
			firstMovementSize: firstMovementSize || 2
		};

		contourWorker.postMessage({
			type: "CALCULATE_CONTOURS",
			data: workerData
		});

		return {
			contourLines: [],
			directionArrows: []
		};
	} else {
		return delaunayContoursSync(contourData, contourLevel, maxEdgeLength);
	}
}

// Step 25) FIXED: Update the result formatting
function formatWorkerResult(workerResult) {
	// Worker now returns properly formatted contourLinesArray
	return {
		contourLinesArray: workerResult.contourLinesArray,
		directionArrows: workerResult.directionArrows
	};
}

// Step 5: Initialize worker after DOM loads
function initInlineContourWorker() {
	if (createInlineContourWorker()) {
		console.log("🚀 Contour calculations now run in web worker - UI will stay responsive!");
	} else {
		console.log("Worker creation failed - using main thread fallback");
	}
}

// Initialize worker when page loads
if (document.readyState === "loading") {
	document.addEventListener("DOMContentLoaded", initInlineContourWorker);
} else {
	initInlineContourWorker();
}

// Clean up worker on page unload
window.addEventListener("beforeunload", function () {
	if (contourWorker) {
		contourWorker.terminate();
	}
});

//===========================================
// END OF Web worker for Delaunay Contours and Hole Hole Times.
//===========================================

document.addEventListener("DOMContentLoaded", function () {
	console.log("🚀 Starting application initialization...");

	// Add click handlers for all file import icon buttons
	const fileImportButtons = document.querySelectorAll(".file-import-btn");

	fileImportButtons.forEach((button) => {
		button.addEventListener("click", function () {
			const targetId = this.getAttribute("data-target");
			const fileInput = document.getElementById(targetId);
			if (fileInput) {
				fileInput.click();
			}
		});
	});

	// Just hide the panel
	const treePanel = document.getElementById("treePanel");
	if (treePanel) {
		treePanel.style.display = "none";
	}

	// Initialize TreeView ONLY when the button is first clicked
	document.getElementById("showTreeBtn").addEventListener("click", function () {
		// Create TreeView on first use
		if (!treeView) {
			console.log("🌳 Creating TreeView for first time...");
			treeView = new TreeView("treePanel");
			updateTreeView();
		}

		// Toggle panel visibility
		const treePanel = document.getElementById("treePanel");
		if (treePanel) {
			if (treePanel.style.display === "none" || !treePanel.style.display) {
				treePanel.style.display = "flex";
			} else {
				treePanel.style.display = "none";
			}
		}
	});

	addPlaySpeedMarkers();
	updateConnectDistance(); // Set initial value based on current slider position
	addConnectDistanceMarkers(); // Add visual scale markers

	// ⭐ CRITICAL: Add handleMouseMove and handleTouchMove listeners ONLY ONCE here
	// These are for general mouse tracking and crosshairs, and should always be active.
	// Ensure 'canvas' is defined globally or accessible here.
	if (typeof canvas !== "undefined" && canvas !== null) {
		// Add a check for 'canvas' existence
		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("touchmove", handleTouchMove);
	}
	// Also add to document if you need tracking outside the canvas area.
	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("touchmove", handleTouchMove);
	// Initialize overlay system automatically
	setTimeout(() => {
		if (typeof debugCorrectVariables === "function") {
			debugCorrectVariables(); // Check variables are ready
			enableAutoUpdate(); // Set up automatic hooks
			console.log("Overlay system initialized and ready");
		}
	}, 1000); // Small delay to ensure all your variables are loaded
	// The rest of your initialization code...
	setTimeout(function () {
		getDarkModeSettings();
		// updatePopup(); // remove and call from the initDB function
		initializeVoronoiControls();

		// Longer delay for jscolor
		setTimeout(function () {
			initializePreferences();
		}, 200);

		console.log("✅ Application initialization complete");
		debugPreferences();
	}, 50);
});
