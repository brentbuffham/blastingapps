var EE = (n, e) => () => (e || n((e = { exports: {} }).exports, e), e.exports);
var BB = EE((_e) => {
	(function () {
		const e = document.createElement("link").relList;
		if (e && e.supports && e.supports("modulepreload")) return;
		for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
		new MutationObserver((r) => {
			for (const s of r) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
		}).observe(document, { childList: !0, subtree: !0 });
		function t(r) {
			const s = {};
			return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? (s.credentials = "include") : r.crossOrigin === "anonymous" ? (s.credentials = "omit") : (s.credentials = "same-origin"), s;
		}
		function i(r) {
			if (r.ep) return;
			r.ep = !0;
			const s = t(r);
			fetch(r.href, s);
		}
	})();
	var gp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
	function U_(n) {
		return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
	}
	var wE = { exports: {} };
	/*!
	 * Bootstrap v5.3.3 (https://getbootstrap.com/)
	 * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	 */ (function (n, e) {
		(function (t, i) {
			n.exports = i();
		})(gp, function () {
			const t = new Map(),
				i = {
					set(C, m, E) {
						t.has(C) || t.set(C, new Map());
						const I = t.get(C);
						I.has(m) || I.size === 0 ? I.set(m, E) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(I.keys())[0]}.`);
					},
					get: (C, m) => (t.has(C) && t.get(C).get(m)) || null,
					remove(C, m) {
						if (!t.has(C)) return;
						const E = t.get(C);
						E.delete(m), E.size === 0 && t.delete(C);
					}
				},
				r = "transitionend",
				s = (C) => (C && window.CSS && window.CSS.escape && (C = C.replace(/#([^\s"#']+)/g, (m, E) => `#${CSS.escape(E)}`)), C),
				a = (C) => {
					C.dispatchEvent(new Event(r));
				},
				o = (C) => !(!C || typeof C != "object") && (C.jquery !== void 0 && (C = C[0]), C.nodeType !== void 0),
				l = (C) => (o(C) ? (C.jquery ? C[0] : C) : typeof C == "string" && C.length > 0 ? document.querySelector(s(C)) : null),
				c = (C) => {
					if (!o(C) || C.getClientRects().length === 0) return !1;
					const m = getComputedStyle(C).getPropertyValue("visibility") === "visible",
						E = C.closest("details:not([open])");
					if (!E) return m;
					if (E !== C) {
						const I = C.closest("summary");
						if ((I && I.parentNode !== E) || I === null) return !1;
					}
					return m;
				},
				u = (C) => !C || C.nodeType !== Node.ELEMENT_NODE || !!C.classList.contains("disabled") || (C.disabled !== void 0 ? C.disabled : C.hasAttribute("disabled") && C.getAttribute("disabled") !== "false"),
				h = (C) => {
					if (!document.documentElement.attachShadow) return null;
					if (typeof C.getRootNode == "function") {
						const m = C.getRootNode();
						return m instanceof ShadowRoot ? m : null;
					}
					return C instanceof ShadowRoot ? C : C.parentNode ? h(C.parentNode) : null;
				},
				d = () => {},
				f = (C) => {
					C.offsetHeight;
				},
				v = () => (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null),
				_ = [],
				p = () => document.documentElement.dir === "rtl",
				g = (C) => {
					var m;
					(m = () => {
						const E = v();
						if (E) {
							const I = C.NAME,
								q = E.fn[I];
							(E.fn[I] = C.jQueryInterface), (E.fn[I].Constructor = C), (E.fn[I].noConflict = () => ((E.fn[I] = q), C.jQueryInterface));
						}
					}),
						document.readyState === "loading"
							? (_.length ||
									document.addEventListener("DOMContentLoaded", () => {
										for (const E of _) E();
									}),
							  _.push(m))
							: m();
				},
				x = (C, m = [], E = C) => (typeof C == "function" ? C(...m) : E),
				b = (C, m, E = !0) => {
					if (!E) return void x(C);
					const I =
						((ce) => {
							if (!ce) return 0;
							let { transitionDuration: be, transitionDelay: Oe } = window.getComputedStyle(ce);
							const $e = Number.parseFloat(be),
								qe = Number.parseFloat(Oe);
							return $e || qe ? ((be = be.split(",")[0]), (Oe = Oe.split(",")[0]), 1e3 * (Number.parseFloat(be) + Number.parseFloat(Oe))) : 0;
						})(m) + 5;
					let q = !1;
					const J = ({ target: ce }) => {
						ce === m && ((q = !0), m.removeEventListener(r, J), x(C));
					};
					m.addEventListener(r, J),
						setTimeout(() => {
							q || a(m);
						}, I);
				},
				T = (C, m, E, I) => {
					const q = C.length;
					let J = C.indexOf(m);
					return J === -1 ? (!E && I ? C[q - 1] : C[0]) : ((J += E ? 1 : -1), I && (J = (J + q) % q), C[Math.max(0, Math.min(J, q - 1))]);
				},
				P = /[^.]*(?=\..*)\.|.*/,
				A = /\..*/,
				M = /::\d+$/,
				w = {};
			let y = 1;
			const S = { mouseenter: "mouseover", mouseleave: "mouseout" },
				L = new Set([
					"click",
					"dblclick",
					"mouseup",
					"mousedown",
					"contextmenu",
					"mousewheel",
					"DOMMouseScroll",
					"mouseover",
					"mouseout",
					"mousemove",
					"selectstart",
					"selectend",
					"keydown",
					"keypress",
					"keyup",
					"orientationchange",
					"touchstart",
					"touchmove",
					"touchend",
					"touchcancel",
					"pointerdown",
					"pointermove",
					"pointerup",
					"pointerleave",
					"pointercancel",
					"gesturestart",
					"gesturechange",
					"gestureend",
					"focus",
					"blur",
					"change",
					"reset",
					"select",
					"submit",
					"focusin",
					"focusout",
					"load",
					"unload",
					"beforeunload",
					"resize",
					"move",
					"DOMContentLoaded",
					"readystatechange",
					"error",
					"abort",
					"scroll"
				]);
			function N(C, m) {
				return (m && `${m}::${y++}`) || C.uidEvent || y++;
			}
			function k(C) {
				const m = N(C);
				return (C.uidEvent = m), (w[m] = w[m] || {}), w[m];
			}
			function B(C, m, E = null) {
				return Object.values(C).find((I) => I.callable === m && I.delegationSelector === E);
			}
			function W(C, m, E) {
				const I = typeof m == "string",
					q = I ? E : m || E;
				let J = K(C);
				return L.has(J) || (J = C), [I, q, J];
			}
			function H(C, m, E, I, q) {
				if (typeof m != "string" || !C) return;
				let [J, ce, be] = W(m, E, I);
				m in S &&
					(ce = ((_t) =>
						function (gt) {
							if (!gt.relatedTarget || (gt.relatedTarget !== gt.delegateTarget && !gt.delegateTarget.contains(gt.relatedTarget))) return _t.call(this, gt);
						})(ce));
				const Oe = k(C),
					$e = Oe[be] || (Oe[be] = {}),
					qe = B($e, ce, J ? E : null);
				if (qe) return void (qe.oneOff = qe.oneOff && q);
				const Ge = N(ce, m.replace(P, "")),
					St = J
						? (function (ht, _t, gt) {
								return function yt(Xt) {
									const Zt = ht.querySelectorAll(_t);
									for (let { target: Mt } = Xt; Mt && Mt !== this; Mt = Mt.parentNode) for (const kt of Zt) if (kt === Mt) return ue(Xt, { delegateTarget: Mt }), yt.oneOff && G.off(ht, Xt.type, _t, gt), gt.apply(Mt, [Xt]);
								};
						  })(C, E, ce)
						: (function (ht, _t) {
								return function gt(yt) {
									return ue(yt, { delegateTarget: ht }), gt.oneOff && G.off(ht, yt.type, _t), _t.apply(ht, [yt]);
								};
						  })(C, ce);
				(St.delegationSelector = J ? E : null), (St.callable = ce), (St.oneOff = q), (St.uidEvent = Ge), ($e[Ge] = St), C.addEventListener(be, St, J);
			}
			function z(C, m, E, I, q) {
				const J = B(m[E], I, q);
				J && (C.removeEventListener(E, J, !!q), delete m[E][J.uidEvent]);
			}
			function X(C, m, E, I) {
				const q = m[E] || {};
				for (const [J, ce] of Object.entries(q)) J.includes(I) && z(C, m, E, ce.callable, ce.delegationSelector);
			}
			function K(C) {
				return (C = C.replace(A, "")), S[C] || C;
			}
			const G = {
				on(C, m, E, I) {
					H(C, m, E, I, !1);
				},
				one(C, m, E, I) {
					H(C, m, E, I, !0);
				},
				off(C, m, E, I) {
					if (typeof m != "string" || !C) return;
					const [q, J, ce] = W(m, E, I),
						be = ce !== m,
						Oe = k(C),
						$e = Oe[ce] || {},
						qe = m.startsWith(".");
					if (J === void 0) {
						if (qe) for (const Ge of Object.keys(Oe)) X(C, Oe, Ge, m.slice(1));
						for (const [Ge, St] of Object.entries($e)) {
							const ht = Ge.replace(M, "");
							(be && !m.includes(ht)) || z(C, Oe, ce, St.callable, St.delegationSelector);
						}
					} else {
						if (!Object.keys($e).length) return;
						z(C, Oe, ce, J, q ? E : null);
					}
				},
				trigger(C, m, E) {
					if (typeof m != "string" || !C) return null;
					const I = v();
					let q = null,
						J = !0,
						ce = !0,
						be = !1;
					m !== K(m) && I && ((q = I.Event(m, E)), I(C).trigger(q), (J = !q.isPropagationStopped()), (ce = !q.isImmediatePropagationStopped()), (be = q.isDefaultPrevented()));
					const Oe = ue(new Event(m, { bubbles: J, cancelable: !0 }), E);
					return be && Oe.preventDefault(), ce && C.dispatchEvent(Oe), Oe.defaultPrevented && q && q.preventDefault(), Oe;
				}
			};
			function ue(C, m = {}) {
				for (const [E, I] of Object.entries(m))
					try {
						C[E] = I;
					} catch {
						Object.defineProperty(C, E, { configurable: !0, get: () => I });
					}
				return C;
			}
			function ae(C) {
				if (C === "true") return !0;
				if (C === "false") return !1;
				if (C === Number(C).toString()) return Number(C);
				if (C === "" || C === "null") return null;
				if (typeof C != "string") return C;
				try {
					return JSON.parse(decodeURIComponent(C));
				} catch {
					return C;
				}
			}
			function Ue(C) {
				return C.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
			}
			const Z = {
				setDataAttribute(C, m, E) {
					C.setAttribute(`data-bs-${Ue(m)}`, E);
				},
				removeDataAttribute(C, m) {
					C.removeAttribute(`data-bs-${Ue(m)}`);
				},
				getDataAttributes(C) {
					if (!C) return {};
					const m = {},
						E = Object.keys(C.dataset).filter((I) => I.startsWith("bs") && !I.startsWith("bsConfig"));
					for (const I of E) {
						let q = I.replace(/^bs/, "");
						(q = q.charAt(0).toLowerCase() + q.slice(1, q.length)), (m[q] = ae(C.dataset[I]));
					}
					return m;
				},
				getDataAttribute: (C, m) => ae(C.getAttribute(`data-bs-${Ue(m)}`))
			};
			class ie {
				static get Default() {
					return {};
				}
				static get DefaultType() {
					return {};
				}
				static get NAME() {
					throw new Error('You have to implement the static method "NAME", for each component!');
				}
				_getConfig(m) {
					return (m = this._mergeConfigObj(m)), (m = this._configAfterMerge(m)), this._typeCheckConfig(m), m;
				}
				_configAfterMerge(m) {
					return m;
				}
				_mergeConfigObj(m, E) {
					const I = o(E) ? Z.getDataAttribute(E, "config") : {};
					return { ...this.constructor.Default, ...(typeof I == "object" ? I : {}), ...(o(E) ? Z.getDataAttributes(E) : {}), ...(typeof m == "object" ? m : {}) };
				}
				_typeCheckConfig(m, E = this.constructor.DefaultType) {
					for (const [q, J] of Object.entries(E)) {
						const ce = m[q],
							be = o(ce)
								? "element"
								: (I = ce) == null
								? `${I}`
								: Object.prototype.toString
										.call(I)
										.match(/\s([a-z]+)/i)[1]
										.toLowerCase();
						if (!new RegExp(J).test(be)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${q}" provided type "${be}" but expected type "${J}".`);
					}
					var I;
				}
			}
			class ge extends ie {
				constructor(m, E) {
					super(), (m = l(m)) && ((this._element = m), (this._config = this._getConfig(E)), i.set(this._element, this.constructor.DATA_KEY, this));
				}
				dispose() {
					i.remove(this._element, this.constructor.DATA_KEY), G.off(this._element, this.constructor.EVENT_KEY);
					for (const m of Object.getOwnPropertyNames(this)) this[m] = null;
				}
				_queueCallback(m, E, I = !0) {
					b(m, E, I);
				}
				_getConfig(m) {
					return (m = this._mergeConfigObj(m, this._element)), (m = this._configAfterMerge(m)), this._typeCheckConfig(m), m;
				}
				static getInstance(m) {
					return i.get(l(m), this.DATA_KEY);
				}
				static getOrCreateInstance(m, E = {}) {
					return this.getInstance(m) || new this(m, typeof E == "object" ? E : null);
				}
				static get VERSION() {
					return "5.3.3";
				}
				static get DATA_KEY() {
					return `bs.${this.NAME}`;
				}
				static get EVENT_KEY() {
					return `.${this.DATA_KEY}`;
				}
				static eventName(m) {
					return `${m}${this.EVENT_KEY}`;
				}
			}
			const V = (C) => {
					let m = C.getAttribute("data-bs-target");
					if (!m || m === "#") {
						let E = C.getAttribute("href");
						if (!E || (!E.includes("#") && !E.startsWith("."))) return null;
						E.includes("#") && !E.startsWith("#") && (E = `#${E.split("#")[1]}`), (m = E && E !== "#" ? E.trim() : null);
					}
					return m
						? m
								.split(",")
								.map((E) => s(E))
								.join(",")
						: null;
				},
				j = {
					find: (C, m = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(m, C)),
					findOne: (C, m = document.documentElement) => Element.prototype.querySelector.call(m, C),
					children: (C, m) => [].concat(...C.children).filter((E) => E.matches(m)),
					parents(C, m) {
						const E = [];
						let I = C.parentNode.closest(m);
						for (; I; ) E.push(I), (I = I.parentNode.closest(m));
						return E;
					},
					prev(C, m) {
						let E = C.previousElementSibling;
						for (; E; ) {
							if (E.matches(m)) return [E];
							E = E.previousElementSibling;
						}
						return [];
					},
					next(C, m) {
						let E = C.nextElementSibling;
						for (; E; ) {
							if (E.matches(m)) return [E];
							E = E.nextElementSibling;
						}
						return [];
					},
					focusableChildren(C) {
						const m = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((E) => `${E}:not([tabindex^="-"])`).join(",");
						return this.find(m, C).filter((E) => !u(E) && c(E));
					},
					getSelectorFromElement(C) {
						const m = V(C);
						return m && j.findOne(m) ? m : null;
					},
					getElementFromSelector(C) {
						const m = V(C);
						return m ? j.findOne(m) : null;
					},
					getMultipleElementsFromSelector(C) {
						const m = V(C);
						return m ? j.find(m) : [];
					}
				},
				he = (C, m = "hide") => {
					const E = `click.dismiss${C.EVENT_KEY}`,
						I = C.NAME;
					G.on(document, E, `[data-bs-dismiss="${I}"]`, function (q) {
						if ((["A", "AREA"].includes(this.tagName) && q.preventDefault(), u(this))) return;
						const J = j.getElementFromSelector(this) || this.closest(`.${I}`);
						C.getOrCreateInstance(J)[m]();
					});
				},
				xe = ".bs.alert",
				He = `close${xe}`,
				F = `closed${xe}`;
			class fe extends ge {
				static get NAME() {
					return "alert";
				}
				close() {
					if (G.trigger(this._element, He).defaultPrevented) return;
					this._element.classList.remove("show");
					const m = this._element.classList.contains("fade");
					this._queueCallback(() => this._destroyElement(), this._element, m);
				}
				_destroyElement() {
					this._element.remove(), G.trigger(this._element, F), this.dispose();
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = fe.getOrCreateInstance(this);
						if (typeof m == "string") {
							if (E[m] === void 0 || m.startsWith("_") || m === "constructor") throw new TypeError(`No method named "${m}"`);
							E[m](this);
						}
					});
				}
			}
			he(fe, "close"), g(fe);
			const pe = '[data-bs-toggle="button"]';
			class Ee extends ge {
				static get NAME() {
					return "button";
				}
				toggle() {
					this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = Ee.getOrCreateInstance(this);
						m === "toggle" && E[m]();
					});
				}
			}
			G.on(document, "click.bs.button.data-api", pe, (C) => {
				C.preventDefault();
				const m = C.target.closest(pe);
				Ee.getOrCreateInstance(m).toggle();
			}),
				g(Ee);
			const re = ".bs.swipe",
				We = `touchstart${re}`,
				Ce = `touchmove${re}`,
				Ie = `touchend${re}`,
				U = `pointerdown${re}`,
				R = `pointerup${re}`,
				ee = { endCallback: null, leftCallback: null, rightCallback: null },
				de = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
			class me extends ie {
				constructor(m, E) {
					super(), (this._element = m), m && me.isSupported() && ((this._config = this._getConfig(E)), (this._deltaX = 0), (this._supportPointerEvents = !!window.PointerEvent), this._initEvents());
				}
				static get Default() {
					return ee;
				}
				static get DefaultType() {
					return de;
				}
				static get NAME() {
					return "swipe";
				}
				dispose() {
					G.off(this._element, re);
				}
				_start(m) {
					this._supportPointerEvents ? this._eventIsPointerPenTouch(m) && (this._deltaX = m.clientX) : (this._deltaX = m.touches[0].clientX);
				}
				_end(m) {
					this._eventIsPointerPenTouch(m) && (this._deltaX = m.clientX - this._deltaX), this._handleSwipe(), x(this._config.endCallback);
				}
				_move(m) {
					this._deltaX = m.touches && m.touches.length > 1 ? 0 : m.touches[0].clientX - this._deltaX;
				}
				_handleSwipe() {
					const m = Math.abs(this._deltaX);
					if (m <= 40) return;
					const E = m / this._deltaX;
					(this._deltaX = 0), E && x(E > 0 ? this._config.rightCallback : this._config.leftCallback);
				}
				_initEvents() {
					this._supportPointerEvents ? (G.on(this._element, U, (m) => this._start(m)), G.on(this._element, R, (m) => this._end(m)), this._element.classList.add("pointer-event")) : (G.on(this._element, We, (m) => this._start(m)), G.on(this._element, Ce, (m) => this._move(m)), G.on(this._element, Ie, (m) => this._end(m)));
				}
				_eventIsPointerPenTouch(m) {
					return this._supportPointerEvents && (m.pointerType === "pen" || m.pointerType === "touch");
				}
				static isSupported() {
					return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
				}
			}
			const oe = ".bs.carousel",
				Xe = ".data-api",
				Me = "next",
				Pe = "prev",
				Je = "left",
				we = "right",
				Fe = `slide${oe}`,
				lt = `slid${oe}`,
				ot = `keydown${oe}`,
				Ne = `mouseenter${oe}`,
				dt = `mouseleave${oe}`,
				vt = `dragstart${oe}`,
				Qt = `load${oe}${Xe}`,
				Y = `click${oe}${Xe}`,
				Le = "carousel",
				ve = "active",
				ye = ".active",
				De = ".carousel-item",
				ct = ye + De,
				Lt = { ArrowLeft: we, ArrowRight: Je },
				hn = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 },
				Mn = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
			class At extends ge {
				constructor(m, E) {
					super(m, E), (this._interval = null), (this._activeElement = null), (this._isSliding = !1), (this.touchTimeout = null), (this._swipeHelper = null), (this._indicatorsElement = j.findOne(".carousel-indicators", this._element)), this._addEventListeners(), this._config.ride === Le && this.cycle();
				}
				static get Default() {
					return hn;
				}
				static get DefaultType() {
					return Mn;
				}
				static get NAME() {
					return "carousel";
				}
				next() {
					this._slide(Me);
				}
				nextWhenVisible() {
					!document.hidden && c(this._element) && this.next();
				}
				prev() {
					this._slide(Pe);
				}
				pause() {
					this._isSliding && a(this._element), this._clearInterval();
				}
				cycle() {
					this._clearInterval(), this._updateInterval(), (this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval));
				}
				_maybeEnableCycle() {
					this._config.ride && (this._isSliding ? G.one(this._element, lt, () => this.cycle()) : this.cycle());
				}
				to(m) {
					const E = this._getItems();
					if (m > E.length - 1 || m < 0) return;
					if (this._isSliding) return void G.one(this._element, lt, () => this.to(m));
					const I = this._getItemIndex(this._getActive());
					if (I === m) return;
					const q = m > I ? Me : Pe;
					this._slide(q, E[m]);
				}
				dispose() {
					this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
				}
				_configAfterMerge(m) {
					return (m.defaultInterval = m.interval), m;
				}
				_addEventListeners() {
					this._config.keyboard && G.on(this._element, ot, (m) => this._keydown(m)), this._config.pause === "hover" && (G.on(this._element, Ne, () => this.pause()), G.on(this._element, dt, () => this._maybeEnableCycle())), this._config.touch && me.isSupported() && this._addTouchEventListeners();
				}
				_addTouchEventListeners() {
					for (const E of j.find(".carousel-item img", this._element)) G.on(E, vt, (I) => I.preventDefault());
					const m = {
						leftCallback: () => this._slide(this._directionToOrder(Je)),
						rightCallback: () => this._slide(this._directionToOrder(we)),
						endCallback: () => {
							this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), (this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval)));
						}
					};
					this._swipeHelper = new me(this._element, m);
				}
				_keydown(m) {
					if (/input|textarea/i.test(m.target.tagName)) return;
					const E = Lt[m.key];
					E && (m.preventDefault(), this._slide(this._directionToOrder(E)));
				}
				_getItemIndex(m) {
					return this._getItems().indexOf(m);
				}
				_setActiveIndicatorElement(m) {
					if (!this._indicatorsElement) return;
					const E = j.findOne(ye, this._indicatorsElement);
					E.classList.remove(ve), E.removeAttribute("aria-current");
					const I = j.findOne(`[data-bs-slide-to="${m}"]`, this._indicatorsElement);
					I && (I.classList.add(ve), I.setAttribute("aria-current", "true"));
				}
				_updateInterval() {
					const m = this._activeElement || this._getActive();
					if (!m) return;
					const E = Number.parseInt(m.getAttribute("data-bs-interval"), 10);
					this._config.interval = E || this._config.defaultInterval;
				}
				_slide(m, E = null) {
					if (this._isSliding) return;
					const I = this._getActive(),
						q = m === Me,
						J = E || T(this._getItems(), I, q, this._config.wrap);
					if (J === I) return;
					const ce = this._getItemIndex(J),
						be = (Ge) => G.trigger(this._element, Ge, { relatedTarget: J, direction: this._orderToDirection(m), from: this._getItemIndex(I), to: ce });
					if (be(Fe).defaultPrevented || !I || !J) return;
					const Oe = !!this._interval;
					this.pause(), (this._isSliding = !0), this._setActiveIndicatorElement(ce), (this._activeElement = J);
					const $e = q ? "carousel-item-start" : "carousel-item-end",
						qe = q ? "carousel-item-next" : "carousel-item-prev";
					J.classList.add(qe),
						f(J),
						I.classList.add($e),
						J.classList.add($e),
						this._queueCallback(
							() => {
								J.classList.remove($e, qe), J.classList.add(ve), I.classList.remove(ve, qe, $e), (this._isSliding = !1), be(lt);
							},
							I,
							this._isAnimated()
						),
						Oe && this.cycle();
				}
				_isAnimated() {
					return this._element.classList.contains("slide");
				}
				_getActive() {
					return j.findOne(ct, this._element);
				}
				_getItems() {
					return j.find(De, this._element);
				}
				_clearInterval() {
					this._interval && (clearInterval(this._interval), (this._interval = null));
				}
				_directionToOrder(m) {
					return p() ? (m === Je ? Pe : Me) : m === Je ? Me : Pe;
				}
				_orderToDirection(m) {
					return p() ? (m === Pe ? Je : we) : m === Pe ? we : Je;
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = At.getOrCreateInstance(this, m);
						if (typeof m != "number") {
							if (typeof m == "string") {
								if (E[m] === void 0 || m.startsWith("_") || m === "constructor") throw new TypeError(`No method named "${m}"`);
								E[m]();
							}
						} else E.to(m);
					});
				}
			}
			G.on(document, Y, "[data-bs-slide], [data-bs-slide-to]", function (C) {
				const m = j.getElementFromSelector(this);
				if (!m || !m.classList.contains(Le)) return;
				C.preventDefault();
				const E = At.getOrCreateInstance(m),
					I = this.getAttribute("data-bs-slide-to");
				return I ? (E.to(I), void E._maybeEnableCycle()) : Z.getDataAttribute(this, "slide") === "next" ? (E.next(), void E._maybeEnableCycle()) : (E.prev(), void E._maybeEnableCycle());
			}),
				G.on(window, Qt, () => {
					const C = j.find('[data-bs-ride="carousel"]');
					for (const m of C) At.getOrCreateInstance(m);
				}),
				g(At);
			const Yn = ".bs.collapse",
				xi = `show${Yn}`,
				oc = `shown${Yn}`,
				Cr = `hide${Yn}`,
				Zo = `hidden${Yn}`,
				lc = `click${Yn}.data-api`,
				Aa = "show",
				Bi = "collapse",
				Us = "collapsing",
				Ca = `:scope .${Bi} .${Bi}`,
				La = '[data-bs-toggle="collapse"]',
				cc = { parent: null, toggle: !0 },
				Eh = { parent: "(null|element)", toggle: "boolean" };
			class ts extends ge {
				constructor(m, E) {
					super(m, E), (this._isTransitioning = !1), (this._triggerArray = []);
					const I = j.find(La);
					for (const q of I) {
						const J = j.getSelectorFromElement(q),
							ce = j.find(J).filter((be) => be === this._element);
						J !== null && ce.length && this._triggerArray.push(q);
					}
					this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
				}
				static get Default() {
					return cc;
				}
				static get DefaultType() {
					return Eh;
				}
				static get NAME() {
					return "collapse";
				}
				toggle() {
					this._isShown() ? this.hide() : this.show();
				}
				show() {
					if (this._isTransitioning || this._isShown()) return;
					let m = [];
					if (
						(this._config.parent &&
							(m = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing")
								.filter((q) => q !== this._element)
								.map((q) => ts.getOrCreateInstance(q, { toggle: !1 }))),
						(m.length && m[0]._isTransitioning) || G.trigger(this._element, xi).defaultPrevented)
					)
						return;
					for (const q of m) q.hide();
					const E = this._getDimension();
					this._element.classList.remove(Bi), this._element.classList.add(Us), (this._element.style[E] = 0), this._addAriaAndCollapsedClass(this._triggerArray, !0), (this._isTransitioning = !0);
					const I = `scroll${E[0].toUpperCase() + E.slice(1)}`;
					this._queueCallback(
						() => {
							(this._isTransitioning = !1), this._element.classList.remove(Us), this._element.classList.add(Bi, Aa), (this._element.style[E] = ""), G.trigger(this._element, oc);
						},
						this._element,
						!0
					),
						(this._element.style[E] = `${this._element[I]}px`);
				}
				hide() {
					if (this._isTransitioning || !this._isShown() || G.trigger(this._element, Cr).defaultPrevented) return;
					const m = this._getDimension();
					(this._element.style[m] = `${this._element.getBoundingClientRect()[m]}px`), f(this._element), this._element.classList.add(Us), this._element.classList.remove(Bi, Aa);
					for (const E of this._triggerArray) {
						const I = j.getElementFromSelector(E);
						I && !this._isShown(I) && this._addAriaAndCollapsedClass([E], !1);
					}
					(this._isTransitioning = !0),
						(this._element.style[m] = ""),
						this._queueCallback(
							() => {
								(this._isTransitioning = !1), this._element.classList.remove(Us), this._element.classList.add(Bi), G.trigger(this._element, Zo);
							},
							this._element,
							!0
						);
				}
				_isShown(m = this._element) {
					return m.classList.contains(Aa);
				}
				_configAfterMerge(m) {
					return (m.toggle = !!m.toggle), (m.parent = l(m.parent)), m;
				}
				_getDimension() {
					return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
				}
				_initializeChildren() {
					if (!this._config.parent) return;
					const m = this._getFirstLevelChildren(La);
					for (const E of m) {
						const I = j.getElementFromSelector(E);
						I && this._addAriaAndCollapsedClass([E], this._isShown(I));
					}
				}
				_getFirstLevelChildren(m) {
					const E = j.find(Ca, this._config.parent);
					return j.find(m, this._config.parent).filter((I) => !E.includes(I));
				}
				_addAriaAndCollapsedClass(m, E) {
					if (m.length) for (const I of m) I.classList.toggle("collapsed", !E), I.setAttribute("aria-expanded", E);
				}
				static jQueryInterface(m) {
					const E = {};
					return (
						typeof m == "string" && /show|hide/.test(m) && (E.toggle = !1),
						this.each(function () {
							const I = ts.getOrCreateInstance(this, E);
							if (typeof m == "string") {
								if (I[m] === void 0) throw new TypeError(`No method named "${m}"`);
								I[m]();
							}
						})
					);
				}
			}
			G.on(document, lc, La, function (C) {
				(C.target.tagName === "A" || (C.delegateTarget && C.delegateTarget.tagName === "A")) && C.preventDefault();
				for (const m of j.getMultipleElementsFromSelector(this)) ts.getOrCreateInstance(m, { toggle: !1 }).toggle();
			}),
				g(ts);
			var In = "top",
				O = "bottom",
				$ = "right",
				te = "left",
				se = "auto",
				Q = [In, O, $, te],
				Ae = "start",
				ke = "end",
				je = "clippingParents",
				Ye = "viewport",
				nt = "popper",
				ut = "reference",
				it = Q.reduce(function (C, m) {
					return C.concat([m + "-" + Ae, m + "-" + ke]);
				}, []),
				It = [].concat(Q, [se]).reduce(function (C, m) {
					return C.concat([m, m + "-" + Ae, m + "-" + ke]);
				}, []),
				en = "beforeRead",
				tn = "read",
				Bn = "afterRead",
				Nt = "beforeMain",
				Qe = "main",
				gn = "afterMain",
				Ut = "beforeWrite",
				si = "write",
				Lr = "afterWrite",
				zn = [en, tn, Bn, Nt, Qe, gn, Ut, si, Lr];
			function ai(C) {
				return C ? (C.nodeName || "").toLowerCase() : null;
			}
			function Ft(C) {
				if (C == null) return window;
				if (C.toString() !== "[object Window]") {
					var m = C.ownerDocument;
					return (m && m.defaultView) || window;
				}
				return C;
			}
			function Hn(C) {
				return C instanceof Ft(C).Element || C instanceof Element;
			}
			function Gn(C) {
				return C instanceof Ft(C).HTMLElement || C instanceof HTMLElement;
			}
			function Vn(C) {
				return typeof ShadowRoot < "u" && (C instanceof Ft(C).ShadowRoot || C instanceof ShadowRoot);
			}
			const ks = {
				name: "applyStyles",
				enabled: !0,
				phase: "write",
				fn: function (C) {
					var m = C.state;
					Object.keys(m.elements).forEach(function (E) {
						var I = m.styles[E] || {},
							q = m.attributes[E] || {},
							J = m.elements[E];
						Gn(J) &&
							ai(J) &&
							(Object.assign(J.style, I),
							Object.keys(q).forEach(function (ce) {
								var be = q[ce];
								be === !1 ? J.removeAttribute(ce) : J.setAttribute(ce, be === !0 ? "" : be);
							}));
					});
				},
				effect: function (C) {
					var m = C.state,
						E = { popper: { position: m.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
					return (
						Object.assign(m.elements.popper.style, E.popper),
						(m.styles = E),
						m.elements.arrow && Object.assign(m.elements.arrow.style, E.arrow),
						function () {
							Object.keys(m.elements).forEach(function (I) {
								var q = m.elements[I],
									J = m.attributes[I] || {},
									ce = Object.keys(m.styles.hasOwnProperty(I) ? m.styles[I] : E[I]).reduce(function (be, Oe) {
										return (be[Oe] = ""), be;
									}, {});
								Gn(q) &&
									ai(q) &&
									(Object.assign(q.style, ce),
									Object.keys(J).forEach(function (be) {
										q.removeAttribute(be);
									}));
							});
						}
					);
				},
				requires: ["computeStyles"]
			};
			function bi(C) {
				return C.split("-")[0];
			}
			var cr = Math.max,
				uc = Math.min,
				Ra = Math.round;
			function wh() {
				var C = navigator.userAgentData;
				return C != null && C.brands && Array.isArray(C.brands)
					? C.brands
							.map(function (m) {
								return m.brand + "/" + m.version;
							})
							.join(" ")
					: navigator.userAgent;
			}
			function vm() {
				return !/^((?!chrome|android).)*safari/i.test(wh());
			}
			function Pa(C, m, E) {
				m === void 0 && (m = !1), E === void 0 && (E = !1);
				var I = C.getBoundingClientRect(),
					q = 1,
					J = 1;
				m && Gn(C) && ((q = (C.offsetWidth > 0 && Ra(I.width) / C.offsetWidth) || 1), (J = (C.offsetHeight > 0 && Ra(I.height) / C.offsetHeight) || 1));
				var ce = (Hn(C) ? Ft(C) : window).visualViewport,
					be = !vm() && E,
					Oe = (I.left + (be && ce ? ce.offsetLeft : 0)) / q,
					$e = (I.top + (be && ce ? ce.offsetTop : 0)) / J,
					qe = I.width / q,
					Ge = I.height / J;
				return { width: qe, height: Ge, top: $e, right: Oe + qe, bottom: $e + Ge, left: Oe, x: Oe, y: $e };
			}
			function Th(C) {
				var m = Pa(C),
					E = C.offsetWidth,
					I = C.offsetHeight;
				return Math.abs(m.width - E) <= 1 && (E = m.width), Math.abs(m.height - I) <= 1 && (I = m.height), { x: C.offsetLeft, y: C.offsetTop, width: E, height: I };
			}
			function _m(C, m) {
				var E = m.getRootNode && m.getRootNode();
				if (C.contains(m)) return !0;
				if (E && Vn(E)) {
					var I = m;
					do {
						if (I && C.isSameNode(I)) return !0;
						I = I.parentNode || I.host;
					} while (I);
				}
				return !1;
			}
			function Rr(C) {
				return Ft(C).getComputedStyle(C);
			}
			function Nb(C) {
				return ["table", "td", "th"].indexOf(ai(C)) >= 0;
			}
			function ns(C) {
				return ((Hn(C) ? C.ownerDocument : C.document) || window.document).documentElement;
			}
			function hc(C) {
				return ai(C) === "html" ? C : C.assignedSlot || C.parentNode || (Vn(C) ? C.host : null) || ns(C);
			}
			function ym(C) {
				return Gn(C) && Rr(C).position !== "fixed" ? C.offsetParent : null;
			}
			function Jo(C) {
				for (var m = Ft(C), E = ym(C); E && Nb(E) && Rr(E).position === "static"; ) E = ym(E);
				return E && (ai(E) === "html" || (ai(E) === "body" && Rr(E).position === "static"))
					? m
					: E ||
							(function (I) {
								var q = /firefox/i.test(wh());
								if (/Trident/i.test(wh()) && Gn(I) && Rr(I).position === "fixed") return null;
								var J = hc(I);
								for (Vn(J) && (J = J.host); Gn(J) && ["html", "body"].indexOf(ai(J)) < 0; ) {
									var ce = Rr(J);
									if (ce.transform !== "none" || ce.perspective !== "none" || ce.contain === "paint" || ["transform", "perspective"].indexOf(ce.willChange) !== -1 || (q && ce.willChange === "filter") || (q && ce.filter && ce.filter !== "none")) return J;
									J = J.parentNode;
								}
								return null;
							})(C) ||
							m;
			}
			function Mh(C) {
				return ["top", "bottom"].indexOf(C) >= 0 ? "x" : "y";
			}
			function Qo(C, m, E) {
				return cr(C, uc(m, E));
			}
			function xm(C) {
				return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, C);
			}
			function bm(C, m) {
				return m.reduce(function (E, I) {
					return (E[I] = C), E;
				}, {});
			}
			const Sm = {
				name: "arrow",
				enabled: !0,
				phase: "main",
				fn: function (C) {
					var m,
						E = C.state,
						I = C.name,
						q = C.options,
						J = E.elements.arrow,
						ce = E.modifiersData.popperOffsets,
						be = bi(E.placement),
						Oe = Mh(be),
						$e = [te, $].indexOf(be) >= 0 ? "height" : "width";
					if (J && ce) {
						var qe = (function ($t, Gt) {
								return xm(typeof ($t = typeof $t == "function" ? $t(Object.assign({}, Gt.rects, { placement: Gt.placement })) : $t) != "number" ? $t : bm($t, Q));
							})(q.padding, E),
							Ge = Th(J),
							St = Oe === "y" ? In : te,
							ht = Oe === "y" ? O : $,
							_t = E.rects.reference[$e] + E.rects.reference[Oe] - ce[Oe] - E.rects.popper[$e],
							gt = ce[Oe] - E.rects.reference[Oe],
							yt = Jo(J),
							Xt = yt ? (Oe === "y" ? yt.clientHeight || 0 : yt.clientWidth || 0) : 0,
							Zt = _t / 2 - gt / 2,
							Mt = qe[St],
							kt = Xt - Ge[$e] - qe[ht],
							Et = Xt / 2 - Ge[$e] / 2 + Zt,
							Rt = Qo(Mt, Et, kt),
							Ht = Oe;
						E.modifiersData[I] = (((m = {})[Ht] = Rt), (m.centerOffset = Rt - Et), m);
					}
				},
				effect: function (C) {
					var m = C.state,
						E = C.options.element,
						I = E === void 0 ? "[data-popper-arrow]" : E;
					I != null && (typeof I != "string" || (I = m.elements.popper.querySelector(I))) && _m(m.elements.popper, I) && (m.elements.arrow = I);
				},
				requires: ["popperOffsets"],
				requiresIfExists: ["preventOverflow"]
			};
			function Da(C) {
				return C.split("-")[1];
			}
			var Ub = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
			function Em(C) {
				var m,
					E = C.popper,
					I = C.popperRect,
					q = C.placement,
					J = C.variation,
					ce = C.offsets,
					be = C.position,
					Oe = C.gpuAcceleration,
					$e = C.adaptive,
					qe = C.roundOffsets,
					Ge = C.isFixed,
					St = ce.x,
					ht = St === void 0 ? 0 : St,
					_t = ce.y,
					gt = _t === void 0 ? 0 : _t,
					yt = typeof qe == "function" ? qe({ x: ht, y: gt }) : { x: ht, y: gt };
				(ht = yt.x), (gt = yt.y);
				var Xt = ce.hasOwnProperty("x"),
					Zt = ce.hasOwnProperty("y"),
					Mt = te,
					kt = In,
					Et = window;
				if ($e) {
					var Rt = Jo(E),
						Ht = "clientHeight",
						$t = "clientWidth";
					Rt === Ft(E) && Rr((Rt = ns(E))).position !== "static" && be === "absolute" && ((Ht = "scrollHeight"), ($t = "scrollWidth")),
						(q === In || ((q === te || q === $) && J === ke)) && ((kt = O), (gt -= (Ge && Rt === Et && Et.visualViewport ? Et.visualViewport.height : Rt[Ht]) - I.height), (gt *= Oe ? 1 : -1)),
						(q !== te && ((q !== In && q !== O) || J !== ke)) || ((Mt = $), (ht -= (Ge && Rt === Et && Et.visualViewport ? Et.visualViewport.width : Rt[$t]) - I.width), (ht *= Oe ? 1 : -1));
				}
				var Gt,
					pn = Object.assign({ position: be }, $e && Ub),
					ci =
						qe === !0
							? (function (Hi, Kn) {
									var Ei = Hi.x,
										wi = Hi.y,
										dn = Kn.devicePixelRatio || 1;
									return { x: Ra(Ei * dn) / dn || 0, y: Ra(wi * dn) / dn || 0 };
							  })({ x: ht, y: gt }, Ft(E))
							: { x: ht, y: gt };
				return (ht = ci.x), (gt = ci.y), Oe ? Object.assign({}, pn, (((Gt = {})[kt] = Zt ? "0" : ""), (Gt[Mt] = Xt ? "0" : ""), (Gt.transform = (Et.devicePixelRatio || 1) <= 1 ? "translate(" + ht + "px, " + gt + "px)" : "translate3d(" + ht + "px, " + gt + "px, 0)"), Gt)) : Object.assign({}, pn, (((m = {})[kt] = Zt ? gt + "px" : ""), (m[Mt] = Xt ? ht + "px" : ""), (m.transform = ""), m));
			}
			const Ah = {
				name: "computeStyles",
				enabled: !0,
				phase: "beforeWrite",
				fn: function (C) {
					var m = C.state,
						E = C.options,
						I = E.gpuAcceleration,
						q = I === void 0 || I,
						J = E.adaptive,
						ce = J === void 0 || J,
						be = E.roundOffsets,
						Oe = be === void 0 || be,
						$e = { placement: bi(m.placement), variation: Da(m.placement), popper: m.elements.popper, popperRect: m.rects.popper, gpuAcceleration: q, isFixed: m.options.strategy === "fixed" };
					m.modifiersData.popperOffsets != null && (m.styles.popper = Object.assign({}, m.styles.popper, Em(Object.assign({}, $e, { offsets: m.modifiersData.popperOffsets, position: m.options.strategy, adaptive: ce, roundOffsets: Oe })))),
						m.modifiersData.arrow != null && (m.styles.arrow = Object.assign({}, m.styles.arrow, Em(Object.assign({}, $e, { offsets: m.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: Oe })))),
						(m.attributes.popper = Object.assign({}, m.attributes.popper, { "data-popper-placement": m.placement }));
				},
				data: {}
			};
			var dc = { passive: !0 };
			const Ch = {
				name: "eventListeners",
				enabled: !0,
				phase: "write",
				fn: function () {},
				effect: function (C) {
					var m = C.state,
						E = C.instance,
						I = C.options,
						q = I.scroll,
						J = q === void 0 || q,
						ce = I.resize,
						be = ce === void 0 || ce,
						Oe = Ft(m.elements.popper),
						$e = [].concat(m.scrollParents.reference, m.scrollParents.popper);
					return (
						J &&
							$e.forEach(function (qe) {
								qe.addEventListener("scroll", E.update, dc);
							}),
						be && Oe.addEventListener("resize", E.update, dc),
						function () {
							J &&
								$e.forEach(function (qe) {
									qe.removeEventListener("scroll", E.update, dc);
								}),
								be && Oe.removeEventListener("resize", E.update, dc);
						}
					);
				},
				data: {}
			};
			var kb = { left: "right", right: "left", bottom: "top", top: "bottom" };
			function fc(C) {
				return C.replace(/left|right|bottom|top/g, function (m) {
					return kb[m];
				});
			}
			var Bb = { start: "end", end: "start" };
			function wm(C) {
				return C.replace(/start|end/g, function (m) {
					return Bb[m];
				});
			}
			function Lh(C) {
				var m = Ft(C);
				return { scrollLeft: m.pageXOffset, scrollTop: m.pageYOffset };
			}
			function Rh(C) {
				return Pa(ns(C)).left + Lh(C).scrollLeft;
			}
			function Ph(C) {
				var m = Rr(C),
					E = m.overflow,
					I = m.overflowX,
					q = m.overflowY;
				return /auto|scroll|overlay|hidden/.test(E + q + I);
			}
			function Tm(C) {
				return ["html", "body", "#document"].indexOf(ai(C)) >= 0 ? C.ownerDocument.body : Gn(C) && Ph(C) ? C : Tm(hc(C));
			}
			function el(C, m) {
				var E;
				m === void 0 && (m = []);
				var I = Tm(C),
					q = I === ((E = C.ownerDocument) == null ? void 0 : E.body),
					J = Ft(I),
					ce = q ? [J].concat(J.visualViewport || [], Ph(I) ? I : []) : I,
					be = m.concat(ce);
				return q ? be : be.concat(el(hc(ce)));
			}
			function Dh(C) {
				return Object.assign({}, C, { left: C.x, top: C.y, right: C.x + C.width, bottom: C.y + C.height });
			}
			function Mm(C, m, E) {
				return m === Ye
					? Dh(
							(function (I, q) {
								var J = Ft(I),
									ce = ns(I),
									be = J.visualViewport,
									Oe = ce.clientWidth,
									$e = ce.clientHeight,
									qe = 0,
									Ge = 0;
								if (be) {
									(Oe = be.width), ($e = be.height);
									var St = vm();
									(St || (!St && q === "fixed")) && ((qe = be.offsetLeft), (Ge = be.offsetTop));
								}
								return { width: Oe, height: $e, x: qe + Rh(I), y: Ge };
							})(C, E)
					  )
					: Hn(m)
					? (function (I, q) {
							var J = Pa(I, !1, q === "fixed");
							return (J.top = J.top + I.clientTop), (J.left = J.left + I.clientLeft), (J.bottom = J.top + I.clientHeight), (J.right = J.left + I.clientWidth), (J.width = I.clientWidth), (J.height = I.clientHeight), (J.x = J.left), (J.y = J.top), J;
					  })(m, E)
					: Dh(
							(function (I) {
								var q,
									J = ns(I),
									ce = Lh(I),
									be = (q = I.ownerDocument) == null ? void 0 : q.body,
									Oe = cr(J.scrollWidth, J.clientWidth, be ? be.scrollWidth : 0, be ? be.clientWidth : 0),
									$e = cr(J.scrollHeight, J.clientHeight, be ? be.scrollHeight : 0, be ? be.clientHeight : 0),
									qe = -ce.scrollLeft + Rh(I),
									Ge = -ce.scrollTop;
								return Rr(be || J).direction === "rtl" && (qe += cr(J.clientWidth, be ? be.clientWidth : 0) - Oe), { width: Oe, height: $e, x: qe, y: Ge };
							})(ns(C))
					  );
			}
			function Am(C) {
				var m,
					E = C.reference,
					I = C.element,
					q = C.placement,
					J = q ? bi(q) : null,
					ce = q ? Da(q) : null,
					be = E.x + E.width / 2 - I.width / 2,
					Oe = E.y + E.height / 2 - I.height / 2;
				switch (J) {
					case In:
						m = { x: be, y: E.y - I.height };
						break;
					case O:
						m = { x: be, y: E.y + E.height };
						break;
					case $:
						m = { x: E.x + E.width, y: Oe };
						break;
					case te:
						m = { x: E.x - I.width, y: Oe };
						break;
					default:
						m = { x: E.x, y: E.y };
				}
				var $e = J ? Mh(J) : null;
				if ($e != null) {
					var qe = $e === "y" ? "height" : "width";
					switch (ce) {
						case Ae:
							m[$e] = m[$e] - (E[qe] / 2 - I[qe] / 2);
							break;
						case ke:
							m[$e] = m[$e] + (E[qe] / 2 - I[qe] / 2);
					}
				}
				return m;
			}
			function Oa(C, m) {
				m === void 0 && (m = {});
				var E = m,
					I = E.placement,
					q = I === void 0 ? C.placement : I,
					J = E.strategy,
					ce = J === void 0 ? C.strategy : J,
					be = E.boundary,
					Oe = be === void 0 ? je : be,
					$e = E.rootBoundary,
					qe = $e === void 0 ? Ye : $e,
					Ge = E.elementContext,
					St = Ge === void 0 ? nt : Ge,
					ht = E.altBoundary,
					_t = ht !== void 0 && ht,
					gt = E.padding,
					yt = gt === void 0 ? 0 : gt,
					Xt = xm(typeof yt != "number" ? yt : bm(yt, Q)),
					Zt = St === nt ? ut : nt,
					Mt = C.rects.popper,
					kt = C.elements[_t ? Zt : St],
					Et = (function (Kn, Ei, wi, dn) {
						var ur =
								Ei === "clippingParents"
									? (function (jt) {
											var Zn = el(hc(jt)),
												Ti = ["absolute", "fixed"].indexOf(Rr(jt).position) >= 0 && Gn(jt) ? Jo(jt) : jt;
											return Hn(Ti)
												? Zn.filter(function (rs) {
														return Hn(rs) && _m(rs, Ti) && ai(rs) !== "body";
												  })
												: [];
									  })(Kn)
									: [].concat(Ei),
							hr = [].concat(ur, [wi]),
							Na = hr[0],
							Rn = hr.reduce(function (jt, Zn) {
								var Ti = Mm(Kn, Zn, dn);
								return (jt.top = cr(Ti.top, jt.top)), (jt.right = uc(Ti.right, jt.right)), (jt.bottom = uc(Ti.bottom, jt.bottom)), (jt.left = cr(Ti.left, jt.left)), jt;
							}, Mm(Kn, Na, dn));
						return (Rn.width = Rn.right - Rn.left), (Rn.height = Rn.bottom - Rn.top), (Rn.x = Rn.left), (Rn.y = Rn.top), Rn;
					})(Hn(kt) ? kt : kt.contextElement || ns(C.elements.popper), Oe, qe, ce),
					Rt = Pa(C.elements.reference),
					Ht = Am({ reference: Rt, element: Mt, strategy: "absolute", placement: q }),
					$t = Dh(Object.assign({}, Mt, Ht)),
					Gt = St === nt ? $t : Rt,
					pn = { top: Et.top - Gt.top + Xt.top, bottom: Gt.bottom - Et.bottom + Xt.bottom, left: Et.left - Gt.left + Xt.left, right: Gt.right - Et.right + Xt.right },
					ci = C.modifiersData.offset;
				if (St === nt && ci) {
					var Hi = ci[q];
					Object.keys(pn).forEach(function (Kn) {
						var Ei = [$, O].indexOf(Kn) >= 0 ? 1 : -1,
							wi = [In, O].indexOf(Kn) >= 0 ? "y" : "x";
						pn[Kn] += Hi[wi] * Ei;
					});
				}
				return pn;
			}
			function zb(C, m) {
				m === void 0 && (m = {});
				var E = m,
					I = E.placement,
					q = E.boundary,
					J = E.rootBoundary,
					ce = E.padding,
					be = E.flipVariations,
					Oe = E.allowedAutoPlacements,
					$e = Oe === void 0 ? It : Oe,
					qe = Da(I),
					Ge = qe
						? be
							? it
							: it.filter(function (_t) {
									return Da(_t) === qe;
							  })
						: Q,
					St = Ge.filter(function (_t) {
						return $e.indexOf(_t) >= 0;
					});
				St.length === 0 && (St = Ge);
				var ht = St.reduce(function (_t, gt) {
					return (_t[gt] = Oa(C, { placement: gt, boundary: q, rootBoundary: J, padding: ce })[bi(gt)]), _t;
				}, {});
				return Object.keys(ht).sort(function (_t, gt) {
					return ht[_t] - ht[gt];
				});
			}
			const Cm = {
				name: "flip",
				enabled: !0,
				phase: "main",
				fn: function (C) {
					var m = C.state,
						E = C.options,
						I = C.name;
					if (!m.modifiersData[I]._skip) {
						for (
							var q = E.mainAxis,
								J = q === void 0 || q,
								ce = E.altAxis,
								be = ce === void 0 || ce,
								Oe = E.fallbackPlacements,
								$e = E.padding,
								qe = E.boundary,
								Ge = E.rootBoundary,
								St = E.altBoundary,
								ht = E.flipVariations,
								_t = ht === void 0 || ht,
								gt = E.allowedAutoPlacements,
								yt = m.options.placement,
								Xt = bi(yt),
								Zt =
									Oe ||
									(Xt !== yt && _t
										? (function (jt) {
												if (bi(jt) === se) return [];
												var Zn = fc(jt);
												return [wm(jt), Zn, wm(Zn)];
										  })(yt)
										: [fc(yt)]),
								Mt = [yt].concat(Zt).reduce(function (jt, Zn) {
									return jt.concat(bi(Zn) === se ? zb(m, { placement: Zn, boundary: qe, rootBoundary: Ge, padding: $e, flipVariations: _t, allowedAutoPlacements: gt }) : Zn);
								}, []),
								kt = m.rects.reference,
								Et = m.rects.popper,
								Rt = new Map(),
								Ht = !0,
								$t = Mt[0],
								Gt = 0;
							Gt < Mt.length;
							Gt++
						) {
							var pn = Mt[Gt],
								ci = bi(pn),
								Hi = Da(pn) === Ae,
								Kn = [In, O].indexOf(ci) >= 0,
								Ei = Kn ? "width" : "height",
								wi = Oa(m, { placement: pn, boundary: qe, rootBoundary: Ge, altBoundary: St, padding: $e }),
								dn = Kn ? (Hi ? $ : te) : Hi ? O : In;
							kt[Ei] > Et[Ei] && (dn = fc(dn));
							var ur = fc(dn),
								hr = [];
							if (
								(J && hr.push(wi[ci] <= 0),
								be && hr.push(wi[dn] <= 0, wi[ur] <= 0),
								hr.every(function (jt) {
									return jt;
								}))
							) {
								($t = pn), (Ht = !1);
								break;
							}
							Rt.set(pn, hr);
						}
						if (Ht)
							for (
								var Na = function (jt) {
										var Zn = Mt.find(function (Ti) {
											var rs = Rt.get(Ti);
											if (rs)
												return rs.slice(0, jt).every(function (Sc) {
													return Sc;
												});
										});
										if (Zn) return ($t = Zn), "break";
									},
									Rn = _t ? 3 : 1;
								Rn > 0 && Na(Rn) !== "break";
								Rn--
							);
						m.placement !== $t && ((m.modifiersData[I]._skip = !0), (m.placement = $t), (m.reset = !0));
					}
				},
				requiresIfExists: ["offset"],
				data: { _skip: !1 }
			};
			function Lm(C, m, E) {
				return E === void 0 && (E = { x: 0, y: 0 }), { top: C.top - m.height - E.y, right: C.right - m.width + E.x, bottom: C.bottom - m.height + E.y, left: C.left - m.width - E.x };
			}
			function Rm(C) {
				return [In, $, O, te].some(function (m) {
					return C[m] >= 0;
				});
			}
			const Pm = {
					name: "hide",
					enabled: !0,
					phase: "main",
					requiresIfExists: ["preventOverflow"],
					fn: function (C) {
						var m = C.state,
							E = C.name,
							I = m.rects.reference,
							q = m.rects.popper,
							J = m.modifiersData.preventOverflow,
							ce = Oa(m, { elementContext: "reference" }),
							be = Oa(m, { altBoundary: !0 }),
							Oe = Lm(ce, I),
							$e = Lm(be, q, J),
							qe = Rm(Oe),
							Ge = Rm($e);
						(m.modifiersData[E] = { referenceClippingOffsets: Oe, popperEscapeOffsets: $e, isReferenceHidden: qe, hasPopperEscaped: Ge }), (m.attributes.popper = Object.assign({}, m.attributes.popper, { "data-popper-reference-hidden": qe, "data-popper-escaped": Ge }));
					}
				},
				Dm = {
					name: "offset",
					enabled: !0,
					phase: "main",
					requires: ["popperOffsets"],
					fn: function (C) {
						var m = C.state,
							E = C.options,
							I = C.name,
							q = E.offset,
							J = q === void 0 ? [0, 0] : q,
							ce = It.reduce(function (qe, Ge) {
								return (
									(qe[Ge] = (function (St, ht, _t) {
										var gt = bi(St),
											yt = [te, In].indexOf(gt) >= 0 ? -1 : 1,
											Xt = typeof _t == "function" ? _t(Object.assign({}, ht, { placement: St })) : _t,
											Zt = Xt[0],
											Mt = Xt[1];
										return (Zt = Zt || 0), (Mt = (Mt || 0) * yt), [te, $].indexOf(gt) >= 0 ? { x: Mt, y: Zt } : { x: Zt, y: Mt };
									})(Ge, m.rects, J)),
									qe
								);
							}, {}),
							be = ce[m.placement],
							Oe = be.x,
							$e = be.y;
						m.modifiersData.popperOffsets != null && ((m.modifiersData.popperOffsets.x += Oe), (m.modifiersData.popperOffsets.y += $e)), (m.modifiersData[I] = ce);
					}
				},
				Oh = {
					name: "popperOffsets",
					enabled: !0,
					phase: "read",
					fn: function (C) {
						var m = C.state,
							E = C.name;
						m.modifiersData[E] = Am({ reference: m.rects.reference, element: m.rects.popper, strategy: "absolute", placement: m.placement });
					},
					data: {}
				},
				Om = {
					name: "preventOverflow",
					enabled: !0,
					phase: "main",
					fn: function (C) {
						var m = C.state,
							E = C.options,
							I = C.name,
							q = E.mainAxis,
							J = q === void 0 || q,
							ce = E.altAxis,
							be = ce !== void 0 && ce,
							Oe = E.boundary,
							$e = E.rootBoundary,
							qe = E.altBoundary,
							Ge = E.padding,
							St = E.tether,
							ht = St === void 0 || St,
							_t = E.tetherOffset,
							gt = _t === void 0 ? 0 : _t,
							yt = Oa(m, { boundary: Oe, rootBoundary: $e, padding: Ge, altBoundary: qe }),
							Xt = bi(m.placement),
							Zt = Da(m.placement),
							Mt = !Zt,
							kt = Mh(Xt),
							Et = kt === "x" ? "y" : "x",
							Rt = m.modifiersData.popperOffsets,
							Ht = m.rects.reference,
							$t = m.rects.popper,
							Gt = typeof gt == "function" ? gt(Object.assign({}, m.rects, { placement: m.placement })) : gt,
							pn = typeof Gt == "number" ? { mainAxis: Gt, altAxis: Gt } : Object.assign({ mainAxis: 0, altAxis: 0 }, Gt),
							ci = m.modifiersData.offset ? m.modifiersData.offset[m.placement] : null,
							Hi = { x: 0, y: 0 };
						if (Rt) {
							if (J) {
								var Kn,
									Ei = kt === "y" ? In : te,
									wi = kt === "y" ? O : $,
									dn = kt === "y" ? "height" : "width",
									ur = Rt[kt],
									hr = ur + yt[Ei],
									Na = ur - yt[wi],
									Rn = ht ? -$t[dn] / 2 : 0,
									jt = Zt === Ae ? Ht[dn] : $t[dn],
									Zn = Zt === Ae ? -$t[dn] : -Ht[dn],
									Ti = m.elements.arrow,
									rs = ht && Ti ? Th(Ti) : { width: 0, height: 0 },
									Sc = m.modifiersData["arrow#persistent"] ? m.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 },
									yg = Sc[Ei],
									xg = Sc[wi],
									Ec = Qo(0, Ht[dn], rs[dn]),
									mE = Mt ? Ht[dn] / 2 - Rn - Ec - yg - pn.mainAxis : jt - Ec - yg - pn.mainAxis,
									gE = Mt ? -Ht[dn] / 2 + Rn + Ec + xg + pn.mainAxis : Zn + Ec + xg + pn.mainAxis,
									$h = m.elements.arrow && Jo(m.elements.arrow),
									vE = $h ? (kt === "y" ? $h.clientTop || 0 : $h.clientLeft || 0) : 0,
									bg = (Kn = ci == null ? void 0 : ci[kt]) != null ? Kn : 0,
									_E = ur + gE - bg,
									Sg = Qo(ht ? uc(hr, ur + mE - bg - vE) : hr, ur, ht ? cr(Na, _E) : Na);
								(Rt[kt] = Sg), (Hi[kt] = Sg - ur);
							}
							if (be) {
								var Eg,
									yE = kt === "x" ? In : te,
									xE = kt === "x" ? O : $,
									$s = Rt[Et],
									wc = Et === "y" ? "height" : "width",
									wg = $s + yt[yE],
									Tg = $s - yt[xE],
									qh = [In, te].indexOf(Xt) !== -1,
									Mg = (Eg = ci == null ? void 0 : ci[Et]) != null ? Eg : 0,
									Ag = qh ? wg : $s - Ht[wc] - $t[wc] - Mg + pn.altAxis,
									Cg = qh ? $s + Ht[wc] + $t[wc] - Mg - pn.altAxis : Tg,
									Lg =
										ht && qh
											? (function (bE, SE, jh) {
													var Rg = Qo(bE, SE, jh);
													return Rg > jh ? jh : Rg;
											  })(Ag, $s, Cg)
											: Qo(ht ? Ag : wg, $s, ht ? Cg : Tg);
								(Rt[Et] = Lg), (Hi[Et] = Lg - $s);
							}
							m.modifiersData[I] = Hi;
						}
					},
					requiresIfExists: ["offset"]
				};
			function Hb(C, m, E) {
				E === void 0 && (E = !1);
				var I,
					q,
					J = Gn(m),
					ce =
						Gn(m) &&
						(function (Ge) {
							var St = Ge.getBoundingClientRect(),
								ht = Ra(St.width) / Ge.offsetWidth || 1,
								_t = Ra(St.height) / Ge.offsetHeight || 1;
							return ht !== 1 || _t !== 1;
						})(m),
					be = ns(m),
					Oe = Pa(C, ce, E),
					$e = { scrollLeft: 0, scrollTop: 0 },
					qe = { x: 0, y: 0 };
				return (J || (!J && !E)) && ((ai(m) !== "body" || Ph(be)) && ($e = (I = m) !== Ft(I) && Gn(I) ? { scrollLeft: (q = I).scrollLeft, scrollTop: q.scrollTop } : Lh(I)), Gn(m) ? (((qe = Pa(m, !0)).x += m.clientLeft), (qe.y += m.clientTop)) : be && (qe.x = Rh(be))), { x: Oe.left + $e.scrollLeft - qe.x, y: Oe.top + $e.scrollTop - qe.y, width: Oe.width, height: Oe.height };
			}
			function Gb(C) {
				var m = new Map(),
					E = new Set(),
					I = [];
				function q(J) {
					E.add(J.name),
						[].concat(J.requires || [], J.requiresIfExists || []).forEach(function (ce) {
							if (!E.has(ce)) {
								var be = m.get(ce);
								be && q(be);
							}
						}),
						I.push(J);
				}
				return (
					C.forEach(function (J) {
						m.set(J.name, J);
					}),
					C.forEach(function (J) {
						E.has(J.name) || q(J);
					}),
					I
				);
			}
			var Im = { placement: "bottom", modifiers: [], strategy: "absolute" };
			function Fm() {
				for (var C = arguments.length, m = new Array(C), E = 0; E < C; E++) m[E] = arguments[E];
				return !m.some(function (I) {
					return !(I && typeof I.getBoundingClientRect == "function");
				});
			}
			function pc(C) {
				C === void 0 && (C = {});
				var m = C,
					E = m.defaultModifiers,
					I = E === void 0 ? [] : E,
					q = m.defaultOptions,
					J = q === void 0 ? Im : q;
				return function (ce, be, Oe) {
					Oe === void 0 && (Oe = J);
					var $e,
						qe,
						Ge = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Im, J), modifiersData: {}, elements: { reference: ce, popper: be }, attributes: {}, styles: {} },
						St = [],
						ht = !1,
						_t = {
							state: Ge,
							setOptions: function (yt) {
								var Xt = typeof yt == "function" ? yt(Ge.options) : yt;
								gt(), (Ge.options = Object.assign({}, J, Ge.options, Xt)), (Ge.scrollParents = { reference: Hn(ce) ? el(ce) : ce.contextElement ? el(ce.contextElement) : [], popper: el(be) });
								var Zt,
									Mt,
									kt = (function (Et) {
										var Rt = Gb(Et);
										return zn.reduce(function (Ht, $t) {
											return Ht.concat(
												Rt.filter(function (Gt) {
													return Gt.phase === $t;
												})
											);
										}, []);
									})(
										((Zt = [].concat(I, Ge.options.modifiers)),
										(Mt = Zt.reduce(function (Et, Rt) {
											var Ht = Et[Rt.name];
											return (Et[Rt.name] = Ht ? Object.assign({}, Ht, Rt, { options: Object.assign({}, Ht.options, Rt.options), data: Object.assign({}, Ht.data, Rt.data) }) : Rt), Et;
										}, {})),
										Object.keys(Mt).map(function (Et) {
											return Mt[Et];
										}))
									);
								return (
									(Ge.orderedModifiers = kt.filter(function (Et) {
										return Et.enabled;
									})),
									Ge.orderedModifiers.forEach(function (Et) {
										var Rt = Et.name,
											Ht = Et.options,
											$t = Ht === void 0 ? {} : Ht,
											Gt = Et.effect;
										if (typeof Gt == "function") {
											var pn = Gt({ state: Ge, name: Rt, instance: _t, options: $t });
											St.push(pn || function () {});
										}
									}),
									_t.update()
								);
							},
							forceUpdate: function () {
								if (!ht) {
									var yt = Ge.elements,
										Xt = yt.reference,
										Zt = yt.popper;
									if (Fm(Xt, Zt)) {
										(Ge.rects = { reference: Hb(Xt, Jo(Zt), Ge.options.strategy === "fixed"), popper: Th(Zt) }),
											(Ge.reset = !1),
											(Ge.placement = Ge.options.placement),
											Ge.orderedModifiers.forEach(function (Gt) {
												return (Ge.modifiersData[Gt.name] = Object.assign({}, Gt.data));
											});
										for (var Mt = 0; Mt < Ge.orderedModifiers.length; Mt++)
											if (Ge.reset !== !0) {
												var kt = Ge.orderedModifiers[Mt],
													Et = kt.fn,
													Rt = kt.options,
													Ht = Rt === void 0 ? {} : Rt,
													$t = kt.name;
												typeof Et == "function" && (Ge = Et({ state: Ge, options: Ht, name: $t, instance: _t }) || Ge);
											} else (Ge.reset = !1), (Mt = -1);
									}
								}
							},
							update:
								(($e = function () {
									return new Promise(function (yt) {
										_t.forceUpdate(), yt(Ge);
									});
								}),
								function () {
									return (
										qe ||
											(qe = new Promise(function (yt) {
												Promise.resolve().then(function () {
													(qe = void 0), yt($e());
												});
											})),
										qe
									);
								}),
							destroy: function () {
								gt(), (ht = !0);
							}
						};
					if (!Fm(ce, be)) return _t;
					function gt() {
						St.forEach(function (yt) {
							return yt();
						}),
							(St = []);
					}
					return (
						_t.setOptions(Oe).then(function (yt) {
							!ht && Oe.onFirstUpdate && Oe.onFirstUpdate(yt);
						}),
						_t
					);
				};
			}
			var Vb = pc(),
				Wb = pc({ defaultModifiers: [Ch, Oh, Ah, ks] }),
				Ih = pc({ defaultModifiers: [Ch, Oh, Ah, ks, Dm, Cm, Om, Sm, Pm] });
			const Nm = Object.freeze(
					Object.defineProperty(
						{
							__proto__: null,
							afterMain: gn,
							afterRead: Bn,
							afterWrite: Lr,
							applyStyles: ks,
							arrow: Sm,
							auto: se,
							basePlacements: Q,
							beforeMain: Nt,
							beforeRead: en,
							beforeWrite: Ut,
							bottom: O,
							clippingParents: je,
							computeStyles: Ah,
							createPopper: Ih,
							createPopperBase: Vb,
							createPopperLite: Wb,
							detectOverflow: Oa,
							end: ke,
							eventListeners: Ch,
							flip: Cm,
							hide: Pm,
							left: te,
							main: Qe,
							modifierPhases: zn,
							offset: Dm,
							placements: It,
							popper: nt,
							popperGenerator: pc,
							popperOffsets: Oh,
							preventOverflow: Om,
							read: tn,
							reference: ut,
							right: $,
							start: Ae,
							top: In,
							variationPlacements: it,
							viewport: Ye,
							write: si
						},
						Symbol.toStringTag,
						{ value: "Module" }
					)
				),
				Um = "dropdown",
				Bs = ".bs.dropdown",
				Fh = ".data-api",
				Xb = "ArrowUp",
				km = "ArrowDown",
				$b = `hide${Bs}`,
				qb = `hidden${Bs}`,
				jb = `show${Bs}`,
				Yb = `shown${Bs}`,
				Bm = `click${Bs}${Fh}`,
				zm = `keydown${Bs}${Fh}`,
				Kb = `keyup${Bs}${Fh}`,
				Ia = "show",
				zs = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
				Zb = `${zs}.${Ia}`,
				mc = ".dropdown-menu",
				Jb = p() ? "top-end" : "top-start",
				Qb = p() ? "top-start" : "top-end",
				eS = p() ? "bottom-end" : "bottom-start",
				tS = p() ? "bottom-start" : "bottom-end",
				nS = p() ? "left-start" : "right-start",
				iS = p() ? "right-start" : "left-start",
				rS = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" },
				sS = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
			class zi extends ge {
				constructor(m, E) {
					super(m, E), (this._popper = null), (this._parent = this._element.parentNode), (this._menu = j.next(this._element, mc)[0] || j.prev(this._element, mc)[0] || j.findOne(mc, this._parent)), (this._inNavbar = this._detectNavbar());
				}
				static get Default() {
					return rS;
				}
				static get DefaultType() {
					return sS;
				}
				static get NAME() {
					return Um;
				}
				toggle() {
					return this._isShown() ? this.hide() : this.show();
				}
				show() {
					if (u(this._element) || this._isShown()) return;
					const m = { relatedTarget: this._element };
					if (!G.trigger(this._element, jb, m).defaultPrevented) {
						if ((this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))) for (const E of [].concat(...document.body.children)) G.on(E, "mouseover", d);
						this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ia), this._element.classList.add(Ia), G.trigger(this._element, Yb, m);
					}
				}
				hide() {
					if (u(this._element) || !this._isShown()) return;
					const m = { relatedTarget: this._element };
					this._completeHide(m);
				}
				dispose() {
					this._popper && this._popper.destroy(), super.dispose();
				}
				update() {
					(this._inNavbar = this._detectNavbar()), this._popper && this._popper.update();
				}
				_completeHide(m) {
					if (!G.trigger(this._element, $b, m).defaultPrevented) {
						if ("ontouchstart" in document.documentElement) for (const E of [].concat(...document.body.children)) G.off(E, "mouseover", d);
						this._popper && this._popper.destroy(), this._menu.classList.remove(Ia), this._element.classList.remove(Ia), this._element.setAttribute("aria-expanded", "false"), Z.removeDataAttribute(this._menu, "popper"), G.trigger(this._element, qb, m);
					}
				}
				_getConfig(m) {
					if (typeof (m = super._getConfig(m)).reference == "object" && !o(m.reference) && typeof m.reference.getBoundingClientRect != "function") throw new TypeError(`${Um.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
					return m;
				}
				_createPopper() {
					if (Nm === void 0) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
					let m = this._element;
					this._config.reference === "parent" ? (m = this._parent) : o(this._config.reference) ? (m = l(this._config.reference)) : typeof this._config.reference == "object" && (m = this._config.reference);
					const E = this._getPopperConfig();
					this._popper = Ih(m, this._menu, E);
				}
				_isShown() {
					return this._menu.classList.contains(Ia);
				}
				_getPlacement() {
					const m = this._parent;
					if (m.classList.contains("dropend")) return nS;
					if (m.classList.contains("dropstart")) return iS;
					if (m.classList.contains("dropup-center")) return "top";
					if (m.classList.contains("dropdown-center")) return "bottom";
					const E = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
					return m.classList.contains("dropup") ? (E ? Qb : Jb) : E ? tS : eS;
				}
				_detectNavbar() {
					return this._element.closest(".navbar") !== null;
				}
				_getOffset() {
					const { offset: m } = this._config;
					return typeof m == "string" ? m.split(",").map((E) => Number.parseInt(E, 10)) : typeof m == "function" ? (E) => m(E, this._element) : m;
				}
				_getPopperConfig() {
					const m = {
						placement: this._getPlacement(),
						modifiers: [
							{ name: "preventOverflow", options: { boundary: this._config.boundary } },
							{ name: "offset", options: { offset: this._getOffset() } }
						]
					};
					return (this._inNavbar || this._config.display === "static") && (Z.setDataAttribute(this._menu, "popper", "static"), (m.modifiers = [{ name: "applyStyles", enabled: !1 }])), { ...m, ...x(this._config.popperConfig, [m]) };
				}
				_selectMenuItem({ key: m, target: E }) {
					const I = j.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((q) => c(q));
					I.length && T(I, E, m === km, !I.includes(E)).focus();
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = zi.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0) throw new TypeError(`No method named "${m}"`);
							E[m]();
						}
					});
				}
				static clearMenus(m) {
					if (m.button === 2 || (m.type === "keyup" && m.key !== "Tab")) return;
					const E = j.find(Zb);
					for (const I of E) {
						const q = zi.getInstance(I);
						if (!q || q._config.autoClose === !1) continue;
						const J = m.composedPath(),
							ce = J.includes(q._menu);
						if (J.includes(q._element) || (q._config.autoClose === "inside" && !ce) || (q._config.autoClose === "outside" && ce) || (q._menu.contains(m.target) && ((m.type === "keyup" && m.key === "Tab") || /input|select|option|textarea|form/i.test(m.target.tagName)))) continue;
						const be = { relatedTarget: q._element };
						m.type === "click" && (be.clickEvent = m), q._completeHide(be);
					}
				}
				static dataApiKeydownHandler(m) {
					const E = /input|textarea/i.test(m.target.tagName),
						I = m.key === "Escape",
						q = [Xb, km].includes(m.key);
					if ((!q && !I) || (E && !I)) return;
					m.preventDefault();
					const J = this.matches(zs) ? this : j.prev(this, zs)[0] || j.next(this, zs)[0] || j.findOne(zs, m.delegateTarget.parentNode),
						ce = zi.getOrCreateInstance(J);
					if (q) return m.stopPropagation(), ce.show(), void ce._selectMenuItem(m);
					ce._isShown() && (m.stopPropagation(), ce.hide(), J.focus());
				}
			}
			G.on(document, zm, zs, zi.dataApiKeydownHandler),
				G.on(document, zm, mc, zi.dataApiKeydownHandler),
				G.on(document, Bm, zi.clearMenus),
				G.on(document, Kb, zi.clearMenus),
				G.on(document, Bm, zs, function (C) {
					C.preventDefault(), zi.getOrCreateInstance(this).toggle();
				}),
				g(zi);
			const Hm = "backdrop",
				Gm = "show",
				Vm = `mousedown.bs.${Hm}`,
				aS = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" },
				oS = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
			class Wm extends ie {
				constructor(m) {
					super(), (this._config = this._getConfig(m)), (this._isAppended = !1), (this._element = null);
				}
				static get Default() {
					return aS;
				}
				static get DefaultType() {
					return oS;
				}
				static get NAME() {
					return Hm;
				}
				show(m) {
					if (!this._config.isVisible) return void x(m);
					this._append();
					const E = this._getElement();
					this._config.isAnimated && f(E),
						E.classList.add(Gm),
						this._emulateAnimation(() => {
							x(m);
						});
				}
				hide(m) {
					this._config.isVisible
						? (this._getElement().classList.remove(Gm),
						  this._emulateAnimation(() => {
								this.dispose(), x(m);
						  }))
						: x(m);
				}
				dispose() {
					this._isAppended && (G.off(this._element, Vm), this._element.remove(), (this._isAppended = !1));
				}
				_getElement() {
					if (!this._element) {
						const m = document.createElement("div");
						(m.className = this._config.className), this._config.isAnimated && m.classList.add("fade"), (this._element = m);
					}
					return this._element;
				}
				_configAfterMerge(m) {
					return (m.rootElement = l(m.rootElement)), m;
				}
				_append() {
					if (this._isAppended) return;
					const m = this._getElement();
					this._config.rootElement.append(m),
						G.on(m, Vm, () => {
							x(this._config.clickCallback);
						}),
						(this._isAppended = !0);
				}
				_emulateAnimation(m) {
					b(m, this._getElement(), this._config.isAnimated);
				}
			}
			const gc = ".bs.focustrap",
				lS = `focusin${gc}`,
				cS = `keydown.tab${gc}`,
				Xm = "backward",
				uS = { autofocus: !0, trapElement: null },
				hS = { autofocus: "boolean", trapElement: "element" };
			class $m extends ie {
				constructor(m) {
					super(), (this._config = this._getConfig(m)), (this._isActive = !1), (this._lastTabNavDirection = null);
				}
				static get Default() {
					return uS;
				}
				static get DefaultType() {
					return hS;
				}
				static get NAME() {
					return "focustrap";
				}
				activate() {
					this._isActive || (this._config.autofocus && this._config.trapElement.focus(), G.off(document, gc), G.on(document, lS, (m) => this._handleFocusin(m)), G.on(document, cS, (m) => this._handleKeydown(m)), (this._isActive = !0));
				}
				deactivate() {
					this._isActive && ((this._isActive = !1), G.off(document, gc));
				}
				_handleFocusin(m) {
					const { trapElement: E } = this._config;
					if (m.target === document || m.target === E || E.contains(m.target)) return;
					const I = j.focusableChildren(E);
					I.length === 0 ? E.focus() : this._lastTabNavDirection === Xm ? I[I.length - 1].focus() : I[0].focus();
				}
				_handleKeydown(m) {
					m.key === "Tab" && (this._lastTabNavDirection = m.shiftKey ? Xm : "forward");
				}
			}
			const qm = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
				jm = ".sticky-top",
				vc = "padding-right",
				Ym = "margin-right";
			class Nh {
				constructor() {
					this._element = document.body;
				}
				getWidth() {
					const m = document.documentElement.clientWidth;
					return Math.abs(window.innerWidth - m);
				}
				hide() {
					const m = this.getWidth();
					this._disableOverFlow(), this._setElementAttributes(this._element, vc, (E) => E + m), this._setElementAttributes(qm, vc, (E) => E + m), this._setElementAttributes(jm, Ym, (E) => E - m);
				}
				reset() {
					this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, vc), this._resetElementAttributes(qm, vc), this._resetElementAttributes(jm, Ym);
				}
				isOverflowing() {
					return this.getWidth() > 0;
				}
				_disableOverFlow() {
					this._saveInitialAttribute(this._element, "overflow"), (this._element.style.overflow = "hidden");
				}
				_setElementAttributes(m, E, I) {
					const q = this.getWidth();
					this._applyManipulationCallback(m, (J) => {
						if (J !== this._element && window.innerWidth > J.clientWidth + q) return;
						this._saveInitialAttribute(J, E);
						const ce = window.getComputedStyle(J).getPropertyValue(E);
						J.style.setProperty(E, `${I(Number.parseFloat(ce))}px`);
					});
				}
				_saveInitialAttribute(m, E) {
					const I = m.style.getPropertyValue(E);
					I && Z.setDataAttribute(m, E, I);
				}
				_resetElementAttributes(m, E) {
					this._applyManipulationCallback(m, (I) => {
						const q = Z.getDataAttribute(I, E);
						q !== null ? (Z.removeDataAttribute(I, E), I.style.setProperty(E, q)) : I.style.removeProperty(E);
					});
				}
				_applyManipulationCallback(m, E) {
					if (o(m)) E(m);
					else for (const I of j.find(m, this._element)) E(I);
				}
			}
			const Si = ".bs.modal",
				dS = `hide${Si}`,
				fS = `hidePrevented${Si}`,
				Km = `hidden${Si}`,
				Zm = `show${Si}`,
				pS = `shown${Si}`,
				mS = `resize${Si}`,
				gS = `click.dismiss${Si}`,
				vS = `mousedown.dismiss${Si}`,
				_S = `keydown.dismiss${Si}`,
				yS = `click${Si}.data-api`,
				Jm = "modal-open",
				Qm = "show",
				Uh = "modal-static",
				xS = { backdrop: !0, focus: !0, keyboard: !0 },
				bS = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
			class Hs extends ge {
				constructor(m, E) {
					super(m, E), (this._dialog = j.findOne(".modal-dialog", this._element)), (this._backdrop = this._initializeBackDrop()), (this._focustrap = this._initializeFocusTrap()), (this._isShown = !1), (this._isTransitioning = !1), (this._scrollBar = new Nh()), this._addEventListeners();
				}
				static get Default() {
					return xS;
				}
				static get DefaultType() {
					return bS;
				}
				static get NAME() {
					return "modal";
				}
				toggle(m) {
					return this._isShown ? this.hide() : this.show(m);
				}
				show(m) {
					this._isShown || this._isTransitioning || G.trigger(this._element, Zm, { relatedTarget: m }).defaultPrevented || ((this._isShown = !0), (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(Jm), this._adjustDialog(), this._backdrop.show(() => this._showElement(m)));
				}
				hide() {
					this._isShown && !this._isTransitioning && (G.trigger(this._element, dS).defaultPrevented || ((this._isShown = !1), (this._isTransitioning = !0), this._focustrap.deactivate(), this._element.classList.remove(Qm), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
				}
				dispose() {
					G.off(window, Si), G.off(this._dialog, Si), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
				}
				handleUpdate() {
					this._adjustDialog();
				}
				_initializeBackDrop() {
					return new Wm({ isVisible: !!this._config.backdrop, isAnimated: this._isAnimated() });
				}
				_initializeFocusTrap() {
					return new $m({ trapElement: this._element });
				}
				_showElement(m) {
					document.body.contains(this._element) || document.body.append(this._element), (this._element.style.display = "block"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), (this._element.scrollTop = 0);
					const E = j.findOne(".modal-body", this._dialog);
					E && (E.scrollTop = 0),
						f(this._element),
						this._element.classList.add(Qm),
						this._queueCallback(
							() => {
								this._config.focus && this._focustrap.activate(), (this._isTransitioning = !1), G.trigger(this._element, pS, { relatedTarget: m });
							},
							this._dialog,
							this._isAnimated()
						);
				}
				_addEventListeners() {
					G.on(this._element, _S, (m) => {
						m.key === "Escape" && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
					}),
						G.on(window, mS, () => {
							this._isShown && !this._isTransitioning && this._adjustDialog();
						}),
						G.on(this._element, vS, (m) => {
							G.one(this._element, gS, (E) => {
								this._element === m.target && this._element === E.target && (this._config.backdrop !== "static" ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
							});
						});
				}
				_hideModal() {
					(this._element.style.display = "none"),
						this._element.setAttribute("aria-hidden", !0),
						this._element.removeAttribute("aria-modal"),
						this._element.removeAttribute("role"),
						(this._isTransitioning = !1),
						this._backdrop.hide(() => {
							document.body.classList.remove(Jm), this._resetAdjustments(), this._scrollBar.reset(), G.trigger(this._element, Km);
						});
				}
				_isAnimated() {
					return this._element.classList.contains("fade");
				}
				_triggerBackdropTransition() {
					if (G.trigger(this._element, fS).defaultPrevented) return;
					const m = this._element.scrollHeight > document.documentElement.clientHeight,
						E = this._element.style.overflowY;
					E === "hidden" ||
						this._element.classList.contains(Uh) ||
						(m || (this._element.style.overflowY = "hidden"),
						this._element.classList.add(Uh),
						this._queueCallback(() => {
							this._element.classList.remove(Uh),
								this._queueCallback(() => {
									this._element.style.overflowY = E;
								}, this._dialog);
						}, this._dialog),
						this._element.focus());
				}
				_adjustDialog() {
					const m = this._element.scrollHeight > document.documentElement.clientHeight,
						E = this._scrollBar.getWidth(),
						I = E > 0;
					if (I && !m) {
						const q = p() ? "paddingLeft" : "paddingRight";
						this._element.style[q] = `${E}px`;
					}
					if (!I && m) {
						const q = p() ? "paddingRight" : "paddingLeft";
						this._element.style[q] = `${E}px`;
					}
				}
				_resetAdjustments() {
					(this._element.style.paddingLeft = ""), (this._element.style.paddingRight = "");
				}
				static jQueryInterface(m, E) {
					return this.each(function () {
						const I = Hs.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (I[m] === void 0) throw new TypeError(`No method named "${m}"`);
							I[m](E);
						}
					});
				}
			}
			G.on(document, yS, '[data-bs-toggle="modal"]', function (C) {
				const m = j.getElementFromSelector(this);
				["A", "AREA"].includes(this.tagName) && C.preventDefault(),
					G.one(m, Zm, (I) => {
						I.defaultPrevented ||
							G.one(m, Km, () => {
								c(this) && this.focus();
							});
					});
				const E = j.findOne(".modal.show");
				E && Hs.getInstance(E).hide(), Hs.getOrCreateInstance(m).toggle(this);
			}),
				he(Hs),
				g(Hs);
			const Pr = ".bs.offcanvas",
				eg = ".data-api",
				SS = `load${Pr}${eg}`,
				tg = "show",
				ng = "showing",
				ig = "hiding",
				rg = ".offcanvas.show",
				ES = `show${Pr}`,
				wS = `shown${Pr}`,
				TS = `hide${Pr}`,
				sg = `hidePrevented${Pr}`,
				ag = `hidden${Pr}`,
				MS = `resize${Pr}`,
				AS = `click${Pr}${eg}`,
				CS = `keydown.dismiss${Pr}`,
				LS = { backdrop: !0, keyboard: !0, scroll: !1 },
				RS = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
			class Dr extends ge {
				constructor(m, E) {
					super(m, E), (this._isShown = !1), (this._backdrop = this._initializeBackDrop()), (this._focustrap = this._initializeFocusTrap()), this._addEventListeners();
				}
				static get Default() {
					return LS;
				}
				static get DefaultType() {
					return RS;
				}
				static get NAME() {
					return "offcanvas";
				}
				toggle(m) {
					return this._isShown ? this.hide() : this.show(m);
				}
				show(m) {
					this._isShown ||
						G.trigger(this._element, ES, { relatedTarget: m }).defaultPrevented ||
						((this._isShown = !0),
						this._backdrop.show(),
						this._config.scroll || new Nh().hide(),
						this._element.setAttribute("aria-modal", !0),
						this._element.setAttribute("role", "dialog"),
						this._element.classList.add(ng),
						this._queueCallback(
							() => {
								(this._config.scroll && !this._config.backdrop) || this._focustrap.activate(), this._element.classList.add(tg), this._element.classList.remove(ng), G.trigger(this._element, wS, { relatedTarget: m });
							},
							this._element,
							!0
						));
				}
				hide() {
					this._isShown &&
						(G.trigger(this._element, TS).defaultPrevented ||
							(this._focustrap.deactivate(),
							this._element.blur(),
							(this._isShown = !1),
							this._element.classList.add(ig),
							this._backdrop.hide(),
							this._queueCallback(
								() => {
									this._element.classList.remove(tg, ig), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new Nh().reset(), G.trigger(this._element, ag);
								},
								this._element,
								!0
							)));
				}
				dispose() {
					this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
				}
				_initializeBackDrop() {
					const m = !!this._config.backdrop;
					return new Wm({
						className: "offcanvas-backdrop",
						isVisible: m,
						isAnimated: !0,
						rootElement: this._element.parentNode,
						clickCallback: m
							? () => {
									this._config.backdrop !== "static" ? this.hide() : G.trigger(this._element, sg);
							  }
							: null
					});
				}
				_initializeFocusTrap() {
					return new $m({ trapElement: this._element });
				}
				_addEventListeners() {
					G.on(this._element, CS, (m) => {
						m.key === "Escape" && (this._config.keyboard ? this.hide() : G.trigger(this._element, sg));
					});
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = Dr.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0 || m.startsWith("_") || m === "constructor") throw new TypeError(`No method named "${m}"`);
							E[m](this);
						}
					});
				}
			}
			G.on(document, AS, '[data-bs-toggle="offcanvas"]', function (C) {
				const m = j.getElementFromSelector(this);
				if ((["A", "AREA"].includes(this.tagName) && C.preventDefault(), u(this))) return;
				G.one(m, ag, () => {
					c(this) && this.focus();
				});
				const E = j.findOne(rg);
				E && E !== m && Dr.getInstance(E).hide(), Dr.getOrCreateInstance(m).toggle(this);
			}),
				G.on(window, SS, () => {
					for (const C of j.find(rg)) Dr.getOrCreateInstance(C).show();
				}),
				G.on(window, MS, () => {
					for (const C of j.find("[aria-modal][class*=show][class*=offcanvas-]")) getComputedStyle(C).position !== "fixed" && Dr.getOrCreateInstance(C).hide();
				}),
				he(Dr),
				g(Dr);
			const og = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] },
				PS = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
				DS = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
				OS = (C, m) => {
					const E = C.nodeName.toLowerCase();
					return m.includes(E) ? !PS.has(E) || !!DS.test(C.nodeValue) : m.filter((I) => I instanceof RegExp).some((I) => I.test(E));
				},
				IS = { allowList: og, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" },
				FS = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" },
				NS = { entry: "(string|element|function|null)", selector: "(string|element)" };
			class US extends ie {
				constructor(m) {
					super(), (this._config = this._getConfig(m));
				}
				static get Default() {
					return IS;
				}
				static get DefaultType() {
					return FS;
				}
				static get NAME() {
					return "TemplateFactory";
				}
				getContent() {
					return Object.values(this._config.content)
						.map((m) => this._resolvePossibleFunction(m))
						.filter(Boolean);
				}
				hasContent() {
					return this.getContent().length > 0;
				}
				changeContent(m) {
					return this._checkContent(m), (this._config.content = { ...this._config.content, ...m }), this;
				}
				toHtml() {
					const m = document.createElement("div");
					m.innerHTML = this._maybeSanitize(this._config.template);
					for (const [q, J] of Object.entries(this._config.content)) this._setContent(m, J, q);
					const E = m.children[0],
						I = this._resolvePossibleFunction(this._config.extraClass);
					return I && E.classList.add(...I.split(" ")), E;
				}
				_typeCheckConfig(m) {
					super._typeCheckConfig(m), this._checkContent(m.content);
				}
				_checkContent(m) {
					for (const [E, I] of Object.entries(m)) super._typeCheckConfig({ selector: E, entry: I }, NS);
				}
				_setContent(m, E, I) {
					const q = j.findOne(I, m);
					q && ((E = this._resolvePossibleFunction(E)) ? (o(E) ? this._putElementInTemplate(l(E), q) : this._config.html ? (q.innerHTML = this._maybeSanitize(E)) : (q.textContent = E)) : q.remove());
				}
				_maybeSanitize(m) {
					return this._config.sanitize
						? (function (E, I, q) {
								if (!E.length) return E;
								if (q && typeof q == "function") return q(E);
								const J = new window.DOMParser().parseFromString(E, "text/html"),
									ce = [].concat(...J.body.querySelectorAll("*"));
								for (const be of ce) {
									const Oe = be.nodeName.toLowerCase();
									if (!Object.keys(I).includes(Oe)) {
										be.remove();
										continue;
									}
									const $e = [].concat(...be.attributes),
										qe = [].concat(I["*"] || [], I[Oe] || []);
									for (const Ge of $e) OS(Ge, qe) || be.removeAttribute(Ge.nodeName);
								}
								return J.body.innerHTML;
						  })(m, this._config.allowList, this._config.sanitizeFn)
						: m;
				}
				_resolvePossibleFunction(m) {
					return x(m, [this]);
				}
				_putElementInTemplate(m, E) {
					if (this._config.html) return (E.innerHTML = ""), void E.append(m);
					E.textContent = m.textContent;
				}
			}
			const kS = new Set(["sanitize", "allowList", "sanitizeFn"]),
				kh = "fade",
				_c = "show",
				lg = ".modal",
				cg = "hide.bs.modal",
				tl = "hover",
				Bh = "focus",
				BS = { AUTO: "auto", TOP: "top", RIGHT: p() ? "left" : "right", BOTTOM: "bottom", LEFT: p() ? "right" : "left" },
				zS = { allowList: og, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" },
				HS = {
					allowList: "object",
					animation: "boolean",
					boundary: "(string|element)",
					container: "(string|element|boolean)",
					customClass: "(string|function)",
					delay: "(number|object)",
					fallbackPlacements: "array",
					html: "boolean",
					offset: "(array|string|function)",
					placement: "(string|function)",
					popperConfig: "(null|object|function)",
					sanitize: "boolean",
					sanitizeFn: "(null|function)",
					selector: "(string|boolean)",
					template: "string",
					title: "(string|element|function)",
					trigger: "string"
				};
			class Gs extends ge {
				constructor(m, E) {
					if (Nm === void 0) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
					super(m, E), (this._isEnabled = !0), (this._timeout = 0), (this._isHovered = null), (this._activeTrigger = {}), (this._popper = null), (this._templateFactory = null), (this._newContent = null), (this.tip = null), this._setListeners(), this._config.selector || this._fixTitle();
				}
				static get Default() {
					return zS;
				}
				static get DefaultType() {
					return HS;
				}
				static get NAME() {
					return "tooltip";
				}
				enable() {
					this._isEnabled = !0;
				}
				disable() {
					this._isEnabled = !1;
				}
				toggleEnabled() {
					this._isEnabled = !this._isEnabled;
				}
				toggle() {
					this._isEnabled && ((this._activeTrigger.click = !this._activeTrigger.click), this._isShown() ? this._leave() : this._enter());
				}
				dispose() {
					clearTimeout(this._timeout), G.off(this._element.closest(lg), cg, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
				}
				show() {
					if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
					if (!this._isWithContent() || !this._isEnabled) return;
					const m = G.trigger(this._element, this.constructor.eventName("show")),
						E = (h(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
					if (m.defaultPrevented || !E) return;
					this._disposePopper();
					const I = this._getTipElement();
					this._element.setAttribute("aria-describedby", I.getAttribute("id"));
					const { container: q } = this._config;
					if ((this._element.ownerDocument.documentElement.contains(this.tip) || (q.append(I), G.trigger(this._element, this.constructor.eventName("inserted"))), (this._popper = this._createPopper(I)), I.classList.add(_c), "ontouchstart" in document.documentElement)) for (const J of [].concat(...document.body.children)) G.on(J, "mouseover", d);
					this._queueCallback(
						() => {
							G.trigger(this._element, this.constructor.eventName("shown")), this._isHovered === !1 && this._leave(), (this._isHovered = !1);
						},
						this.tip,
						this._isAnimated()
					);
				}
				hide() {
					if (this._isShown() && !G.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
						if ((this._getTipElement().classList.remove(_c), "ontouchstart" in document.documentElement)) for (const m of [].concat(...document.body.children)) G.off(m, "mouseover", d);
						(this._activeTrigger.click = !1),
							(this._activeTrigger[Bh] = !1),
							(this._activeTrigger[tl] = !1),
							(this._isHovered = null),
							this._queueCallback(
								() => {
									this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), G.trigger(this._element, this.constructor.eventName("hidden")));
								},
								this.tip,
								this._isAnimated()
							);
					}
				}
				update() {
					this._popper && this._popper.update();
				}
				_isWithContent() {
					return !!this._getTitle();
				}
				_getTipElement() {
					return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
				}
				_createTipElement(m) {
					const E = this._getTemplateFactory(m).toHtml();
					if (!E) return null;
					E.classList.remove(kh, _c), E.classList.add(`bs-${this.constructor.NAME}-auto`);
					const I = ((q) => {
						do q += Math.floor(1e6 * Math.random());
						while (document.getElementById(q));
						return q;
					})(this.constructor.NAME).toString();
					return E.setAttribute("id", I), this._isAnimated() && E.classList.add(kh), E;
				}
				setContent(m) {
					(this._newContent = m), this._isShown() && (this._disposePopper(), this.show());
				}
				_getTemplateFactory(m) {
					return this._templateFactory ? this._templateFactory.changeContent(m) : (this._templateFactory = new US({ ...this._config, content: m, extraClass: this._resolvePossibleFunction(this._config.customClass) })), this._templateFactory;
				}
				_getContentForTemplate() {
					return { ".tooltip-inner": this._getTitle() };
				}
				_getTitle() {
					return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
				}
				_initializeOnDelegatedTarget(m) {
					return this.constructor.getOrCreateInstance(m.delegateTarget, this._getDelegateConfig());
				}
				_isAnimated() {
					return this._config.animation || (this.tip && this.tip.classList.contains(kh));
				}
				_isShown() {
					return this.tip && this.tip.classList.contains(_c);
				}
				_createPopper(m) {
					const E = x(this._config.placement, [this, m, this._element]),
						I = BS[E.toUpperCase()];
					return Ih(this._element, m, this._getPopperConfig(I));
				}
				_getOffset() {
					const { offset: m } = this._config;
					return typeof m == "string" ? m.split(",").map((E) => Number.parseInt(E, 10)) : typeof m == "function" ? (E) => m(E, this._element) : m;
				}
				_resolvePossibleFunction(m) {
					return x(m, [this._element]);
				}
				_getPopperConfig(m) {
					const E = {
						placement: m,
						modifiers: [
							{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } },
							{ name: "offset", options: { offset: this._getOffset() } },
							{ name: "preventOverflow", options: { boundary: this._config.boundary } },
							{ name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } },
							{
								name: "preSetPlacement",
								enabled: !0,
								phase: "beforeMain",
								fn: (I) => {
									this._getTipElement().setAttribute("data-popper-placement", I.state.placement);
								}
							}
						]
					};
					return { ...E, ...x(this._config.popperConfig, [E]) };
				}
				_setListeners() {
					const m = this._config.trigger.split(" ");
					for (const E of m)
						if (E === "click")
							G.on(this._element, this.constructor.eventName("click"), this._config.selector, (I) => {
								this._initializeOnDelegatedTarget(I).toggle();
							});
						else if (E !== "manual") {
							const I = E === tl ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
								q = E === tl ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
							G.on(this._element, I, this._config.selector, (J) => {
								const ce = this._initializeOnDelegatedTarget(J);
								(ce._activeTrigger[J.type === "focusin" ? Bh : tl] = !0), ce._enter();
							}),
								G.on(this._element, q, this._config.selector, (J) => {
									const ce = this._initializeOnDelegatedTarget(J);
									(ce._activeTrigger[J.type === "focusout" ? Bh : tl] = ce._element.contains(J.relatedTarget)), ce._leave();
								});
						}
					(this._hideModalHandler = () => {
						this._element && this.hide();
					}),
						G.on(this._element.closest(lg), cg, this._hideModalHandler);
				}
				_fixTitle() {
					const m = this._element.getAttribute("title");
					m && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", m), this._element.setAttribute("data-bs-original-title", m), this._element.removeAttribute("title"));
				}
				_enter() {
					this._isShown() || this._isHovered
						? (this._isHovered = !0)
						: ((this._isHovered = !0),
						  this._setTimeout(() => {
								this._isHovered && this.show();
						  }, this._config.delay.show));
				}
				_leave() {
					this._isWithActiveTrigger() ||
						((this._isHovered = !1),
						this._setTimeout(() => {
							this._isHovered || this.hide();
						}, this._config.delay.hide));
				}
				_setTimeout(m, E) {
					clearTimeout(this._timeout), (this._timeout = setTimeout(m, E));
				}
				_isWithActiveTrigger() {
					return Object.values(this._activeTrigger).includes(!0);
				}
				_getConfig(m) {
					const E = Z.getDataAttributes(this._element);
					for (const I of Object.keys(E)) kS.has(I) && delete E[I];
					return (m = { ...E, ...(typeof m == "object" && m ? m : {}) }), (m = this._mergeConfigObj(m)), (m = this._configAfterMerge(m)), this._typeCheckConfig(m), m;
				}
				_configAfterMerge(m) {
					return (m.container = m.container === !1 ? document.body : l(m.container)), typeof m.delay == "number" && (m.delay = { show: m.delay, hide: m.delay }), typeof m.title == "number" && (m.title = m.title.toString()), typeof m.content == "number" && (m.content = m.content.toString()), m;
				}
				_getDelegateConfig() {
					const m = {};
					for (const [E, I] of Object.entries(this._config)) this.constructor.Default[E] !== I && (m[E] = I);
					return (m.selector = !1), (m.trigger = "manual"), m;
				}
				_disposePopper() {
					this._popper && (this._popper.destroy(), (this._popper = null)), this.tip && (this.tip.remove(), (this.tip = null));
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = Gs.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0) throw new TypeError(`No method named "${m}"`);
							E[m]();
						}
					});
				}
			}
			g(Gs);
			const GS = { ...Gs.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" },
				VS = { ...Gs.DefaultType, content: "(null|string|element|function)" };
			class yc extends Gs {
				static get Default() {
					return GS;
				}
				static get DefaultType() {
					return VS;
				}
				static get NAME() {
					return "popover";
				}
				_isWithContent() {
					return this._getTitle() || this._getContent();
				}
				_getContentForTemplate() {
					return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() };
				}
				_getContent() {
					return this._resolvePossibleFunction(this._config.content);
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = yc.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0) throw new TypeError(`No method named "${m}"`);
							E[m]();
						}
					});
				}
			}
			g(yc);
			const zh = ".bs.scrollspy",
				WS = `activate${zh}`,
				ug = `click${zh}`,
				XS = `load${zh}.data-api`,
				Fa = "active",
				Hh = "[href]",
				hg = ".nav-link",
				$S = `${hg}, .nav-item > ${hg}, .list-group-item`,
				qS = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1] },
				jS = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
			class nl extends ge {
				constructor(m, E) {
					super(m, E), (this._targetLinks = new Map()), (this._observableSections = new Map()), (this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element), (this._activeTarget = null), (this._observer = null), (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }), this.refresh();
				}
				static get Default() {
					return qS;
				}
				static get DefaultType() {
					return jS;
				}
				static get NAME() {
					return "scrollspy";
				}
				refresh() {
					this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : (this._observer = this._getNewObserver());
					for (const m of this._observableSections.values()) this._observer.observe(m);
				}
				dispose() {
					this._observer.disconnect(), super.dispose();
				}
				_configAfterMerge(m) {
					return (m.target = l(m.target) || document.body), (m.rootMargin = m.offset ? `${m.offset}px 0px -30%` : m.rootMargin), typeof m.threshold == "string" && (m.threshold = m.threshold.split(",").map((E) => Number.parseFloat(E))), m;
				}
				_maybeEnableSmoothScroll() {
					this._config.smoothScroll &&
						(G.off(this._config.target, ug),
						G.on(this._config.target, ug, Hh, (m) => {
							const E = this._observableSections.get(m.target.hash);
							if (E) {
								m.preventDefault();
								const I = this._rootElement || window,
									q = E.offsetTop - this._element.offsetTop;
								if (I.scrollTo) return void I.scrollTo({ top: q, behavior: "smooth" });
								I.scrollTop = q;
							}
						}));
				}
				_getNewObserver() {
					const m = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
					return new IntersectionObserver((E) => this._observerCallback(E), m);
				}
				_observerCallback(m) {
					const E = (ce) => this._targetLinks.get(`#${ce.target.id}`),
						I = (ce) => {
							(this._previousScrollData.visibleEntryTop = ce.target.offsetTop), this._process(E(ce));
						},
						q = (this._rootElement || document.documentElement).scrollTop,
						J = q >= this._previousScrollData.parentScrollTop;
					this._previousScrollData.parentScrollTop = q;
					for (const ce of m) {
						if (!ce.isIntersecting) {
							(this._activeTarget = null), this._clearActiveClass(E(ce));
							continue;
						}
						const be = ce.target.offsetTop >= this._previousScrollData.visibleEntryTop;
						if (J && be) {
							if ((I(ce), !q)) return;
						} else J || be || I(ce);
					}
				}
				_initializeTargetsAndObservables() {
					(this._targetLinks = new Map()), (this._observableSections = new Map());
					const m = j.find(Hh, this._config.target);
					for (const E of m) {
						if (!E.hash || u(E)) continue;
						const I = j.findOne(decodeURI(E.hash), this._element);
						c(I) && (this._targetLinks.set(decodeURI(E.hash), E), this._observableSections.set(E.hash, I));
					}
				}
				_process(m) {
					this._activeTarget !== m && (this._clearActiveClass(this._config.target), (this._activeTarget = m), m.classList.add(Fa), this._activateParents(m), G.trigger(this._element, WS, { relatedTarget: m }));
				}
				_activateParents(m) {
					if (m.classList.contains("dropdown-item")) j.findOne(".dropdown-toggle", m.closest(".dropdown")).classList.add(Fa);
					else for (const E of j.parents(m, ".nav, .list-group")) for (const I of j.prev(E, $S)) I.classList.add(Fa);
				}
				_clearActiveClass(m) {
					m.classList.remove(Fa);
					const E = j.find(`${Hh}.${Fa}`, m);
					for (const I of E) I.classList.remove(Fa);
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = nl.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0 || m.startsWith("_") || m === "constructor") throw new TypeError(`No method named "${m}"`);
							E[m]();
						}
					});
				}
			}
			G.on(window, XS, () => {
				for (const C of j.find('[data-bs-spy="scroll"]')) nl.getOrCreateInstance(C);
			}),
				g(nl);
			const Vs = ".bs.tab",
				YS = `hide${Vs}`,
				KS = `hidden${Vs}`,
				ZS = `show${Vs}`,
				JS = `shown${Vs}`,
				QS = `click${Vs}`,
				eE = `keydown${Vs}`,
				tE = `load${Vs}`,
				nE = "ArrowLeft",
				dg = "ArrowRight",
				iE = "ArrowUp",
				fg = "ArrowDown",
				Gh = "Home",
				pg = "End",
				Ws = "active",
				mg = "fade",
				Vh = "show",
				gg = ".dropdown-toggle",
				Wh = `:not(${gg})`,
				vg = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
				Xh = `.nav-link${Wh}, .list-group-item${Wh}, [role="tab"]${Wh}, ${vg}`,
				rE = `.${Ws}[data-bs-toggle="tab"], .${Ws}[data-bs-toggle="pill"], .${Ws}[data-bs-toggle="list"]`;
			class Xs extends ge {
				constructor(m) {
					super(m), (this._parent = this._element.closest('.list-group, .nav, [role="tablist"]')), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), G.on(this._element, eE, (E) => this._keydown(E)));
				}
				static get NAME() {
					return "tab";
				}
				show() {
					const m = this._element;
					if (this._elemIsActive(m)) return;
					const E = this._getActiveElem(),
						I = E ? G.trigger(E, YS, { relatedTarget: m }) : null;
					G.trigger(m, ZS, { relatedTarget: E }).defaultPrevented || (I && I.defaultPrevented) || (this._deactivate(E, m), this._activate(m, E));
				}
				_activate(m, E) {
					m &&
						(m.classList.add(Ws),
						this._activate(j.getElementFromSelector(m)),
						this._queueCallback(
							() => {
								m.getAttribute("role") === "tab" ? (m.removeAttribute("tabindex"), m.setAttribute("aria-selected", !0), this._toggleDropDown(m, !0), G.trigger(m, JS, { relatedTarget: E })) : m.classList.add(Vh);
							},
							m,
							m.classList.contains(mg)
						));
				}
				_deactivate(m, E) {
					m &&
						(m.classList.remove(Ws),
						m.blur(),
						this._deactivate(j.getElementFromSelector(m)),
						this._queueCallback(
							() => {
								m.getAttribute("role") === "tab" ? (m.setAttribute("aria-selected", !1), m.setAttribute("tabindex", "-1"), this._toggleDropDown(m, !1), G.trigger(m, KS, { relatedTarget: E })) : m.classList.remove(Vh);
							},
							m,
							m.classList.contains(mg)
						));
				}
				_keydown(m) {
					if (![nE, dg, iE, fg, Gh, pg].includes(m.key)) return;
					m.stopPropagation(), m.preventDefault();
					const E = this._getChildren().filter((q) => !u(q));
					let I;
					if ([Gh, pg].includes(m.key)) I = E[m.key === Gh ? 0 : E.length - 1];
					else {
						const q = [dg, fg].includes(m.key);
						I = T(E, m.target, q, !0);
					}
					I && (I.focus({ preventScroll: !0 }), Xs.getOrCreateInstance(I).show());
				}
				_getChildren() {
					return j.find(Xh, this._parent);
				}
				_getActiveElem() {
					return this._getChildren().find((m) => this._elemIsActive(m)) || null;
				}
				_setInitialAttributes(m, E) {
					this._setAttributeIfNotExists(m, "role", "tablist");
					for (const I of E) this._setInitialAttributesOnChild(I);
				}
				_setInitialAttributesOnChild(m) {
					m = this._getInnerElement(m);
					const E = this._elemIsActive(m),
						I = this._getOuterElement(m);
					m.setAttribute("aria-selected", E), I !== m && this._setAttributeIfNotExists(I, "role", "presentation"), E || m.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(m, "role", "tab"), this._setInitialAttributesOnTargetPanel(m);
				}
				_setInitialAttributesOnTargetPanel(m) {
					const E = j.getElementFromSelector(m);
					E && (this._setAttributeIfNotExists(E, "role", "tabpanel"), m.id && this._setAttributeIfNotExists(E, "aria-labelledby", `${m.id}`));
				}
				_toggleDropDown(m, E) {
					const I = this._getOuterElement(m);
					if (!I.classList.contains("dropdown")) return;
					const q = (J, ce) => {
						const be = j.findOne(J, I);
						be && be.classList.toggle(ce, E);
					};
					q(gg, Ws), q(".dropdown-menu", Vh), I.setAttribute("aria-expanded", E);
				}
				_setAttributeIfNotExists(m, E, I) {
					m.hasAttribute(E) || m.setAttribute(E, I);
				}
				_elemIsActive(m) {
					return m.classList.contains(Ws);
				}
				_getInnerElement(m) {
					return m.matches(Xh) ? m : j.findOne(Xh, m);
				}
				_getOuterElement(m) {
					return m.closest(".nav-item, .list-group-item") || m;
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = Xs.getOrCreateInstance(this);
						if (typeof m == "string") {
							if (E[m] === void 0 || m.startsWith("_") || m === "constructor") throw new TypeError(`No method named "${m}"`);
							E[m]();
						}
					});
				}
			}
			G.on(document, QS, vg, function (C) {
				["A", "AREA"].includes(this.tagName) && C.preventDefault(), u(this) || Xs.getOrCreateInstance(this).show();
			}),
				G.on(window, tE, () => {
					for (const C of j.find(rE)) Xs.getOrCreateInstance(C);
				}),
				g(Xs);
			const is = ".bs.toast",
				sE = `mouseover${is}`,
				aE = `mouseout${is}`,
				oE = `focusin${is}`,
				lE = `focusout${is}`,
				cE = `hide${is}`,
				uE = `hidden${is}`,
				hE = `show${is}`,
				dE = `shown${is}`,
				_g = "hide",
				xc = "show",
				bc = "showing",
				fE = { animation: "boolean", autohide: "boolean", delay: "number" },
				pE = { animation: !0, autohide: !0, delay: 5e3 };
			class il extends ge {
				constructor(m, E) {
					super(m, E), (this._timeout = null), (this._hasMouseInteraction = !1), (this._hasKeyboardInteraction = !1), this._setListeners();
				}
				static get Default() {
					return pE;
				}
				static get DefaultType() {
					return fE;
				}
				static get NAME() {
					return "toast";
				}
				show() {
					G.trigger(this._element, hE).defaultPrevented ||
						(this._clearTimeout(),
						this._config.animation && this._element.classList.add("fade"),
						this._element.classList.remove(_g),
						f(this._element),
						this._element.classList.add(xc, bc),
						this._queueCallback(
							() => {
								this._element.classList.remove(bc), G.trigger(this._element, dE), this._maybeScheduleHide();
							},
							this._element,
							this._config.animation
						));
				}
				hide() {
					this.isShown() &&
						(G.trigger(this._element, cE).defaultPrevented ||
							(this._element.classList.add(bc),
							this._queueCallback(
								() => {
									this._element.classList.add(_g), this._element.classList.remove(bc, xc), G.trigger(this._element, uE);
								},
								this._element,
								this._config.animation
							)));
				}
				dispose() {
					this._clearTimeout(), this.isShown() && this._element.classList.remove(xc), super.dispose();
				}
				isShown() {
					return this._element.classList.contains(xc);
				}
				_maybeScheduleHide() {
					this._config.autohide &&
						(this._hasMouseInteraction ||
							this._hasKeyboardInteraction ||
							(this._timeout = setTimeout(() => {
								this.hide();
							}, this._config.delay)));
				}
				_onInteraction(m, E) {
					switch (m.type) {
						case "mouseover":
						case "mouseout":
							this._hasMouseInteraction = E;
							break;
						case "focusin":
						case "focusout":
							this._hasKeyboardInteraction = E;
					}
					if (E) return void this._clearTimeout();
					const I = m.relatedTarget;
					this._element === I || this._element.contains(I) || this._maybeScheduleHide();
				}
				_setListeners() {
					G.on(this._element, sE, (m) => this._onInteraction(m, !0)), G.on(this._element, aE, (m) => this._onInteraction(m, !1)), G.on(this._element, oE, (m) => this._onInteraction(m, !0)), G.on(this._element, lE, (m) => this._onInteraction(m, !1));
				}
				_clearTimeout() {
					clearTimeout(this._timeout), (this._timeout = null);
				}
				static jQueryInterface(m) {
					return this.each(function () {
						const E = il.getOrCreateInstance(this, m);
						if (typeof m == "string") {
							if (E[m] === void 0) throw new TypeError(`No method named "${m}"`);
							E[m](this);
						}
					});
				}
			}
			return he(il), g(il), { Alert: fe, Button: Ee, Carousel: At, Collapse: ts, Dropdown: zi, Modal: Hs, Offcanvas: Dr, Popover: yc, ScrollSpy: nl, Tab: Xs, Toast: il, Tooltip: Gs };
		});
	})(wE);
	var ii = "top",
		pi = "bottom",
		mi = "right",
		ri = "left",
		uh = "auto",
		Go = [ii, pi, mi, ri],
		ma = "start",
		Ro = "end",
		k_ = "clippingParents",
		vp = "viewport",
		uo = "popper",
		B_ = "reference",
		ff = Go.reduce(function (n, e) {
			return n.concat([e + "-" + ma, e + "-" + Ro]);
		}, []),
		_p = [].concat(Go, [uh]).reduce(function (n, e) {
			return n.concat([e, e + "-" + ma, e + "-" + Ro]);
		}, []),
		z_ = "beforeRead",
		H_ = "read",
		G_ = "afterRead",
		V_ = "beforeMain",
		W_ = "main",
		X_ = "afterMain",
		$_ = "beforeWrite",
		q_ = "write",
		j_ = "afterWrite",
		Y_ = [z_, H_, G_, V_, W_, X_, $_, q_, j_];
	function br(n) {
		return n ? (n.nodeName || "").toLowerCase() : null;
	}
	function gi(n) {
		if (n == null) return window;
		if (n.toString() !== "[object Window]") {
			var e = n.ownerDocument;
			return (e && e.defaultView) || window;
		}
		return n;
	}
	function ga(n) {
		var e = gi(n).Element;
		return n instanceof e || n instanceof Element;
	}
	function Ii(n) {
		var e = gi(n).HTMLElement;
		return n instanceof e || n instanceof HTMLElement;
	}
	function yp(n) {
		if (typeof ShadowRoot > "u") return !1;
		var e = gi(n).ShadowRoot;
		return n instanceof e || n instanceof ShadowRoot;
	}
	function TE(n) {
		var e = n.state;
		Object.keys(e.elements).forEach(function (t) {
			var i = e.styles[t] || {},
				r = e.attributes[t] || {},
				s = e.elements[t];
			!Ii(s) ||
				!br(s) ||
				(Object.assign(s.style, i),
				Object.keys(r).forEach(function (a) {
					var o = r[a];
					o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
				}));
		});
	}
	function ME(n) {
		var e = n.state,
			t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
		return (
			Object.assign(e.elements.popper.style, t.popper),
			(e.styles = t),
			e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow),
			function () {
				Object.keys(e.elements).forEach(function (i) {
					var r = e.elements[i],
						s = e.attributes[i] || {},
						a = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]),
						o = a.reduce(function (l, c) {
							return (l[c] = ""), l;
						}, {});
					!Ii(r) ||
						!br(r) ||
						(Object.assign(r.style, o),
						Object.keys(s).forEach(function (l) {
							r.removeAttribute(l);
						}));
				});
			}
		);
	}
	const xp = { name: "applyStyles", enabled: !0, phase: "write", fn: TE, effect: ME, requires: ["computeStyles"] };
	function _r(n) {
		return n.split("-")[0];
	}
	var pa = Math.max,
		zu = Math.min,
		Po = Math.round;
	function pf() {
		var n = navigator.userAgentData;
		return n != null && n.brands && Array.isArray(n.brands)
			? n.brands
					.map(function (e) {
						return e.brand + "/" + e.version;
					})
					.join(" ")
			: navigator.userAgent;
	}
	function K_() {
		return !/^((?!chrome|android).)*safari/i.test(pf());
	}
	function Do(n, e, t) {
		e === void 0 && (e = !1), t === void 0 && (t = !1);
		var i = n.getBoundingClientRect(),
			r = 1,
			s = 1;
		e && Ii(n) && ((r = (n.offsetWidth > 0 && Po(i.width) / n.offsetWidth) || 1), (s = (n.offsetHeight > 0 && Po(i.height) / n.offsetHeight) || 1));
		var a = ga(n) ? gi(n) : window,
			o = a.visualViewport,
			l = !K_() && t,
			c = (i.left + (l && o ? o.offsetLeft : 0)) / r,
			u = (i.top + (l && o ? o.offsetTop : 0)) / s,
			h = i.width / r,
			d = i.height / s;
		return { width: h, height: d, top: u, right: c + h, bottom: u + d, left: c, x: c, y: u };
	}
	function bp(n) {
		var e = Do(n),
			t = n.offsetWidth,
			i = n.offsetHeight;
		return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: i };
	}
	function Z_(n, e) {
		var t = e.getRootNode && e.getRootNode();
		if (n.contains(e)) return !0;
		if (t && yp(t)) {
			var i = e;
			do {
				if (i && n.isSameNode(i)) return !0;
				i = i.parentNode || i.host;
			} while (i);
		}
		return !1;
	}
	function jr(n) {
		return gi(n).getComputedStyle(n);
	}
	function AE(n) {
		return ["table", "td", "th"].indexOf(br(n)) >= 0;
	}
	function Ds(n) {
		return ((ga(n) ? n.ownerDocument : n.document) || window.document).documentElement;
	}
	function hh(n) {
		return br(n) === "html" ? n : n.assignedSlot || n.parentNode || (yp(n) ? n.host : null) || Ds(n);
	}
	function Pg(n) {
		return !Ii(n) || jr(n).position === "fixed" ? null : n.offsetParent;
	}
	function CE(n) {
		var e = /firefox/i.test(pf()),
			t = /Trident/i.test(pf());
		if (t && Ii(n)) {
			var i = jr(n);
			if (i.position === "fixed") return null;
		}
		var r = hh(n);
		for (yp(r) && (r = r.host); Ii(r) && ["html", "body"].indexOf(br(r)) < 0; ) {
			var s = jr(r);
			if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || (e && s.willChange === "filter") || (e && s.filter && s.filter !== "none")) return r;
			r = r.parentNode;
		}
		return null;
	}
	function Vl(n) {
		for (var e = gi(n), t = Pg(n); t && AE(t) && jr(t).position === "static"; ) t = Pg(t);
		return t && (br(t) === "html" || (br(t) === "body" && jr(t).position === "static")) ? e : t || CE(n) || e;
	}
	function Sp(n) {
		return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
	}
	function wl(n, e, t) {
		return pa(n, zu(e, t));
	}
	function LE(n, e, t) {
		var i = wl(n, e, t);
		return i > t ? t : i;
	}
	function J_() {
		return { top: 0, right: 0, bottom: 0, left: 0 };
	}
	function Q_(n) {
		return Object.assign({}, J_(), n);
	}
	function ey(n, e) {
		return e.reduce(function (t, i) {
			return (t[i] = n), t;
		}, {});
	}
	var RE = function (e, t) {
		return (e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e), Q_(typeof e != "number" ? e : ey(e, Go));
	};
	function PE(n) {
		var e,
			t = n.state,
			i = n.name,
			r = n.options,
			s = t.elements.arrow,
			a = t.modifiersData.popperOffsets,
			o = _r(t.placement),
			l = Sp(o),
			c = [ri, mi].indexOf(o) >= 0,
			u = c ? "height" : "width";
		if (!(!s || !a)) {
			var h = RE(r.padding, t),
				d = bp(s),
				f = l === "y" ? ii : ri,
				v = l === "y" ? pi : mi,
				_ = t.rects.reference[u] + t.rects.reference[l] - a[l] - t.rects.popper[u],
				p = a[l] - t.rects.reference[l],
				g = Vl(s),
				x = g ? (l === "y" ? g.clientHeight || 0 : g.clientWidth || 0) : 0,
				b = _ / 2 - p / 2,
				T = h[f],
				P = x - d[u] - h[v],
				A = x / 2 - d[u] / 2 + b,
				M = wl(T, A, P),
				w = l;
			t.modifiersData[i] = ((e = {}), (e[w] = M), (e.centerOffset = M - A), e);
		}
	}
	function DE(n) {
		var e = n.state,
			t = n.options,
			i = t.element,
			r = i === void 0 ? "[data-popper-arrow]" : i;
		r != null && ((typeof r == "string" && ((r = e.elements.popper.querySelector(r)), !r)) || (Z_(e.elements.popper, r) && (e.elements.arrow = r)));
	}
	const ty = { name: "arrow", enabled: !0, phase: "main", fn: PE, effect: DE, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
	function Oo(n) {
		return n.split("-")[1];
	}
	var OE = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
	function IE(n, e) {
		var t = n.x,
			i = n.y,
			r = e.devicePixelRatio || 1;
		return { x: Po(t * r) / r || 0, y: Po(i * r) / r || 0 };
	}
	function Dg(n) {
		var e,
			t = n.popper,
			i = n.popperRect,
			r = n.placement,
			s = n.variation,
			a = n.offsets,
			o = n.position,
			l = n.gpuAcceleration,
			c = n.adaptive,
			u = n.roundOffsets,
			h = n.isFixed,
			d = a.x,
			f = d === void 0 ? 0 : d,
			v = a.y,
			_ = v === void 0 ? 0 : v,
			p = typeof u == "function" ? u({ x: f, y: _ }) : { x: f, y: _ };
		(f = p.x), (_ = p.y);
		var g = a.hasOwnProperty("x"),
			x = a.hasOwnProperty("y"),
			b = ri,
			T = ii,
			P = window;
		if (c) {
			var A = Vl(t),
				M = "clientHeight",
				w = "clientWidth";
			if ((A === gi(t) && ((A = Ds(t)), jr(A).position !== "static" && o === "absolute" && ((M = "scrollHeight"), (w = "scrollWidth"))), (A = A), r === ii || ((r === ri || r === mi) && s === Ro))) {
				T = pi;
				var y = h && A === P && P.visualViewport ? P.visualViewport.height : A[M];
				(_ -= y - i.height), (_ *= l ? 1 : -1);
			}
			if (r === ri || ((r === ii || r === pi) && s === Ro)) {
				b = mi;
				var S = h && A === P && P.visualViewport ? P.visualViewport.width : A[w];
				(f -= S - i.width), (f *= l ? 1 : -1);
			}
		}
		var L = Object.assign({ position: o }, c && OE),
			N = u === !0 ? IE({ x: f, y: _ }, gi(t)) : { x: f, y: _ };
		if (((f = N.x), (_ = N.y), l)) {
			var k;
			return Object.assign({}, L, ((k = {}), (k[T] = x ? "0" : ""), (k[b] = g ? "0" : ""), (k.transform = (P.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + _ + "px)" : "translate3d(" + f + "px, " + _ + "px, 0)"), k));
		}
		return Object.assign({}, L, ((e = {}), (e[T] = x ? _ + "px" : ""), (e[b] = g ? f + "px" : ""), (e.transform = ""), e));
	}
	function FE(n) {
		var e = n.state,
			t = n.options,
			i = t.gpuAcceleration,
			r = i === void 0 ? !0 : i,
			s = t.adaptive,
			a = s === void 0 ? !0 : s,
			o = t.roundOffsets,
			l = o === void 0 ? !0 : o,
			c = { placement: _r(e.placement), variation: Oo(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: r, isFixed: e.options.strategy === "fixed" };
		e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Dg(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: l })))),
			e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Dg(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))),
			(e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }));
	}
	const Ep = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: FE, data: {} };
	var Tc = { passive: !0 };
	function NE(n) {
		var e = n.state,
			t = n.instance,
			i = n.options,
			r = i.scroll,
			s = r === void 0 ? !0 : r,
			a = i.resize,
			o = a === void 0 ? !0 : a,
			l = gi(e.elements.popper),
			c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
		return (
			s &&
				c.forEach(function (u) {
					u.addEventListener("scroll", t.update, Tc);
				}),
			o && l.addEventListener("resize", t.update, Tc),
			function () {
				s &&
					c.forEach(function (u) {
						u.removeEventListener("scroll", t.update, Tc);
					}),
					o && l.removeEventListener("resize", t.update, Tc);
			}
		);
	}
	const wp = { name: "eventListeners", enabled: !0, phase: "write", fn: function () {}, effect: NE, data: {} };
	var UE = { left: "right", right: "left", bottom: "top", top: "bottom" };
	function Tu(n) {
		return n.replace(/left|right|bottom|top/g, function (e) {
			return UE[e];
		});
	}
	var kE = { start: "end", end: "start" };
	function Og(n) {
		return n.replace(/start|end/g, function (e) {
			return kE[e];
		});
	}
	function Tp(n) {
		var e = gi(n),
			t = e.pageXOffset,
			i = e.pageYOffset;
		return { scrollLeft: t, scrollTop: i };
	}
	function Mp(n) {
		return Do(Ds(n)).left + Tp(n).scrollLeft;
	}
	function BE(n, e) {
		var t = gi(n),
			i = Ds(n),
			r = t.visualViewport,
			s = i.clientWidth,
			a = i.clientHeight,
			o = 0,
			l = 0;
		if (r) {
			(s = r.width), (a = r.height);
			var c = K_();
			(c || (!c && e === "fixed")) && ((o = r.offsetLeft), (l = r.offsetTop));
		}
		return { width: s, height: a, x: o + Mp(n), y: l };
	}
	function zE(n) {
		var e,
			t = Ds(n),
			i = Tp(n),
			r = (e = n.ownerDocument) == null ? void 0 : e.body,
			s = pa(t.scrollWidth, t.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0),
			a = pa(t.scrollHeight, t.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0),
			o = -i.scrollLeft + Mp(n),
			l = -i.scrollTop;
		return jr(r || t).direction === "rtl" && (o += pa(t.clientWidth, r ? r.clientWidth : 0) - s), { width: s, height: a, x: o, y: l };
	}
	function Ap(n) {
		var e = jr(n),
			t = e.overflow,
			i = e.overflowX,
			r = e.overflowY;
		return /auto|scroll|overlay|hidden/.test(t + r + i);
	}
	function ny(n) {
		return ["html", "body", "#document"].indexOf(br(n)) >= 0 ? n.ownerDocument.body : Ii(n) && Ap(n) ? n : ny(hh(n));
	}
	function Tl(n, e) {
		var t;
		e === void 0 && (e = []);
		var i = ny(n),
			r = i === ((t = n.ownerDocument) == null ? void 0 : t.body),
			s = gi(i),
			a = r ? [s].concat(s.visualViewport || [], Ap(i) ? i : []) : i,
			o = e.concat(a);
		return r ? o : o.concat(Tl(hh(a)));
	}
	function mf(n) {
		return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height });
	}
	function HE(n, e) {
		var t = Do(n, !1, e === "fixed");
		return (t.top = t.top + n.clientTop), (t.left = t.left + n.clientLeft), (t.bottom = t.top + n.clientHeight), (t.right = t.left + n.clientWidth), (t.width = n.clientWidth), (t.height = n.clientHeight), (t.x = t.left), (t.y = t.top), t;
	}
	function Ig(n, e, t) {
		return e === vp ? mf(BE(n, t)) : ga(e) ? HE(e, t) : mf(zE(Ds(n)));
	}
	function GE(n) {
		var e = Tl(hh(n)),
			t = ["absolute", "fixed"].indexOf(jr(n).position) >= 0,
			i = t && Ii(n) ? Vl(n) : n;
		return ga(i)
			? e.filter(function (r) {
					return ga(r) && Z_(r, i) && br(r) !== "body";
			  })
			: [];
	}
	function VE(n, e, t, i) {
		var r = e === "clippingParents" ? GE(n) : [].concat(e),
			s = [].concat(r, [t]),
			a = s[0],
			o = s.reduce(function (l, c) {
				var u = Ig(n, c, i);
				return (l.top = pa(u.top, l.top)), (l.right = zu(u.right, l.right)), (l.bottom = zu(u.bottom, l.bottom)), (l.left = pa(u.left, l.left)), l;
			}, Ig(n, a, i));
		return (o.width = o.right - o.left), (o.height = o.bottom - o.top), (o.x = o.left), (o.y = o.top), o;
	}
	function iy(n) {
		var e = n.reference,
			t = n.element,
			i = n.placement,
			r = i ? _r(i) : null,
			s = i ? Oo(i) : null,
			a = e.x + e.width / 2 - t.width / 2,
			o = e.y + e.height / 2 - t.height / 2,
			l;
		switch (r) {
			case ii:
				l = { x: a, y: e.y - t.height };
				break;
			case pi:
				l = { x: a, y: e.y + e.height };
				break;
			case mi:
				l = { x: e.x + e.width, y: o };
				break;
			case ri:
				l = { x: e.x - t.width, y: o };
				break;
			default:
				l = { x: e.x, y: e.y };
		}
		var c = r ? Sp(r) : null;
		if (c != null) {
			var u = c === "y" ? "height" : "width";
			switch (s) {
				case ma:
					l[c] = l[c] - (e[u] / 2 - t[u] / 2);
					break;
				case Ro:
					l[c] = l[c] + (e[u] / 2 - t[u] / 2);
					break;
			}
		}
		return l;
	}
	function Io(n, e) {
		e === void 0 && (e = {});
		var t = e,
			i = t.placement,
			r = i === void 0 ? n.placement : i,
			s = t.strategy,
			a = s === void 0 ? n.strategy : s,
			o = t.boundary,
			l = o === void 0 ? k_ : o,
			c = t.rootBoundary,
			u = c === void 0 ? vp : c,
			h = t.elementContext,
			d = h === void 0 ? uo : h,
			f = t.altBoundary,
			v = f === void 0 ? !1 : f,
			_ = t.padding,
			p = _ === void 0 ? 0 : _,
			g = Q_(typeof p != "number" ? p : ey(p, Go)),
			x = d === uo ? B_ : uo,
			b = n.rects.popper,
			T = n.elements[v ? x : d],
			P = VE(ga(T) ? T : T.contextElement || Ds(n.elements.popper), l, u, a),
			A = Do(n.elements.reference),
			M = iy({ reference: A, element: b, strategy: "absolute", placement: r }),
			w = mf(Object.assign({}, b, M)),
			y = d === uo ? w : A,
			S = { top: P.top - y.top + g.top, bottom: y.bottom - P.bottom + g.bottom, left: P.left - y.left + g.left, right: y.right - P.right + g.right },
			L = n.modifiersData.offset;
		if (d === uo && L) {
			var N = L[r];
			Object.keys(S).forEach(function (k) {
				var B = [mi, pi].indexOf(k) >= 0 ? 1 : -1,
					W = [ii, pi].indexOf(k) >= 0 ? "y" : "x";
				S[k] += N[W] * B;
			});
		}
		return S;
	}
	function WE(n, e) {
		e === void 0 && (e = {});
		var t = e,
			i = t.placement,
			r = t.boundary,
			s = t.rootBoundary,
			a = t.padding,
			o = t.flipVariations,
			l = t.allowedAutoPlacements,
			c = l === void 0 ? _p : l,
			u = Oo(i),
			h = u
				? o
					? ff
					: ff.filter(function (v) {
							return Oo(v) === u;
					  })
				: Go,
			d = h.filter(function (v) {
				return c.indexOf(v) >= 0;
			});
		d.length === 0 && (d = h);
		var f = d.reduce(function (v, _) {
			return (v[_] = Io(n, { placement: _, boundary: r, rootBoundary: s, padding: a })[_r(_)]), v;
		}, {});
		return Object.keys(f).sort(function (v, _) {
			return f[v] - f[_];
		});
	}
	function XE(n) {
		if (_r(n) === uh) return [];
		var e = Tu(n);
		return [Og(n), e, Og(e)];
	}
	function $E(n) {
		var e = n.state,
			t = n.options,
			i = n.name;
		if (!e.modifiersData[i]._skip) {
			for (
				var r = t.mainAxis,
					s = r === void 0 ? !0 : r,
					a = t.altAxis,
					o = a === void 0 ? !0 : a,
					l = t.fallbackPlacements,
					c = t.padding,
					u = t.boundary,
					h = t.rootBoundary,
					d = t.altBoundary,
					f = t.flipVariations,
					v = f === void 0 ? !0 : f,
					_ = t.allowedAutoPlacements,
					p = e.options.placement,
					g = _r(p),
					x = g === p,
					b = l || (x || !v ? [Tu(p)] : XE(p)),
					T = [p].concat(b).reduce(function (Z, ie) {
						return Z.concat(_r(ie) === uh ? WE(e, { placement: ie, boundary: u, rootBoundary: h, padding: c, flipVariations: v, allowedAutoPlacements: _ }) : ie);
					}, []),
					P = e.rects.reference,
					A = e.rects.popper,
					M = new Map(),
					w = !0,
					y = T[0],
					S = 0;
				S < T.length;
				S++
			) {
				var L = T[S],
					N = _r(L),
					k = Oo(L) === ma,
					B = [ii, pi].indexOf(N) >= 0,
					W = B ? "width" : "height",
					H = Io(e, { placement: L, boundary: u, rootBoundary: h, altBoundary: d, padding: c }),
					z = B ? (k ? mi : ri) : k ? pi : ii;
				P[W] > A[W] && (z = Tu(z));
				var X = Tu(z),
					K = [];
				if (
					(s && K.push(H[N] <= 0),
					o && K.push(H[z] <= 0, H[X] <= 0),
					K.every(function (Z) {
						return Z;
					}))
				) {
					(y = L), (w = !1);
					break;
				}
				M.set(L, K);
			}
			if (w)
				for (
					var G = v ? 3 : 1,
						ue = function (ie) {
							var ge = T.find(function (V) {
								var j = M.get(V);
								if (j)
									return j.slice(0, ie).every(function (he) {
										return he;
									});
							});
							if (ge) return (y = ge), "break";
						},
						ae = G;
					ae > 0;
					ae--
				) {
					var Ue = ue(ae);
					if (Ue === "break") break;
				}
			e.placement !== y && ((e.modifiersData[i]._skip = !0), (e.placement = y), (e.reset = !0));
		}
	}
	const ry = { name: "flip", enabled: !0, phase: "main", fn: $E, requiresIfExists: ["offset"], data: { _skip: !1 } };
	function Fg(n, e, t) {
		return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x };
	}
	function Ng(n) {
		return [ii, mi, pi, ri].some(function (e) {
			return n[e] >= 0;
		});
	}
	function qE(n) {
		var e = n.state,
			t = n.name,
			i = e.rects.reference,
			r = e.rects.popper,
			s = e.modifiersData.preventOverflow,
			a = Io(e, { elementContext: "reference" }),
			o = Io(e, { altBoundary: !0 }),
			l = Fg(a, i),
			c = Fg(o, r, s),
			u = Ng(l),
			h = Ng(c);
		(e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: h }), (e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": h }));
	}
	const sy = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: qE };
	function jE(n, e, t) {
		var i = _r(n),
			r = [ri, ii].indexOf(i) >= 0 ? -1 : 1,
			s = typeof t == "function" ? t(Object.assign({}, e, { placement: n })) : t,
			a = s[0],
			o = s[1];
		return (a = a || 0), (o = (o || 0) * r), [ri, mi].indexOf(i) >= 0 ? { x: o, y: a } : { x: a, y: o };
	}
	function YE(n) {
		var e = n.state,
			t = n.options,
			i = n.name,
			r = t.offset,
			s = r === void 0 ? [0, 0] : r,
			a = _p.reduce(function (u, h) {
				return (u[h] = jE(h, e.rects, s)), u;
			}, {}),
			o = a[e.placement],
			l = o.x,
			c = o.y;
		e.modifiersData.popperOffsets != null && ((e.modifiersData.popperOffsets.x += l), (e.modifiersData.popperOffsets.y += c)), (e.modifiersData[i] = a);
	}
	const ay = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: YE };
	function KE(n) {
		var e = n.state,
			t = n.name;
		e.modifiersData[t] = iy({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
	}
	const Cp = { name: "popperOffsets", enabled: !0, phase: "read", fn: KE, data: {} };
	function ZE(n) {
		return n === "x" ? "y" : "x";
	}
	function JE(n) {
		var e = n.state,
			t = n.options,
			i = n.name,
			r = t.mainAxis,
			s = r === void 0 ? !0 : r,
			a = t.altAxis,
			o = a === void 0 ? !1 : a,
			l = t.boundary,
			c = t.rootBoundary,
			u = t.altBoundary,
			h = t.padding,
			d = t.tether,
			f = d === void 0 ? !0 : d,
			v = t.tetherOffset,
			_ = v === void 0 ? 0 : v,
			p = Io(e, { boundary: l, rootBoundary: c, padding: h, altBoundary: u }),
			g = _r(e.placement),
			x = Oo(e.placement),
			b = !x,
			T = Sp(g),
			P = ZE(T),
			A = e.modifiersData.popperOffsets,
			M = e.rects.reference,
			w = e.rects.popper,
			y = typeof _ == "function" ? _(Object.assign({}, e.rects, { placement: e.placement })) : _,
			S = typeof y == "number" ? { mainAxis: y, altAxis: y } : Object.assign({ mainAxis: 0, altAxis: 0 }, y),
			L = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
			N = { x: 0, y: 0 };
		if (A) {
			if (s) {
				var k,
					B = T === "y" ? ii : ri,
					W = T === "y" ? pi : mi,
					H = T === "y" ? "height" : "width",
					z = A[T],
					X = z + p[B],
					K = z - p[W],
					G = f ? -w[H] / 2 : 0,
					ue = x === ma ? M[H] : w[H],
					ae = x === ma ? -w[H] : -M[H],
					Ue = e.elements.arrow,
					Z = f && Ue ? bp(Ue) : { width: 0, height: 0 },
					ie = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : J_(),
					ge = ie[B],
					V = ie[W],
					j = wl(0, M[H], Z[H]),
					he = b ? M[H] / 2 - G - j - ge - S.mainAxis : ue - j - ge - S.mainAxis,
					xe = b ? -M[H] / 2 + G + j + V + S.mainAxis : ae + j + V + S.mainAxis,
					He = e.elements.arrow && Vl(e.elements.arrow),
					F = He ? (T === "y" ? He.clientTop || 0 : He.clientLeft || 0) : 0,
					fe = (k = L == null ? void 0 : L[T]) != null ? k : 0,
					pe = z + he - fe - F,
					Ee = z + xe - fe,
					re = wl(f ? zu(X, pe) : X, z, f ? pa(K, Ee) : K);
				(A[T] = re), (N[T] = re - z);
			}
			if (o) {
				var We,
					Ce = T === "x" ? ii : ri,
					Ie = T === "x" ? pi : mi,
					U = A[P],
					R = P === "y" ? "height" : "width",
					ee = U + p[Ce],
					de = U - p[Ie],
					me = [ii, ri].indexOf(g) !== -1,
					oe = (We = L == null ? void 0 : L[P]) != null ? We : 0,
					Xe = me ? ee : U - M[R] - w[R] - oe + S.altAxis,
					Me = me ? U + M[R] + w[R] - oe - S.altAxis : de,
					Pe = f && me ? LE(Xe, U, Me) : wl(f ? Xe : ee, U, f ? Me : de);
				(A[P] = Pe), (N[P] = Pe - U);
			}
			e.modifiersData[i] = N;
		}
	}
	const oy = { name: "preventOverflow", enabled: !0, phase: "main", fn: JE, requiresIfExists: ["offset"] };
	function QE(n) {
		return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop };
	}
	function ew(n) {
		return n === gi(n) || !Ii(n) ? Tp(n) : QE(n);
	}
	function tw(n) {
		var e = n.getBoundingClientRect(),
			t = Po(e.width) / n.offsetWidth || 1,
			i = Po(e.height) / n.offsetHeight || 1;
		return t !== 1 || i !== 1;
	}
	function nw(n, e, t) {
		t === void 0 && (t = !1);
		var i = Ii(e),
			r = Ii(e) && tw(e),
			s = Ds(e),
			a = Do(n, r, t),
			o = { scrollLeft: 0, scrollTop: 0 },
			l = { x: 0, y: 0 };
		return (i || (!i && !t)) && ((br(e) !== "body" || Ap(s)) && (o = ew(e)), Ii(e) ? ((l = Do(e, !0)), (l.x += e.clientLeft), (l.y += e.clientTop)) : s && (l.x = Mp(s))), { x: a.left + o.scrollLeft - l.x, y: a.top + o.scrollTop - l.y, width: a.width, height: a.height };
	}
	function iw(n) {
		var e = new Map(),
			t = new Set(),
			i = [];
		n.forEach(function (s) {
			e.set(s.name, s);
		});
		function r(s) {
			t.add(s.name);
			var a = [].concat(s.requires || [], s.requiresIfExists || []);
			a.forEach(function (o) {
				if (!t.has(o)) {
					var l = e.get(o);
					l && r(l);
				}
			}),
				i.push(s);
		}
		return (
			n.forEach(function (s) {
				t.has(s.name) || r(s);
			}),
			i
		);
	}
	function rw(n) {
		var e = iw(n);
		return Y_.reduce(function (t, i) {
			return t.concat(
				e.filter(function (r) {
					return r.phase === i;
				})
			);
		}, []);
	}
	function sw(n) {
		var e;
		return function () {
			return (
				e ||
					(e = new Promise(function (t) {
						Promise.resolve().then(function () {
							(e = void 0), t(n());
						});
					})),
				e
			);
		};
	}
	function aw(n) {
		var e = n.reduce(function (t, i) {
			var r = t[i.name];
			return (t[i.name] = r ? Object.assign({}, r, i, { options: Object.assign({}, r.options, i.options), data: Object.assign({}, r.data, i.data) }) : i), t;
		}, {});
		return Object.keys(e).map(function (t) {
			return e[t];
		});
	}
	var Ug = { placement: "bottom", modifiers: [], strategy: "absolute" };
	function kg() {
		for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
		return !e.some(function (i) {
			return !(i && typeof i.getBoundingClientRect == "function");
		});
	}
	function dh(n) {
		n === void 0 && (n = {});
		var e = n,
			t = e.defaultModifiers,
			i = t === void 0 ? [] : t,
			r = e.defaultOptions,
			s = r === void 0 ? Ug : r;
		return function (o, l, c) {
			c === void 0 && (c = s);
			var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ug, s), modifiersData: {}, elements: { reference: o, popper: l }, attributes: {}, styles: {} },
				h = [],
				d = !1,
				f = {
					state: u,
					setOptions: function (g) {
						var x = typeof g == "function" ? g(u.options) : g;
						_(), (u.options = Object.assign({}, s, u.options, x)), (u.scrollParents = { reference: ga(o) ? Tl(o) : o.contextElement ? Tl(o.contextElement) : [], popper: Tl(l) });
						var b = rw(aw([].concat(i, u.options.modifiers)));
						return (
							(u.orderedModifiers = b.filter(function (T) {
								return T.enabled;
							})),
							v(),
							f.update()
						);
					},
					forceUpdate: function () {
						if (!d) {
							var g = u.elements,
								x = g.reference,
								b = g.popper;
							if (kg(x, b)) {
								(u.rects = { reference: nw(x, Vl(b), u.options.strategy === "fixed"), popper: bp(b) }),
									(u.reset = !1),
									(u.placement = u.options.placement),
									u.orderedModifiers.forEach(function (S) {
										return (u.modifiersData[S.name] = Object.assign({}, S.data));
									});
								for (var T = 0; T < u.orderedModifiers.length; T++) {
									if (u.reset === !0) {
										(u.reset = !1), (T = -1);
										continue;
									}
									var P = u.orderedModifiers[T],
										A = P.fn,
										M = P.options,
										w = M === void 0 ? {} : M,
										y = P.name;
									typeof A == "function" && (u = A({ state: u, options: w, name: y, instance: f }) || u);
								}
							}
						}
					},
					update: sw(function () {
						return new Promise(function (p) {
							f.forceUpdate(), p(u);
						});
					}),
					destroy: function () {
						_(), (d = !0);
					}
				};
			if (!kg(o, l)) return f;
			f.setOptions(c).then(function (p) {
				!d && c.onFirstUpdate && c.onFirstUpdate(p);
			});
			function v() {
				u.orderedModifiers.forEach(function (p) {
					var g = p.name,
						x = p.options,
						b = x === void 0 ? {} : x,
						T = p.effect;
					if (typeof T == "function") {
						var P = T({ state: u, name: g, instance: f, options: b }),
							A = function () {};
						h.push(P || A);
					}
				});
			}
			function _() {
				h.forEach(function (p) {
					return p();
				}),
					(h = []);
			}
			return f;
		};
	}
	var ow = dh(),
		lw = [wp, Cp, Ep, xp],
		cw = dh({ defaultModifiers: lw }),
		uw = [wp, Cp, Ep, xp, ay, ry, oy, ty, sy],
		Lp = dh({ defaultModifiers: uw });
	const ly = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				afterMain: X_,
				afterRead: G_,
				afterWrite: j_,
				applyStyles: xp,
				arrow: ty,
				auto: uh,
				basePlacements: Go,
				beforeMain: V_,
				beforeRead: z_,
				beforeWrite: $_,
				bottom: pi,
				clippingParents: k_,
				computeStyles: Ep,
				createPopper: Lp,
				createPopperBase: ow,
				createPopperLite: cw,
				detectOverflow: Io,
				end: Ro,
				eventListeners: wp,
				flip: ry,
				hide: sy,
				left: ri,
				main: W_,
				modifierPhases: Y_,
				offset: ay,
				placements: _p,
				popper: uo,
				popperGenerator: dh,
				popperOffsets: Cp,
				preventOverflow: oy,
				read: H_,
				reference: B_,
				right: mi,
				start: ma,
				top: ii,
				variationPlacements: ff,
				viewport: vp,
				write: q_
			},
			Symbol.toStringTag,
			{ value: "Module" }
		)
	);
	/*!
	 * Bootstrap v5.3.3 (https://getbootstrap.com/)
	 * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	 */ const ss = new Map(),
		Yh = {
			set(n, e, t) {
				ss.has(n) || ss.set(n, new Map());
				const i = ss.get(n);
				if (!i.has(e) && i.size !== 0) {
					console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`);
					return;
				}
				i.set(e, t);
			},
			get(n, e) {
				return (ss.has(n) && ss.get(n).get(e)) || null;
			},
			remove(n, e) {
				if (!ss.has(n)) return;
				const t = ss.get(n);
				t.delete(e), t.size === 0 && ss.delete(n);
			}
		},
		hw = 1e6,
		dw = 1e3,
		gf = "transitionend",
		cy = (n) => (n && window.CSS && window.CSS.escape && (n = n.replace(/#([^\s"#']+)/g, (e, t) => `#${CSS.escape(t)}`)), n),
		fw = (n) =>
			n == null
				? `${n}`
				: Object.prototype.toString
						.call(n)
						.match(/\s([a-z]+)/i)[1]
						.toLowerCase(),
		pw = (n) => {
			do n += Math.floor(Math.random() * hw);
			while (document.getElementById(n));
			return n;
		},
		mw = (n) => {
			if (!n) return 0;
			let { transitionDuration: e, transitionDelay: t } = window.getComputedStyle(n);
			const i = Number.parseFloat(e),
				r = Number.parseFloat(t);
			return !i && !r ? 0 : ((e = e.split(",")[0]), (t = t.split(",")[0]), (Number.parseFloat(e) + Number.parseFloat(t)) * dw);
		},
		uy = (n) => {
			n.dispatchEvent(new Event(gf));
		},
		Wr = (n) => (!n || typeof n != "object" ? !1 : (typeof n.jquery < "u" && (n = n[0]), typeof n.nodeType < "u")),
		Ls = (n) => (Wr(n) ? (n.jquery ? n[0] : n) : typeof n == "string" && n.length > 0 ? document.querySelector(cy(n)) : null),
		Vo = (n) => {
			if (!Wr(n) || n.getClientRects().length === 0) return !1;
			const e = getComputedStyle(n).getPropertyValue("visibility") === "visible",
				t = n.closest("details:not([open])");
			if (!t) return e;
			if (t !== n) {
				const i = n.closest("summary");
				if ((i && i.parentNode !== t) || i === null) return !1;
			}
			return e;
		},
		Rs = (n) => (!n || n.nodeType !== Node.ELEMENT_NODE || n.classList.contains("disabled") ? !0 : typeof n.disabled < "u" ? n.disabled : n.hasAttribute("disabled") && n.getAttribute("disabled") !== "false"),
		hy = (n) => {
			if (!document.documentElement.attachShadow) return null;
			if (typeof n.getRootNode == "function") {
				const e = n.getRootNode();
				return e instanceof ShadowRoot ? e : null;
			}
			return n instanceof ShadowRoot ? n : n.parentNode ? hy(n.parentNode) : null;
		},
		Hu = () => {},
		Wl = (n) => {
			n.offsetHeight;
		},
		dy = () => (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null),
		Kh = [],
		gw = (n) => {
			document.readyState === "loading"
				? (Kh.length ||
						document.addEventListener("DOMContentLoaded", () => {
							for (const e of Kh) e();
						}),
				  Kh.push(n))
				: n();
		},
		Ni = () => document.documentElement.dir === "rtl",
		ki = (n) => {
			gw(() => {
				const e = dy();
				if (e) {
					const t = n.NAME,
						i = e.fn[t];
					(e.fn[t] = n.jQueryInterface), (e.fn[t].Constructor = n), (e.fn[t].noConflict = () => ((e.fn[t] = i), n.jQueryInterface));
				}
			});
		},
		oi = (n, e = [], t = n) => (typeof n == "function" ? n(...e) : t),
		fy = (n, e, t = !0) => {
			if (!t) {
				oi(n);
				return;
			}
			const r = mw(e) + 5;
			let s = !1;
			const a = ({ target: o }) => {
				o === e && ((s = !0), e.removeEventListener(gf, a), oi(n));
			};
			e.addEventListener(gf, a),
				setTimeout(() => {
					s || uy(e);
				}, r);
		},
		Rp = (n, e, t, i) => {
			const r = n.length;
			let s = n.indexOf(e);
			return s === -1 ? (!t && i ? n[r - 1] : n[0]) : ((s += t ? 1 : -1), i && (s = (s + r) % r), n[Math.max(0, Math.min(s, r - 1))]);
		},
		vw = /[^.]*(?=\..*)\.|.*/,
		_w = /\..*/,
		yw = /::\d+$/,
		Zh = {};
	let Bg = 1;
	const py = { mouseenter: "mouseover", mouseleave: "mouseout" },
		xw = new Set([
			"click",
			"dblclick",
			"mouseup",
			"mousedown",
			"contextmenu",
			"mousewheel",
			"DOMMouseScroll",
			"mouseover",
			"mouseout",
			"mousemove",
			"selectstart",
			"selectend",
			"keydown",
			"keypress",
			"keyup",
			"orientationchange",
			"touchstart",
			"touchmove",
			"touchend",
			"touchcancel",
			"pointerdown",
			"pointermove",
			"pointerup",
			"pointerleave",
			"pointercancel",
			"gesturestart",
			"gesturechange",
			"gestureend",
			"focus",
			"blur",
			"change",
			"reset",
			"select",
			"submit",
			"focusin",
			"focusout",
			"load",
			"unload",
			"beforeunload",
			"resize",
			"move",
			"DOMContentLoaded",
			"readystatechange",
			"error",
			"abort",
			"scroll"
		]);
	function my(n, e) {
		return (e && `${e}::${Bg++}`) || n.uidEvent || Bg++;
	}
	function gy(n) {
		const e = my(n);
		return (n.uidEvent = e), (Zh[e] = Zh[e] || {}), Zh[e];
	}
	function bw(n, e) {
		return function t(i) {
			return Pp(i, { delegateTarget: n }), t.oneOff && Te.off(n, i.type, e), e.apply(n, [i]);
		};
	}
	function Sw(n, e, t) {
		return function i(r) {
			const s = n.querySelectorAll(e);
			for (let { target: a } = r; a && a !== this; a = a.parentNode) for (const o of s) if (o === a) return Pp(r, { delegateTarget: a }), i.oneOff && Te.off(n, r.type, e, t), t.apply(a, [r]);
		};
	}
	function vy(n, e, t = null) {
		return Object.values(n).find((i) => i.callable === e && i.delegationSelector === t);
	}
	function _y(n, e, t) {
		const i = typeof e == "string",
			r = i ? t : e || t;
		let s = yy(n);
		return xw.has(s) || (s = n), [i, r, s];
	}
	function zg(n, e, t, i, r) {
		if (typeof e != "string" || !n) return;
		let [s, a, o] = _y(e, t, i);
		e in py &&
			(a = ((v) =>
				function (_) {
					if (!_.relatedTarget || (_.relatedTarget !== _.delegateTarget && !_.delegateTarget.contains(_.relatedTarget))) return v.call(this, _);
				})(a));
		const l = gy(n),
			c = l[o] || (l[o] = {}),
			u = vy(c, a, s ? t : null);
		if (u) {
			u.oneOff = u.oneOff && r;
			return;
		}
		const h = my(a, e.replace(vw, "")),
			d = s ? Sw(n, t, a) : bw(n, a);
		(d.delegationSelector = s ? t : null), (d.callable = a), (d.oneOff = r), (d.uidEvent = h), (c[h] = d), n.addEventListener(o, d, s);
	}
	function vf(n, e, t, i, r) {
		const s = vy(e[t], i, r);
		s && (n.removeEventListener(t, s, !!r), delete e[t][s.uidEvent]);
	}
	function Ew(n, e, t, i) {
		const r = e[t] || {};
		for (const [s, a] of Object.entries(r)) s.includes(i) && vf(n, e, t, a.callable, a.delegationSelector);
	}
	function yy(n) {
		return (n = n.replace(_w, "")), py[n] || n;
	}
	const Te = {
		on(n, e, t, i) {
			zg(n, e, t, i, !1);
		},
		one(n, e, t, i) {
			zg(n, e, t, i, !0);
		},
		off(n, e, t, i) {
			if (typeof e != "string" || !n) return;
			const [r, s, a] = _y(e, t, i),
				o = a !== e,
				l = gy(n),
				c = l[a] || {},
				u = e.startsWith(".");
			if (typeof s < "u") {
				if (!Object.keys(c).length) return;
				vf(n, l, a, s, r ? t : null);
				return;
			}
			if (u) for (const h of Object.keys(l)) Ew(n, l, h, e.slice(1));
			for (const [h, d] of Object.entries(c)) {
				const f = h.replace(yw, "");
				(!o || e.includes(f)) && vf(n, l, a, d.callable, d.delegationSelector);
			}
		},
		trigger(n, e, t) {
			if (typeof e != "string" || !n) return null;
			const i = dy(),
				r = yy(e),
				s = e !== r;
			let a = null,
				o = !0,
				l = !0,
				c = !1;
			s && i && ((a = i.Event(e, t)), i(n).trigger(a), (o = !a.isPropagationStopped()), (l = !a.isImmediatePropagationStopped()), (c = a.isDefaultPrevented()));
			const u = Pp(new Event(e, { bubbles: o, cancelable: !0 }), t);
			return c && u.preventDefault(), l && n.dispatchEvent(u), u.defaultPrevented && a && a.preventDefault(), u;
		}
	};
	function Pp(n, e = {}) {
		for (const [t, i] of Object.entries(e))
			try {
				n[t] = i;
			} catch {
				Object.defineProperty(n, t, {
					configurable: !0,
					get() {
						return i;
					}
				});
			}
		return n;
	}
	function Hg(n) {
		if (n === "true") return !0;
		if (n === "false") return !1;
		if (n === Number(n).toString()) return Number(n);
		if (n === "" || n === "null") return null;
		if (typeof n != "string") return n;
		try {
			return JSON.parse(decodeURIComponent(n));
		} catch {
			return n;
		}
	}
	function Jh(n) {
		return n.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);
	}
	const Xr = {
		setDataAttribute(n, e, t) {
			n.setAttribute(`data-bs-${Jh(e)}`, t);
		},
		removeDataAttribute(n, e) {
			n.removeAttribute(`data-bs-${Jh(e)}`);
		},
		getDataAttributes(n) {
			if (!n) return {};
			const e = {},
				t = Object.keys(n.dataset).filter((i) => i.startsWith("bs") && !i.startsWith("bsConfig"));
			for (const i of t) {
				let r = i.replace(/^bs/, "");
				(r = r.charAt(0).toLowerCase() + r.slice(1, r.length)), (e[r] = Hg(n.dataset[i]));
			}
			return e;
		},
		getDataAttribute(n, e) {
			return Hg(n.getAttribute(`data-bs-${Jh(e)}`));
		}
	};
	class Xl {
		static get Default() {
			return {};
		}
		static get DefaultType() {
			return {};
		}
		static get NAME() {
			throw new Error('You have to implement the static method "NAME", for each component!');
		}
		_getConfig(e) {
			return (e = this._mergeConfigObj(e)), (e = this._configAfterMerge(e)), this._typeCheckConfig(e), e;
		}
		_configAfterMerge(e) {
			return e;
		}
		_mergeConfigObj(e, t) {
			const i = Wr(t) ? Xr.getDataAttribute(t, "config") : {};
			return { ...this.constructor.Default, ...(typeof i == "object" ? i : {}), ...(Wr(t) ? Xr.getDataAttributes(t) : {}), ...(typeof e == "object" ? e : {}) };
		}
		_typeCheckConfig(e, t = this.constructor.DefaultType) {
			for (const [i, r] of Object.entries(t)) {
				const s = e[i],
					a = Wr(s) ? "element" : fw(s);
				if (!new RegExp(r).test(a)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${a}" but expected type "${r}".`);
			}
		}
	}
	const ww = "5.3.3";
	class ar extends Xl {
		constructor(e, t) {
			super(), (e = Ls(e)), e && ((this._element = e), (this._config = this._getConfig(t)), Yh.set(this._element, this.constructor.DATA_KEY, this));
		}
		dispose() {
			Yh.remove(this._element, this.constructor.DATA_KEY), Te.off(this._element, this.constructor.EVENT_KEY);
			for (const e of Object.getOwnPropertyNames(this)) this[e] = null;
		}
		_queueCallback(e, t, i = !0) {
			fy(e, t, i);
		}
		_getConfig(e) {
			return (e = this._mergeConfigObj(e, this._element)), (e = this._configAfterMerge(e)), this._typeCheckConfig(e), e;
		}
		static getInstance(e) {
			return Yh.get(Ls(e), this.DATA_KEY);
		}
		static getOrCreateInstance(e, t = {}) {
			return this.getInstance(e) || new this(e, typeof t == "object" ? t : null);
		}
		static get VERSION() {
			return ww;
		}
		static get DATA_KEY() {
			return `bs.${this.NAME}`;
		}
		static get EVENT_KEY() {
			return `.${this.DATA_KEY}`;
		}
		static eventName(e) {
			return `${e}${this.EVENT_KEY}`;
		}
	}
	const Qh = (n) => {
			let e = n.getAttribute("data-bs-target");
			if (!e || e === "#") {
				let t = n.getAttribute("href");
				if (!t || (!t.includes("#") && !t.startsWith("."))) return null;
				t.includes("#") && !t.startsWith("#") && (t = `#${t.split("#")[1]}`), (e = t && t !== "#" ? t.trim() : null);
			}
			return e
				? e
						.split(",")
						.map((t) => cy(t))
						.join(",")
				: null;
		},
		at = {
			find(n, e = document.documentElement) {
				return [].concat(...Element.prototype.querySelectorAll.call(e, n));
			},
			findOne(n, e = document.documentElement) {
				return Element.prototype.querySelector.call(e, n);
			},
			children(n, e) {
				return [].concat(...n.children).filter((t) => t.matches(e));
			},
			parents(n, e) {
				const t = [];
				let i = n.parentNode.closest(e);
				for (; i; ) t.push(i), (i = i.parentNode.closest(e));
				return t;
			},
			prev(n, e) {
				let t = n.previousElementSibling;
				for (; t; ) {
					if (t.matches(e)) return [t];
					t = t.previousElementSibling;
				}
				return [];
			},
			next(n, e) {
				let t = n.nextElementSibling;
				for (; t; ) {
					if (t.matches(e)) return [t];
					t = t.nextElementSibling;
				}
				return [];
			},
			focusableChildren(n) {
				const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t) => `${t}:not([tabindex^="-"])`).join(",");
				return this.find(e, n).filter((t) => !Rs(t) && Vo(t));
			},
			getSelectorFromElement(n) {
				const e = Qh(n);
				return e && at.findOne(e) ? e : null;
			},
			getElementFromSelector(n) {
				const e = Qh(n);
				return e ? at.findOne(e) : null;
			},
			getMultipleElementsFromSelector(n) {
				const e = Qh(n);
				return e ? at.find(e) : [];
			}
		},
		fh = (n, e = "hide") => {
			const t = `click.dismiss${n.EVENT_KEY}`,
				i = n.NAME;
			Te.on(document, t, `[data-bs-dismiss="${i}"]`, function (r) {
				if ((["A", "AREA"].includes(this.tagName) && r.preventDefault(), Rs(this))) return;
				const s = at.getElementFromSelector(this) || this.closest(`.${i}`);
				n.getOrCreateInstance(s)[e]();
			});
		},
		Tw = "alert",
		Mw = "bs.alert",
		xy = `.${Mw}`,
		Aw = `close${xy}`,
		Cw = `closed${xy}`,
		Lw = "fade",
		Rw = "show";
	class $l extends ar {
		static get NAME() {
			return Tw;
		}
		close() {
			if (Te.trigger(this._element, Aw).defaultPrevented) return;
			this._element.classList.remove(Rw);
			const t = this._element.classList.contains(Lw);
			this._queueCallback(() => this._destroyElement(), this._element, t);
		}
		_destroyElement() {
			this._element.remove(), Te.trigger(this._element, Cw), this.dispose();
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = $l.getOrCreateInstance(this);
				if (typeof e == "string") {
					if (t[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`);
					t[e](this);
				}
			});
		}
	}
	fh($l, "close");
	ki($l);
	const Pw = "button",
		Dw = "bs.button",
		Ow = `.${Dw}`,
		Iw = ".data-api",
		Fw = "active",
		Gg = '[data-bs-toggle="button"]',
		Nw = `click${Ow}${Iw}`;
	class ql extends ar {
		static get NAME() {
			return Pw;
		}
		toggle() {
			this._element.setAttribute("aria-pressed", this._element.classList.toggle(Fw));
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = ql.getOrCreateInstance(this);
				e === "toggle" && t[e]();
			});
		}
	}
	Te.on(document, Nw, Gg, (n) => {
		n.preventDefault();
		const e = n.target.closest(Gg);
		ql.getOrCreateInstance(e).toggle();
	});
	ki(ql);
	const Uw = "swipe",
		Wo = ".bs.swipe",
		kw = `touchstart${Wo}`,
		Bw = `touchmove${Wo}`,
		zw = `touchend${Wo}`,
		Hw = `pointerdown${Wo}`,
		Gw = `pointerup${Wo}`,
		Vw = "touch",
		Ww = "pen",
		Xw = "pointer-event",
		$w = 40,
		qw = { endCallback: null, leftCallback: null, rightCallback: null },
		jw = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
	class Gu extends Xl {
		constructor(e, t) {
			super(), (this._element = e), !(!e || !Gu.isSupported()) && ((this._config = this._getConfig(t)), (this._deltaX = 0), (this._supportPointerEvents = !!window.PointerEvent), this._initEvents());
		}
		static get Default() {
			return qw;
		}
		static get DefaultType() {
			return jw;
		}
		static get NAME() {
			return Uw;
		}
		dispose() {
			Te.off(this._element, Wo);
		}
		_start(e) {
			if (!this._supportPointerEvents) {
				this._deltaX = e.touches[0].clientX;
				return;
			}
			this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX);
		}
		_end(e) {
			this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), oi(this._config.endCallback);
		}
		_move(e) {
			this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX;
		}
		_handleSwipe() {
			const e = Math.abs(this._deltaX);
			if (e <= $w) return;
			const t = e / this._deltaX;
			(this._deltaX = 0), t && oi(t > 0 ? this._config.rightCallback : this._config.leftCallback);
		}
		_initEvents() {
			this._supportPointerEvents ? (Te.on(this._element, Hw, (e) => this._start(e)), Te.on(this._element, Gw, (e) => this._end(e)), this._element.classList.add(Xw)) : (Te.on(this._element, kw, (e) => this._start(e)), Te.on(this._element, Bw, (e) => this._move(e)), Te.on(this._element, zw, (e) => this._end(e)));
		}
		_eventIsPointerPenTouch(e) {
			return this._supportPointerEvents && (e.pointerType === Ww || e.pointerType === Vw);
		}
		static isSupported() {
			return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
		}
	}
	const Yw = "carousel",
		Kw = "bs.carousel",
		Os = `.${Kw}`,
		by = ".data-api",
		Zw = "ArrowLeft",
		Jw = "ArrowRight",
		Qw = 500,
		rl = "next",
		Ua = "prev",
		ho = "left",
		Mu = "right",
		e1 = `slide${Os}`,
		ed = `slid${Os}`,
		t1 = `keydown${Os}`,
		n1 = `mouseenter${Os}`,
		i1 = `mouseleave${Os}`,
		r1 = `dragstart${Os}`,
		s1 = `load${Os}${by}`,
		a1 = `click${Os}${by}`,
		Sy = "carousel",
		Mc = "active",
		o1 = "slide",
		l1 = "carousel-item-end",
		c1 = "carousel-item-start",
		u1 = "carousel-item-next",
		h1 = "carousel-item-prev",
		Ey = ".active",
		wy = ".carousel-item",
		d1 = Ey + wy,
		f1 = ".carousel-item img",
		p1 = ".carousel-indicators",
		m1 = "[data-bs-slide], [data-bs-slide-to]",
		g1 = '[data-bs-ride="carousel"]',
		v1 = { [Zw]: Mu, [Jw]: ho },
		_1 = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 },
		y1 = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
	class Xo extends ar {
		constructor(e, t) {
			super(e, t), (this._interval = null), (this._activeElement = null), (this._isSliding = !1), (this.touchTimeout = null), (this._swipeHelper = null), (this._indicatorsElement = at.findOne(p1, this._element)), this._addEventListeners(), this._config.ride === Sy && this.cycle();
		}
		static get Default() {
			return _1;
		}
		static get DefaultType() {
			return y1;
		}
		static get NAME() {
			return Yw;
		}
		next() {
			this._slide(rl);
		}
		nextWhenVisible() {
			!document.hidden && Vo(this._element) && this.next();
		}
		prev() {
			this._slide(Ua);
		}
		pause() {
			this._isSliding && uy(this._element), this._clearInterval();
		}
		cycle() {
			this._clearInterval(), this._updateInterval(), (this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval));
		}
		_maybeEnableCycle() {
			if (this._config.ride) {
				if (this._isSliding) {
					Te.one(this._element, ed, () => this.cycle());
					return;
				}
				this.cycle();
			}
		}
		to(e) {
			const t = this._getItems();
			if (e > t.length - 1 || e < 0) return;
			if (this._isSliding) {
				Te.one(this._element, ed, () => this.to(e));
				return;
			}
			const i = this._getItemIndex(this._getActive());
			if (i === e) return;
			const r = e > i ? rl : Ua;
			this._slide(r, t[e]);
		}
		dispose() {
			this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
		}
		_configAfterMerge(e) {
			return (e.defaultInterval = e.interval), e;
		}
		_addEventListeners() {
			this._config.keyboard && Te.on(this._element, t1, (e) => this._keydown(e)), this._config.pause === "hover" && (Te.on(this._element, n1, () => this.pause()), Te.on(this._element, i1, () => this._maybeEnableCycle())), this._config.touch && Gu.isSupported() && this._addTouchEventListeners();
		}
		_addTouchEventListeners() {
			for (const i of at.find(f1, this._element)) Te.on(i, r1, (r) => r.preventDefault());
			const t = {
				leftCallback: () => this._slide(this._directionToOrder(ho)),
				rightCallback: () => this._slide(this._directionToOrder(Mu)),
				endCallback: () => {
					this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), (this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), Qw + this._config.interval)));
				}
			};
			this._swipeHelper = new Gu(this._element, t);
		}
		_keydown(e) {
			if (/input|textarea/i.test(e.target.tagName)) return;
			const t = v1[e.key];
			t && (e.preventDefault(), this._slide(this._directionToOrder(t)));
		}
		_getItemIndex(e) {
			return this._getItems().indexOf(e);
		}
		_setActiveIndicatorElement(e) {
			if (!this._indicatorsElement) return;
			const t = at.findOne(Ey, this._indicatorsElement);
			t.classList.remove(Mc), t.removeAttribute("aria-current");
			const i = at.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement);
			i && (i.classList.add(Mc), i.setAttribute("aria-current", "true"));
		}
		_updateInterval() {
			const e = this._activeElement || this._getActive();
			if (!e) return;
			const t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
			this._config.interval = t || this._config.defaultInterval;
		}
		_slide(e, t = null) {
			if (this._isSliding) return;
			const i = this._getActive(),
				r = e === rl,
				s = t || Rp(this._getItems(), i, r, this._config.wrap);
			if (s === i) return;
			const a = this._getItemIndex(s),
				o = (f) => Te.trigger(this._element, f, { relatedTarget: s, direction: this._orderToDirection(e), from: this._getItemIndex(i), to: a });
			if (o(e1).defaultPrevented || !i || !s) return;
			const c = !!this._interval;
			this.pause(), (this._isSliding = !0), this._setActiveIndicatorElement(a), (this._activeElement = s);
			const u = r ? c1 : l1,
				h = r ? u1 : h1;
			s.classList.add(h), Wl(s), i.classList.add(u), s.classList.add(u);
			const d = () => {
				s.classList.remove(u, h), s.classList.add(Mc), i.classList.remove(Mc, h, u), (this._isSliding = !1), o(ed);
			};
			this._queueCallback(d, i, this._isAnimated()), c && this.cycle();
		}
		_isAnimated() {
			return this._element.classList.contains(o1);
		}
		_getActive() {
			return at.findOne(d1, this._element);
		}
		_getItems() {
			return at.find(wy, this._element);
		}
		_clearInterval() {
			this._interval && (clearInterval(this._interval), (this._interval = null));
		}
		_directionToOrder(e) {
			return Ni() ? (e === ho ? Ua : rl) : e === ho ? rl : Ua;
		}
		_orderToDirection(e) {
			return Ni() ? (e === Ua ? ho : Mu) : e === Ua ? Mu : ho;
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = Xo.getOrCreateInstance(this, e);
				if (typeof e == "number") {
					t.to(e);
					return;
				}
				if (typeof e == "string") {
					if (t[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
	}
	Te.on(document, a1, m1, function (n) {
		const e = at.getElementFromSelector(this);
		if (!e || !e.classList.contains(Sy)) return;
		n.preventDefault();
		const t = Xo.getOrCreateInstance(e),
			i = this.getAttribute("data-bs-slide-to");
		if (i) {
			t.to(i), t._maybeEnableCycle();
			return;
		}
		if (Xr.getDataAttribute(this, "slide") === "next") {
			t.next(), t._maybeEnableCycle();
			return;
		}
		t.prev(), t._maybeEnableCycle();
	});
	Te.on(window, s1, () => {
		const n = at.find(g1);
		for (const e of n) Xo.getOrCreateInstance(e);
	});
	ki(Xo);
	const x1 = "collapse",
		b1 = "bs.collapse",
		jl = `.${b1}`,
		S1 = ".data-api",
		E1 = `show${jl}`,
		w1 = `shown${jl}`,
		T1 = `hide${jl}`,
		M1 = `hidden${jl}`,
		A1 = `click${jl}${S1}`,
		td = "show",
		mo = "collapse",
		Ac = "collapsing",
		C1 = "collapsed",
		L1 = `:scope .${mo} .${mo}`,
		R1 = "collapse-horizontal",
		P1 = "width",
		D1 = "height",
		O1 = ".collapse.show, .collapse.collapsing",
		_f = '[data-bs-toggle="collapse"]',
		I1 = { parent: null, toggle: !0 },
		F1 = { parent: "(null|element)", toggle: "boolean" };
	class Fo extends ar {
		constructor(e, t) {
			super(e, t), (this._isTransitioning = !1), (this._triggerArray = []);
			const i = at.find(_f);
			for (const r of i) {
				const s = at.getSelectorFromElement(r),
					a = at.find(s).filter((o) => o === this._element);
				s !== null && a.length && this._triggerArray.push(r);
			}
			this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
		}
		static get Default() {
			return I1;
		}
		static get DefaultType() {
			return F1;
		}
		static get NAME() {
			return x1;
		}
		toggle() {
			this._isShown() ? this.hide() : this.show();
		}
		show() {
			if (this._isTransitioning || this._isShown()) return;
			let e = [];
			if (
				(this._config.parent &&
					(e = this._getFirstLevelChildren(O1)
						.filter((o) => o !== this._element)
						.map((o) => Fo.getOrCreateInstance(o, { toggle: !1 }))),
				(e.length && e[0]._isTransitioning) || Te.trigger(this._element, E1).defaultPrevented)
			)
				return;
			for (const o of e) o.hide();
			const i = this._getDimension();
			this._element.classList.remove(mo), this._element.classList.add(Ac), (this._element.style[i] = 0), this._addAriaAndCollapsedClass(this._triggerArray, !0), (this._isTransitioning = !0);
			const r = () => {
					(this._isTransitioning = !1), this._element.classList.remove(Ac), this._element.classList.add(mo, td), (this._element.style[i] = ""), Te.trigger(this._element, w1);
				},
				a = `scroll${i[0].toUpperCase() + i.slice(1)}`;
			this._queueCallback(r, this._element, !0), (this._element.style[i] = `${this._element[a]}px`);
		}
		hide() {
			if (this._isTransitioning || !this._isShown() || Te.trigger(this._element, T1).defaultPrevented) return;
			const t = this._getDimension();
			(this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`), Wl(this._element), this._element.classList.add(Ac), this._element.classList.remove(mo, td);
			for (const r of this._triggerArray) {
				const s = at.getElementFromSelector(r);
				s && !this._isShown(s) && this._addAriaAndCollapsedClass([r], !1);
			}
			this._isTransitioning = !0;
			const i = () => {
				(this._isTransitioning = !1), this._element.classList.remove(Ac), this._element.classList.add(mo), Te.trigger(this._element, M1);
			};
			(this._element.style[t] = ""), this._queueCallback(i, this._element, !0);
		}
		_isShown(e = this._element) {
			return e.classList.contains(td);
		}
		_configAfterMerge(e) {
			return (e.toggle = !!e.toggle), (e.parent = Ls(e.parent)), e;
		}
		_getDimension() {
			return this._element.classList.contains(R1) ? P1 : D1;
		}
		_initializeChildren() {
			if (!this._config.parent) return;
			const e = this._getFirstLevelChildren(_f);
			for (const t of e) {
				const i = at.getElementFromSelector(t);
				i && this._addAriaAndCollapsedClass([t], this._isShown(i));
			}
		}
		_getFirstLevelChildren(e) {
			const t = at.find(L1, this._config.parent);
			return at.find(e, this._config.parent).filter((i) => !t.includes(i));
		}
		_addAriaAndCollapsedClass(e, t) {
			if (e.length) for (const i of e) i.classList.toggle(C1, !t), i.setAttribute("aria-expanded", t);
		}
		static jQueryInterface(e) {
			const t = {};
			return (
				typeof e == "string" && /show|hide/.test(e) && (t.toggle = !1),
				this.each(function () {
					const i = Fo.getOrCreateInstance(this, t);
					if (typeof e == "string") {
						if (typeof i[e] > "u") throw new TypeError(`No method named "${e}"`);
						i[e]();
					}
				})
			);
		}
	}
	Te.on(document, A1, _f, function (n) {
		(n.target.tagName === "A" || (n.delegateTarget && n.delegateTarget.tagName === "A")) && n.preventDefault();
		for (const e of at.getMultipleElementsFromSelector(this)) Fo.getOrCreateInstance(e, { toggle: !1 }).toggle();
	});
	ki(Fo);
	const Vg = "dropdown",
		N1 = "bs.dropdown",
		Ea = `.${N1}`,
		Dp = ".data-api",
		U1 = "Escape",
		Wg = "Tab",
		k1 = "ArrowUp",
		Xg = "ArrowDown",
		B1 = 2,
		z1 = `hide${Ea}`,
		H1 = `hidden${Ea}`,
		G1 = `show${Ea}`,
		V1 = `shown${Ea}`,
		Ty = `click${Ea}${Dp}`,
		My = `keydown${Ea}${Dp}`,
		W1 = `keyup${Ea}${Dp}`,
		fo = "show",
		X1 = "dropup",
		$1 = "dropend",
		q1 = "dropstart",
		j1 = "dropup-center",
		Y1 = "dropdown-center",
		ua = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
		K1 = `${ua}.${fo}`,
		Au = ".dropdown-menu",
		Z1 = ".navbar",
		J1 = ".navbar-nav",
		Q1 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
		eT = Ni() ? "top-end" : "top-start",
		tT = Ni() ? "top-start" : "top-end",
		nT = Ni() ? "bottom-end" : "bottom-start",
		iT = Ni() ? "bottom-start" : "bottom-end",
		rT = Ni() ? "left-start" : "right-start",
		sT = Ni() ? "right-start" : "left-start",
		aT = "top",
		oT = "bottom",
		lT = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" },
		cT = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
	class tr extends ar {
		constructor(e, t) {
			super(e, t), (this._popper = null), (this._parent = this._element.parentNode), (this._menu = at.next(this._element, Au)[0] || at.prev(this._element, Au)[0] || at.findOne(Au, this._parent)), (this._inNavbar = this._detectNavbar());
		}
		static get Default() {
			return lT;
		}
		static get DefaultType() {
			return cT;
		}
		static get NAME() {
			return Vg;
		}
		toggle() {
			return this._isShown() ? this.hide() : this.show();
		}
		show() {
			if (Rs(this._element) || this._isShown()) return;
			const e = { relatedTarget: this._element };
			if (!Te.trigger(this._element, G1, e).defaultPrevented) {
				if ((this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(J1))) for (const i of [].concat(...document.body.children)) Te.on(i, "mouseover", Hu);
				this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(fo), this._element.classList.add(fo), Te.trigger(this._element, V1, e);
			}
		}
		hide() {
			if (Rs(this._element) || !this._isShown()) return;
			const e = { relatedTarget: this._element };
			this._completeHide(e);
		}
		dispose() {
			this._popper && this._popper.destroy(), super.dispose();
		}
		update() {
			(this._inNavbar = this._detectNavbar()), this._popper && this._popper.update();
		}
		_completeHide(e) {
			if (!Te.trigger(this._element, z1, e).defaultPrevented) {
				if ("ontouchstart" in document.documentElement) for (const i of [].concat(...document.body.children)) Te.off(i, "mouseover", Hu);
				this._popper && this._popper.destroy(), this._menu.classList.remove(fo), this._element.classList.remove(fo), this._element.setAttribute("aria-expanded", "false"), Xr.removeDataAttribute(this._menu, "popper"), Te.trigger(this._element, H1, e);
			}
		}
		_getConfig(e) {
			if (((e = super._getConfig(e)), typeof e.reference == "object" && !Wr(e.reference) && typeof e.reference.getBoundingClientRect != "function")) throw new TypeError(`${Vg.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
			return e;
		}
		_createPopper() {
			if (typeof ly > "u") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
			let e = this._element;
			this._config.reference === "parent" ? (e = this._parent) : Wr(this._config.reference) ? (e = Ls(this._config.reference)) : typeof this._config.reference == "object" && (e = this._config.reference);
			const t = this._getPopperConfig();
			this._popper = Lp(e, this._menu, t);
		}
		_isShown() {
			return this._menu.classList.contains(fo);
		}
		_getPlacement() {
			const e = this._parent;
			if (e.classList.contains($1)) return rT;
			if (e.classList.contains(q1)) return sT;
			if (e.classList.contains(j1)) return aT;
			if (e.classList.contains(Y1)) return oT;
			const t = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
			return e.classList.contains(X1) ? (t ? tT : eT) : t ? iT : nT;
		}
		_detectNavbar() {
			return this._element.closest(Z1) !== null;
		}
		_getOffset() {
			const { offset: e } = this._config;
			return typeof e == "string" ? e.split(",").map((t) => Number.parseInt(t, 10)) : typeof e == "function" ? (t) => e(t, this._element) : e;
		}
		_getPopperConfig() {
			const e = {
				placement: this._getPlacement(),
				modifiers: [
					{ name: "preventOverflow", options: { boundary: this._config.boundary } },
					{ name: "offset", options: { offset: this._getOffset() } }
				]
			};
			return (this._inNavbar || this._config.display === "static") && (Xr.setDataAttribute(this._menu, "popper", "static"), (e.modifiers = [{ name: "applyStyles", enabled: !1 }])), { ...e, ...oi(this._config.popperConfig, [e]) };
		}
		_selectMenuItem({ key: e, target: t }) {
			const i = at.find(Q1, this._menu).filter((r) => Vo(r));
			i.length && Rp(i, t, e === Xg, !i.includes(t)).focus();
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = tr.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (typeof t[e] > "u") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
		static clearMenus(e) {
			if (e.button === B1 || (e.type === "keyup" && e.key !== Wg)) return;
			const t = at.find(K1);
			for (const i of t) {
				const r = tr.getInstance(i);
				if (!r || r._config.autoClose === !1) continue;
				const s = e.composedPath(),
					a = s.includes(r._menu);
				if (s.includes(r._element) || (r._config.autoClose === "inside" && !a) || (r._config.autoClose === "outside" && a) || (r._menu.contains(e.target) && ((e.type === "keyup" && e.key === Wg) || /input|select|option|textarea|form/i.test(e.target.tagName)))) continue;
				const o = { relatedTarget: r._element };
				e.type === "click" && (o.clickEvent = e), r._completeHide(o);
			}
		}
		static dataApiKeydownHandler(e) {
			const t = /input|textarea/i.test(e.target.tagName),
				i = e.key === U1,
				r = [k1, Xg].includes(e.key);
			if ((!r && !i) || (t && !i)) return;
			e.preventDefault();
			const s = this.matches(ua) ? this : at.prev(this, ua)[0] || at.next(this, ua)[0] || at.findOne(ua, e.delegateTarget.parentNode),
				a = tr.getOrCreateInstance(s);
			if (r) {
				e.stopPropagation(), a.show(), a._selectMenuItem(e);
				return;
			}
			a._isShown() && (e.stopPropagation(), a.hide(), s.focus());
		}
	}
	Te.on(document, My, ua, tr.dataApiKeydownHandler);
	Te.on(document, My, Au, tr.dataApiKeydownHandler);
	Te.on(document, Ty, tr.clearMenus);
	Te.on(document, W1, tr.clearMenus);
	Te.on(document, Ty, ua, function (n) {
		n.preventDefault(), tr.getOrCreateInstance(this).toggle();
	});
	ki(tr);
	const Ay = "backdrop",
		uT = "fade",
		$g = "show",
		qg = `mousedown.bs.${Ay}`,
		hT = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" },
		dT = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
	class Cy extends Xl {
		constructor(e) {
			super(), (this._config = this._getConfig(e)), (this._isAppended = !1), (this._element = null);
		}
		static get Default() {
			return hT;
		}
		static get DefaultType() {
			return dT;
		}
		static get NAME() {
			return Ay;
		}
		show(e) {
			if (!this._config.isVisible) {
				oi(e);
				return;
			}
			this._append();
			const t = this._getElement();
			this._config.isAnimated && Wl(t),
				t.classList.add($g),
				this._emulateAnimation(() => {
					oi(e);
				});
		}
		hide(e) {
			if (!this._config.isVisible) {
				oi(e);
				return;
			}
			this._getElement().classList.remove($g),
				this._emulateAnimation(() => {
					this.dispose(), oi(e);
				});
		}
		dispose() {
			this._isAppended && (Te.off(this._element, qg), this._element.remove(), (this._isAppended = !1));
		}
		_getElement() {
			if (!this._element) {
				const e = document.createElement("div");
				(e.className = this._config.className), this._config.isAnimated && e.classList.add(uT), (this._element = e);
			}
			return this._element;
		}
		_configAfterMerge(e) {
			return (e.rootElement = Ls(e.rootElement)), e;
		}
		_append() {
			if (this._isAppended) return;
			const e = this._getElement();
			this._config.rootElement.append(e),
				Te.on(e, qg, () => {
					oi(this._config.clickCallback);
				}),
				(this._isAppended = !0);
		}
		_emulateAnimation(e) {
			fy(e, this._getElement(), this._config.isAnimated);
		}
	}
	const fT = "focustrap",
		pT = "bs.focustrap",
		Vu = `.${pT}`,
		mT = `focusin${Vu}`,
		gT = `keydown.tab${Vu}`,
		vT = "Tab",
		_T = "forward",
		jg = "backward",
		yT = { autofocus: !0, trapElement: null },
		xT = { autofocus: "boolean", trapElement: "element" };
	class Ly extends Xl {
		constructor(e) {
			super(), (this._config = this._getConfig(e)), (this._isActive = !1), (this._lastTabNavDirection = null);
		}
		static get Default() {
			return yT;
		}
		static get DefaultType() {
			return xT;
		}
		static get NAME() {
			return fT;
		}
		activate() {
			this._isActive || (this._config.autofocus && this._config.trapElement.focus(), Te.off(document, Vu), Te.on(document, mT, (e) => this._handleFocusin(e)), Te.on(document, gT, (e) => this._handleKeydown(e)), (this._isActive = !0));
		}
		deactivate() {
			this._isActive && ((this._isActive = !1), Te.off(document, Vu));
		}
		_handleFocusin(e) {
			const { trapElement: t } = this._config;
			if (e.target === document || e.target === t || t.contains(e.target)) return;
			const i = at.focusableChildren(t);
			i.length === 0 ? t.focus() : this._lastTabNavDirection === jg ? i[i.length - 1].focus() : i[0].focus();
		}
		_handleKeydown(e) {
			e.key === vT && (this._lastTabNavDirection = e.shiftKey ? jg : _T);
		}
	}
	const Yg = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
		Kg = ".sticky-top",
		Cc = "padding-right",
		Zg = "margin-right";
	class yf {
		constructor() {
			this._element = document.body;
		}
		getWidth() {
			const e = document.documentElement.clientWidth;
			return Math.abs(window.innerWidth - e);
		}
		hide() {
			const e = this.getWidth();
			this._disableOverFlow(), this._setElementAttributes(this._element, Cc, (t) => t + e), this._setElementAttributes(Yg, Cc, (t) => t + e), this._setElementAttributes(Kg, Zg, (t) => t - e);
		}
		reset() {
			this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Cc), this._resetElementAttributes(Yg, Cc), this._resetElementAttributes(Kg, Zg);
		}
		isOverflowing() {
			return this.getWidth() > 0;
		}
		_disableOverFlow() {
			this._saveInitialAttribute(this._element, "overflow"), (this._element.style.overflow = "hidden");
		}
		_setElementAttributes(e, t, i) {
			const r = this.getWidth(),
				s = (a) => {
					if (a !== this._element && window.innerWidth > a.clientWidth + r) return;
					this._saveInitialAttribute(a, t);
					const o = window.getComputedStyle(a).getPropertyValue(t);
					a.style.setProperty(t, `${i(Number.parseFloat(o))}px`);
				};
			this._applyManipulationCallback(e, s);
		}
		_saveInitialAttribute(e, t) {
			const i = e.style.getPropertyValue(t);
			i && Xr.setDataAttribute(e, t, i);
		}
		_resetElementAttributes(e, t) {
			const i = (r) => {
				const s = Xr.getDataAttribute(r, t);
				if (s === null) {
					r.style.removeProperty(t);
					return;
				}
				Xr.removeDataAttribute(r, t), r.style.setProperty(t, s);
			};
			this._applyManipulationCallback(e, i);
		}
		_applyManipulationCallback(e, t) {
			if (Wr(e)) {
				t(e);
				return;
			}
			for (const i of at.find(e, this._element)) t(i);
		}
	}
	const bT = "modal",
		ST = "bs.modal",
		Ui = `.${ST}`,
		ET = ".data-api",
		wT = "Escape",
		TT = `hide${Ui}`,
		MT = `hidePrevented${Ui}`,
		Ry = `hidden${Ui}`,
		Py = `show${Ui}`,
		AT = `shown${Ui}`,
		CT = `resize${Ui}`,
		LT = `click.dismiss${Ui}`,
		RT = `mousedown.dismiss${Ui}`,
		PT = `keydown.dismiss${Ui}`,
		DT = `click${Ui}${ET}`,
		Jg = "modal-open",
		OT = "fade",
		Qg = "show",
		nd = "modal-static",
		IT = ".modal.show",
		FT = ".modal-dialog",
		NT = ".modal-body",
		UT = '[data-bs-toggle="modal"]',
		kT = { backdrop: !0, focus: !0, keyboard: !0 },
		BT = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
	class Sr extends ar {
		constructor(e, t) {
			super(e, t), (this._dialog = at.findOne(FT, this._element)), (this._backdrop = this._initializeBackDrop()), (this._focustrap = this._initializeFocusTrap()), (this._isShown = !1), (this._isTransitioning = !1), (this._scrollBar = new yf()), this._addEventListeners();
		}
		static get Default() {
			return kT;
		}
		static get DefaultType() {
			return BT;
		}
		static get NAME() {
			return bT;
		}
		toggle(e) {
			return this._isShown ? this.hide() : this.show(e);
		}
		show(e) {
			this._isShown || this._isTransitioning || Te.trigger(this._element, Py, { relatedTarget: e }).defaultPrevented || ((this._isShown = !0), (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(Jg), this._adjustDialog(), this._backdrop.show(() => this._showElement(e)));
		}
		hide() {
			!this._isShown || this._isTransitioning || Te.trigger(this._element, TT).defaultPrevented || ((this._isShown = !1), (this._isTransitioning = !0), this._focustrap.deactivate(), this._element.classList.remove(Qg), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()));
		}
		dispose() {
			Te.off(window, Ui), Te.off(this._dialog, Ui), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
		}
		handleUpdate() {
			this._adjustDialog();
		}
		_initializeBackDrop() {
			return new Cy({ isVisible: !!this._config.backdrop, isAnimated: this._isAnimated() });
		}
		_initializeFocusTrap() {
			return new Ly({ trapElement: this._element });
		}
		_showElement(e) {
			document.body.contains(this._element) || document.body.append(this._element), (this._element.style.display = "block"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), (this._element.scrollTop = 0);
			const t = at.findOne(NT, this._dialog);
			t && (t.scrollTop = 0), Wl(this._element), this._element.classList.add(Qg);
			const i = () => {
				this._config.focus && this._focustrap.activate(), (this._isTransitioning = !1), Te.trigger(this._element, AT, { relatedTarget: e });
			};
			this._queueCallback(i, this._dialog, this._isAnimated());
		}
		_addEventListeners() {
			Te.on(this._element, PT, (e) => {
				if (e.key === wT) {
					if (this._config.keyboard) {
						this.hide();
						return;
					}
					this._triggerBackdropTransition();
				}
			}),
				Te.on(window, CT, () => {
					this._isShown && !this._isTransitioning && this._adjustDialog();
				}),
				Te.on(this._element, RT, (e) => {
					Te.one(this._element, LT, (t) => {
						if (!(this._element !== e.target || this._element !== t.target)) {
							if (this._config.backdrop === "static") {
								this._triggerBackdropTransition();
								return;
							}
							this._config.backdrop && this.hide();
						}
					});
				});
		}
		_hideModal() {
			(this._element.style.display = "none"),
				this._element.setAttribute("aria-hidden", !0),
				this._element.removeAttribute("aria-modal"),
				this._element.removeAttribute("role"),
				(this._isTransitioning = !1),
				this._backdrop.hide(() => {
					document.body.classList.remove(Jg), this._resetAdjustments(), this._scrollBar.reset(), Te.trigger(this._element, Ry);
				});
		}
		_isAnimated() {
			return this._element.classList.contains(OT);
		}
		_triggerBackdropTransition() {
			if (Te.trigger(this._element, MT).defaultPrevented) return;
			const t = this._element.scrollHeight > document.documentElement.clientHeight,
				i = this._element.style.overflowY;
			i === "hidden" ||
				this._element.classList.contains(nd) ||
				(t || (this._element.style.overflowY = "hidden"),
				this._element.classList.add(nd),
				this._queueCallback(() => {
					this._element.classList.remove(nd),
						this._queueCallback(() => {
							this._element.style.overflowY = i;
						}, this._dialog);
				}, this._dialog),
				this._element.focus());
		}
		_adjustDialog() {
			const e = this._element.scrollHeight > document.documentElement.clientHeight,
				t = this._scrollBar.getWidth(),
				i = t > 0;
			if (i && !e) {
				const r = Ni() ? "paddingLeft" : "paddingRight";
				this._element.style[r] = `${t}px`;
			}
			if (!i && e) {
				const r = Ni() ? "paddingRight" : "paddingLeft";
				this._element.style[r] = `${t}px`;
			}
		}
		_resetAdjustments() {
			(this._element.style.paddingLeft = ""), (this._element.style.paddingRight = "");
		}
		static jQueryInterface(e, t) {
			return this.each(function () {
				const i = Sr.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (typeof i[e] > "u") throw new TypeError(`No method named "${e}"`);
					i[e](t);
				}
			});
		}
	}
	Te.on(document, DT, UT, function (n) {
		const e = at.getElementFromSelector(this);
		["A", "AREA"].includes(this.tagName) && n.preventDefault(),
			Te.one(e, Py, (r) => {
				r.defaultPrevented ||
					Te.one(e, Ry, () => {
						Vo(this) && this.focus();
					});
			});
		const t = at.findOne(IT);
		t && Sr.getInstance(t).hide(), Sr.getOrCreateInstance(e).toggle(this);
	});
	fh(Sr);
	ki(Sr);
	const zT = "offcanvas",
		HT = "bs.offcanvas",
		Jr = `.${HT}`,
		Dy = ".data-api",
		GT = `load${Jr}${Dy}`,
		VT = "Escape",
		ev = "show",
		tv = "showing",
		nv = "hiding",
		WT = "offcanvas-backdrop",
		Oy = ".offcanvas.show",
		XT = `show${Jr}`,
		$T = `shown${Jr}`,
		qT = `hide${Jr}`,
		iv = `hidePrevented${Jr}`,
		Iy = `hidden${Jr}`,
		jT = `resize${Jr}`,
		YT = `click${Jr}${Dy}`,
		KT = `keydown.dismiss${Jr}`,
		ZT = '[data-bs-toggle="offcanvas"]',
		JT = { backdrop: !0, keyboard: !0, scroll: !1 },
		QT = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
	class Yr extends ar {
		constructor(e, t) {
			super(e, t), (this._isShown = !1), (this._backdrop = this._initializeBackDrop()), (this._focustrap = this._initializeFocusTrap()), this._addEventListeners();
		}
		static get Default() {
			return JT;
		}
		static get DefaultType() {
			return QT;
		}
		static get NAME() {
			return zT;
		}
		toggle(e) {
			return this._isShown ? this.hide() : this.show(e);
		}
		show(e) {
			if (this._isShown || Te.trigger(this._element, XT, { relatedTarget: e }).defaultPrevented) return;
			(this._isShown = !0), this._backdrop.show(), this._config.scroll || new yf().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(tv);
			const i = () => {
				(!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(ev), this._element.classList.remove(tv), Te.trigger(this._element, $T, { relatedTarget: e });
			};
			this._queueCallback(i, this._element, !0);
		}
		hide() {
			if (!this._isShown || Te.trigger(this._element, qT).defaultPrevented) return;
			this._focustrap.deactivate(), this._element.blur(), (this._isShown = !1), this._element.classList.add(nv), this._backdrop.hide();
			const t = () => {
				this._element.classList.remove(ev, nv), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new yf().reset(), Te.trigger(this._element, Iy);
			};
			this._queueCallback(t, this._element, !0);
		}
		dispose() {
			this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
		}
		_initializeBackDrop() {
			const e = () => {
					if (this._config.backdrop === "static") {
						Te.trigger(this._element, iv);
						return;
					}
					this.hide();
				},
				t = !!this._config.backdrop;
			return new Cy({ className: WT, isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? e : null });
		}
		_initializeFocusTrap() {
			return new Ly({ trapElement: this._element });
		}
		_addEventListeners() {
			Te.on(this._element, KT, (e) => {
				if (e.key === VT) {
					if (this._config.keyboard) {
						this.hide();
						return;
					}
					Te.trigger(this._element, iv);
				}
			});
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = Yr.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (t[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`);
					t[e](this);
				}
			});
		}
	}
	Te.on(document, YT, ZT, function (n) {
		const e = at.getElementFromSelector(this);
		if ((["A", "AREA"].includes(this.tagName) && n.preventDefault(), Rs(this))) return;
		Te.one(e, Iy, () => {
			Vo(this) && this.focus();
		});
		const t = at.findOne(Oy);
		t && t !== e && Yr.getInstance(t).hide(), Yr.getOrCreateInstance(e).toggle(this);
	});
	Te.on(window, GT, () => {
		for (const n of at.find(Oy)) Yr.getOrCreateInstance(n).show();
	});
	Te.on(window, jT, () => {
		for (const n of at.find("[aria-modal][class*=show][class*=offcanvas-]")) getComputedStyle(n).position !== "fixed" && Yr.getOrCreateInstance(n).hide();
	});
	fh(Yr);
	ki(Yr);
	const eM = /^aria-[\w-]*$/i,
		Fy = { "*": ["class", "dir", "id", "lang", "role", eM], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] },
		tM = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
		nM = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
		iM = (n, e) => {
			const t = n.nodeName.toLowerCase();
			return e.includes(t) ? (tM.has(t) ? !!nM.test(n.nodeValue) : !0) : e.filter((i) => i instanceof RegExp).some((i) => i.test(t));
		};
	function rM(n, e, t) {
		if (!n.length) return n;
		if (t && typeof t == "function") return t(n);
		const r = new window.DOMParser().parseFromString(n, "text/html"),
			s = [].concat(...r.body.querySelectorAll("*"));
		for (const a of s) {
			const o = a.nodeName.toLowerCase();
			if (!Object.keys(e).includes(o)) {
				a.remove();
				continue;
			}
			const l = [].concat(...a.attributes),
				c = [].concat(e["*"] || [], e[o] || []);
			for (const u of l) iM(u, c) || a.removeAttribute(u.nodeName);
		}
		return r.body.innerHTML;
	}
	const sM = "TemplateFactory",
		aM = { allowList: Fy, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" },
		oM = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" },
		lM = { entry: "(string|element|function|null)", selector: "(string|element)" };
	class cM extends Xl {
		constructor(e) {
			super(), (this._config = this._getConfig(e));
		}
		static get Default() {
			return aM;
		}
		static get DefaultType() {
			return oM;
		}
		static get NAME() {
			return sM;
		}
		getContent() {
			return Object.values(this._config.content)
				.map((e) => this._resolvePossibleFunction(e))
				.filter(Boolean);
		}
		hasContent() {
			return this.getContent().length > 0;
		}
		changeContent(e) {
			return this._checkContent(e), (this._config.content = { ...this._config.content, ...e }), this;
		}
		toHtml() {
			const e = document.createElement("div");
			e.innerHTML = this._maybeSanitize(this._config.template);
			for (const [r, s] of Object.entries(this._config.content)) this._setContent(e, s, r);
			const t = e.children[0],
				i = this._resolvePossibleFunction(this._config.extraClass);
			return i && t.classList.add(...i.split(" ")), t;
		}
		_typeCheckConfig(e) {
			super._typeCheckConfig(e), this._checkContent(e.content);
		}
		_checkContent(e) {
			for (const [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, lM);
		}
		_setContent(e, t, i) {
			const r = at.findOne(i, e);
			if (r) {
				if (((t = this._resolvePossibleFunction(t)), !t)) {
					r.remove();
					return;
				}
				if (Wr(t)) {
					this._putElementInTemplate(Ls(t), r);
					return;
				}
				if (this._config.html) {
					r.innerHTML = this._maybeSanitize(t);
					return;
				}
				r.textContent = t;
			}
		}
		_maybeSanitize(e) {
			return this._config.sanitize ? rM(e, this._config.allowList, this._config.sanitizeFn) : e;
		}
		_resolvePossibleFunction(e) {
			return oi(e, [this]);
		}
		_putElementInTemplate(e, t) {
			if (this._config.html) {
				(t.innerHTML = ""), t.append(e);
				return;
			}
			t.textContent = e.textContent;
		}
	}
	const uM = "tooltip",
		hM = new Set(["sanitize", "allowList", "sanitizeFn"]),
		id = "fade",
		dM = "modal",
		Lc = "show",
		fM = ".tooltip-inner",
		rv = `.${dM}`,
		sv = "hide.bs.modal",
		sl = "hover",
		rd = "focus",
		pM = "click",
		mM = "manual",
		gM = "hide",
		vM = "hidden",
		_M = "show",
		yM = "shown",
		xM = "inserted",
		bM = "click",
		SM = "focusin",
		EM = "focusout",
		wM = "mouseenter",
		TM = "mouseleave",
		MM = { AUTO: "auto", TOP: "top", RIGHT: Ni() ? "left" : "right", BOTTOM: "bottom", LEFT: Ni() ? "right" : "left" },
		AM = { allowList: Fy, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" },
		CM = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
	class wa extends ar {
		constructor(e, t) {
			if (typeof ly > "u") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
			super(e, t), (this._isEnabled = !0), (this._timeout = 0), (this._isHovered = null), (this._activeTrigger = {}), (this._popper = null), (this._templateFactory = null), (this._newContent = null), (this.tip = null), this._setListeners(), this._config.selector || this._fixTitle();
		}
		static get Default() {
			return AM;
		}
		static get DefaultType() {
			return CM;
		}
		static get NAME() {
			return uM;
		}
		enable() {
			this._isEnabled = !0;
		}
		disable() {
			this._isEnabled = !1;
		}
		toggleEnabled() {
			this._isEnabled = !this._isEnabled;
		}
		toggle() {
			if (this._isEnabled) {
				if (((this._activeTrigger.click = !this._activeTrigger.click), this._isShown())) {
					this._leave();
					return;
				}
				this._enter();
			}
		}
		dispose() {
			clearTimeout(this._timeout), Te.off(this._element.closest(rv), sv, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
		}
		show() {
			if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
			if (!(this._isWithContent() && this._isEnabled)) return;
			const e = Te.trigger(this._element, this.constructor.eventName(_M)),
				i = (hy(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
			if (e.defaultPrevented || !i) return;
			this._disposePopper();
			const r = this._getTipElement();
			this._element.setAttribute("aria-describedby", r.getAttribute("id"));
			const { container: s } = this._config;
			if ((this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(r), Te.trigger(this._element, this.constructor.eventName(xM))), (this._popper = this._createPopper(r)), r.classList.add(Lc), "ontouchstart" in document.documentElement)) for (const o of [].concat(...document.body.children)) Te.on(o, "mouseover", Hu);
			const a = () => {
				Te.trigger(this._element, this.constructor.eventName(yM)), this._isHovered === !1 && this._leave(), (this._isHovered = !1);
			};
			this._queueCallback(a, this.tip, this._isAnimated());
		}
		hide() {
			if (!this._isShown() || Te.trigger(this._element, this.constructor.eventName(gM)).defaultPrevented) return;
			if ((this._getTipElement().classList.remove(Lc), "ontouchstart" in document.documentElement)) for (const r of [].concat(...document.body.children)) Te.off(r, "mouseover", Hu);
			(this._activeTrigger[pM] = !1), (this._activeTrigger[rd] = !1), (this._activeTrigger[sl] = !1), (this._isHovered = null);
			const i = () => {
				this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), Te.trigger(this._element, this.constructor.eventName(vM)));
			};
			this._queueCallback(i, this.tip, this._isAnimated());
		}
		update() {
			this._popper && this._popper.update();
		}
		_isWithContent() {
			return !!this._getTitle();
		}
		_getTipElement() {
			return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
		}
		_createTipElement(e) {
			const t = this._getTemplateFactory(e).toHtml();
			if (!t) return null;
			t.classList.remove(id, Lc), t.classList.add(`bs-${this.constructor.NAME}-auto`);
			const i = pw(this.constructor.NAME).toString();
			return t.setAttribute("id", i), this._isAnimated() && t.classList.add(id), t;
		}
		setContent(e) {
			(this._newContent = e), this._isShown() && (this._disposePopper(), this.show());
		}
		_getTemplateFactory(e) {
			return this._templateFactory ? this._templateFactory.changeContent(e) : (this._templateFactory = new cM({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) })), this._templateFactory;
		}
		_getContentForTemplate() {
			return { [fM]: this._getTitle() };
		}
		_getTitle() {
			return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
		}
		_initializeOnDelegatedTarget(e) {
			return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig());
		}
		_isAnimated() {
			return this._config.animation || (this.tip && this.tip.classList.contains(id));
		}
		_isShown() {
			return this.tip && this.tip.classList.contains(Lc);
		}
		_createPopper(e) {
			const t = oi(this._config.placement, [this, e, this._element]),
				i = MM[t.toUpperCase()];
			return Lp(this._element, e, this._getPopperConfig(i));
		}
		_getOffset() {
			const { offset: e } = this._config;
			return typeof e == "string" ? e.split(",").map((t) => Number.parseInt(t, 10)) : typeof e == "function" ? (t) => e(t, this._element) : e;
		}
		_resolvePossibleFunction(e) {
			return oi(e, [this._element]);
		}
		_getPopperConfig(e) {
			const t = {
				placement: e,
				modifiers: [
					{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } },
					{ name: "offset", options: { offset: this._getOffset() } },
					{ name: "preventOverflow", options: { boundary: this._config.boundary } },
					{ name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } },
					{
						name: "preSetPlacement",
						enabled: !0,
						phase: "beforeMain",
						fn: (i) => {
							this._getTipElement().setAttribute("data-popper-placement", i.state.placement);
						}
					}
				]
			};
			return { ...t, ...oi(this._config.popperConfig, [t]) };
		}
		_setListeners() {
			const e = this._config.trigger.split(" ");
			for (const t of e)
				if (t === "click")
					Te.on(this._element, this.constructor.eventName(bM), this._config.selector, (i) => {
						this._initializeOnDelegatedTarget(i).toggle();
					});
				else if (t !== mM) {
					const i = t === sl ? this.constructor.eventName(wM) : this.constructor.eventName(SM),
						r = t === sl ? this.constructor.eventName(TM) : this.constructor.eventName(EM);
					Te.on(this._element, i, this._config.selector, (s) => {
						const a = this._initializeOnDelegatedTarget(s);
						(a._activeTrigger[s.type === "focusin" ? rd : sl] = !0), a._enter();
					}),
						Te.on(this._element, r, this._config.selector, (s) => {
							const a = this._initializeOnDelegatedTarget(s);
							(a._activeTrigger[s.type === "focusout" ? rd : sl] = a._element.contains(s.relatedTarget)), a._leave();
						});
				}
			(this._hideModalHandler = () => {
				this._element && this.hide();
			}),
				Te.on(this._element.closest(rv), sv, this._hideModalHandler);
		}
		_fixTitle() {
			const e = this._element.getAttribute("title");
			e && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", e), this._element.setAttribute("data-bs-original-title", e), this._element.removeAttribute("title"));
		}
		_enter() {
			if (this._isShown() || this._isHovered) {
				this._isHovered = !0;
				return;
			}
			(this._isHovered = !0),
				this._setTimeout(() => {
					this._isHovered && this.show();
				}, this._config.delay.show);
		}
		_leave() {
			this._isWithActiveTrigger() ||
				((this._isHovered = !1),
				this._setTimeout(() => {
					this._isHovered || this.hide();
				}, this._config.delay.hide));
		}
		_setTimeout(e, t) {
			clearTimeout(this._timeout), (this._timeout = setTimeout(e, t));
		}
		_isWithActiveTrigger() {
			return Object.values(this._activeTrigger).includes(!0);
		}
		_getConfig(e) {
			const t = Xr.getDataAttributes(this._element);
			for (const i of Object.keys(t)) hM.has(i) && delete t[i];
			return (e = { ...t, ...(typeof e == "object" && e ? e : {}) }), (e = this._mergeConfigObj(e)), (e = this._configAfterMerge(e)), this._typeCheckConfig(e), e;
		}
		_configAfterMerge(e) {
			return (e.container = e.container === !1 ? document.body : Ls(e.container)), typeof e.delay == "number" && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title == "number" && (e.title = e.title.toString()), typeof e.content == "number" && (e.content = e.content.toString()), e;
		}
		_getDelegateConfig() {
			const e = {};
			for (const [t, i] of Object.entries(this._config)) this.constructor.Default[t] !== i && (e[t] = i);
			return (e.selector = !1), (e.trigger = "manual"), e;
		}
		_disposePopper() {
			this._popper && (this._popper.destroy(), (this._popper = null)), this.tip && (this.tip.remove(), (this.tip = null));
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = wa.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (typeof t[e] > "u") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
	}
	ki(wa);
	const LM = "popover",
		RM = ".popover-header",
		PM = ".popover-body",
		DM = { ...wa.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" },
		OM = { ...wa.DefaultType, content: "(null|string|element|function)" };
	class ph extends wa {
		static get Default() {
			return DM;
		}
		static get DefaultType() {
			return OM;
		}
		static get NAME() {
			return LM;
		}
		_isWithContent() {
			return this._getTitle() || this._getContent();
		}
		_getContentForTemplate() {
			return { [RM]: this._getTitle(), [PM]: this._getContent() };
		}
		_getContent() {
			return this._resolvePossibleFunction(this._config.content);
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = ph.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (typeof t[e] > "u") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
	}
	ki(ph);
	const IM = "scrollspy",
		FM = "bs.scrollspy",
		Op = `.${FM}`,
		NM = ".data-api",
		UM = `activate${Op}`,
		av = `click${Op}`,
		kM = `load${Op}${NM}`,
		BM = "dropdown-item",
		ka = "active",
		zM = '[data-bs-spy="scroll"]',
		sd = "[href]",
		HM = ".nav, .list-group",
		ov = ".nav-link",
		GM = ".nav-item",
		VM = ".list-group-item",
		WM = `${ov}, ${GM} > ${ov}, ${VM}`,
		XM = ".dropdown",
		$M = ".dropdown-toggle",
		qM = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1] },
		jM = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
	class Yl extends ar {
		constructor(e, t) {
			super(e, t), (this._targetLinks = new Map()), (this._observableSections = new Map()), (this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element), (this._activeTarget = null), (this._observer = null), (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }), this.refresh();
		}
		static get Default() {
			return qM;
		}
		static get DefaultType() {
			return jM;
		}
		static get NAME() {
			return IM;
		}
		refresh() {
			this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : (this._observer = this._getNewObserver());
			for (const e of this._observableSections.values()) this._observer.observe(e);
		}
		dispose() {
			this._observer.disconnect(), super.dispose();
		}
		_configAfterMerge(e) {
			return (e.target = Ls(e.target) || document.body), (e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin), typeof e.threshold == "string" && (e.threshold = e.threshold.split(",").map((t) => Number.parseFloat(t))), e;
		}
		_maybeEnableSmoothScroll() {
			this._config.smoothScroll &&
				(Te.off(this._config.target, av),
				Te.on(this._config.target, av, sd, (e) => {
					const t = this._observableSections.get(e.target.hash);
					if (t) {
						e.preventDefault();
						const i = this._rootElement || window,
							r = t.offsetTop - this._element.offsetTop;
						if (i.scrollTo) {
							i.scrollTo({ top: r, behavior: "smooth" });
							return;
						}
						i.scrollTop = r;
					}
				}));
		}
		_getNewObserver() {
			const e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
			return new IntersectionObserver((t) => this._observerCallback(t), e);
		}
		_observerCallback(e) {
			const t = (a) => this._targetLinks.get(`#${a.target.id}`),
				i = (a) => {
					(this._previousScrollData.visibleEntryTop = a.target.offsetTop), this._process(t(a));
				},
				r = (this._rootElement || document.documentElement).scrollTop,
				s = r >= this._previousScrollData.parentScrollTop;
			this._previousScrollData.parentScrollTop = r;
			for (const a of e) {
				if (!a.isIntersecting) {
					(this._activeTarget = null), this._clearActiveClass(t(a));
					continue;
				}
				const o = a.target.offsetTop >= this._previousScrollData.visibleEntryTop;
				if (s && o) {
					if ((i(a), !r)) return;
					continue;
				}
				!s && !o && i(a);
			}
		}
		_initializeTargetsAndObservables() {
			(this._targetLinks = new Map()), (this._observableSections = new Map());
			const e = at.find(sd, this._config.target);
			for (const t of e) {
				if (!t.hash || Rs(t)) continue;
				const i = at.findOne(decodeURI(t.hash), this._element);
				Vo(i) && (this._targetLinks.set(decodeURI(t.hash), t), this._observableSections.set(t.hash, i));
			}
		}
		_process(e) {
			this._activeTarget !== e && (this._clearActiveClass(this._config.target), (this._activeTarget = e), e.classList.add(ka), this._activateParents(e), Te.trigger(this._element, UM, { relatedTarget: e }));
		}
		_activateParents(e) {
			if (e.classList.contains(BM)) {
				at.findOne($M, e.closest(XM)).classList.add(ka);
				return;
			}
			for (const t of at.parents(e, HM)) for (const i of at.prev(t, WM)) i.classList.add(ka);
		}
		_clearActiveClass(e) {
			e.classList.remove(ka);
			const t = at.find(`${sd}.${ka}`, e);
			for (const i of t) i.classList.remove(ka);
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = Yl.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (t[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
	}
	Te.on(window, kM, () => {
		for (const n of at.find(zM)) Yl.getOrCreateInstance(n);
	});
	ki(Yl);
	const YM = "tab",
		KM = "bs.tab",
		Ta = `.${KM}`,
		ZM = `hide${Ta}`,
		JM = `hidden${Ta}`,
		QM = `show${Ta}`,
		eA = `shown${Ta}`,
		tA = `click${Ta}`,
		nA = `keydown${Ta}`,
		iA = `load${Ta}`,
		rA = "ArrowLeft",
		lv = "ArrowRight",
		sA = "ArrowUp",
		cv = "ArrowDown",
		ad = "Home",
		uv = "End",
		ha = "active",
		hv = "fade",
		od = "show",
		aA = "dropdown",
		Ny = ".dropdown-toggle",
		oA = ".dropdown-menu",
		ld = `:not(${Ny})`,
		lA = '.list-group, .nav, [role="tablist"]',
		cA = ".nav-item, .list-group-item",
		uA = `.nav-link${ld}, .list-group-item${ld}, [role="tab"]${ld}`,
		Uy = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
		cd = `${uA}, ${Uy}`,
		hA = `.${ha}[data-bs-toggle="tab"], .${ha}[data-bs-toggle="pill"], .${ha}[data-bs-toggle="list"]`;
	class va extends ar {
		constructor(e) {
			super(e), (this._parent = this._element.closest(lA)), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), Te.on(this._element, nA, (t) => this._keydown(t)));
		}
		static get NAME() {
			return YM;
		}
		show() {
			const e = this._element;
			if (this._elemIsActive(e)) return;
			const t = this._getActiveElem(),
				i = t ? Te.trigger(t, ZM, { relatedTarget: e }) : null;
			Te.trigger(e, QM, { relatedTarget: t }).defaultPrevented || (i && i.defaultPrevented) || (this._deactivate(t, e), this._activate(e, t));
		}
		_activate(e, t) {
			if (!e) return;
			e.classList.add(ha), this._activate(at.getElementFromSelector(e));
			const i = () => {
				if (e.getAttribute("role") !== "tab") {
					e.classList.add(od);
					return;
				}
				e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), Te.trigger(e, eA, { relatedTarget: t });
			};
			this._queueCallback(i, e, e.classList.contains(hv));
		}
		_deactivate(e, t) {
			if (!e) return;
			e.classList.remove(ha), e.blur(), this._deactivate(at.getElementFromSelector(e));
			const i = () => {
				if (e.getAttribute("role") !== "tab") {
					e.classList.remove(od);
					return;
				}
				e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), Te.trigger(e, JM, { relatedTarget: t });
			};
			this._queueCallback(i, e, e.classList.contains(hv));
		}
		_keydown(e) {
			if (![rA, lv, sA, cv, ad, uv].includes(e.key)) return;
			e.stopPropagation(), e.preventDefault();
			const t = this._getChildren().filter((r) => !Rs(r));
			let i;
			if ([ad, uv].includes(e.key)) i = t[e.key === ad ? 0 : t.length - 1];
			else {
				const r = [lv, cv].includes(e.key);
				i = Rp(t, e.target, r, !0);
			}
			i && (i.focus({ preventScroll: !0 }), va.getOrCreateInstance(i).show());
		}
		_getChildren() {
			return at.find(cd, this._parent);
		}
		_getActiveElem() {
			return this._getChildren().find((e) => this._elemIsActive(e)) || null;
		}
		_setInitialAttributes(e, t) {
			this._setAttributeIfNotExists(e, "role", "tablist");
			for (const i of t) this._setInitialAttributesOnChild(i);
		}
		_setInitialAttributesOnChild(e) {
			e = this._getInnerElement(e);
			const t = this._elemIsActive(e),
				i = this._getOuterElement(e);
			e.setAttribute("aria-selected", t), i !== e && this._setAttributeIfNotExists(i, "role", "presentation"), t || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e);
		}
		_setInitialAttributesOnTargetPanel(e) {
			const t = at.getElementFromSelector(e);
			t && (this._setAttributeIfNotExists(t, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(t, "aria-labelledby", `${e.id}`));
		}
		_toggleDropDown(e, t) {
			const i = this._getOuterElement(e);
			if (!i.classList.contains(aA)) return;
			const r = (s, a) => {
				const o = at.findOne(s, i);
				o && o.classList.toggle(a, t);
			};
			r(Ny, ha), r(oA, od), i.setAttribute("aria-expanded", t);
		}
		_setAttributeIfNotExists(e, t, i) {
			e.hasAttribute(t) || e.setAttribute(t, i);
		}
		_elemIsActive(e) {
			return e.classList.contains(ha);
		}
		_getInnerElement(e) {
			return e.matches(cd) ? e : at.findOne(cd, e);
		}
		_getOuterElement(e) {
			return e.closest(cA) || e;
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = va.getOrCreateInstance(this);
				if (typeof e == "string") {
					if (t[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`);
					t[e]();
				}
			});
		}
	}
	Te.on(document, tA, Uy, function (n) {
		["A", "AREA"].includes(this.tagName) && n.preventDefault(), !Rs(this) && va.getOrCreateInstance(this).show();
	});
	Te.on(window, iA, () => {
		for (const n of at.find(hA)) va.getOrCreateInstance(n);
	});
	ki(va);
	const dA = "toast",
		fA = "bs.toast",
		Is = `.${fA}`,
		pA = `mouseover${Is}`,
		mA = `mouseout${Is}`,
		gA = `focusin${Is}`,
		vA = `focusout${Is}`,
		_A = `hide${Is}`,
		yA = `hidden${Is}`,
		xA = `show${Is}`,
		bA = `shown${Is}`,
		SA = "fade",
		dv = "hide",
		Rc = "show",
		Pc = "showing",
		EA = { animation: "boolean", autohide: "boolean", delay: "number" },
		wA = { animation: !0, autohide: !0, delay: 5e3 };
	class Kl extends ar {
		constructor(e, t) {
			super(e, t), (this._timeout = null), (this._hasMouseInteraction = !1), (this._hasKeyboardInteraction = !1), this._setListeners();
		}
		static get Default() {
			return wA;
		}
		static get DefaultType() {
			return EA;
		}
		static get NAME() {
			return dA;
		}
		show() {
			if (Te.trigger(this._element, xA).defaultPrevented) return;
			this._clearTimeout(), this._config.animation && this._element.classList.add(SA);
			const t = () => {
				this._element.classList.remove(Pc), Te.trigger(this._element, bA), this._maybeScheduleHide();
			};
			this._element.classList.remove(dv), Wl(this._element), this._element.classList.add(Rc, Pc), this._queueCallback(t, this._element, this._config.animation);
		}
		hide() {
			if (!this.isShown() || Te.trigger(this._element, _A).defaultPrevented) return;
			const t = () => {
				this._element.classList.add(dv), this._element.classList.remove(Pc, Rc), Te.trigger(this._element, yA);
			};
			this._element.classList.add(Pc), this._queueCallback(t, this._element, this._config.animation);
		}
		dispose() {
			this._clearTimeout(), this.isShown() && this._element.classList.remove(Rc), super.dispose();
		}
		isShown() {
			return this._element.classList.contains(Rc);
		}
		_maybeScheduleHide() {
			this._config.autohide &&
				(this._hasMouseInteraction ||
					this._hasKeyboardInteraction ||
					(this._timeout = setTimeout(() => {
						this.hide();
					}, this._config.delay)));
		}
		_onInteraction(e, t) {
			switch (e.type) {
				case "mouseover":
				case "mouseout": {
					this._hasMouseInteraction = t;
					break;
				}
				case "focusin":
				case "focusout": {
					this._hasKeyboardInteraction = t;
					break;
				}
			}
			if (t) {
				this._clearTimeout();
				return;
			}
			const i = e.relatedTarget;
			this._element === i || this._element.contains(i) || this._maybeScheduleHide();
		}
		_setListeners() {
			Te.on(this._element, pA, (e) => this._onInteraction(e, !0)), Te.on(this._element, mA, (e) => this._onInteraction(e, !1)), Te.on(this._element, gA, (e) => this._onInteraction(e, !0)), Te.on(this._element, vA, (e) => this._onInteraction(e, !1));
		}
		_clearTimeout() {
			clearTimeout(this._timeout), (this._timeout = null);
		}
		static jQueryInterface(e) {
			return this.each(function () {
				const t = Kl.getOrCreateInstance(this, e);
				if (typeof e == "string") {
					if (typeof t[e] > "u") throw new TypeError(`No method named "${e}"`);
					t[e](this);
				}
			});
		}
	}
	fh(Kl);
	ki(Kl);
	const TA = Object.freeze(Object.defineProperty({ __proto__: null, Alert: $l, Button: ql, Carousel: Xo, Collapse: Fo, Dropdown: tr, Modal: Sr, Offcanvas: Yr, Popover: ph, ScrollSpy: Yl, Tab: va, Toast: Kl, Tooltip: wa }, Symbol.toStringTag, { value: "Module" })),
		MA = "Kirra3D_Database",
		as = { pointCloud: "CSV_PointCloudStore", k3dBlast: "K3D_BlastStore", csvBlast: "CSV_BlastStore", objMesh: "OBJ_MeshStore" };
	function Zl() {
		return new Promise((n, e) => {
			const t = indexedDB.open(MA, 1);
			(t.onupgradeneeded = (i) => {
				const r = i.target.result;
				r.objectStoreNames.contains(as.pointCloud) || (r.createObjectStore(as.pointCloud, { keyPath: "id", autoIncrement: !0 }), console.log("CSV_PointCloudStore created")),
					r.objectStoreNames.contains(as.k3dBlast) || (r.createObjectStore(as.k3dBlast, { keyPath: "id", autoIncrement: !0 }), console.log("K3D_BlastStore created")),
					r.objectStoreNames.contains(as.csvBlast) || (r.createObjectStore(as.csvBlast, { keyPath: "id", autoIncrement: !0 }), console.log("CSV_BlastStore created")),
					r.objectStoreNames.contains(as.objMesh) || (r.createObjectStore(as.objMesh, { keyPath: "id", autoIncrement: !0 }), console.log("OBJ_MeshStore created"));
			}),
				(t.onsuccess = (i) => {
					console.log("Database opened successfully"), n(i.target.result);
				}),
				(t.onerror = (i) => {
					console.error("Database error:", i.target.error), e(i.target.error);
				});
		});
	}
	function Ip(n, e, t) {
		return new Promise((i, r) => {
			const o = n.transaction([e], "readwrite").objectStore(e).add(t);
			(o.onsuccess = () => {
				console.log("Data written successfully to", e), i();
			}),
				(o.onerror = (l) => {
					console.error("Write failed:", l.target.error), r(l.target.error);
				});
		});
	}
	function mh(n, e) {
		return new Promise((t, i) => {
			const a = n.transaction([e], "readonly").objectStore(e).getAll();
			(a.onsuccess = () => {
				console.log("Data read successfully from", e, ":", a.result), t(a.result);
			}),
				(a.onerror = (o) => {
					console.error("Read failed:", o.target.error), i(o.target.error);
				});
		});
	}
	function AA(n, e, t) {
		return new Promise((i, r) => {
			const s = indexedDB.open(n);
			(s.onsuccess = (a) => {
				const u = a.target.result.transaction([e], "readwrite").objectStore(e).delete(t);
				(u.onsuccess = () => {
					console.log("Data deleted successfully from store: " + e), i();
				}),
					(u.onerror = (h) => {
						console.error("Delete failed from store " + e + ": " + h.target.error), r(h.target.error);
					});
			}),
				(s.onerror = (a) => {
					console.error("Failed to open database:", a.target.error), r(a.target.error);
				});
		});
	}
	function CA(n, e) {
		return new Promise((t, i) => {
			const r = indexedDB.open(n);
			(r.onsuccess = (s) => {
				const a = s.target.result;
				if (a.objectStoreNames.contains(e)) {
					const c = a.transaction([e], "readwrite").objectStore(e).clear();
					(c.onsuccess = () => {
						console.log(`All data cleared from ${e}`), t();
					}),
						(c.onerror = (u) => {
							console.error("Failed to clear data from " + e + ": " + u.target.error), i(u.target.error);
						});
				} else console.log("Object store " + e + " does not exist, skipping."), t();
			}),
				(r.onerror = (s) => {
					console.error("Database open failed:", s.target.error), i(s.target.error);
				});
		});
	}
	var Fn = [];
	for (var ud = 0; ud < 256; ++ud) Fn.push((ud + 256).toString(16).slice(1));
	function LA(n, e = 0) {
		return (Fn[n[e + 0]] + Fn[n[e + 1]] + Fn[n[e + 2]] + Fn[n[e + 3]] + "-" + Fn[n[e + 4]] + Fn[n[e + 5]] + "-" + Fn[n[e + 6]] + Fn[n[e + 7]] + "-" + Fn[n[e + 8]] + Fn[n[e + 9]] + "-" + Fn[n[e + 10]] + Fn[n[e + 11]] + Fn[n[e + 12]] + Fn[n[e + 13]] + Fn[n[e + 14]] + Fn[n[e + 15]]).toLowerCase();
	}
	var Dc,
		RA = new Uint8Array(16);
	function PA() {
		if (!Dc && ((Dc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)), !Dc)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
		return Dc(RA);
	}
	var DA = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	const fv = { randomUUID: DA };
	function Fp(n, e, t) {
		if (fv.randomUUID && !e && !n) return fv.randomUUID();
		n = n || {};
		var i = n.random || (n.rng || PA)();
		return (i[6] = (i[6] & 15) | 64), (i[8] = (i[8] & 63) | 128), LA(i);
	}
	function OA(n, e) {
		const t = n.split(`
`);
		let i = [];
		for (let r = 0; r < t.length; r++) {
			const s = t[r].split(",");
			if (s.length === 12) {
				const a = Fp(),
					o = s[0],
					l = s[1],
					c = parseFloat(s[2]),
					u = parseFloat(s[3]),
					h = parseFloat(s[4]),
					d = parseFloat(s[5]),
					f = parseFloat(s[6]),
					v = parseFloat(s[7]),
					_ = parseFloat(s[8]),
					p = parseFloat(s[9]),
					g = s[10].trim().toLowerCase(),
					x = s[11].trim().toLowerCase();
				!isNaN(c) && !isNaN(u) && !isNaN(h) && !isNaN(d) && !isNaN(f) && !isNaN(v) && i.push({ uuid: a, blastName: o, pointID: l, startXLocation: c, startYLocation: u, startZLocation: h, endXLocation: d, endYLocation: f, endZLocation: v, diameter: _, subdrill: p, shapeType: g, holeColour: x });
			}
		}
		return (
			(async () => {
				try {
					const r = await Zl();
					console.log("Database opened successfully. Attempting to write data..."), await Ip(r, e, i), console.log("Data written successfully to " + e);
					const s = await mh(r, e);
					console.log("Data read back from the database:", s);
				} catch (r) {
					console.error("Failed to write or read data from the database:", r);
				}
			})(),
			i
		);
	}
	/**
	 * @license
	 * Copyright 2010-2024 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */ const Np = "167",
		hd = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
		IA = 0,
		pv = 1,
		FA = 2,
		ky = 1,
		NA = 2,
		Br = 3,
		Kr = 0,
		li = 1,
		An = 2,
		ws = 0,
		bo = 1,
		mv = 2,
		gv = 3,
		vv = 4,
		UA = 5,
		aa = 100,
		kA = 101,
		BA = 102,
		zA = 103,
		HA = 104,
		GA = 200,
		VA = 201,
		WA = 202,
		XA = 203,
		xf = 204,
		bf = 205,
		$A = 206,
		qA = 207,
		jA = 208,
		YA = 209,
		KA = 210,
		ZA = 211,
		JA = 212,
		QA = 213,
		eC = 214,
		tC = 0,
		nC = 1,
		iC = 2,
		Wu = 3,
		rC = 4,
		sC = 5,
		aC = 6,
		oC = 7,
		Up = 0,
		lC = 1,
		cC = 2,
		Ts = 0,
		uC = 1,
		hC = 2,
		dC = 3,
		fC = 4,
		pC = 5,
		mC = 6,
		gC = 7,
		By = 300,
		No = 301,
		Uo = 302,
		Sf = 303,
		Ef = 304,
		gh = 306,
		Xu = 1e3,
		da = 1001,
		wf = 1002,
		Di = 1003,
		vC = 1004,
		Oc = 1005,
		Zi = 1006,
		dd = 1007,
		fa = 1008,
		Zr = 1009,
		zy = 1010,
		Hy = 1011,
		Dl = 1012,
		kp = 1013,
		_a = 1014,
		Hr = 1015,
		Jl = 1016,
		Bp = 1017,
		zp = 1018,
		ko = 1020,
		Gy = 35902,
		Vy = 1021,
		Wy = 1022,
		er = 1023,
		Xy = 1024,
		$y = 1025,
		So = 1026,
		Bo = 1027,
		qy = 1028,
		Hp = 1029,
		jy = 1030,
		Gp = 1031,
		Vp = 1033,
		Cu = 33776,
		Lu = 33777,
		Ru = 33778,
		Pu = 33779,
		Tf = 35840,
		Mf = 35841,
		Af = 35842,
		Cf = 35843,
		Lf = 36196,
		Rf = 37492,
		Pf = 37496,
		Df = 37808,
		Of = 37809,
		If = 37810,
		Ff = 37811,
		Nf = 37812,
		Uf = 37813,
		kf = 37814,
		Bf = 37815,
		zf = 37816,
		Hf = 37817,
		Gf = 37818,
		Vf = 37819,
		Wf = 37820,
		Xf = 37821,
		Du = 36492,
		$f = 36494,
		qf = 36495,
		Yy = 36283,
		jf = 36284,
		Yf = 36285,
		Kf = 36286,
		_C = 3200,
		yC = 3201,
		Ky = 0,
		xC = 1,
		xs = "",
		ni = "srgb",
		Fs = "srgb-linear",
		Wp = "display-p3",
		vh = "display-p3-linear",
		$u = "linear",
		nn = "srgb",
		qu = "rec709",
		ju = "p3",
		Ba = 7680,
		_v = 519,
		bC = 512,
		SC = 513,
		EC = 514,
		Zy = 515,
		wC = 516,
		TC = 517,
		MC = 518,
		AC = 519,
		Zf = 35044,
		yv = "300 es",
		Gr = 2e3,
		Yu = 2001;
	class Ns {
		addEventListener(e, t) {
			this._listeners === void 0 && (this._listeners = {});
			const i = this._listeners;
			i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
		}
		hasEventListener(e, t) {
			if (this._listeners === void 0) return !1;
			const i = this._listeners;
			return i[e] !== void 0 && i[e].indexOf(t) !== -1;
		}
		removeEventListener(e, t) {
			if (this._listeners === void 0) return;
			const r = this._listeners[e];
			if (r !== void 0) {
				const s = r.indexOf(t);
				s !== -1 && r.splice(s, 1);
			}
		}
		dispatchEvent(e) {
			if (this._listeners === void 0) return;
			const i = this._listeners[e.type];
			if (i !== void 0) {
				e.target = this;
				const r = i.slice(0);
				for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
				e.target = null;
			}
		}
	}
	const Wn = [
		"00",
		"01",
		"02",
		"03",
		"04",
		"05",
		"06",
		"07",
		"08",
		"09",
		"0a",
		"0b",
		"0c",
		"0d",
		"0e",
		"0f",
		"10",
		"11",
		"12",
		"13",
		"14",
		"15",
		"16",
		"17",
		"18",
		"19",
		"1a",
		"1b",
		"1c",
		"1d",
		"1e",
		"1f",
		"20",
		"21",
		"22",
		"23",
		"24",
		"25",
		"26",
		"27",
		"28",
		"29",
		"2a",
		"2b",
		"2c",
		"2d",
		"2e",
		"2f",
		"30",
		"31",
		"32",
		"33",
		"34",
		"35",
		"36",
		"37",
		"38",
		"39",
		"3a",
		"3b",
		"3c",
		"3d",
		"3e",
		"3f",
		"40",
		"41",
		"42",
		"43",
		"44",
		"45",
		"46",
		"47",
		"48",
		"49",
		"4a",
		"4b",
		"4c",
		"4d",
		"4e",
		"4f",
		"50",
		"51",
		"52",
		"53",
		"54",
		"55",
		"56",
		"57",
		"58",
		"59",
		"5a",
		"5b",
		"5c",
		"5d",
		"5e",
		"5f",
		"60",
		"61",
		"62",
		"63",
		"64",
		"65",
		"66",
		"67",
		"68",
		"69",
		"6a",
		"6b",
		"6c",
		"6d",
		"6e",
		"6f",
		"70",
		"71",
		"72",
		"73",
		"74",
		"75",
		"76",
		"77",
		"78",
		"79",
		"7a",
		"7b",
		"7c",
		"7d",
		"7e",
		"7f",
		"80",
		"81",
		"82",
		"83",
		"84",
		"85",
		"86",
		"87",
		"88",
		"89",
		"8a",
		"8b",
		"8c",
		"8d",
		"8e",
		"8f",
		"90",
		"91",
		"92",
		"93",
		"94",
		"95",
		"96",
		"97",
		"98",
		"99",
		"9a",
		"9b",
		"9c",
		"9d",
		"9e",
		"9f",
		"a0",
		"a1",
		"a2",
		"a3",
		"a4",
		"a5",
		"a6",
		"a7",
		"a8",
		"a9",
		"aa",
		"ab",
		"ac",
		"ad",
		"ae",
		"af",
		"b0",
		"b1",
		"b2",
		"b3",
		"b4",
		"b5",
		"b6",
		"b7",
		"b8",
		"b9",
		"ba",
		"bb",
		"bc",
		"bd",
		"be",
		"bf",
		"c0",
		"c1",
		"c2",
		"c3",
		"c4",
		"c5",
		"c6",
		"c7",
		"c8",
		"c9",
		"ca",
		"cb",
		"cc",
		"cd",
		"ce",
		"cf",
		"d0",
		"d1",
		"d2",
		"d3",
		"d4",
		"d5",
		"d6",
		"d7",
		"d8",
		"d9",
		"da",
		"db",
		"dc",
		"dd",
		"de",
		"df",
		"e0",
		"e1",
		"e2",
		"e3",
		"e4",
		"e5",
		"e6",
		"e7",
		"e8",
		"e9",
		"ea",
		"eb",
		"ec",
		"ed",
		"ee",
		"ef",
		"f0",
		"f1",
		"f2",
		"f3",
		"f4",
		"f5",
		"f6",
		"f7",
		"f8",
		"f9",
		"fa",
		"fb",
		"fc",
		"fd",
		"fe",
		"ff"
	];
	let xv = 1234567;
	const Ml = Math.PI / 180,
		Ol = 180 / Math.PI;
	function yr() {
		const n = (Math.random() * 4294967295) | 0,
			e = (Math.random() * 4294967295) | 0,
			t = (Math.random() * 4294967295) | 0,
			i = (Math.random() * 4294967295) | 0;
		return (Wn[n & 255] + Wn[(n >> 8) & 255] + Wn[(n >> 16) & 255] + Wn[(n >> 24) & 255] + "-" + Wn[e & 255] + Wn[(e >> 8) & 255] + "-" + Wn[((e >> 16) & 15) | 64] + Wn[(e >> 24) & 255] + "-" + Wn[(t & 63) | 128] + Wn[(t >> 8) & 255] + "-" + Wn[(t >> 16) & 255] + Wn[(t >> 24) & 255] + Wn[i & 255] + Wn[(i >> 8) & 255] + Wn[(i >> 16) & 255] + Wn[(i >> 24) & 255]).toLowerCase();
	}
	function Nn(n, e, t) {
		return Math.max(e, Math.min(t, n));
	}
	function Xp(n, e) {
		return ((n % e) + e) % e;
	}
	function CC(n, e, t, i, r) {
		return i + ((n - e) * (r - i)) / (t - e);
	}
	function LC(n, e, t) {
		return n !== e ? (t - n) / (e - n) : 0;
	}
	function Al(n, e, t) {
		return (1 - t) * n + t * e;
	}
	function RC(n, e, t, i) {
		return Al(n, e, 1 - Math.exp(-t * i));
	}
	function PC(n, e = 1) {
		return e - Math.abs(Xp(n, e * 2) - e);
	}
	function DC(n, e, t) {
		return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
	}
	function OC(n, e, t) {
		return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
	}
	function IC(n, e) {
		return n + Math.floor(Math.random() * (e - n + 1));
	}
	function FC(n, e) {
		return n + Math.random() * (e - n);
	}
	function NC(n) {
		return n * (0.5 - Math.random());
	}
	function UC(n) {
		n !== void 0 && (xv = n);
		let e = (xv += 1831565813);
		return (e = Math.imul(e ^ (e >>> 15), e | 1)), (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)), ((e ^ (e >>> 14)) >>> 0) / 4294967296;
	}
	function kC(n) {
		return n * Ml;
	}
	function BC(n) {
		return n * Ol;
	}
	function zC(n) {
		return (n & (n - 1)) === 0 && n !== 0;
	}
	function HC(n) {
		return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
	}
	function GC(n) {
		return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
	}
	function VC(n, e, t, i, r) {
		const s = Math.cos,
			a = Math.sin,
			o = s(t / 2),
			l = a(t / 2),
			c = s((e + i) / 2),
			u = a((e + i) / 2),
			h = s((e - i) / 2),
			d = a((e - i) / 2),
			f = s((i - e) / 2),
			v = a((i - e) / 2);
		switch (r) {
			case "XYX":
				n.set(o * u, l * h, l * d, o * c);
				break;
			case "YZY":
				n.set(l * d, o * u, l * h, o * c);
				break;
			case "ZXZ":
				n.set(l * h, l * d, o * u, o * c);
				break;
			case "XZX":
				n.set(o * u, l * v, l * f, o * c);
				break;
			case "YXY":
				n.set(l * f, o * u, l * v, o * c);
				break;
			case "ZYZ":
				n.set(l * v, l * f, o * u, o * c);
				break;
			default:
				console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
		}
	}
	function Ji(n, e) {
		switch (e.constructor) {
			case Float32Array:
				return n;
			case Uint32Array:
				return n / 4294967295;
			case Uint16Array:
				return n / 65535;
			case Uint8Array:
				return n / 255;
			case Int32Array:
				return Math.max(n / 2147483647, -1);
			case Int16Array:
				return Math.max(n / 32767, -1);
			case Int8Array:
				return Math.max(n / 127, -1);
			default:
				throw new Error("Invalid component type.");
		}
	}
	function Vt(n, e) {
		switch (e.constructor) {
			case Float32Array:
				return n;
			case Uint32Array:
				return Math.round(n * 4294967295);
			case Uint16Array:
				return Math.round(n * 65535);
			case Uint8Array:
				return Math.round(n * 255);
			case Int32Array:
				return Math.round(n * 2147483647);
			case Int16Array:
				return Math.round(n * 32767);
			case Int8Array:
				return Math.round(n * 127);
			default:
				throw new Error("Invalid component type.");
		}
	}
	const an = { DEG2RAD: Ml, RAD2DEG: Ol, generateUUID: yr, clamp: Nn, euclideanModulo: Xp, mapLinear: CC, inverseLerp: LC, lerp: Al, damp: RC, pingpong: PC, smoothstep: DC, smootherstep: OC, randInt: IC, randFloat: FC, randFloatSpread: NC, seededRandom: UC, degToRad: kC, radToDeg: BC, isPowerOfTwo: zC, ceilPowerOfTwo: HC, floorPowerOfTwo: GC, setQuaternionFromProperEuler: VC, normalize: Vt, denormalize: Ji };
	class Se {
		constructor(e = 0, t = 0) {
			(Se.prototype.isVector2 = !0), (this.x = e), (this.y = t);
		}
		get width() {
			return this.x;
		}
		set width(e) {
			this.x = e;
		}
		get height() {
			return this.y;
		}
		set height(e) {
			this.y = e;
		}
		set(e, t) {
			return (this.x = e), (this.y = t), this;
		}
		setScalar(e) {
			return (this.x = e), (this.y = e), this;
		}
		setX(e) {
			return (this.x = e), this;
		}
		setY(e) {
			return (this.y = e), this;
		}
		setComponent(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				default:
					throw new Error("index is out of range: " + e);
			}
			return this;
		}
		getComponent(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw new Error("index is out of range: " + e);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y);
		}
		copy(e) {
			return (this.x = e.x), (this.y = e.y), this;
		}
		add(e) {
			return (this.x += e.x), (this.y += e.y), this;
		}
		addScalar(e) {
			return (this.x += e), (this.y += e), this;
		}
		addVectors(e, t) {
			return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
		}
		addScaledVector(e, t) {
			return (this.x += e.x * t), (this.y += e.y * t), this;
		}
		sub(e) {
			return (this.x -= e.x), (this.y -= e.y), this;
		}
		subScalar(e) {
			return (this.x -= e), (this.y -= e), this;
		}
		subVectors(e, t) {
			return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
		}
		multiply(e) {
			return (this.x *= e.x), (this.y *= e.y), this;
		}
		multiplyScalar(e) {
			return (this.x *= e), (this.y *= e), this;
		}
		divide(e) {
			return (this.x /= e.x), (this.y /= e.y), this;
		}
		divideScalar(e) {
			return this.multiplyScalar(1 / e);
		}
		applyMatrix3(e) {
			const t = this.x,
				i = this.y,
				r = e.elements;
			return (this.x = r[0] * t + r[3] * i + r[6]), (this.y = r[1] * t + r[4] * i + r[7]), this;
		}
		min(e) {
			return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
		}
		max(e) {
			return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
		}
		clamp(e, t) {
			return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), this;
		}
		clampScalar(e, t) {
			return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), this;
		}
		clampLength(e, t) {
			const i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
		}
		floor() {
			return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
		}
		ceil() {
			return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
		}
		round() {
			return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
		}
		roundToZero() {
			return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
		}
		negate() {
			return (this.x = -this.x), (this.y = -this.y), this;
		}
		dot(e) {
			return this.x * e.x + this.y * e.y;
		}
		cross(e) {
			return this.x * e.y - this.y * e.x;
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		angle() {
			return Math.atan2(-this.y, -this.x) + Math.PI;
		}
		angleTo(e) {
			const t = Math.sqrt(this.lengthSq() * e.lengthSq());
			if (t === 0) return Math.PI / 2;
			const i = this.dot(e) / t;
			return Math.acos(Nn(i, -1, 1));
		}
		distanceTo(e) {
			return Math.sqrt(this.distanceToSquared(e));
		}
		distanceToSquared(e) {
			const t = this.x - e.x,
				i = this.y - e.y;
			return t * t + i * i;
		}
		manhattanDistanceTo(e) {
			return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
		}
		setLength(e) {
			return this.normalize().multiplyScalar(e);
		}
		lerp(e, t) {
			return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
		}
		lerpVectors(e, t, i) {
			return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this;
		}
		equals(e) {
			return e.x === this.x && e.y === this.y;
		}
		fromArray(e, t = 0) {
			return (this.x = e[t]), (this.y = e[t + 1]), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this.x), (e[t + 1] = this.y), e;
		}
		fromBufferAttribute(e, t) {
			return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
		}
		rotateAround(e, t) {
			const i = Math.cos(t),
				r = Math.sin(t),
				s = this.x - e.x,
				a = this.y - e.y;
			return (this.x = s * i - a * r + e.x), (this.y = s * r + a * i + e.y), this;
		}
		random() {
			return (this.x = Math.random()), (this.y = Math.random()), this;
		}
		*[Symbol.iterator]() {
			yield this.x, yield this.y;
		}
	}
	class wt {
		constructor(e, t, i, r, s, a, o, l, c) {
			(wt.prototype.isMatrix3 = !0), (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]), e !== void 0 && this.set(e, t, i, r, s, a, o, l, c);
		}
		set(e, t, i, r, s, a, o, l, c) {
			const u = this.elements;
			return (u[0] = e), (u[1] = r), (u[2] = o), (u[3] = t), (u[4] = s), (u[5] = l), (u[6] = i), (u[7] = a), (u[8] = c), this;
		}
		identity() {
			return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
		}
		copy(e) {
			const t = this.elements,
				i = e.elements;
			return (t[0] = i[0]), (t[1] = i[1]), (t[2] = i[2]), (t[3] = i[3]), (t[4] = i[4]), (t[5] = i[5]), (t[6] = i[6]), (t[7] = i[7]), (t[8] = i[8]), this;
		}
		extractBasis(e, t, i) {
			return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
		}
		setFromMatrix4(e) {
			const t = e.elements;
			return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
		}
		multiply(e) {
			return this.multiplyMatrices(this, e);
		}
		premultiply(e) {
			return this.multiplyMatrices(e, this);
		}
		multiplyMatrices(e, t) {
			const i = e.elements,
				r = t.elements,
				s = this.elements,
				a = i[0],
				o = i[3],
				l = i[6],
				c = i[1],
				u = i[4],
				h = i[7],
				d = i[2],
				f = i[5],
				v = i[8],
				_ = r[0],
				p = r[3],
				g = r[6],
				x = r[1],
				b = r[4],
				T = r[7],
				P = r[2],
				A = r[5],
				M = r[8];
			return (s[0] = a * _ + o * x + l * P), (s[3] = a * p + o * b + l * A), (s[6] = a * g + o * T + l * M), (s[1] = c * _ + u * x + h * P), (s[4] = c * p + u * b + h * A), (s[7] = c * g + u * T + h * M), (s[2] = d * _ + f * x + v * P), (s[5] = d * p + f * b + v * A), (s[8] = d * g + f * T + v * M), this;
		}
		multiplyScalar(e) {
			const t = this.elements;
			return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
		}
		determinant() {
			const e = this.elements,
				t = e[0],
				i = e[1],
				r = e[2],
				s = e[3],
				a = e[4],
				o = e[5],
				l = e[6],
				c = e[7],
				u = e[8];
			return t * a * u - t * o * c - i * s * u + i * o * l + r * s * c - r * a * l;
		}
		invert() {
			const e = this.elements,
				t = e[0],
				i = e[1],
				r = e[2],
				s = e[3],
				a = e[4],
				o = e[5],
				l = e[6],
				c = e[7],
				u = e[8],
				h = u * a - o * c,
				d = o * l - u * s,
				f = c * s - a * l,
				v = t * h + i * d + r * f;
			if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const _ = 1 / v;
			return (e[0] = h * _), (e[1] = (r * c - u * i) * _), (e[2] = (o * i - r * a) * _), (e[3] = d * _), (e[4] = (u * t - r * l) * _), (e[5] = (r * s - o * t) * _), (e[6] = f * _), (e[7] = (i * l - c * t) * _), (e[8] = (a * t - i * s) * _), this;
		}
		transpose() {
			let e;
			const t = this.elements;
			return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
		}
		getNormalMatrix(e) {
			return this.setFromMatrix4(e).invert().transpose();
		}
		transposeIntoArray(e) {
			const t = this.elements;
			return (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]), this;
		}
		setUvTransform(e, t, i, r, s, a, o) {
			const l = Math.cos(s),
				c = Math.sin(s);
			return this.set(i * l, i * c, -i * (l * a + c * o) + a + e, -r * c, r * l, -r * (-c * a + l * o) + o + t, 0, 0, 1), this;
		}
		scale(e, t) {
			return this.premultiply(fd.makeScale(e, t)), this;
		}
		rotate(e) {
			return this.premultiply(fd.makeRotation(-e)), this;
		}
		translate(e, t) {
			return this.premultiply(fd.makeTranslation(e, t)), this;
		}
		makeTranslation(e, t) {
			return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
		}
		makeRotation(e) {
			const t = Math.cos(e),
				i = Math.sin(e);
			return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
		}
		makeScale(e, t) {
			return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
		}
		equals(e) {
			const t = this.elements,
				i = e.elements;
			for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
			return !0;
		}
		fromArray(e, t = 0) {
			for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
			return this;
		}
		toArray(e = [], t = 0) {
			const i = this.elements;
			return (e[t] = i[0]), (e[t + 1] = i[1]), (e[t + 2] = i[2]), (e[t + 3] = i[3]), (e[t + 4] = i[4]), (e[t + 5] = i[5]), (e[t + 6] = i[6]), (e[t + 7] = i[7]), (e[t + 8] = i[8]), e;
		}
		clone() {
			return new this.constructor().fromArray(this.elements);
		}
	}
	const fd = new wt();
	function Jy(n) {
		for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
		return !1;
	}
	function Il(n) {
		return document.createElementNS("http://www.w3.org/1999/xhtml", n);
	}
	function WC() {
		const n = Il("canvas");
		return (n.style.display = "block"), n;
	}
	const bv = {};
	function Eo(n) {
		n in bv || ((bv[n] = !0), console.warn(n));
	}
	function XC(n, e, t) {
		return new Promise(function (i, r) {
			function s() {
				switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
					case n.WAIT_FAILED:
						r();
						break;
					case n.TIMEOUT_EXPIRED:
						setTimeout(s, t);
						break;
					default:
						i();
				}
			}
			setTimeout(s, t);
		});
	}
	const Sv = new wt().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199),
		Ev = new wt().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735),
		al = {
			[Fs]: { transfer: $u, primaries: qu, luminanceCoefficients: [0.2126, 0.7152, 0.0722], toReference: (n) => n, fromReference: (n) => n },
			[ni]: { transfer: nn, primaries: qu, luminanceCoefficients: [0.2126, 0.7152, 0.0722], toReference: (n) => n.convertSRGBToLinear(), fromReference: (n) => n.convertLinearToSRGB() },
			[vh]: { transfer: $u, primaries: ju, luminanceCoefficients: [0.2289, 0.6917, 0.0793], toReference: (n) => n.applyMatrix3(Ev), fromReference: (n) => n.applyMatrix3(Sv) },
			[Wp]: { transfer: nn, primaries: ju, luminanceCoefficients: [0.2289, 0.6917, 0.0793], toReference: (n) => n.convertSRGBToLinear().applyMatrix3(Ev), fromReference: (n) => n.applyMatrix3(Sv).convertLinearToSRGB() }
		},
		$C = new Set([Fs, vh]),
		zt = {
			enabled: !0,
			_workingColorSpace: Fs,
			get workingColorSpace() {
				return this._workingColorSpace;
			},
			set workingColorSpace(n) {
				if (!$C.has(n)) throw new Error(`Unsupported working color space, "${n}".`);
				this._workingColorSpace = n;
			},
			convert: function (n, e, t) {
				if (this.enabled === !1 || e === t || !e || !t) return n;
				const i = al[e].toReference,
					r = al[t].fromReference;
				return r(i(n));
			},
			fromWorkingColorSpace: function (n, e) {
				return this.convert(n, this._workingColorSpace, e);
			},
			toWorkingColorSpace: function (n, e) {
				return this.convert(n, e, this._workingColorSpace);
			},
			getPrimaries: function (n) {
				return al[n].primaries;
			},
			getTransfer: function (n) {
				return n === xs ? $u : al[n].transfer;
			},
			getLuminanceCoefficients: function (n, e = this._workingColorSpace) {
				return n.fromArray(al[e].luminanceCoefficients);
			}
		};
	function wo(n) {
		return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
	}
	function pd(n) {
		return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
	}
	let za;
	class qC {
		static getDataURL(e) {
			if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
			let t;
			if (e instanceof HTMLCanvasElement) t = e;
			else {
				za === void 0 && (za = Il("canvas")), (za.width = e.width), (za.height = e.height);
				const i = za.getContext("2d");
				e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), (t = za);
			}
			return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
		}
		static sRGBToLinear(e) {
			if ((typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) || (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) || (typeof ImageBitmap < "u" && e instanceof ImageBitmap)) {
				const t = Il("canvas");
				(t.width = e.width), (t.height = e.height);
				const i = t.getContext("2d");
				i.drawImage(e, 0, 0, e.width, e.height);
				const r = i.getImageData(0, 0, e.width, e.height),
					s = r.data;
				for (let a = 0; a < s.length; a++) s[a] = wo(s[a] / 255) * 255;
				return i.putImageData(r, 0, 0), t;
			} else if (e.data) {
				const t = e.data.slice(0);
				for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? (t[i] = Math.floor(wo(t[i] / 255) * 255)) : (t[i] = wo(t[i]));
				return { data: t, width: e.width, height: e.height };
			} else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
		}
	}
	let jC = 0;
	class Qy {
		constructor(e = null) {
			(this.isSource = !0), Object.defineProperty(this, "id", { value: jC++ }), (this.uuid = yr()), (this.data = e), (this.dataReady = !0), (this.version = 0);
		}
		set needsUpdate(e) {
			e === !0 && this.version++;
		}
		toJSON(e) {
			const t = e === void 0 || typeof e == "string";
			if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
			const i = { uuid: this.uuid, url: "" },
				r = this.data;
			if (r !== null) {
				let s;
				if (Array.isArray(r)) {
					s = [];
					for (let a = 0, o = r.length; a < o; a++) r[a].isDataTexture ? s.push(md(r[a].image)) : s.push(md(r[a]));
				} else s = md(r);
				i.url = s;
			}
			return t || (e.images[this.uuid] = i), i;
		}
	}
	function md(n) {
		return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) || (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) || (typeof ImageBitmap < "u" && n instanceof ImageBitmap) ? qC.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
	}
	let YC = 0;
	class jn extends Ns {
		constructor(e = jn.DEFAULT_IMAGE, t = jn.DEFAULT_MAPPING, i = da, r = da, s = Zi, a = fa, o = er, l = Zr, c = jn.DEFAULT_ANISOTROPY, u = xs) {
			super(),
				(this.isTexture = !0),
				Object.defineProperty(this, "id", { value: YC++ }),
				(this.uuid = yr()),
				(this.name = ""),
				(this.source = new Qy(e)),
				(this.mipmaps = []),
				(this.mapping = t),
				(this.channel = 0),
				(this.wrapS = i),
				(this.wrapT = r),
				(this.magFilter = s),
				(this.minFilter = a),
				(this.anisotropy = c),
				(this.format = o),
				(this.internalFormat = null),
				(this.type = l),
				(this.offset = new Se(0, 0)),
				(this.repeat = new Se(1, 1)),
				(this.center = new Se(0, 0)),
				(this.rotation = 0),
				(this.matrixAutoUpdate = !0),
				(this.matrix = new wt()),
				(this.generateMipmaps = !0),
				(this.premultiplyAlpha = !1),
				(this.flipY = !0),
				(this.unpackAlignment = 4),
				(this.colorSpace = u),
				(this.userData = {}),
				(this.version = 0),
				(this.onUpdate = null),
				(this.isRenderTargetTexture = !1),
				(this.pmremVersion = 0);
		}
		get image() {
			return this.source.data;
		}
		set image(e = null) {
			this.source.data = e;
		}
		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			return (
				(this.name = e.name),
				(this.source = e.source),
				(this.mipmaps = e.mipmaps.slice(0)),
				(this.mapping = e.mapping),
				(this.channel = e.channel),
				(this.wrapS = e.wrapS),
				(this.wrapT = e.wrapT),
				(this.magFilter = e.magFilter),
				(this.minFilter = e.minFilter),
				(this.anisotropy = e.anisotropy),
				(this.format = e.format),
				(this.internalFormat = e.internalFormat),
				(this.type = e.type),
				this.offset.copy(e.offset),
				this.repeat.copy(e.repeat),
				this.center.copy(e.center),
				(this.rotation = e.rotation),
				(this.matrixAutoUpdate = e.matrixAutoUpdate),
				this.matrix.copy(e.matrix),
				(this.generateMipmaps = e.generateMipmaps),
				(this.premultiplyAlpha = e.premultiplyAlpha),
				(this.flipY = e.flipY),
				(this.unpackAlignment = e.unpackAlignment),
				(this.colorSpace = e.colorSpace),
				(this.userData = JSON.parse(JSON.stringify(e.userData))),
				(this.needsUpdate = !0),
				this
			);
		}
		toJSON(e) {
			const t = e === void 0 || typeof e == "string";
			if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
			const i = {
				metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
				uuid: this.uuid,
				name: this.name,
				image: this.source.toJSON(e).uuid,
				mapping: this.mapping,
				channel: this.channel,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				internalFormat: this.internalFormat,
				type: this.type,
				colorSpace: this.colorSpace,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				generateMipmaps: this.generateMipmaps,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};
			return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
		}
		dispose() {
			this.dispatchEvent({ type: "dispose" });
		}
		transformUv(e) {
			if (this.mapping !== By) return e;
			if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
				switch (this.wrapS) {
					case Xu:
						e.x = e.x - Math.floor(e.x);
						break;
					case da:
						e.x = e.x < 0 ? 0 : 1;
						break;
					case wf:
						Math.abs(Math.floor(e.x) % 2) === 1 ? (e.x = Math.ceil(e.x) - e.x) : (e.x = e.x - Math.floor(e.x));
						break;
				}
			if (e.y < 0 || e.y > 1)
				switch (this.wrapT) {
					case Xu:
						e.y = e.y - Math.floor(e.y);
						break;
					case da:
						e.y = e.y < 0 ? 0 : 1;
						break;
					case wf:
						Math.abs(Math.floor(e.y) % 2) === 1 ? (e.y = Math.ceil(e.y) - e.y) : (e.y = e.y - Math.floor(e.y));
						break;
				}
			return this.flipY && (e.y = 1 - e.y), e;
		}
		set needsUpdate(e) {
			e === !0 && (this.version++, (this.source.needsUpdate = !0));
		}
		set needsPMREMUpdate(e) {
			e === !0 && this.pmremVersion++;
		}
	}
	jn.DEFAULT_IMAGE = null;
	jn.DEFAULT_MAPPING = By;
	jn.DEFAULT_ANISOTROPY = 1;
	class wn {
		constructor(e = 0, t = 0, i = 0, r = 1) {
			(wn.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = i), (this.w = r);
		}
		get width() {
			return this.z;
		}
		set width(e) {
			this.z = e;
		}
		get height() {
			return this.w;
		}
		set height(e) {
			this.w = e;
		}
		set(e, t, i, r) {
			return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
		}
		setScalar(e) {
			return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
		}
		setX(e) {
			return (this.x = e), this;
		}
		setY(e) {
			return (this.y = e), this;
		}
		setZ(e) {
			return (this.z = e), this;
		}
		setW(e) {
			return (this.w = e), this;
		}
		setComponent(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				case 3:
					this.w = t;
					break;
				default:
					throw new Error("index is out of range: " + e);
			}
			return this;
		}
		getComponent(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw new Error("index is out of range: " + e);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}
		copy(e) {
			return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== void 0 ? e.w : 1), this;
		}
		add(e) {
			return (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this;
		}
		addScalar(e) {
			return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
		}
		addVectors(e, t) {
			return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
		}
		addScaledVector(e, t) {
			return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
		}
		sub(e) {
			return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this;
		}
		subScalar(e) {
			return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
		}
		subVectors(e, t) {
			return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
		}
		multiply(e) {
			return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
		}
		multiplyScalar(e) {
			return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
		}
		applyMatrix4(e) {
			const t = this.x,
				i = this.y,
				r = this.z,
				s = this.w,
				a = e.elements;
			return (this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s), (this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s), (this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s), (this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s), this;
		}
		divideScalar(e) {
			return this.multiplyScalar(1 / e);
		}
		setAxisAngleFromQuaternion(e) {
			this.w = 2 * Math.acos(e.w);
			const t = Math.sqrt(1 - e.w * e.w);
			return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
		}
		setAxisAngleFromRotationMatrix(e) {
			let t, i, r, s;
			const l = e.elements,
				c = l[0],
				u = l[4],
				h = l[8],
				d = l[1],
				f = l[5],
				v = l[9],
				_ = l[2],
				p = l[6],
				g = l[10];
			if (Math.abs(u - d) < 0.01 && Math.abs(h - _) < 0.01 && Math.abs(v - p) < 0.01) {
				if (Math.abs(u + d) < 0.1 && Math.abs(h + _) < 0.1 && Math.abs(v + p) < 0.1 && Math.abs(c + f + g - 3) < 0.1) return this.set(1, 0, 0, 0), this;
				t = Math.PI;
				const b = (c + 1) / 2,
					T = (f + 1) / 2,
					P = (g + 1) / 2,
					A = (u + d) / 4,
					M = (h + _) / 4,
					w = (v + p) / 4;
				return b > T && b > P ? (b < 0.01 ? ((i = 0), (r = 0.707106781), (s = 0.707106781)) : ((i = Math.sqrt(b)), (r = A / i), (s = M / i))) : T > P ? (T < 0.01 ? ((i = 0.707106781), (r = 0), (s = 0.707106781)) : ((r = Math.sqrt(T)), (i = A / r), (s = w / r))) : P < 0.01 ? ((i = 0.707106781), (r = 0.707106781), (s = 0)) : ((s = Math.sqrt(P)), (i = M / s), (r = w / s)), this.set(i, r, s, t), this;
			}
			let x = Math.sqrt((p - v) * (p - v) + (h - _) * (h - _) + (d - u) * (d - u));
			return Math.abs(x) < 0.001 && (x = 1), (this.x = (p - v) / x), (this.y = (h - _) / x), (this.z = (d - u) / x), (this.w = Math.acos((c + f + g - 1) / 2)), this;
		}
		setFromMatrixPosition(e) {
			const t = e.elements;
			return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), (this.w = t[15]), this;
		}
		min(e) {
			return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), (this.w = Math.min(this.w, e.w)), this;
		}
		max(e) {
			return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), (this.w = Math.max(this.w, e.w)), this;
		}
		clamp(e, t) {
			return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), (this.z = Math.max(e.z, Math.min(t.z, this.z))), (this.w = Math.max(e.w, Math.min(t.w, this.w))), this;
		}
		clampScalar(e, t) {
			return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), (this.z = Math.max(e, Math.min(t, this.z))), (this.w = Math.max(e, Math.min(t, this.w))), this;
		}
		clampLength(e, t) {
			const i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
		}
		floor() {
			return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this;
		}
		ceil() {
			return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
		}
		round() {
			return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this;
		}
		roundToZero() {
			return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), (this.w = Math.trunc(this.w)), this;
		}
		negate() {
			return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
		}
		dot(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		setLength(e) {
			return this.normalize().multiplyScalar(e);
		}
		lerp(e, t) {
			return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), (this.w += (e.w - this.w) * t), this;
		}
		lerpVectors(e, t, i) {
			return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), (this.z = e.z + (t.z - e.z) * i), (this.w = e.w + (t.w - e.w) * i), this;
		}
		equals(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
		}
		fromArray(e, t = 0) {
			return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
		}
		fromBufferAttribute(e, t) {
			return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this;
		}
		random() {
			return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this;
		}
		*[Symbol.iterator]() {
			yield this.x, yield this.y, yield this.z, yield this.w;
		}
	}
	class KC extends Ns {
		constructor(e = 1, t = 1, i = {}) {
			super(), (this.isRenderTarget = !0), (this.width = e), (this.height = t), (this.depth = 1), (this.scissor = new wn(0, 0, e, t)), (this.scissorTest = !1), (this.viewport = new wn(0, 0, e, t));
			const r = { width: e, height: t, depth: 1 };
			i = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: Zi, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, i);
			const s = new jn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
			(s.flipY = !1), (s.generateMipmaps = i.generateMipmaps), (s.internalFormat = i.internalFormat), (this.textures = []);
			const a = i.count;
			for (let o = 0; o < a; o++) (this.textures[o] = s.clone()), (this.textures[o].isRenderTargetTexture = !0);
			(this.depthBuffer = i.depthBuffer), (this.stencilBuffer = i.stencilBuffer), (this.resolveDepthBuffer = i.resolveDepthBuffer), (this.resolveStencilBuffer = i.resolveStencilBuffer), (this.depthTexture = i.depthTexture), (this.samples = i.samples);
		}
		get texture() {
			return this.textures[0];
		}
		set texture(e) {
			this.textures[0] = e;
		}
		setSize(e, t, i = 1) {
			if (this.width !== e || this.height !== t || this.depth !== i) {
				(this.width = e), (this.height = t), (this.depth = i);
				for (let r = 0, s = this.textures.length; r < s; r++) (this.textures[r].image.width = e), (this.textures[r].image.height = t), (this.textures[r].image.depth = i);
				this.dispose();
			}
			this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			(this.width = e.width), (this.height = e.height), (this.depth = e.depth), this.scissor.copy(e.scissor), (this.scissorTest = e.scissorTest), this.viewport.copy(e.viewport), (this.textures.length = 0);
			for (let i = 0, r = e.textures.length; i < r; i++) (this.textures[i] = e.textures[i].clone()), (this.textures[i].isRenderTargetTexture = !0);
			const t = Object.assign({}, e.texture.image);
			return (this.texture.source = new Qy(t)), (this.depthBuffer = e.depthBuffer), (this.stencilBuffer = e.stencilBuffer), (this.resolveDepthBuffer = e.resolveDepthBuffer), (this.resolveStencilBuffer = e.resolveStencilBuffer), e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), (this.samples = e.samples), this;
		}
		dispose() {
			this.dispatchEvent({ type: "dispose" });
		}
	}
	class ya extends KC {
		constructor(e = 1, t = 1, i = {}) {
			super(e, t, i), (this.isWebGLRenderTarget = !0);
		}
	}
	class ex extends jn {
		constructor(e = null, t = 1, i = 1, r = 1) {
			super(null), (this.isDataArrayTexture = !0), (this.image = { data: e, width: t, height: i, depth: r }), (this.magFilter = Di), (this.minFilter = Di), (this.wrapR = da), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.layerUpdates = new Set());
		}
		addLayerUpdate(e) {
			this.layerUpdates.add(e);
		}
		clearLayerUpdates() {
			this.layerUpdates.clear();
		}
	}
	class ZC extends jn {
		constructor(e = null, t = 1, i = 1, r = 1) {
			super(null), (this.isData3DTexture = !0), (this.image = { data: e, width: t, height: i, depth: r }), (this.magFilter = Di), (this.minFilter = Di), (this.wrapR = da), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1);
		}
	}
	class En {
		constructor(e = 0, t = 0, i = 0, r = 1) {
			(this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = i), (this._w = r);
		}
		static slerpFlat(e, t, i, r, s, a, o) {
			let l = i[r + 0],
				c = i[r + 1],
				u = i[r + 2],
				h = i[r + 3];
			const d = s[a + 0],
				f = s[a + 1],
				v = s[a + 2],
				_ = s[a + 3];
			if (o === 0) {
				(e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
				return;
			}
			if (o === 1) {
				(e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = v), (e[t + 3] = _);
				return;
			}
			if (h !== _ || l !== d || c !== f || u !== v) {
				let p = 1 - o;
				const g = l * d + c * f + u * v + h * _,
					x = g >= 0 ? 1 : -1,
					b = 1 - g * g;
				if (b > Number.EPSILON) {
					const P = Math.sqrt(b),
						A = Math.atan2(P, g * x);
					(p = Math.sin(p * A) / P), (o = Math.sin(o * A) / P);
				}
				const T = o * x;
				if (((l = l * p + d * T), (c = c * p + f * T), (u = u * p + v * T), (h = h * p + _ * T), p === 1 - o)) {
					const P = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
					(l *= P), (c *= P), (u *= P), (h *= P);
				}
			}
			(e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
		}
		static multiplyQuaternionsFlat(e, t, i, r, s, a) {
			const o = i[r],
				l = i[r + 1],
				c = i[r + 2],
				u = i[r + 3],
				h = s[a],
				d = s[a + 1],
				f = s[a + 2],
				v = s[a + 3];
			return (e[t] = o * v + u * h + l * f - c * d), (e[t + 1] = l * v + u * d + c * h - o * f), (e[t + 2] = c * v + u * f + o * d - l * h), (e[t + 3] = u * v - o * h - l * d - c * f), e;
		}
		get x() {
			return this._x;
		}
		set x(e) {
			(this._x = e), this._onChangeCallback();
		}
		get y() {
			return this._y;
		}
		set y(e) {
			(this._y = e), this._onChangeCallback();
		}
		get z() {
			return this._z;
		}
		set z(e) {
			(this._z = e), this._onChangeCallback();
		}
		get w() {
			return this._w;
		}
		set w(e) {
			(this._w = e), this._onChangeCallback();
		}
		set(e, t, i, r) {
			return (this._x = e), (this._y = t), (this._z = i), (this._w = r), this._onChangeCallback(), this;
		}
		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}
		copy(e) {
			return (this._x = e.x), (this._y = e.y), (this._z = e.z), (this._w = e.w), this._onChangeCallback(), this;
		}
		setFromEuler(e, t = !0) {
			const i = e._x,
				r = e._y,
				s = e._z,
				a = e._order,
				o = Math.cos,
				l = Math.sin,
				c = o(i / 2),
				u = o(r / 2),
				h = o(s / 2),
				d = l(i / 2),
				f = l(r / 2),
				v = l(s / 2);
			switch (a) {
				case "XYZ":
					(this._x = d * u * h + c * f * v), (this._y = c * f * h - d * u * v), (this._z = c * u * v + d * f * h), (this._w = c * u * h - d * f * v);
					break;
				case "YXZ":
					(this._x = d * u * h + c * f * v), (this._y = c * f * h - d * u * v), (this._z = c * u * v - d * f * h), (this._w = c * u * h + d * f * v);
					break;
				case "ZXY":
					(this._x = d * u * h - c * f * v), (this._y = c * f * h + d * u * v), (this._z = c * u * v + d * f * h), (this._w = c * u * h - d * f * v);
					break;
				case "ZYX":
					(this._x = d * u * h - c * f * v), (this._y = c * f * h + d * u * v), (this._z = c * u * v - d * f * h), (this._w = c * u * h + d * f * v);
					break;
				case "YZX":
					(this._x = d * u * h + c * f * v), (this._y = c * f * h + d * u * v), (this._z = c * u * v - d * f * h), (this._w = c * u * h - d * f * v);
					break;
				case "XZY":
					(this._x = d * u * h - c * f * v), (this._y = c * f * h - d * u * v), (this._z = c * u * v + d * f * h), (this._w = c * u * h + d * f * v);
					break;
				default:
					console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
			}
			return t === !0 && this._onChangeCallback(), this;
		}
		setFromAxisAngle(e, t) {
			const i = t / 2,
				r = Math.sin(i);
			return (this._x = e.x * r), (this._y = e.y * r), (this._z = e.z * r), (this._w = Math.cos(i)), this._onChangeCallback(), this;
		}
		setFromRotationMatrix(e) {
			const t = e.elements,
				i = t[0],
				r = t[4],
				s = t[8],
				a = t[1],
				o = t[5],
				l = t[9],
				c = t[2],
				u = t[6],
				h = t[10],
				d = i + o + h;
			if (d > 0) {
				const f = 0.5 / Math.sqrt(d + 1);
				(this._w = 0.25 / f), (this._x = (u - l) * f), (this._y = (s - c) * f), (this._z = (a - r) * f);
			} else if (i > o && i > h) {
				const f = 2 * Math.sqrt(1 + i - o - h);
				(this._w = (u - l) / f), (this._x = 0.25 * f), (this._y = (r + a) / f), (this._z = (s + c) / f);
			} else if (o > h) {
				const f = 2 * Math.sqrt(1 + o - i - h);
				(this._w = (s - c) / f), (this._x = (r + a) / f), (this._y = 0.25 * f), (this._z = (l + u) / f);
			} else {
				const f = 2 * Math.sqrt(1 + h - i - o);
				(this._w = (a - r) / f), (this._x = (s + c) / f), (this._y = (l + u) / f), (this._z = 0.25 * f);
			}
			return this._onChangeCallback(), this;
		}
		setFromUnitVectors(e, t) {
			let i = e.dot(t) + 1;
			return i < Number.EPSILON ? ((i = 0), Math.abs(e.x) > Math.abs(e.z) ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i)) : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i))) : ((this._x = e.y * t.z - e.z * t.y), (this._y = e.z * t.x - e.x * t.z), (this._z = e.x * t.y - e.y * t.x), (this._w = i)), this.normalize();
		}
		angleTo(e) {
			return 2 * Math.acos(Math.abs(Nn(this.dot(e), -1, 1)));
		}
		rotateTowards(e, t) {
			const i = this.angleTo(e);
			if (i === 0) return this;
			const r = Math.min(1, t / i);
			return this.slerp(e, r), this;
		}
		identity() {
			return this.set(0, 0, 0, 1);
		}
		invert() {
			return this.conjugate();
		}
		conjugate() {
			return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
		}
		dot(e) {
			return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
		}
		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}
		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}
		normalize() {
			let e = this.length();
			return e === 0 ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)), this._onChangeCallback(), this;
		}
		multiply(e) {
			return this.multiplyQuaternions(this, e);
		}
		premultiply(e) {
			return this.multiplyQuaternions(e, this);
		}
		multiplyQuaternions(e, t) {
			const i = e._x,
				r = e._y,
				s = e._z,
				a = e._w,
				o = t._x,
				l = t._y,
				c = t._z,
				u = t._w;
			return (this._x = i * u + a * o + r * c - s * l), (this._y = r * u + a * l + s * o - i * c), (this._z = s * u + a * c + i * l - r * o), (this._w = a * u - i * o - r * l - s * c), this._onChangeCallback(), this;
		}
		slerp(e, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(e);
			const i = this._x,
				r = this._y,
				s = this._z,
				a = this._w;
			let o = a * e._w + i * e._x + r * e._y + s * e._z;
			if ((o < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (o = -o)) : this.copy(e), o >= 1)) return (this._w = a), (this._x = i), (this._y = r), (this._z = s), this;
			const l = 1 - o * o;
			if (l <= Number.EPSILON) {
				const f = 1 - t;
				return (this._w = f * a + t * this._w), (this._x = f * i + t * this._x), (this._y = f * r + t * this._y), (this._z = f * s + t * this._z), this.normalize(), this;
			}
			const c = Math.sqrt(l),
				u = Math.atan2(c, o),
				h = Math.sin((1 - t) * u) / c,
				d = Math.sin(t * u) / c;
			return (this._w = a * h + this._w * d), (this._x = i * h + this._x * d), (this._y = r * h + this._y * d), (this._z = s * h + this._z * d), this._onChangeCallback(), this;
		}
		slerpQuaternions(e, t, i) {
			return this.copy(e).slerp(t, i);
		}
		random() {
			const e = 2 * Math.PI * Math.random(),
				t = 2 * Math.PI * Math.random(),
				i = Math.random(),
				r = Math.sqrt(1 - i),
				s = Math.sqrt(i);
			return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
		}
		equals(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
		}
		fromArray(e, t = 0) {
			return (this._x = e[t]), (this._y = e[t + 1]), (this._z = e[t + 2]), (this._w = e[t + 3]), this._onChangeCallback(), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
		}
		fromBufferAttribute(e, t) {
			return (this._x = e.getX(t)), (this._y = e.getY(t)), (this._z = e.getZ(t)), (this._w = e.getW(t)), this._onChangeCallback(), this;
		}
		toJSON() {
			return this.toArray();
		}
		_onChange(e) {
			return (this._onChangeCallback = e), this;
		}
		_onChangeCallback() {}
		*[Symbol.iterator]() {
			yield this._x, yield this._y, yield this._z, yield this._w;
		}
	}
	class D {
		constructor(e = 0, t = 0, i = 0) {
			(D.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
		}
		set(e, t, i) {
			return i === void 0 && (i = this.z), (this.x = e), (this.y = t), (this.z = i), this;
		}
		setScalar(e) {
			return (this.x = e), (this.y = e), (this.z = e), this;
		}
		setX(e) {
			return (this.x = e), this;
		}
		setY(e) {
			return (this.y = e), this;
		}
		setZ(e) {
			return (this.z = e), this;
		}
		setComponent(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				default:
					throw new Error("index is out of range: " + e);
			}
			return this;
		}
		getComponent(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw new Error("index is out of range: " + e);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}
		copy(e) {
			return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
		}
		add(e) {
			return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
		}
		addScalar(e) {
			return (this.x += e), (this.y += e), (this.z += e), this;
		}
		addVectors(e, t) {
			return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
		}
		addScaledVector(e, t) {
			return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
		}
		sub(e) {
			return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
		}
		subScalar(e) {
			return (this.x -= e), (this.y -= e), (this.z -= e), this;
		}
		subVectors(e, t) {
			return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
		}
		multiply(e) {
			return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
		}
		multiplyScalar(e) {
			return (this.x *= e), (this.y *= e), (this.z *= e), this;
		}
		multiplyVectors(e, t) {
			return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
		}
		applyEuler(e) {
			return this.applyQuaternion(wv.setFromEuler(e));
		}
		applyAxisAngle(e, t) {
			return this.applyQuaternion(wv.setFromAxisAngle(e, t));
		}
		applyMatrix3(e) {
			const t = this.x,
				i = this.y,
				r = this.z,
				s = e.elements;
			return (this.x = s[0] * t + s[3] * i + s[6] * r), (this.y = s[1] * t + s[4] * i + s[7] * r), (this.z = s[2] * t + s[5] * i + s[8] * r), this;
		}
		applyNormalMatrix(e) {
			return this.applyMatrix3(e).normalize();
		}
		applyMatrix4(e) {
			const t = this.x,
				i = this.y,
				r = this.z,
				s = e.elements,
				a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
			return (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a), (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a), (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a), this;
		}
		applyQuaternion(e) {
			const t = this.x,
				i = this.y,
				r = this.z,
				s = e.x,
				a = e.y,
				o = e.z,
				l = e.w,
				c = 2 * (a * r - o * i),
				u = 2 * (o * t - s * r),
				h = 2 * (s * i - a * t);
			return (this.x = t + l * c + a * h - o * u), (this.y = i + l * u + o * c - s * h), (this.z = r + l * h + s * u - a * c), this;
		}
		project(e) {
			return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
		}
		unproject(e) {
			return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
		}
		transformDirection(e) {
			const t = this.x,
				i = this.y,
				r = this.z,
				s = e.elements;
			return (this.x = s[0] * t + s[4] * i + s[8] * r), (this.y = s[1] * t + s[5] * i + s[9] * r), (this.z = s[2] * t + s[6] * i + s[10] * r), this.normalize();
		}
		divide(e) {
			return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
		}
		divideScalar(e) {
			return this.multiplyScalar(1 / e);
		}
		min(e) {
			return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), this;
		}
		max(e) {
			return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), this;
		}
		clamp(e, t) {
			return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), (this.z = Math.max(e.z, Math.min(t.z, this.z))), this;
		}
		clampScalar(e, t) {
			return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), (this.z = Math.max(e, Math.min(t, this.z))), this;
		}
		clampLength(e, t) {
			const i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
		}
		floor() {
			return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
		}
		ceil() {
			return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
		}
		round() {
			return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
		}
		roundToZero() {
			return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), this;
		}
		negate() {
			return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
		}
		dot(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z;
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		setLength(e) {
			return this.normalize().multiplyScalar(e);
		}
		lerp(e, t) {
			return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
		}
		lerpVectors(e, t, i) {
			return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), (this.z = e.z + (t.z - e.z) * i), this;
		}
		cross(e) {
			return this.crossVectors(this, e);
		}
		crossVectors(e, t) {
			const i = e.x,
				r = e.y,
				s = e.z,
				a = t.x,
				o = t.y,
				l = t.z;
			return (this.x = r * l - s * o), (this.y = s * a - i * l), (this.z = i * o - r * a), this;
		}
		projectOnVector(e) {
			const t = e.lengthSq();
			if (t === 0) return this.set(0, 0, 0);
			const i = e.dot(this) / t;
			return this.copy(e).multiplyScalar(i);
		}
		projectOnPlane(e) {
			return gd.copy(this).projectOnVector(e), this.sub(gd);
		}
		reflect(e) {
			return this.sub(gd.copy(e).multiplyScalar(2 * this.dot(e)));
		}
		angleTo(e) {
			const t = Math.sqrt(this.lengthSq() * e.lengthSq());
			if (t === 0) return Math.PI / 2;
			const i = this.dot(e) / t;
			return Math.acos(Nn(i, -1, 1));
		}
		distanceTo(e) {
			return Math.sqrt(this.distanceToSquared(e));
		}
		distanceToSquared(e) {
			const t = this.x - e.x,
				i = this.y - e.y,
				r = this.z - e.z;
			return t * t + i * i + r * r;
		}
		manhattanDistanceTo(e) {
			return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
		}
		setFromSpherical(e) {
			return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
		}
		setFromSphericalCoords(e, t, i) {
			const r = Math.sin(t) * e;
			return (this.x = r * Math.sin(i)), (this.y = Math.cos(t) * e), (this.z = r * Math.cos(i)), this;
		}
		setFromCylindrical(e) {
			return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
		}
		setFromCylindricalCoords(e, t, i) {
			return (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this;
		}
		setFromMatrixPosition(e) {
			const t = e.elements;
			return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
		}
		setFromMatrixScale(e) {
			const t = this.setFromMatrixColumn(e, 0).length(),
				i = this.setFromMatrixColumn(e, 1).length(),
				r = this.setFromMatrixColumn(e, 2).length();
			return (this.x = t), (this.y = i), (this.z = r), this;
		}
		setFromMatrixColumn(e, t) {
			return this.fromArray(e.elements, t * 4);
		}
		setFromMatrix3Column(e, t) {
			return this.fromArray(e.elements, t * 3);
		}
		setFromEuler(e) {
			return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
		}
		setFromColor(e) {
			return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
		}
		equals(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z;
		}
		fromArray(e, t = 0) {
			return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
		}
		fromBufferAttribute(e, t) {
			return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
		}
		random() {
			return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
		}
		randomDirection() {
			const e = Math.random() * Math.PI * 2,
				t = Math.random() * 2 - 1,
				i = Math.sqrt(1 - t * t);
			return (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this;
		}
		*[Symbol.iterator]() {
			yield this.x, yield this.y, yield this.z;
		}
	}
	const gd = new D(),
		wv = new En();
	class Tr {
		constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
			(this.isBox3 = !0), (this.min = e), (this.max = t);
		}
		set(e, t) {
			return this.min.copy(e), this.max.copy(t), this;
		}
		setFromArray(e) {
			this.makeEmpty();
			for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Gi.fromArray(e, t));
			return this;
		}
		setFromBufferAttribute(e) {
			this.makeEmpty();
			for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Gi.fromBufferAttribute(e, t));
			return this;
		}
		setFromPoints(e) {
			this.makeEmpty();
			for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
			return this;
		}
		setFromCenterAndSize(e, t) {
			const i = Gi.copy(t).multiplyScalar(0.5);
			return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
		}
		setFromObject(e, t = !1) {
			return this.makeEmpty(), this.expandByObject(e, t);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this;
		}
		makeEmpty() {
			return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
		}
		isEmpty() {
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		}
		getCenter(e) {
			return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
		}
		getSize(e) {
			return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
		}
		expandByPoint(e) {
			return this.min.min(e), this.max.max(e), this;
		}
		expandByVector(e) {
			return this.min.sub(e), this.max.add(e), this;
		}
		expandByScalar(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this;
		}
		expandByObject(e, t = !1) {
			e.updateWorldMatrix(!1, !1);
			const i = e.geometry;
			if (i !== void 0) {
				const s = i.getAttribute("position");
				if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0) for (let a = 0, o = s.count; a < o; a++) e.isMesh === !0 ? e.getVertexPosition(a, Gi) : Gi.fromBufferAttribute(s, a), Gi.applyMatrix4(e.matrixWorld), this.expandByPoint(Gi);
				else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Ic.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Ic.copy(i.boundingBox)), Ic.applyMatrix4(e.matrixWorld), this.union(Ic);
			}
			const r = e.children;
			for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
			return this;
		}
		containsPoint(e) {
			return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
		}
		containsBox(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
		}
		getParameter(e, t) {
			return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
		}
		intersectsBox(e) {
			return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
		}
		intersectsSphere(e) {
			return this.clampPoint(e.center, Gi), Gi.distanceToSquared(e.center) <= e.radius * e.radius;
		}
		intersectsPlane(e) {
			let t, i;
			return (
				e.normal.x > 0 ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x)) : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)), e.normal.y > 0 ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y)) : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)), e.normal.z > 0 ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z)) : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)), t <= -e.constant && i >= -e.constant
			);
		}
		intersectsTriangle(e) {
			if (this.isEmpty()) return !1;
			this.getCenter(ol), Fc.subVectors(this.max, ol), Ha.subVectors(e.a, ol), Ga.subVectors(e.b, ol), Va.subVectors(e.c, ol), os.subVectors(Ga, Ha), ls.subVectors(Va, Ga), qs.subVectors(Ha, Va);
			let t = [0, -os.z, os.y, 0, -ls.z, ls.y, 0, -qs.z, qs.y, os.z, 0, -os.x, ls.z, 0, -ls.x, qs.z, 0, -qs.x, -os.y, os.x, 0, -ls.y, ls.x, 0, -qs.y, qs.x, 0];
			return !vd(t, Ha, Ga, Va, Fc) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !vd(t, Ha, Ga, Va, Fc)) ? !1 : (Nc.crossVectors(os, ls), (t = [Nc.x, Nc.y, Nc.z]), vd(t, Ha, Ga, Va, Fc));
		}
		clampPoint(e, t) {
			return t.copy(e).clamp(this.min, this.max);
		}
		distanceToPoint(e) {
			return this.clampPoint(e, Gi).distanceTo(e);
		}
		getBoundingSphere(e) {
			return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), (e.radius = this.getSize(Gi).length() * 0.5)), e;
		}
		intersect(e) {
			return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
		}
		union(e) {
			return this.min.min(e.min), this.max.max(e.max), this;
		}
		applyMatrix4(e) {
			return this.isEmpty()
				? this
				: (Or[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
				  Or[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
				  Or[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
				  Or[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
				  Or[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
				  Or[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
				  Or[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
				  Or[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
				  this.setFromPoints(Or),
				  this);
		}
		translate(e) {
			return this.min.add(e), this.max.add(e), this;
		}
		equals(e) {
			return e.min.equals(this.min) && e.max.equals(this.max);
		}
	}
	const Or = [new D(), new D(), new D(), new D(), new D(), new D(), new D(), new D()],
		Gi = new D(),
		Ic = new Tr(),
		Ha = new D(),
		Ga = new D(),
		Va = new D(),
		os = new D(),
		ls = new D(),
		qs = new D(),
		ol = new D(),
		Fc = new D(),
		Nc = new D(),
		js = new D();
	function vd(n, e, t, i, r) {
		for (let s = 0, a = n.length - 3; s <= a; s += 3) {
			js.fromArray(n, s);
			const o = r.x * Math.abs(js.x) + r.y * Math.abs(js.y) + r.z * Math.abs(js.z),
				l = e.dot(js),
				c = t.dot(js),
				u = i.dot(js);
			if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
		}
		return !0;
	}
	const JC = new Tr(),
		ll = new D(),
		_d = new D();
	let $o = class {
		constructor(e = new D(), t = -1) {
			(this.isSphere = !0), (this.center = e), (this.radius = t);
		}
		set(e, t) {
			return this.center.copy(e), (this.radius = t), this;
		}
		setFromPoints(e, t) {
			const i = this.center;
			t !== void 0 ? i.copy(t) : JC.setFromPoints(e).getCenter(i);
			let r = 0;
			for (let s = 0, a = e.length; s < a; s++) r = Math.max(r, i.distanceToSquared(e[s]));
			return (this.radius = Math.sqrt(r)), this;
		}
		copy(e) {
			return this.center.copy(e.center), (this.radius = e.radius), this;
		}
		isEmpty() {
			return this.radius < 0;
		}
		makeEmpty() {
			return this.center.set(0, 0, 0), (this.radius = -1), this;
		}
		containsPoint(e) {
			return e.distanceToSquared(this.center) <= this.radius * this.radius;
		}
		distanceToPoint(e) {
			return e.distanceTo(this.center) - this.radius;
		}
		intersectsSphere(e) {
			const t = this.radius + e.radius;
			return e.center.distanceToSquared(this.center) <= t * t;
		}
		intersectsBox(e) {
			return e.intersectsSphere(this);
		}
		intersectsPlane(e) {
			return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
		}
		clampPoint(e, t) {
			const i = this.center.distanceToSquared(e);
			return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
		}
		getBoundingBox(e) {
			return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
		}
		applyMatrix4(e) {
			return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
		}
		translate(e) {
			return this.center.add(e), this;
		}
		expandByPoint(e) {
			if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
			ll.subVectors(e, this.center);
			const t = ll.lengthSq();
			if (t > this.radius * this.radius) {
				const i = Math.sqrt(t),
					r = (i - this.radius) * 0.5;
				this.center.addScaledVector(ll, r / i), (this.radius += r);
			}
			return this;
		}
		union(e) {
			return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? (this.radius = Math.max(this.radius, e.radius)) : (_d.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(ll.copy(e.center).add(_d)), this.expandByPoint(ll.copy(e.center).sub(_d))), this);
		}
		equals(e) {
			return e.center.equals(this.center) && e.radius === this.radius;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	};
	const Ir = new D(),
		yd = new D(),
		Uc = new D(),
		cs = new D(),
		xd = new D(),
		kc = new D(),
		bd = new D();
	let _h = class {
		constructor(e = new D(), t = new D(0, 0, -1)) {
			(this.origin = e), (this.direction = t);
		}
		set(e, t) {
			return this.origin.copy(e), this.direction.copy(t), this;
		}
		copy(e) {
			return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
		}
		at(e, t) {
			return t.copy(this.origin).addScaledVector(this.direction, e);
		}
		lookAt(e) {
			return this.direction.copy(e).sub(this.origin).normalize(), this;
		}
		recast(e) {
			return this.origin.copy(this.at(e, Ir)), this;
		}
		closestPointToPoint(e, t) {
			t.subVectors(e, this.origin);
			const i = t.dot(this.direction);
			return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
		}
		distanceToPoint(e) {
			return Math.sqrt(this.distanceSqToPoint(e));
		}
		distanceSqToPoint(e) {
			const t = Ir.subVectors(e, this.origin).dot(this.direction);
			return t < 0 ? this.origin.distanceToSquared(e) : (Ir.copy(this.origin).addScaledVector(this.direction, t), Ir.distanceToSquared(e));
		}
		distanceSqToSegment(e, t, i, r) {
			yd.copy(e).add(t).multiplyScalar(0.5), Uc.copy(t).sub(e).normalize(), cs.copy(this.origin).sub(yd);
			const s = e.distanceTo(t) * 0.5,
				a = -this.direction.dot(Uc),
				o = cs.dot(this.direction),
				l = -cs.dot(Uc),
				c = cs.lengthSq(),
				u = Math.abs(1 - a * a);
			let h, d, f, v;
			if (u > 0)
				if (((h = a * l - o), (d = a * o - l), (v = s * u), h >= 0))
					if (d >= -v)
						if (d <= v) {
							const _ = 1 / u;
							(h *= _), (d *= _), (f = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + c);
						} else (d = s), (h = Math.max(0, -(a * d + o))), (f = -h * h + d * (d + 2 * l) + c);
					else (d = -s), (h = Math.max(0, -(a * d + o))), (f = -h * h + d * (d + 2 * l) + c);
				else d <= -v ? ((h = Math.max(0, -(-a * s + o))), (d = h > 0 ? -s : Math.min(Math.max(-s, -l), s)), (f = -h * h + d * (d + 2 * l) + c)) : d <= v ? ((h = 0), (d = Math.min(Math.max(-s, -l), s)), (f = d * (d + 2 * l) + c)) : ((h = Math.max(0, -(a * s + o))), (d = h > 0 ? s : Math.min(Math.max(-s, -l), s)), (f = -h * h + d * (d + 2 * l) + c));
			else (d = a > 0 ? -s : s), (h = Math.max(0, -(a * d + o))), (f = -h * h + d * (d + 2 * l) + c);
			return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(yd).addScaledVector(Uc, d), f;
		}
		intersectSphere(e, t) {
			Ir.subVectors(e.center, this.origin);
			const i = Ir.dot(this.direction),
				r = Ir.dot(Ir) - i * i,
				s = e.radius * e.radius;
			if (r > s) return null;
			const a = Math.sqrt(s - r),
				o = i - a,
				l = i + a;
			return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
		}
		intersectsSphere(e) {
			return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
		}
		distanceToPlane(e) {
			const t = e.normal.dot(this.direction);
			if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
			const i = -(this.origin.dot(e.normal) + e.constant) / t;
			return i >= 0 ? i : null;
		}
		intersectPlane(e, t) {
			const i = this.distanceToPlane(e);
			return i === null ? null : this.at(i, t);
		}
		intersectsPlane(e) {
			const t = e.distanceToPoint(this.origin);
			return t === 0 || e.normal.dot(this.direction) * t < 0;
		}
		intersectBox(e, t) {
			let i, r, s, a, o, l;
			const c = 1 / this.direction.x,
				u = 1 / this.direction.y,
				h = 1 / this.direction.z,
				d = this.origin;
			return (
				c >= 0 ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c)) : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
				u >= 0 ? ((s = (e.min.y - d.y) * u), (a = (e.max.y - d.y) * u)) : ((s = (e.max.y - d.y) * u), (a = (e.min.y - d.y) * u)),
				i > a || s > r || ((s > i || isNaN(i)) && (i = s), (a < r || isNaN(r)) && (r = a), h >= 0 ? ((o = (e.min.z - d.z) * h), (l = (e.max.z - d.z) * h)) : ((o = (e.max.z - d.z) * h), (l = (e.min.z - d.z) * h)), i > l || o > r) || ((o > i || i !== i) && (i = o), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t)
			);
		}
		intersectsBox(e) {
			return this.intersectBox(e, Ir) !== null;
		}
		intersectTriangle(e, t, i, r, s) {
			xd.subVectors(t, e), kc.subVectors(i, e), bd.crossVectors(xd, kc);
			let a = this.direction.dot(bd),
				o;
			if (a > 0) {
				if (r) return null;
				o = 1;
			} else if (a < 0) (o = -1), (a = -a);
			else return null;
			cs.subVectors(this.origin, e);
			const l = o * this.direction.dot(kc.crossVectors(cs, kc));
			if (l < 0) return null;
			const c = o * this.direction.dot(xd.cross(cs));
			if (c < 0 || l + c > a) return null;
			const u = -o * cs.dot(bd);
			return u < 0 ? null : this.at(u / a, s);
		}
		applyMatrix4(e) {
			return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
		}
		equals(e) {
			return e.origin.equals(this.origin) && e.direction.equals(this.direction);
		}
		clone() {
			return new this.constructor().copy(this);
		}
	};
	class pt {
		constructor(e, t, i, r, s, a, o, l, c, u, h, d, f, v, _, p) {
			(pt.prototype.isMatrix4 = !0), (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), e !== void 0 && this.set(e, t, i, r, s, a, o, l, c, u, h, d, f, v, _, p);
		}
		set(e, t, i, r, s, a, o, l, c, u, h, d, f, v, _, p) {
			const g = this.elements;
			return (g[0] = e), (g[4] = t), (g[8] = i), (g[12] = r), (g[1] = s), (g[5] = a), (g[9] = o), (g[13] = l), (g[2] = c), (g[6] = u), (g[10] = h), (g[14] = d), (g[3] = f), (g[7] = v), (g[11] = _), (g[15] = p), this;
		}
		identity() {
			return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
		}
		clone() {
			return new pt().fromArray(this.elements);
		}
		copy(e) {
			const t = this.elements,
				i = e.elements;
			return (t[0] = i[0]), (t[1] = i[1]), (t[2] = i[2]), (t[3] = i[3]), (t[4] = i[4]), (t[5] = i[5]), (t[6] = i[6]), (t[7] = i[7]), (t[8] = i[8]), (t[9] = i[9]), (t[10] = i[10]), (t[11] = i[11]), (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), (t[15] = i[15]), this;
		}
		copyPosition(e) {
			const t = this.elements,
				i = e.elements;
			return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
		}
		setFromMatrix3(e) {
			const t = e.elements;
			return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
		}
		extractBasis(e, t, i) {
			return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
		}
		makeBasis(e, t, i) {
			return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
		}
		extractRotation(e) {
			const t = this.elements,
				i = e.elements,
				r = 1 / Wa.setFromMatrixColumn(e, 0).length(),
				s = 1 / Wa.setFromMatrixColumn(e, 1).length(),
				a = 1 / Wa.setFromMatrixColumn(e, 2).length();
			return (t[0] = i[0] * r), (t[1] = i[1] * r), (t[2] = i[2] * r), (t[3] = 0), (t[4] = i[4] * s), (t[5] = i[5] * s), (t[6] = i[6] * s), (t[7] = 0), (t[8] = i[8] * a), (t[9] = i[9] * a), (t[10] = i[10] * a), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
		}
		makeRotationFromEuler(e) {
			const t = this.elements,
				i = e.x,
				r = e.y,
				s = e.z,
				a = Math.cos(i),
				o = Math.sin(i),
				l = Math.cos(r),
				c = Math.sin(r),
				u = Math.cos(s),
				h = Math.sin(s);
			if (e.order === "XYZ") {
				const d = a * u,
					f = a * h,
					v = o * u,
					_ = o * h;
				(t[0] = l * u), (t[4] = -l * h), (t[8] = c), (t[1] = f + v * c), (t[5] = d - _ * c), (t[9] = -o * l), (t[2] = _ - d * c), (t[6] = v + f * c), (t[10] = a * l);
			} else if (e.order === "YXZ") {
				const d = l * u,
					f = l * h,
					v = c * u,
					_ = c * h;
				(t[0] = d + _ * o), (t[4] = v * o - f), (t[8] = a * c), (t[1] = a * h), (t[5] = a * u), (t[9] = -o), (t[2] = f * o - v), (t[6] = _ + d * o), (t[10] = a * l);
			} else if (e.order === "ZXY") {
				const d = l * u,
					f = l * h,
					v = c * u,
					_ = c * h;
				(t[0] = d - _ * o), (t[4] = -a * h), (t[8] = v + f * o), (t[1] = f + v * o), (t[5] = a * u), (t[9] = _ - d * o), (t[2] = -a * c), (t[6] = o), (t[10] = a * l);
			} else if (e.order === "ZYX") {
				const d = a * u,
					f = a * h,
					v = o * u,
					_ = o * h;
				(t[0] = l * u), (t[4] = v * c - f), (t[8] = d * c + _), (t[1] = l * h), (t[5] = _ * c + d), (t[9] = f * c - v), (t[2] = -c), (t[6] = o * l), (t[10] = a * l);
			} else if (e.order === "YZX") {
				const d = a * l,
					f = a * c,
					v = o * l,
					_ = o * c;
				(t[0] = l * u), (t[4] = _ - d * h), (t[8] = v * h + f), (t[1] = h), (t[5] = a * u), (t[9] = -o * u), (t[2] = -c * u), (t[6] = f * h + v), (t[10] = d - _ * h);
			} else if (e.order === "XZY") {
				const d = a * l,
					f = a * c,
					v = o * l,
					_ = o * c;
				(t[0] = l * u), (t[4] = -h), (t[8] = c * u), (t[1] = d * h + _), (t[5] = a * u), (t[9] = f * h - v), (t[2] = v * h - f), (t[6] = o * u), (t[10] = _ * h + d);
			}
			return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
		}
		makeRotationFromQuaternion(e) {
			return this.compose(QC, e, eL);
		}
		lookAt(e, t, i) {
			const r = this.elements;
			return ui.subVectors(e, t), ui.lengthSq() === 0 && (ui.z = 1), ui.normalize(), us.crossVectors(i, ui), us.lengthSq() === 0 && (Math.abs(i.z) === 1 ? (ui.x += 1e-4) : (ui.z += 1e-4), ui.normalize(), us.crossVectors(i, ui)), us.normalize(), Bc.crossVectors(ui, us), (r[0] = us.x), (r[4] = Bc.x), (r[8] = ui.x), (r[1] = us.y), (r[5] = Bc.y), (r[9] = ui.y), (r[2] = us.z), (r[6] = Bc.z), (r[10] = ui.z), this;
		}
		multiply(e) {
			return this.multiplyMatrices(this, e);
		}
		premultiply(e) {
			return this.multiplyMatrices(e, this);
		}
		multiplyMatrices(e, t) {
			const i = e.elements,
				r = t.elements,
				s = this.elements,
				a = i[0],
				o = i[4],
				l = i[8],
				c = i[12],
				u = i[1],
				h = i[5],
				d = i[9],
				f = i[13],
				v = i[2],
				_ = i[6],
				p = i[10],
				g = i[14],
				x = i[3],
				b = i[7],
				T = i[11],
				P = i[15],
				A = r[0],
				M = r[4],
				w = r[8],
				y = r[12],
				S = r[1],
				L = r[5],
				N = r[9],
				k = r[13],
				B = r[2],
				W = r[6],
				H = r[10],
				z = r[14],
				X = r[3],
				K = r[7],
				G = r[11],
				ue = r[15];
			return (
				(s[0] = a * A + o * S + l * B + c * X),
				(s[4] = a * M + o * L + l * W + c * K),
				(s[8] = a * w + o * N + l * H + c * G),
				(s[12] = a * y + o * k + l * z + c * ue),
				(s[1] = u * A + h * S + d * B + f * X),
				(s[5] = u * M + h * L + d * W + f * K),
				(s[9] = u * w + h * N + d * H + f * G),
				(s[13] = u * y + h * k + d * z + f * ue),
				(s[2] = v * A + _ * S + p * B + g * X),
				(s[6] = v * M + _ * L + p * W + g * K),
				(s[10] = v * w + _ * N + p * H + g * G),
				(s[14] = v * y + _ * k + p * z + g * ue),
				(s[3] = x * A + b * S + T * B + P * X),
				(s[7] = x * M + b * L + T * W + P * K),
				(s[11] = x * w + b * N + T * H + P * G),
				(s[15] = x * y + b * k + T * z + P * ue),
				this
			);
		}
		multiplyScalar(e) {
			const t = this.elements;
			return (t[0] *= e), (t[4] *= e), (t[8] *= e), (t[12] *= e), (t[1] *= e), (t[5] *= e), (t[9] *= e), (t[13] *= e), (t[2] *= e), (t[6] *= e), (t[10] *= e), (t[14] *= e), (t[3] *= e), (t[7] *= e), (t[11] *= e), (t[15] *= e), this;
		}
		determinant() {
			const e = this.elements,
				t = e[0],
				i = e[4],
				r = e[8],
				s = e[12],
				a = e[1],
				o = e[5],
				l = e[9],
				c = e[13],
				u = e[2],
				h = e[6],
				d = e[10],
				f = e[14],
				v = e[3],
				_ = e[7],
				p = e[11],
				g = e[15];
			return v * (+s * l * h - r * c * h - s * o * d + i * c * d + r * o * f - i * l * f) + _ * (+t * l * f - t * c * d + s * a * d - r * a * f + r * c * u - s * l * u) + p * (+t * c * h - t * o * f - s * a * h + i * a * f + s * o * u - i * c * u) + g * (-r * o * u - t * l * h + t * o * d + r * a * h - i * a * d + i * l * u);
		}
		transpose() {
			const e = this.elements;
			let t;
			return (t = e[1]), (e[1] = e[4]), (e[4] = t), (t = e[2]), (e[2] = e[8]), (e[8] = t), (t = e[6]), (e[6] = e[9]), (e[9] = t), (t = e[3]), (e[3] = e[12]), (e[12] = t), (t = e[7]), (e[7] = e[13]), (e[13] = t), (t = e[11]), (e[11] = e[14]), (e[14] = t), this;
		}
		setPosition(e, t, i) {
			const r = this.elements;
			return e.isVector3 ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z)) : ((r[12] = e), (r[13] = t), (r[14] = i)), this;
		}
		invert() {
			const e = this.elements,
				t = e[0],
				i = e[1],
				r = e[2],
				s = e[3],
				a = e[4],
				o = e[5],
				l = e[6],
				c = e[7],
				u = e[8],
				h = e[9],
				d = e[10],
				f = e[11],
				v = e[12],
				_ = e[13],
				p = e[14],
				g = e[15],
				x = h * p * c - _ * d * c + _ * l * f - o * p * f - h * l * g + o * d * g,
				b = v * d * c - u * p * c - v * l * f + a * p * f + u * l * g - a * d * g,
				T = u * _ * c - v * h * c + v * o * f - a * _ * f - u * o * g + a * h * g,
				P = v * h * l - u * _ * l - v * o * d + a * _ * d + u * o * p - a * h * p,
				A = t * x + i * b + r * T + s * P;
			if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const M = 1 / A;
			return (
				(e[0] = x * M),
				(e[1] = (_ * d * s - h * p * s - _ * r * f + i * p * f + h * r * g - i * d * g) * M),
				(e[2] = (o * p * s - _ * l * s + _ * r * c - i * p * c - o * r * g + i * l * g) * M),
				(e[3] = (h * l * s - o * d * s - h * r * c + i * d * c + o * r * f - i * l * f) * M),
				(e[4] = b * M),
				(e[5] = (u * p * s - v * d * s + v * r * f - t * p * f - u * r * g + t * d * g) * M),
				(e[6] = (v * l * s - a * p * s - v * r * c + t * p * c + a * r * g - t * l * g) * M),
				(e[7] = (a * d * s - u * l * s + u * r * c - t * d * c - a * r * f + t * l * f) * M),
				(e[8] = T * M),
				(e[9] = (v * h * s - u * _ * s - v * i * f + t * _ * f + u * i * g - t * h * g) * M),
				(e[10] = (a * _ * s - v * o * s + v * i * c - t * _ * c - a * i * g + t * o * g) * M),
				(e[11] = (u * o * s - a * h * s - u * i * c + t * h * c + a * i * f - t * o * f) * M),
				(e[12] = P * M),
				(e[13] = (u * _ * r - v * h * r + v * i * d - t * _ * d - u * i * p + t * h * p) * M),
				(e[14] = (v * o * r - a * _ * r - v * i * l + t * _ * l + a * i * p - t * o * p) * M),
				(e[15] = (a * h * r - u * o * r + u * i * l - t * h * l - a * i * d + t * o * d) * M),
				this
			);
		}
		scale(e) {
			const t = this.elements,
				i = e.x,
				r = e.y,
				s = e.z;
			return (t[0] *= i), (t[4] *= r), (t[8] *= s), (t[1] *= i), (t[5] *= r), (t[9] *= s), (t[2] *= i), (t[6] *= r), (t[10] *= s), (t[3] *= i), (t[7] *= r), (t[11] *= s), this;
		}
		getMaxScaleOnAxis() {
			const e = this.elements,
				t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
				i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
				r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
			return Math.sqrt(Math.max(t, i, r));
		}
		makeTranslation(e, t, i) {
			return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
		}
		makeRotationX(e) {
			const t = Math.cos(e),
				i = Math.sin(e);
			return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
		}
		makeRotationY(e) {
			const t = Math.cos(e),
				i = Math.sin(e);
			return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
		}
		makeRotationZ(e) {
			const t = Math.cos(e),
				i = Math.sin(e);
			return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
		}
		makeRotationAxis(e, t) {
			const i = Math.cos(t),
				r = Math.sin(t),
				s = 1 - i,
				a = e.x,
				o = e.y,
				l = e.z,
				c = s * a,
				u = s * o;
			return this.set(c * a + i, c * o - r * l, c * l + r * o, 0, c * o + r * l, u * o + i, u * l - r * a, 0, c * l - r * o, u * l + r * a, s * l * l + i, 0, 0, 0, 0, 1), this;
		}
		makeScale(e, t, i) {
			return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
		}
		makeShear(e, t, i, r, s, a) {
			return this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
		}
		compose(e, t, i) {
			const r = this.elements,
				s = t._x,
				a = t._y,
				o = t._z,
				l = t._w,
				c = s + s,
				u = a + a,
				h = o + o,
				d = s * c,
				f = s * u,
				v = s * h,
				_ = a * u,
				p = a * h,
				g = o * h,
				x = l * c,
				b = l * u,
				T = l * h,
				P = i.x,
				A = i.y,
				M = i.z;
			return (r[0] = (1 - (_ + g)) * P), (r[1] = (f + T) * P), (r[2] = (v - b) * P), (r[3] = 0), (r[4] = (f - T) * A), (r[5] = (1 - (d + g)) * A), (r[6] = (p + x) * A), (r[7] = 0), (r[8] = (v + b) * M), (r[9] = (p - x) * M), (r[10] = (1 - (d + _)) * M), (r[11] = 0), (r[12] = e.x), (r[13] = e.y), (r[14] = e.z), (r[15] = 1), this;
		}
		decompose(e, t, i) {
			const r = this.elements;
			let s = Wa.set(r[0], r[1], r[2]).length();
			const a = Wa.set(r[4], r[5], r[6]).length(),
				o = Wa.set(r[8], r[9], r[10]).length();
			this.determinant() < 0 && (s = -s), (e.x = r[12]), (e.y = r[13]), (e.z = r[14]), Vi.copy(this);
			const c = 1 / s,
				u = 1 / a,
				h = 1 / o;
			return (Vi.elements[0] *= c), (Vi.elements[1] *= c), (Vi.elements[2] *= c), (Vi.elements[4] *= u), (Vi.elements[5] *= u), (Vi.elements[6] *= u), (Vi.elements[8] *= h), (Vi.elements[9] *= h), (Vi.elements[10] *= h), t.setFromRotationMatrix(Vi), (i.x = s), (i.y = a), (i.z = o), this;
		}
		makePerspective(e, t, i, r, s, a, o = Gr) {
			const l = this.elements,
				c = (2 * s) / (t - e),
				u = (2 * s) / (i - r),
				h = (t + e) / (t - e),
				d = (i + r) / (i - r);
			let f, v;
			if (o === Gr) (f = -(a + s) / (a - s)), (v = (-2 * a * s) / (a - s));
			else if (o === Yu) (f = -a / (a - s)), (v = (-a * s) / (a - s));
			else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
			return (l[0] = c), (l[4] = 0), (l[8] = h), (l[12] = 0), (l[1] = 0), (l[5] = u), (l[9] = d), (l[13] = 0), (l[2] = 0), (l[6] = 0), (l[10] = f), (l[14] = v), (l[3] = 0), (l[7] = 0), (l[11] = -1), (l[15] = 0), this;
		}
		makeOrthographic(e, t, i, r, s, a, o = Gr) {
			const l = this.elements,
				c = 1 / (t - e),
				u = 1 / (i - r),
				h = 1 / (a - s),
				d = (t + e) * c,
				f = (i + r) * u;
			let v, _;
			if (o === Gr) (v = (a + s) * h), (_ = -2 * h);
			else if (o === Yu) (v = s * h), (_ = -1 * h);
			else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
			return (l[0] = 2 * c), (l[4] = 0), (l[8] = 0), (l[12] = -d), (l[1] = 0), (l[5] = 2 * u), (l[9] = 0), (l[13] = -f), (l[2] = 0), (l[6] = 0), (l[10] = _), (l[14] = -v), (l[3] = 0), (l[7] = 0), (l[11] = 0), (l[15] = 1), this;
		}
		equals(e) {
			const t = this.elements,
				i = e.elements;
			for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
			return !0;
		}
		fromArray(e, t = 0) {
			for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
			return this;
		}
		toArray(e = [], t = 0) {
			const i = this.elements;
			return (e[t] = i[0]), (e[t + 1] = i[1]), (e[t + 2] = i[2]), (e[t + 3] = i[3]), (e[t + 4] = i[4]), (e[t + 5] = i[5]), (e[t + 6] = i[6]), (e[t + 7] = i[7]), (e[t + 8] = i[8]), (e[t + 9] = i[9]), (e[t + 10] = i[10]), (e[t + 11] = i[11]), (e[t + 12] = i[12]), (e[t + 13] = i[13]), (e[t + 14] = i[14]), (e[t + 15] = i[15]), e;
		}
	}
	const Wa = new D(),
		Vi = new pt(),
		QC = new D(0, 0, 0),
		eL = new D(1, 1, 1),
		us = new D(),
		Bc = new D(),
		ui = new D(),
		Tv = new pt(),
		Mv = new En();
	class Un {
		constructor(e = 0, t = 0, i = 0, r = Un.DEFAULT_ORDER) {
			(this.isEuler = !0), (this._x = e), (this._y = t), (this._z = i), (this._order = r);
		}
		get x() {
			return this._x;
		}
		set x(e) {
			(this._x = e), this._onChangeCallback();
		}
		get y() {
			return this._y;
		}
		set y(e) {
			(this._y = e), this._onChangeCallback();
		}
		get z() {
			return this._z;
		}
		set z(e) {
			(this._z = e), this._onChangeCallback();
		}
		get order() {
			return this._order;
		}
		set order(e) {
			(this._order = e), this._onChangeCallback();
		}
		set(e, t, i, r = this._order) {
			return (this._x = e), (this._y = t), (this._z = i), (this._order = r), this._onChangeCallback(), this;
		}
		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}
		copy(e) {
			return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._onChangeCallback(), this;
		}
		setFromRotationMatrix(e, t = this._order, i = !0) {
			const r = e.elements,
				s = r[0],
				a = r[4],
				o = r[8],
				l = r[1],
				c = r[5],
				u = r[9],
				h = r[2],
				d = r[6],
				f = r[10];
			switch (t) {
				case "XYZ":
					(this._y = Math.asin(Nn(o, -1, 1))), Math.abs(o) < 0.9999999 ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-a, s))) : ((this._x = Math.atan2(d, c)), (this._z = 0));
					break;
				case "YXZ":
					(this._x = Math.asin(-Nn(u, -1, 1))), Math.abs(u) < 0.9999999 ? ((this._y = Math.atan2(o, f)), (this._z = Math.atan2(l, c))) : ((this._y = Math.atan2(-h, s)), (this._z = 0));
					break;
				case "ZXY":
					(this._x = Math.asin(Nn(d, -1, 1))), Math.abs(d) < 0.9999999 ? ((this._y = Math.atan2(-h, f)), (this._z = Math.atan2(-a, c))) : ((this._y = 0), (this._z = Math.atan2(l, s)));
					break;
				case "ZYX":
					(this._y = Math.asin(-Nn(h, -1, 1))), Math.abs(h) < 0.9999999 ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, s))) : ((this._x = 0), (this._z = Math.atan2(-a, c)));
					break;
				case "YZX":
					(this._z = Math.asin(Nn(l, -1, 1))), Math.abs(l) < 0.9999999 ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-h, s))) : ((this._x = 0), (this._y = Math.atan2(o, f)));
					break;
				case "XZY":
					(this._z = Math.asin(-Nn(a, -1, 1))), Math.abs(a) < 0.9999999 ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(o, s))) : ((this._x = Math.atan2(-u, f)), (this._y = 0));
					break;
				default:
					console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
			}
			return (this._order = t), i === !0 && this._onChangeCallback(), this;
		}
		setFromQuaternion(e, t, i) {
			return Tv.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Tv, t, i);
		}
		setFromVector3(e, t = this._order) {
			return this.set(e.x, e.y, e.z, t);
		}
		reorder(e) {
			return Mv.setFromEuler(this), this.setFromQuaternion(Mv, e);
		}
		equals(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
		}
		fromArray(e) {
			return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e;
		}
		_onChange(e) {
			return (this._onChangeCallback = e), this;
		}
		_onChangeCallback() {}
		*[Symbol.iterator]() {
			yield this._x, yield this._y, yield this._z, yield this._order;
		}
	}
	Un.DEFAULT_ORDER = "XYZ";
	class $p {
		constructor() {
			this.mask = 1;
		}
		set(e) {
			this.mask = ((1 << e) | 0) >>> 0;
		}
		enable(e) {
			this.mask |= (1 << e) | 0;
		}
		enableAll() {
			this.mask = -1;
		}
		toggle(e) {
			this.mask ^= (1 << e) | 0;
		}
		disable(e) {
			this.mask &= ~((1 << e) | 0);
		}
		disableAll() {
			this.mask = 0;
		}
		test(e) {
			return (this.mask & e.mask) !== 0;
		}
		isEnabled(e) {
			return (this.mask & ((1 << e) | 0)) !== 0;
		}
	}
	let tL = 0;
	const Av = new D(),
		Xa = new En(),
		Fr = new pt(),
		zc = new D(),
		cl = new D(),
		nL = new D(),
		iL = new En(),
		Cv = new D(1, 0, 0),
		Lv = new D(0, 1, 0),
		Rv = new D(0, 0, 1),
		Pv = { type: "added" },
		rL = { type: "removed" },
		$a = { type: "childadded", child: null },
		Sd = { type: "childremoved", child: null };
	class on extends Ns {
		constructor() {
			super(), (this.isObject3D = !0), Object.defineProperty(this, "id", { value: tL++ }), (this.uuid = yr()), (this.name = ""), (this.type = "Object3D"), (this.parent = null), (this.children = []), (this.up = on.DEFAULT_UP.clone());
			const e = new D(),
				t = new Un(),
				i = new En(),
				r = new D(1, 1, 1);
			function s() {
				i.setFromEuler(t, !1);
			}
			function a() {
				t.setFromQuaternion(i, void 0, !1);
			}
			t._onChange(s),
				i._onChange(a),
				Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new pt() }, normalMatrix: { value: new wt() } }),
				(this.matrix = new pt()),
				(this.matrixWorld = new pt()),
				(this.matrixAutoUpdate = on.DEFAULT_MATRIX_AUTO_UPDATE),
				(this.matrixWorldAutoUpdate = on.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
				(this.matrixWorldNeedsUpdate = !1),
				(this.layers = new $p()),
				(this.visible = !0),
				(this.castShadow = !1),
				(this.receiveShadow = !1),
				(this.frustumCulled = !0),
				(this.renderOrder = 0),
				(this.animations = []),
				(this.userData = {});
		}
		onBeforeShadow() {}
		onAfterShadow() {}
		onBeforeRender() {}
		onAfterRender() {}
		applyMatrix4(e) {
			this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
		}
		applyQuaternion(e) {
			return this.quaternion.premultiply(e), this;
		}
		setRotationFromAxisAngle(e, t) {
			this.quaternion.setFromAxisAngle(e, t);
		}
		setRotationFromEuler(e) {
			this.quaternion.setFromEuler(e, !0);
		}
		setRotationFromMatrix(e) {
			this.quaternion.setFromRotationMatrix(e);
		}
		setRotationFromQuaternion(e) {
			this.quaternion.copy(e);
		}
		rotateOnAxis(e, t) {
			return Xa.setFromAxisAngle(e, t), this.quaternion.multiply(Xa), this;
		}
		rotateOnWorldAxis(e, t) {
			return Xa.setFromAxisAngle(e, t), this.quaternion.premultiply(Xa), this;
		}
		rotateX(e) {
			return this.rotateOnAxis(Cv, e);
		}
		rotateY(e) {
			return this.rotateOnAxis(Lv, e);
		}
		rotateZ(e) {
			return this.rotateOnAxis(Rv, e);
		}
		translateOnAxis(e, t) {
			return Av.copy(e).applyQuaternion(this.quaternion), this.position.add(Av.multiplyScalar(t)), this;
		}
		translateX(e) {
			return this.translateOnAxis(Cv, e);
		}
		translateY(e) {
			return this.translateOnAxis(Lv, e);
		}
		translateZ(e) {
			return this.translateOnAxis(Rv, e);
		}
		localToWorld(e) {
			return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
		}
		worldToLocal(e) {
			return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Fr.copy(this.matrixWorld).invert());
		}
		lookAt(e, t, i) {
			e.isVector3 ? zc.copy(e) : zc.set(e, t, i);
			const r = this.parent;
			this.updateWorldMatrix(!0, !1), cl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fr.lookAt(cl, zc, this.up) : Fr.lookAt(zc, cl, this.up), this.quaternion.setFromRotationMatrix(Fr), r && (Fr.extractRotation(r.matrixWorld), Xa.setFromRotationMatrix(Fr), this.quaternion.premultiply(Xa.invert()));
		}
		add(e) {
			if (arguments.length > 1) {
				for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
				return this;
			}
			return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), (e.parent = this), this.children.push(e), e.dispatchEvent(Pv), ($a.child = e), this.dispatchEvent($a), ($a.child = null)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
		}
		remove(e) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
				return this;
			}
			const t = this.children.indexOf(e);
			return t !== -1 && ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(rL), (Sd.child = e), this.dispatchEvent(Sd), (Sd.child = null)), this;
		}
		removeFromParent() {
			const e = this.parent;
			return e !== null && e.remove(this), this;
		}
		clear() {
			return this.remove(...this.children);
		}
		attach(e) {
			return this.updateWorldMatrix(!0, !1), Fr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Fr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Fr), e.removeFromParent(), (e.parent = this), this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Pv), ($a.child = e), this.dispatchEvent($a), ($a.child = null), this;
		}
		getObjectById(e) {
			return this.getObjectByProperty("id", e);
		}
		getObjectByName(e) {
			return this.getObjectByProperty("name", e);
		}
		getObjectByProperty(e, t) {
			if (this[e] === t) return this;
			for (let i = 0, r = this.children.length; i < r; i++) {
				const a = this.children[i].getObjectByProperty(e, t);
				if (a !== void 0) return a;
			}
		}
		getObjectsByProperty(e, t, i = []) {
			this[e] === t && i.push(this);
			const r = this.children;
			for (let s = 0, a = r.length; s < a; s++) r[s].getObjectsByProperty(e, t, i);
			return i;
		}
		getWorldPosition(e) {
			return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
		}
		getWorldQuaternion(e) {
			return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cl, e, nL), e;
		}
		getWorldScale(e) {
			return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cl, iL, e), e;
		}
		getWorldDirection(e) {
			this.updateWorldMatrix(!0, !1);
			const t = this.matrixWorld.elements;
			return e.set(t[8], t[9], t[10]).normalize();
		}
		raycast() {}
		traverse(e) {
			e(this);
			const t = this.children;
			for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
		}
		traverseVisible(e) {
			if (this.visible === !1) return;
			e(this);
			const t = this.children;
			for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
		}
		traverseAncestors(e) {
			const t = this.parent;
			t !== null && (e(t), t.traverseAncestors(e));
		}
		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
		}
		updateMatrixWorld(e) {
			this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), (this.matrixWorldNeedsUpdate = !1), (e = !0));
			const t = this.children;
			for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e);
		}
		updateWorldMatrix(e, t) {
			const i = this.parent;
			if ((e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0)) {
				const r = this.children;
				for (let s = 0, a = r.length; s < a; s++) r[s].updateWorldMatrix(!1, !0);
			}
		}
		toJSON(e) {
			const t = e === void 0 || typeof e == "string",
				i = {};
			t && ((e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }), (i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }));
			const r = {};
			(r.uuid = this.uuid),
				(r.type = this.type),
				this.name !== "" && (r.name = this.name),
				this.castShadow === !0 && (r.castShadow = !0),
				this.receiveShadow === !0 && (r.receiveShadow = !0),
				this.visible === !1 && (r.visible = !1),
				this.frustumCulled === !1 && (r.frustumCulled = !1),
				this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
				Object.keys(this.userData).length > 0 && (r.userData = this.userData),
				(r.layers = this.layers.mask),
				(r.matrix = this.matrix.toArray()),
				(r.up = this.up.toArray()),
				this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
				this.isInstancedMesh && ((r.type = "InstancedMesh"), (r.count = this.count), (r.instanceMatrix = this.instanceMatrix.toJSON()), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
				this.isBatchedMesh &&
					((r.type = "BatchedMesh"),
					(r.perObjectFrustumCulled = this.perObjectFrustumCulled),
					(r.sortObjects = this.sortObjects),
					(r.drawRanges = this._drawRanges),
					(r.reservedRanges = this._reservedRanges),
					(r.visibility = this._visibility),
					(r.active = this._active),
					(r.bounds = this._bounds.map((o) => ({ boxInitialized: o.boxInitialized, boxMin: o.box.min.toArray(), boxMax: o.box.max.toArray(), sphereInitialized: o.sphereInitialized, sphereRadius: o.sphere.radius, sphereCenter: o.sphere.center.toArray() }))),
					(r.maxInstanceCount = this._maxInstanceCount),
					(r.maxVertexCount = this._maxVertexCount),
					(r.maxIndexCount = this._maxIndexCount),
					(r.geometryInitialized = this._geometryInitialized),
					(r.geometryCount = this._geometryCount),
					(r.matricesTexture = this._matricesTexture.toJSON(e)),
					this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
					this.boundingSphere !== null && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }),
					this.boundingBox !== null && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() }));
			function s(o, l) {
				return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
			}
			if (this.isScene) this.background && (this.background.isColor ? (r.background = this.background.toJSON()) : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
			else if (this.isMesh || this.isLine || this.isPoints) {
				r.geometry = s(e.geometries, this.geometry);
				const o = this.geometry.parameters;
				if (o !== void 0 && o.shapes !== void 0) {
					const l = o.shapes;
					if (Array.isArray(l))
						for (let c = 0, u = l.length; c < u; c++) {
							const h = l[c];
							s(e.shapes, h);
						}
					else s(e.shapes, l);
				}
			}
			if ((this.isSkinnedMesh && ((r.bindMode = this.bindMode), (r.bindMatrix = this.bindMatrix.toArray()), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))), this.material !== void 0))
				if (Array.isArray(this.material)) {
					const o = [];
					for (let l = 0, c = this.material.length; l < c; l++) o.push(s(e.materials, this.material[l]));
					r.material = o;
				} else r.material = s(e.materials, this.material);
			if (this.children.length > 0) {
				r.children = [];
				for (let o = 0; o < this.children.length; o++) r.children.push(this.children[o].toJSON(e).object);
			}
			if (this.animations.length > 0) {
				r.animations = [];
				for (let o = 0; o < this.animations.length; o++) {
					const l = this.animations[o];
					r.animations.push(s(e.animations, l));
				}
			}
			if (t) {
				const o = a(e.geometries),
					l = a(e.materials),
					c = a(e.textures),
					u = a(e.images),
					h = a(e.shapes),
					d = a(e.skeletons),
					f = a(e.animations),
					v = a(e.nodes);
				o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), v.length > 0 && (i.nodes = v);
			}
			return (i.object = r), i;
			function a(o) {
				const l = [];
				for (const c in o) {
					const u = o[c];
					delete u.metadata, l.push(u);
				}
				return l;
			}
		}
		clone(e) {
			return new this.constructor().copy(this, e);
		}
		copy(e, t = !0) {
			if (
				((this.name = e.name),
				this.up.copy(e.up),
				this.position.copy(e.position),
				(this.rotation.order = e.rotation.order),
				this.quaternion.copy(e.quaternion),
				this.scale.copy(e.scale),
				this.matrix.copy(e.matrix),
				this.matrixWorld.copy(e.matrixWorld),
				(this.matrixAutoUpdate = e.matrixAutoUpdate),
				(this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
				(this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
				(this.layers.mask = e.layers.mask),
				(this.visible = e.visible),
				(this.castShadow = e.castShadow),
				(this.receiveShadow = e.receiveShadow),
				(this.frustumCulled = e.frustumCulled),
				(this.renderOrder = e.renderOrder),
				(this.animations = e.animations.slice()),
				(this.userData = JSON.parse(JSON.stringify(e.userData))),
				t === !0)
			)
				for (let i = 0; i < e.children.length; i++) {
					const r = e.children[i];
					this.add(r.clone());
				}
			return this;
		}
	}
	on.DEFAULT_UP = new D(0, 1, 0);
	on.DEFAULT_MATRIX_AUTO_UPDATE = !0;
	on.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
	const Wi = new D(),
		Nr = new D(),
		Ed = new D(),
		Ur = new D(),
		qa = new D(),
		ja = new D(),
		Dv = new D(),
		wd = new D(),
		Td = new D(),
		Md = new D();
	class Qi {
		constructor(e = new D(), t = new D(), i = new D()) {
			(this.a = e), (this.b = t), (this.c = i);
		}
		static getNormal(e, t, i, r) {
			r.subVectors(i, t), Wi.subVectors(e, t), r.cross(Wi);
			const s = r.lengthSq();
			return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
		}
		static getBarycoord(e, t, i, r, s) {
			Wi.subVectors(r, t), Nr.subVectors(i, t), Ed.subVectors(e, t);
			const a = Wi.dot(Wi),
				o = Wi.dot(Nr),
				l = Wi.dot(Ed),
				c = Nr.dot(Nr),
				u = Nr.dot(Ed),
				h = a * c - o * o;
			if (h === 0) return s.set(0, 0, 0), null;
			const d = 1 / h,
				f = (c * l - o * u) * d,
				v = (a * u - o * l) * d;
			return s.set(1 - f - v, v, f);
		}
		static containsPoint(e, t, i, r) {
			return this.getBarycoord(e, t, i, r, Ur) === null ? !1 : Ur.x >= 0 && Ur.y >= 0 && Ur.x + Ur.y <= 1;
		}
		static getInterpolation(e, t, i, r, s, a, o, l) {
			return this.getBarycoord(e, t, i, r, Ur) === null ? ((l.x = 0), (l.y = 0), "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, Ur.x), l.addScaledVector(a, Ur.y), l.addScaledVector(o, Ur.z), l);
		}
		static isFrontFacing(e, t, i, r) {
			return Wi.subVectors(i, t), Nr.subVectors(e, t), Wi.cross(Nr).dot(r) < 0;
		}
		set(e, t, i) {
			return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
		}
		setFromPointsAndIndices(e, t, i, r) {
			return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
		}
		setFromAttributeAndIndices(e, t, i, r) {
			return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
		}
		getArea() {
			return Wi.subVectors(this.c, this.b), Nr.subVectors(this.a, this.b), Wi.cross(Nr).length() * 0.5;
		}
		getMidpoint(e) {
			return e
				.addVectors(this.a, this.b)
				.add(this.c)
				.multiplyScalar(1 / 3);
		}
		getNormal(e) {
			return Qi.getNormal(this.a, this.b, this.c, e);
		}
		getPlane(e) {
			return e.setFromCoplanarPoints(this.a, this.b, this.c);
		}
		getBarycoord(e, t) {
			return Qi.getBarycoord(e, this.a, this.b, this.c, t);
		}
		getInterpolation(e, t, i, r, s) {
			return Qi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
		}
		containsPoint(e) {
			return Qi.containsPoint(e, this.a, this.b, this.c);
		}
		isFrontFacing(e) {
			return Qi.isFrontFacing(this.a, this.b, this.c, e);
		}
		intersectsBox(e) {
			return e.intersectsTriangle(this);
		}
		closestPointToPoint(e, t) {
			const i = this.a,
				r = this.b,
				s = this.c;
			let a, o;
			qa.subVectors(r, i), ja.subVectors(s, i), wd.subVectors(e, i);
			const l = qa.dot(wd),
				c = ja.dot(wd);
			if (l <= 0 && c <= 0) return t.copy(i);
			Td.subVectors(e, r);
			const u = qa.dot(Td),
				h = ja.dot(Td);
			if (u >= 0 && h <= u) return t.copy(r);
			const d = l * h - u * c;
			if (d <= 0 && l >= 0 && u <= 0) return (a = l / (l - u)), t.copy(i).addScaledVector(qa, a);
			Md.subVectors(e, s);
			const f = qa.dot(Md),
				v = ja.dot(Md);
			if (v >= 0 && f <= v) return t.copy(s);
			const _ = f * c - l * v;
			if (_ <= 0 && c >= 0 && v <= 0) return (o = c / (c - v)), t.copy(i).addScaledVector(ja, o);
			const p = u * v - f * h;
			if (p <= 0 && h - u >= 0 && f - v >= 0) return Dv.subVectors(s, r), (o = (h - u) / (h - u + (f - v))), t.copy(r).addScaledVector(Dv, o);
			const g = 1 / (p + _ + d);
			return (a = _ * g), (o = d * g), t.copy(i).addScaledVector(qa, a).addScaledVector(ja, o);
		}
		equals(e) {
			return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
		}
	}
	const tx = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		},
		hs = { h: 0, s: 0, l: 0 },
		Hc = { h: 0, s: 0, l: 0 };
	function Ad(n, e, t) {
		return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
	}
	class rt {
		constructor(e, t, i) {
			return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, i);
		}
		set(e, t, i) {
			if (t === void 0 && i === void 0) {
				const r = e;
				r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
			} else this.setRGB(e, t, i);
			return this;
		}
		setScalar(e) {
			return (this.r = e), (this.g = e), (this.b = e), this;
		}
		setHex(e, t = ni) {
			return (e = Math.floor(e)), (this.r = ((e >> 16) & 255) / 255), (this.g = ((e >> 8) & 255) / 255), (this.b = (e & 255) / 255), zt.toWorkingColorSpace(this, t), this;
		}
		setRGB(e, t, i, r = zt.workingColorSpace) {
			return (this.r = e), (this.g = t), (this.b = i), zt.toWorkingColorSpace(this, r), this;
		}
		setHSL(e, t, i, r = zt.workingColorSpace) {
			if (((e = Xp(e, 1)), (t = Nn(t, 0, 1)), (i = Nn(i, 0, 1)), t === 0)) this.r = this.g = this.b = i;
			else {
				const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
					a = 2 * i - s;
				(this.r = Ad(a, s, e + 1 / 3)), (this.g = Ad(a, s, e)), (this.b = Ad(a, s, e - 1 / 3));
			}
			return zt.toWorkingColorSpace(this, r), this;
		}
		setStyle(e, t = ni) {
			function i(s) {
				s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
			}
			let r;
			if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
				let s;
				const a = r[1],
					o = r[2];
				switch (a) {
					case "rgb":
					case "rgba":
						if ((s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
						if ((s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
						break;
					case "hsl":
					case "hsla":
						if ((s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
						break;
					default:
						console.warn("THREE.Color: Unknown color model " + e);
				}
			} else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
				const s = r[1],
					a = s.length;
				if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
				if (a === 6) return this.setHex(parseInt(s, 16), t);
				console.warn("THREE.Color: Invalid hex color " + e);
			} else if (e && e.length > 0) return this.setColorName(e, t);
			return this;
		}
		setColorName(e, t = ni) {
			const i = tx[e.toLowerCase()];
			return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
		}
		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}
		copy(e) {
			return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
		}
		copySRGBToLinear(e) {
			return (this.r = wo(e.r)), (this.g = wo(e.g)), (this.b = wo(e.b)), this;
		}
		copyLinearToSRGB(e) {
			return (this.r = pd(e.r)), (this.g = pd(e.g)), (this.b = pd(e.b)), this;
		}
		convertSRGBToLinear() {
			return this.copySRGBToLinear(this), this;
		}
		convertLinearToSRGB() {
			return this.copyLinearToSRGB(this), this;
		}
		getHex(e = ni) {
			return zt.fromWorkingColorSpace(Xn.copy(this), e), Math.round(Nn(Xn.r * 255, 0, 255)) * 65536 + Math.round(Nn(Xn.g * 255, 0, 255)) * 256 + Math.round(Nn(Xn.b * 255, 0, 255));
		}
		getHexString(e = ni) {
			return ("000000" + this.getHex(e).toString(16)).slice(-6);
		}
		getHSL(e, t = zt.workingColorSpace) {
			zt.fromWorkingColorSpace(Xn.copy(this), t);
			const i = Xn.r,
				r = Xn.g,
				s = Xn.b,
				a = Math.max(i, r, s),
				o = Math.min(i, r, s);
			let l, c;
			const u = (o + a) / 2;
			if (o === a) (l = 0), (c = 0);
			else {
				const h = a - o;
				switch (((c = u <= 0.5 ? h / (a + o) : h / (2 - a - o)), a)) {
					case i:
						l = (r - s) / h + (r < s ? 6 : 0);
						break;
					case r:
						l = (s - i) / h + 2;
						break;
					case s:
						l = (i - r) / h + 4;
						break;
				}
				l /= 6;
			}
			return (e.h = l), (e.s = c), (e.l = u), e;
		}
		getRGB(e, t = zt.workingColorSpace) {
			return zt.fromWorkingColorSpace(Xn.copy(this), t), (e.r = Xn.r), (e.g = Xn.g), (e.b = Xn.b), e;
		}
		getStyle(e = ni) {
			zt.fromWorkingColorSpace(Xn.copy(this), e);
			const t = Xn.r,
				i = Xn.g,
				r = Xn.b;
			return e !== ni ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
		}
		offsetHSL(e, t, i) {
			return this.getHSL(hs), this.setHSL(hs.h + e, hs.s + t, hs.l + i);
		}
		add(e) {
			return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
		}
		addColors(e, t) {
			return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
		}
		addScalar(e) {
			return (this.r += e), (this.g += e), (this.b += e), this;
		}
		sub(e) {
			return (this.r = Math.max(0, this.r - e.r)), (this.g = Math.max(0, this.g - e.g)), (this.b = Math.max(0, this.b - e.b)), this;
		}
		multiply(e) {
			return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
		}
		multiplyScalar(e) {
			return (this.r *= e), (this.g *= e), (this.b *= e), this;
		}
		lerp(e, t) {
			return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
		}
		lerpColors(e, t, i) {
			return (this.r = e.r + (t.r - e.r) * i), (this.g = e.g + (t.g - e.g) * i), (this.b = e.b + (t.b - e.b) * i), this;
		}
		lerpHSL(e, t) {
			this.getHSL(hs), e.getHSL(Hc);
			const i = Al(hs.h, Hc.h, t),
				r = Al(hs.s, Hc.s, t),
				s = Al(hs.l, Hc.l, t);
			return this.setHSL(i, r, s), this;
		}
		setFromVector3(e) {
			return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
		}
		applyMatrix3(e) {
			const t = this.r,
				i = this.g,
				r = this.b,
				s = e.elements;
			return (this.r = s[0] * t + s[3] * i + s[6] * r), (this.g = s[1] * t + s[4] * i + s[7] * r), (this.b = s[2] * t + s[5] * i + s[8] * r), this;
		}
		equals(e) {
			return e.r === this.r && e.g === this.g && e.b === this.b;
		}
		fromArray(e, t = 0) {
			return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
		}
		toArray(e = [], t = 0) {
			return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
		}
		fromBufferAttribute(e, t) {
			return (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this;
		}
		toJSON() {
			return this.getHex();
		}
		*[Symbol.iterator]() {
			yield this.r, yield this.g, yield this.b;
		}
	}
	const Xn = new rt();
	rt.NAMES = tx;
	let sL = 0;
	class Er extends Ns {
		constructor() {
			super(),
				(this.isMaterial = !0),
				Object.defineProperty(this, "id", { value: sL++ }),
				(this.uuid = yr()),
				(this.name = ""),
				(this.type = "Material"),
				(this.blending = bo),
				(this.side = Kr),
				(this.vertexColors = !1),
				(this.opacity = 1),
				(this.transparent = !1),
				(this.alphaHash = !1),
				(this.blendSrc = xf),
				(this.blendDst = bf),
				(this.blendEquation = aa),
				(this.blendSrcAlpha = null),
				(this.blendDstAlpha = null),
				(this.blendEquationAlpha = null),
				(this.blendColor = new rt(0, 0, 0)),
				(this.blendAlpha = 0),
				(this.depthFunc = Wu),
				(this.depthTest = !0),
				(this.depthWrite = !0),
				(this.stencilWriteMask = 255),
				(this.stencilFunc = _v),
				(this.stencilRef = 0),
				(this.stencilFuncMask = 255),
				(this.stencilFail = Ba),
				(this.stencilZFail = Ba),
				(this.stencilZPass = Ba),
				(this.stencilWrite = !1),
				(this.clippingPlanes = null),
				(this.clipIntersection = !1),
				(this.clipShadows = !1),
				(this.shadowSide = null),
				(this.colorWrite = !0),
				(this.precision = null),
				(this.polygonOffset = !1),
				(this.polygonOffsetFactor = 0),
				(this.polygonOffsetUnits = 0),
				(this.dithering = !1),
				(this.alphaToCoverage = !1),
				(this.premultipliedAlpha = !1),
				(this.forceSinglePass = !1),
				(this.visible = !0),
				(this.toneMapped = !0),
				(this.userData = {}),
				(this.version = 0),
				(this._alphaTest = 0);
		}
		get alphaTest() {
			return this._alphaTest;
		}
		set alphaTest(e) {
			this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
		}
		onBeforeCompile() {}
		customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		}
		setValues(e) {
			if (e !== void 0)
				for (const t in e) {
					const i = e[t];
					if (i === void 0) {
						console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
						continue;
					}
					const r = this[t];
					if (r === void 0) {
						console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
						continue;
					}
					r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : (this[t] = i);
				}
		}
		toJSON(e) {
			const t = e === void 0 || typeof e == "string";
			t && (e = { textures: {}, images: {} });
			const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
			(i.uuid = this.uuid),
				(i.type = this.type),
				this.name !== "" && (i.name = this.name),
				this.color && this.color.isColor && (i.color = this.color.getHex()),
				this.roughness !== void 0 && (i.roughness = this.roughness),
				this.metalness !== void 0 && (i.metalness = this.metalness),
				this.sheen !== void 0 && (i.sheen = this.sheen),
				this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
				this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
				this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
				this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
				this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
				this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
				this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
				this.shininess !== void 0 && (i.shininess = this.shininess),
				this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
				this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
				this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
				this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
				this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid), (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
				this.dispersion !== void 0 && (i.dispersion = this.dispersion),
				this.iridescence !== void 0 && (i.iridescence = this.iridescence),
				this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
				this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
				this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
				this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
				this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
				this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
				this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
				this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
				this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
				this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
				this.lightMap && this.lightMap.isTexture && ((i.lightMap = this.lightMap.toJSON(e).uuid), (i.lightMapIntensity = this.lightMapIntensity)),
				this.aoMap && this.aoMap.isTexture && ((i.aoMap = this.aoMap.toJSON(e).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
				this.bumpMap && this.bumpMap.isTexture && ((i.bumpMap = this.bumpMap.toJSON(e).uuid), (i.bumpScale = this.bumpScale)),
				this.normalMap && this.normalMap.isTexture && ((i.normalMap = this.normalMap.toJSON(e).uuid), (i.normalMapType = this.normalMapType), (i.normalScale = this.normalScale.toArray())),
				this.displacementMap && this.displacementMap.isTexture && ((i.displacementMap = this.displacementMap.toJSON(e).uuid), (i.displacementScale = this.displacementScale), (i.displacementBias = this.displacementBias)),
				this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
				this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
				this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
				this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
				this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
				this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
				this.envMap && this.envMap.isTexture && ((i.envMap = this.envMap.toJSON(e).uuid), this.combine !== void 0 && (i.combine = this.combine)),
				this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
				this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
				this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
				this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
				this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
				this.transmission !== void 0 && (i.transmission = this.transmission),
				this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
				this.thickness !== void 0 && (i.thickness = this.thickness),
				this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
				this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
				this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
				this.size !== void 0 && (i.size = this.size),
				this.shadowSide !== null && (i.shadowSide = this.shadowSide),
				this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
				this.blending !== bo && (i.blending = this.blending),
				this.side !== Kr && (i.side = this.side),
				this.vertexColors === !0 && (i.vertexColors = !0),
				this.opacity < 1 && (i.opacity = this.opacity),
				this.transparent === !0 && (i.transparent = !0),
				this.blendSrc !== xf && (i.blendSrc = this.blendSrc),
				this.blendDst !== bf && (i.blendDst = this.blendDst),
				this.blendEquation !== aa && (i.blendEquation = this.blendEquation),
				this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
				this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
				this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
				this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
				this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
				this.depthFunc !== Wu && (i.depthFunc = this.depthFunc),
				this.depthTest === !1 && (i.depthTest = this.depthTest),
				this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
				this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
				this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
				this.stencilFunc !== _v && (i.stencilFunc = this.stencilFunc),
				this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
				this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
				this.stencilFail !== Ba && (i.stencilFail = this.stencilFail),
				this.stencilZFail !== Ba && (i.stencilZFail = this.stencilZFail),
				this.stencilZPass !== Ba && (i.stencilZPass = this.stencilZPass),
				this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
				this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
				this.polygonOffset === !0 && (i.polygonOffset = !0),
				this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
				this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
				this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
				this.dashSize !== void 0 && (i.dashSize = this.dashSize),
				this.gapSize !== void 0 && (i.gapSize = this.gapSize),
				this.scale !== void 0 && (i.scale = this.scale),
				this.dithering === !0 && (i.dithering = !0),
				this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
				this.alphaHash === !0 && (i.alphaHash = !0),
				this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
				this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
				this.forceSinglePass === !0 && (i.forceSinglePass = !0),
				this.wireframe === !0 && (i.wireframe = !0),
				this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
				this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
				this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
				this.flatShading === !0 && (i.flatShading = !0),
				this.visible === !1 && (i.visible = !1),
				this.toneMapped === !1 && (i.toneMapped = !1),
				this.fog === !1 && (i.fog = !1),
				Object.keys(this.userData).length > 0 && (i.userData = this.userData);
			function r(s) {
				const a = [];
				for (const o in s) {
					const l = s[o];
					delete l.metadata, a.push(l);
				}
				return a;
			}
			if (t) {
				const s = r(e.textures),
					a = r(e.images);
				s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
			}
			return i;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			(this.name = e.name),
				(this.blending = e.blending),
				(this.side = e.side),
				(this.vertexColors = e.vertexColors),
				(this.opacity = e.opacity),
				(this.transparent = e.transparent),
				(this.blendSrc = e.blendSrc),
				(this.blendDst = e.blendDst),
				(this.blendEquation = e.blendEquation),
				(this.blendSrcAlpha = e.blendSrcAlpha),
				(this.blendDstAlpha = e.blendDstAlpha),
				(this.blendEquationAlpha = e.blendEquationAlpha),
				this.blendColor.copy(e.blendColor),
				(this.blendAlpha = e.blendAlpha),
				(this.depthFunc = e.depthFunc),
				(this.depthTest = e.depthTest),
				(this.depthWrite = e.depthWrite),
				(this.stencilWriteMask = e.stencilWriteMask),
				(this.stencilFunc = e.stencilFunc),
				(this.stencilRef = e.stencilRef),
				(this.stencilFuncMask = e.stencilFuncMask),
				(this.stencilFail = e.stencilFail),
				(this.stencilZFail = e.stencilZFail),
				(this.stencilZPass = e.stencilZPass),
				(this.stencilWrite = e.stencilWrite);
			const t = e.clippingPlanes;
			let i = null;
			if (t !== null) {
				const r = t.length;
				i = new Array(r);
				for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
			}
			return (
				(this.clippingPlanes = i),
				(this.clipIntersection = e.clipIntersection),
				(this.clipShadows = e.clipShadows),
				(this.shadowSide = e.shadowSide),
				(this.colorWrite = e.colorWrite),
				(this.precision = e.precision),
				(this.polygonOffset = e.polygonOffset),
				(this.polygonOffsetFactor = e.polygonOffsetFactor),
				(this.polygonOffsetUnits = e.polygonOffsetUnits),
				(this.dithering = e.dithering),
				(this.alphaTest = e.alphaTest),
				(this.alphaHash = e.alphaHash),
				(this.alphaToCoverage = e.alphaToCoverage),
				(this.premultipliedAlpha = e.premultipliedAlpha),
				(this.forceSinglePass = e.forceSinglePass),
				(this.visible = e.visible),
				(this.toneMapped = e.toneMapped),
				(this.userData = JSON.parse(JSON.stringify(e.userData))),
				this
			);
		}
		dispose() {
			this.dispatchEvent({ type: "dispose" });
		}
		set needsUpdate(e) {
			e === !0 && this.version++;
		}
		onBuild() {
			console.warn("Material: onBuild() has been removed.");
		}
		onBeforeRender() {
			console.warn("Material: onBeforeRender() has been removed.");
		}
	}
	class Kt extends Er {
		constructor(e) {
			super(),
				(this.isMeshBasicMaterial = !0),
				(this.type = "MeshBasicMaterial"),
				(this.color = new rt(16777215)),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.specularMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.envMapRotation = new Un()),
				(this.combine = Up),
				(this.reflectivity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.fog = !0),
				this.setValues(e);
		}
		copy(e) {
			return (
				super.copy(e),
				this.color.copy(e.color),
				(this.map = e.map),
				(this.lightMap = e.lightMap),
				(this.lightMapIntensity = e.lightMapIntensity),
				(this.aoMap = e.aoMap),
				(this.aoMapIntensity = e.aoMapIntensity),
				(this.specularMap = e.specularMap),
				(this.alphaMap = e.alphaMap),
				(this.envMap = e.envMap),
				this.envMapRotation.copy(e.envMapRotation),
				(this.combine = e.combine),
				(this.reflectivity = e.reflectivity),
				(this.refractionRatio = e.refractionRatio),
				(this.wireframe = e.wireframe),
				(this.wireframeLinewidth = e.wireframeLinewidth),
				(this.wireframeLinecap = e.wireframeLinecap),
				(this.wireframeLinejoin = e.wireframeLinejoin),
				(this.fog = e.fog),
				this
			);
		}
	}
	const vn = new D(),
		Gc = new Se();
	class mn {
		constructor(e, t, i = !1) {
			if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
			(this.isBufferAttribute = !0), (this.name = ""), (this.array = e), (this.itemSize = t), (this.count = e !== void 0 ? e.length / t : 0), (this.normalized = i), (this.usage = Zf), (this._updateRange = { offset: 0, count: -1 }), (this.updateRanges = []), (this.gpuType = Hr), (this.version = 0);
		}
		onUploadCallback() {}
		set needsUpdate(e) {
			e === !0 && this.version++;
		}
		get updateRange() {
			return Eo("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
		}
		setUsage(e) {
			return (this.usage = e), this;
		}
		addUpdateRange(e, t) {
			this.updateRanges.push({ start: e, count: t });
		}
		clearUpdateRanges() {
			this.updateRanges.length = 0;
		}
		copy(e) {
			return (this.name = e.name), (this.array = new e.array.constructor(e.array)), (this.itemSize = e.itemSize), (this.count = e.count), (this.normalized = e.normalized), (this.usage = e.usage), (this.gpuType = e.gpuType), this;
		}
		copyAt(e, t, i) {
			(e *= this.itemSize), (i *= t.itemSize);
			for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
			return this;
		}
		copyArray(e) {
			return this.array.set(e), this;
		}
		applyMatrix3(e) {
			if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) Gc.fromBufferAttribute(this, t), Gc.applyMatrix3(e), this.setXY(t, Gc.x, Gc.y);
			else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) vn.fromBufferAttribute(this, t), vn.applyMatrix3(e), this.setXYZ(t, vn.x, vn.y, vn.z);
			return this;
		}
		applyMatrix4(e) {
			for (let t = 0, i = this.count; t < i; t++) vn.fromBufferAttribute(this, t), vn.applyMatrix4(e), this.setXYZ(t, vn.x, vn.y, vn.z);
			return this;
		}
		applyNormalMatrix(e) {
			for (let t = 0, i = this.count; t < i; t++) vn.fromBufferAttribute(this, t), vn.applyNormalMatrix(e), this.setXYZ(t, vn.x, vn.y, vn.z);
			return this;
		}
		transformDirection(e) {
			for (let t = 0, i = this.count; t < i; t++) vn.fromBufferAttribute(this, t), vn.transformDirection(e), this.setXYZ(t, vn.x, vn.y, vn.z);
			return this;
		}
		set(e, t = 0) {
			return this.array.set(e, t), this;
		}
		getComponent(e, t) {
			let i = this.array[e * this.itemSize + t];
			return this.normalized && (i = Ji(i, this.array)), i;
		}
		setComponent(e, t, i) {
			return this.normalized && (i = Vt(i, this.array)), (this.array[e * this.itemSize + t] = i), this;
		}
		getX(e) {
			let t = this.array[e * this.itemSize];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		setX(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.array[e * this.itemSize] = t), this;
		}
		getY(e) {
			let t = this.array[e * this.itemSize + 1];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		setY(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.array[e * this.itemSize + 1] = t), this;
		}
		getZ(e) {
			let t = this.array[e * this.itemSize + 2];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		setZ(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.array[e * this.itemSize + 2] = t), this;
		}
		getW(e) {
			let t = this.array[e * this.itemSize + 3];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		setW(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.array[e * this.itemSize + 3] = t), this;
		}
		setXY(e, t, i) {
			return (e *= this.itemSize), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array))), (this.array[e + 0] = t), (this.array[e + 1] = i), this;
		}
		setXYZ(e, t, i, r) {
			return (e *= this.itemSize), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array)), (r = Vt(r, this.array))), (this.array[e + 0] = t), (this.array[e + 1] = i), (this.array[e + 2] = r), this;
		}
		setXYZW(e, t, i, r, s) {
			return (e *= this.itemSize), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array)), (r = Vt(r, this.array)), (s = Vt(s, this.array))), (this.array[e + 0] = t), (this.array[e + 1] = i), (this.array[e + 2] = r), (this.array[e + 3] = s), this;
		}
		onUpload(e) {
			return (this.onUploadCallback = e), this;
		}
		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}
		toJSON() {
			const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
			return this.name !== "" && (e.name = this.name), this.usage !== Zf && (e.usage = this.usage), e;
		}
	}
	class nx extends mn {
		constructor(e, t, i) {
			super(new Uint16Array(e), t, i);
		}
	}
	class ix extends mn {
		constructor(e, t, i) {
			super(new Uint32Array(e), t, i);
		}
	}
	class Tt extends mn {
		constructor(e, t, i) {
			super(new Float32Array(e), t, i);
		}
	}
	let aL = 0;
	const Mi = new pt(),
		Cd = new on(),
		Ya = new D(),
		hi = new Tr(),
		ul = new Tr(),
		Pn = new D();
	class bt extends Ns {
		constructor() {
			super(), (this.isBufferGeometry = !0), Object.defineProperty(this, "id", { value: aL++ }), (this.uuid = yr()), (this.name = ""), (this.type = "BufferGeometry"), (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.morphTargetsRelative = !1), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null), (this.drawRange = { start: 0, count: 1 / 0 }), (this.userData = {});
		}
		getIndex() {
			return this.index;
		}
		setIndex(e) {
			return Array.isArray(e) ? (this.index = new (Jy(e) ? ix : nx)(e, 1)) : (this.index = e), this;
		}
		getAttribute(e) {
			return this.attributes[e];
		}
		setAttribute(e, t) {
			return (this.attributes[e] = t), this;
		}
		deleteAttribute(e) {
			return delete this.attributes[e], this;
		}
		hasAttribute(e) {
			return this.attributes[e] !== void 0;
		}
		addGroup(e, t, i = 0) {
			this.groups.push({ start: e, count: t, materialIndex: i });
		}
		clearGroups() {
			this.groups = [];
		}
		setDrawRange(e, t) {
			(this.drawRange.start = e), (this.drawRange.count = t);
		}
		applyMatrix4(e) {
			const t = this.attributes.position;
			t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
			const i = this.attributes.normal;
			if (i !== void 0) {
				const s = new wt().getNormalMatrix(e);
				i.applyNormalMatrix(s), (i.needsUpdate = !0);
			}
			const r = this.attributes.tangent;
			return r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
		}
		applyQuaternion(e) {
			return Mi.makeRotationFromQuaternion(e), this.applyMatrix4(Mi), this;
		}
		rotateX(e) {
			return Mi.makeRotationX(e), this.applyMatrix4(Mi), this;
		}
		rotateY(e) {
			return Mi.makeRotationY(e), this.applyMatrix4(Mi), this;
		}
		rotateZ(e) {
			return Mi.makeRotationZ(e), this.applyMatrix4(Mi), this;
		}
		translate(e, t, i) {
			return Mi.makeTranslation(e, t, i), this.applyMatrix4(Mi), this;
		}
		scale(e, t, i) {
			return Mi.makeScale(e, t, i), this.applyMatrix4(Mi), this;
		}
		lookAt(e) {
			return Cd.lookAt(e), Cd.updateMatrix(), this.applyMatrix4(Cd.matrix), this;
		}
		center() {
			return this.computeBoundingBox(), this.boundingBox.getCenter(Ya).negate(), this.translate(Ya.x, Ya.y, Ya.z), this;
		}
		setFromPoints(e) {
			const t = [];
			for (let i = 0, r = e.length; i < r; i++) {
				const s = e[i];
				t.push(s.x, s.y, s.z || 0);
			}
			return this.setAttribute("position", new Tt(t, 3)), this;
		}
		computeBoundingBox() {
			this.boundingBox === null && (this.boundingBox = new Tr());
			const e = this.attributes.position,
				t = this.morphAttributes.position;
			if (e && e.isGLBufferAttribute) {
				console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0));
				return;
			}
			if (e !== void 0) {
				if ((this.boundingBox.setFromBufferAttribute(e), t))
					for (let i = 0, r = t.length; i < r; i++) {
						const s = t[i];
						hi.setFromBufferAttribute(s), this.morphTargetsRelative ? (Pn.addVectors(this.boundingBox.min, hi.min), this.boundingBox.expandByPoint(Pn), Pn.addVectors(this.boundingBox.max, hi.max), this.boundingBox.expandByPoint(Pn)) : (this.boundingBox.expandByPoint(hi.min), this.boundingBox.expandByPoint(hi.max));
					}
			} else this.boundingBox.makeEmpty();
			(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
		}
		computeBoundingSphere() {
			this.boundingSphere === null && (this.boundingSphere = new $o());
			const e = this.attributes.position,
				t = this.morphAttributes.position;
			if (e && e.isGLBufferAttribute) {
				console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new D(), 1 / 0);
				return;
			}
			if (e) {
				const i = this.boundingSphere.center;
				if ((hi.setFromBufferAttribute(e), t))
					for (let s = 0, a = t.length; s < a; s++) {
						const o = t[s];
						ul.setFromBufferAttribute(o), this.morphTargetsRelative ? (Pn.addVectors(hi.min, ul.min), hi.expandByPoint(Pn), Pn.addVectors(hi.max, ul.max), hi.expandByPoint(Pn)) : (hi.expandByPoint(ul.min), hi.expandByPoint(ul.max));
					}
				hi.getCenter(i);
				let r = 0;
				for (let s = 0, a = e.count; s < a; s++) Pn.fromBufferAttribute(e, s), (r = Math.max(r, i.distanceToSquared(Pn)));
				if (t)
					for (let s = 0, a = t.length; s < a; s++) {
						const o = t[s],
							l = this.morphTargetsRelative;
						for (let c = 0, u = o.count; c < u; c++) Pn.fromBufferAttribute(o, c), l && (Ya.fromBufferAttribute(e, c), Pn.add(Ya)), (r = Math.max(r, i.distanceToSquared(Pn)));
					}
				(this.boundingSphere.radius = Math.sqrt(r)), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
			}
		}
		computeTangents() {
			const e = this.index,
				t = this.attributes;
			if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
				console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
				return;
			}
			const i = t.position,
				r = t.normal,
				s = t.uv;
			this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new mn(new Float32Array(4 * i.count), 4));
			const a = this.getAttribute("tangent"),
				o = [],
				l = [];
			for (let w = 0; w < i.count; w++) (o[w] = new D()), (l[w] = new D());
			const c = new D(),
				u = new D(),
				h = new D(),
				d = new Se(),
				f = new Se(),
				v = new Se(),
				_ = new D(),
				p = new D();
			function g(w, y, S) {
				c.fromBufferAttribute(i, w), u.fromBufferAttribute(i, y), h.fromBufferAttribute(i, S), d.fromBufferAttribute(s, w), f.fromBufferAttribute(s, y), v.fromBufferAttribute(s, S), u.sub(c), h.sub(c), f.sub(d), v.sub(d);
				const L = 1 / (f.x * v.y - v.x * f.y);
				isFinite(L) && (_.copy(u).multiplyScalar(v.y).addScaledVector(h, -f.y).multiplyScalar(L), p.copy(h).multiplyScalar(f.x).addScaledVector(u, -v.x).multiplyScalar(L), o[w].add(_), o[y].add(_), o[S].add(_), l[w].add(p), l[y].add(p), l[S].add(p));
			}
			let x = this.groups;
			x.length === 0 && (x = [{ start: 0, count: e.count }]);
			for (let w = 0, y = x.length; w < y; ++w) {
				const S = x[w],
					L = S.start,
					N = S.count;
				for (let k = L, B = L + N; k < B; k += 3) g(e.getX(k + 0), e.getX(k + 1), e.getX(k + 2));
			}
			const b = new D(),
				T = new D(),
				P = new D(),
				A = new D();
			function M(w) {
				P.fromBufferAttribute(r, w), A.copy(P);
				const y = o[w];
				b.copy(y), b.sub(P.multiplyScalar(P.dot(y))).normalize(), T.crossVectors(A, y);
				const L = T.dot(l[w]) < 0 ? -1 : 1;
				a.setXYZW(w, b.x, b.y, b.z, L);
			}
			for (let w = 0, y = x.length; w < y; ++w) {
				const S = x[w],
					L = S.start,
					N = S.count;
				for (let k = L, B = L + N; k < B; k += 3) M(e.getX(k + 0)), M(e.getX(k + 1)), M(e.getX(k + 2));
			}
		}
		computeVertexNormals() {
			const e = this.index,
				t = this.getAttribute("position");
			if (t !== void 0) {
				let i = this.getAttribute("normal");
				if (i === void 0) (i = new mn(new Float32Array(t.count * 3), 3)), this.setAttribute("normal", i);
				else for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
				const r = new D(),
					s = new D(),
					a = new D(),
					o = new D(),
					l = new D(),
					c = new D(),
					u = new D(),
					h = new D();
				if (e)
					for (let d = 0, f = e.count; d < f; d += 3) {
						const v = e.getX(d + 0),
							_ = e.getX(d + 1),
							p = e.getX(d + 2);
						r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, _), a.fromBufferAttribute(t, p), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), o.fromBufferAttribute(i, v), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, p), o.add(u), l.add(u), c.add(u), i.setXYZ(v, o.x, o.y, o.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(p, c.x, c.y, c.z);
					}
				else for (let d = 0, f = t.count; d < f; d += 3) r.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
				this.normalizeNormals(), (i.needsUpdate = !0);
			}
		}
		normalizeNormals() {
			const e = this.attributes.normal;
			for (let t = 0, i = e.count; t < i; t++) Pn.fromBufferAttribute(e, t), Pn.normalize(), e.setXYZ(t, Pn.x, Pn.y, Pn.z);
		}
		toNonIndexed() {
			function e(o, l) {
				const c = o.array,
					u = o.itemSize,
					h = o.normalized,
					d = new c.constructor(l.length * u);
				let f = 0,
					v = 0;
				for (let _ = 0, p = l.length; _ < p; _++) {
					o.isInterleavedBufferAttribute ? (f = l[_] * o.data.stride + o.offset) : (f = l[_] * u);
					for (let g = 0; g < u; g++) d[v++] = c[f++];
				}
				return new mn(d, u, h);
			}
			if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
			const t = new bt(),
				i = this.index.array,
				r = this.attributes;
			for (const o in r) {
				const l = r[o],
					c = e(l, i);
				t.setAttribute(o, c);
			}
			const s = this.morphAttributes;
			for (const o in s) {
				const l = [],
					c = s[o];
				for (let u = 0, h = c.length; u < h; u++) {
					const d = c[u],
						f = e(d, i);
					l.push(f);
				}
				t.morphAttributes[o] = l;
			}
			t.morphTargetsRelative = this.morphTargetsRelative;
			const a = this.groups;
			for (let o = 0, l = a.length; o < l; o++) {
				const c = a[o];
				t.addGroup(c.start, c.count, c.materialIndex);
			}
			return t;
		}
		toJSON() {
			const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
			if (((e.uuid = this.uuid), (e.type = this.type), this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0)) {
				const l = this.parameters;
				for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
				return e;
			}
			e.data = { attributes: {} };
			const t = this.index;
			t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
			const i = this.attributes;
			for (const l in i) {
				const c = i[l];
				e.data.attributes[l] = c.toJSON(e.data);
			}
			const r = {};
			let s = !1;
			for (const l in this.morphAttributes) {
				const c = this.morphAttributes[l],
					u = [];
				for (let h = 0, d = c.length; h < d; h++) {
					const f = c[h];
					u.push(f.toJSON(e.data));
				}
				u.length > 0 && ((r[l] = u), (s = !0));
			}
			s && ((e.data.morphAttributes = r), (e.data.morphTargetsRelative = this.morphTargetsRelative));
			const a = this.groups;
			a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
			const o = this.boundingSphere;
			return o !== null && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			(this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null);
			const t = {};
			this.name = e.name;
			const i = e.index;
			i !== null && this.setIndex(i.clone(t));
			const r = e.attributes;
			for (const c in r) {
				const u = r[c];
				this.setAttribute(c, u.clone(t));
			}
			const s = e.morphAttributes;
			for (const c in s) {
				const u = [],
					h = s[c];
				for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
				this.morphAttributes[c] = u;
			}
			this.morphTargetsRelative = e.morphTargetsRelative;
			const a = e.groups;
			for (let c = 0, u = a.length; c < u; c++) {
				const h = a[c];
				this.addGroup(h.start, h.count, h.materialIndex);
			}
			const o = e.boundingBox;
			o !== null && (this.boundingBox = o.clone());
			const l = e.boundingSphere;
			return l !== null && (this.boundingSphere = l.clone()), (this.drawRange.start = e.drawRange.start), (this.drawRange.count = e.drawRange.count), (this.userData = e.userData), this;
		}
		dispose() {
			this.dispatchEvent({ type: "dispose" });
		}
	}
	const Ov = new pt(),
		Ys = new _h(),
		Vc = new $o(),
		Iv = new D(),
		Ka = new D(),
		Za = new D(),
		Ja = new D(),
		Ld = new D(),
		Wc = new D(),
		Xc = new Se(),
		$c = new Se(),
		qc = new Se(),
		Fv = new D(),
		Nv = new D(),
		Uv = new D(),
		jc = new D(),
		Yc = new D();
	class Re extends on {
		constructor(e = new bt(), t = new Kt()) {
			super(), (this.isMesh = !0), (this.type = "Mesh"), (this.geometry = e), (this.material = t), this.updateMorphTargets();
		}
		copy(e, t) {
			return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), (this.material = Array.isArray(e.material) ? e.material.slice() : e.material), (this.geometry = e.geometry), this;
		}
		updateMorphTargets() {
			const t = this.geometry.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const r = t[i[0]];
				if (r !== void 0) {
					(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
					for (let s = 0, a = r.length; s < a; s++) {
						const o = r[s].name || String(s);
						this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = s);
					}
				}
			}
		}
		getVertexPosition(e, t) {
			const i = this.geometry,
				r = i.attributes.position,
				s = i.morphAttributes.position,
				a = i.morphTargetsRelative;
			t.fromBufferAttribute(r, e);
			const o = this.morphTargetInfluences;
			if (s && o) {
				Wc.set(0, 0, 0);
				for (let l = 0, c = s.length; l < c; l++) {
					const u = o[l],
						h = s[l];
					u !== 0 && (Ld.fromBufferAttribute(h, e), a ? Wc.addScaledVector(Ld, u) : Wc.addScaledVector(Ld.sub(t), u));
				}
				t.add(Wc);
			}
			return t;
		}
		raycast(e, t) {
			const i = this.geometry,
				r = this.material,
				s = this.matrixWorld;
			r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Vc.copy(i.boundingSphere), Vc.applyMatrix4(s), Ys.copy(e.ray).recast(e.near), !(Vc.containsPoint(Ys.origin) === !1 && (Ys.intersectSphere(Vc, Iv) === null || Ys.origin.distanceToSquared(Iv) > (e.far - e.near) ** 2)) && (Ov.copy(s).invert(), Ys.copy(e.ray).applyMatrix4(Ov), !(i.boundingBox !== null && Ys.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Ys)));
		}
		_computeIntersections(e, t, i) {
			let r;
			const s = this.geometry,
				a = this.material,
				o = s.index,
				l = s.attributes.position,
				c = s.attributes.uv,
				u = s.attributes.uv1,
				h = s.attributes.normal,
				d = s.groups,
				f = s.drawRange;
			if (o !== null)
				if (Array.isArray(a))
					for (let v = 0, _ = d.length; v < _; v++) {
						const p = d[v],
							g = a[p.materialIndex],
							x = Math.max(p.start, f.start),
							b = Math.min(o.count, Math.min(p.start + p.count, f.start + f.count));
						for (let T = x, P = b; T < P; T += 3) {
							const A = o.getX(T),
								M = o.getX(T + 1),
								w = o.getX(T + 2);
							(r = Kc(this, g, e, i, c, u, h, A, M, w)), r && ((r.faceIndex = Math.floor(T / 3)), (r.face.materialIndex = p.materialIndex), t.push(r));
						}
					}
				else {
					const v = Math.max(0, f.start),
						_ = Math.min(o.count, f.start + f.count);
					for (let p = v, g = _; p < g; p += 3) {
						const x = o.getX(p),
							b = o.getX(p + 1),
							T = o.getX(p + 2);
						(r = Kc(this, a, e, i, c, u, h, x, b, T)), r && ((r.faceIndex = Math.floor(p / 3)), t.push(r));
					}
				}
			else if (l !== void 0)
				if (Array.isArray(a))
					for (let v = 0, _ = d.length; v < _; v++) {
						const p = d[v],
							g = a[p.materialIndex],
							x = Math.max(p.start, f.start),
							b = Math.min(l.count, Math.min(p.start + p.count, f.start + f.count));
						for (let T = x, P = b; T < P; T += 3) {
							const A = T,
								M = T + 1,
								w = T + 2;
							(r = Kc(this, g, e, i, c, u, h, A, M, w)), r && ((r.faceIndex = Math.floor(T / 3)), (r.face.materialIndex = p.materialIndex), t.push(r));
						}
					}
				else {
					const v = Math.max(0, f.start),
						_ = Math.min(l.count, f.start + f.count);
					for (let p = v, g = _; p < g; p += 3) {
						const x = p,
							b = p + 1,
							T = p + 2;
						(r = Kc(this, a, e, i, c, u, h, x, b, T)), r && ((r.faceIndex = Math.floor(p / 3)), t.push(r));
					}
				}
		}
	}
	function oL(n, e, t, i, r, s, a, o) {
		let l;
		if ((e.side === li ? (l = i.intersectTriangle(a, s, r, !0, o)) : (l = i.intersectTriangle(r, s, a, e.side === Kr, o)), l === null)) return null;
		Yc.copy(o), Yc.applyMatrix4(n.matrixWorld);
		const c = t.ray.origin.distanceTo(Yc);
		return c < t.near || c > t.far ? null : { distance: c, point: Yc.clone(), object: n };
	}
	function Kc(n, e, t, i, r, s, a, o, l, c) {
		n.getVertexPosition(o, Ka), n.getVertexPosition(l, Za), n.getVertexPosition(c, Ja);
		const u = oL(n, e, t, i, Ka, Za, Ja, jc);
		if (u) {
			r && (Xc.fromBufferAttribute(r, o), $c.fromBufferAttribute(r, l), qc.fromBufferAttribute(r, c), (u.uv = Qi.getInterpolation(jc, Ka, Za, Ja, Xc, $c, qc, new Se()))),
				s && (Xc.fromBufferAttribute(s, o), $c.fromBufferAttribute(s, l), qc.fromBufferAttribute(s, c), (u.uv1 = Qi.getInterpolation(jc, Ka, Za, Ja, Xc, $c, qc, new Se()))),
				a && (Fv.fromBufferAttribute(a, o), Nv.fromBufferAttribute(a, l), Uv.fromBufferAttribute(a, c), (u.normal = Qi.getInterpolation(jc, Ka, Za, Ja, Fv, Nv, Uv, new D())), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
			const h = { a: o, b: l, c, normal: new D(), materialIndex: 0 };
			Qi.getNormal(Ka, Za, Ja, h.normal), (u.face = h);
		}
		return u;
	}
	class yn extends bt {
		constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
			super(), (this.type = "BoxGeometry"), (this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: a });
			const o = this;
			(r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
			const l = [],
				c = [],
				u = [],
				h = [];
			let d = 0,
				f = 0;
			v("z", "y", "x", -1, -1, i, t, e, a, s, 0), v("z", "y", "x", 1, -1, i, t, -e, a, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, a, 2), v("x", "z", "y", 1, -1, e, i, -t, r, a, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new Tt(c, 3)), this.setAttribute("normal", new Tt(u, 3)), this.setAttribute("uv", new Tt(h, 2));
			function v(_, p, g, x, b, T, P, A, M, w, y) {
				const S = T / M,
					L = P / w,
					N = T / 2,
					k = P / 2,
					B = A / 2,
					W = M + 1,
					H = w + 1;
				let z = 0,
					X = 0;
				const K = new D();
				for (let G = 0; G < H; G++) {
					const ue = G * L - k;
					for (let ae = 0; ae < W; ae++) {
						const Ue = ae * S - N;
						(K[_] = Ue * x), (K[p] = ue * b), (K[g] = B), c.push(K.x, K.y, K.z), (K[_] = 0), (K[p] = 0), (K[g] = A > 0 ? 1 : -1), u.push(K.x, K.y, K.z), h.push(ae / M), h.push(1 - G / w), (z += 1);
					}
				}
				for (let G = 0; G < w; G++)
					for (let ue = 0; ue < M; ue++) {
						const ae = d + ue + W * G,
							Ue = d + ue + W * (G + 1),
							Z = d + (ue + 1) + W * (G + 1),
							ie = d + (ue + 1) + W * G;
						l.push(ae, Ue, ie), l.push(Ue, Z, ie), (X += 6);
					}
				o.addGroup(f, X, y), (f += X), (d += z);
			}
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new yn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
		}
	}
	function zo(n) {
		const e = {};
		for (const t in n) {
			e[t] = {};
			for (const i in n[t]) {
				const r = n[t][i];
				r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? (r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), (e[t][i] = null)) : (e[t][i] = r.clone())) : Array.isArray(r) ? (e[t][i] = r.slice()) : (e[t][i] = r);
			}
		}
		return e;
	}
	function ei(n) {
		const e = {};
		for (let t = 0; t < n.length; t++) {
			const i = zo(n[t]);
			for (const r in i) e[r] = i[r];
		}
		return e;
	}
	function lL(n) {
		const e = [];
		for (let t = 0; t < n.length; t++) e.push(n[t].clone());
		return e;
	}
	function rx(n) {
		const e = n.getRenderTarget();
		return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : zt.workingColorSpace;
	}
	const cL = { clone: zo, merge: ei };
	var uL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
		hL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
	class wr extends Er {
		constructor(e) {
			super(),
				(this.isShaderMaterial = !0),
				(this.type = "ShaderMaterial"),
				(this.defines = {}),
				(this.uniforms = {}),
				(this.uniformsGroups = []),
				(this.vertexShader = uL),
				(this.fragmentShader = hL),
				(this.linewidth = 1),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.fog = !1),
				(this.lights = !1),
				(this.clipping = !1),
				(this.forceSinglePass = !0),
				(this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
				(this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
				(this.index0AttributeName = void 0),
				(this.uniformsNeedUpdate = !1),
				(this.glslVersion = null),
				e !== void 0 && this.setValues(e);
		}
		copy(e) {
			return super.copy(e), (this.fragmentShader = e.fragmentShader), (this.vertexShader = e.vertexShader), (this.uniforms = zo(e.uniforms)), (this.uniformsGroups = lL(e.uniformsGroups)), (this.defines = Object.assign({}, e.defines)), (this.wireframe = e.wireframe), (this.wireframeLinewidth = e.wireframeLinewidth), (this.fog = e.fog), (this.lights = e.lights), (this.clipping = e.clipping), (this.extensions = Object.assign({}, e.extensions)), (this.glslVersion = e.glslVersion), this;
		}
		toJSON(e) {
			const t = super.toJSON(e);
			(t.glslVersion = this.glslVersion), (t.uniforms = {});
			for (const r in this.uniforms) {
				const a = this.uniforms[r].value;
				a && a.isTexture
					? (t.uniforms[r] = { type: "t", value: a.toJSON(e).uuid })
					: a && a.isColor
					? (t.uniforms[r] = { type: "c", value: a.getHex() })
					: a && a.isVector2
					? (t.uniforms[r] = { type: "v2", value: a.toArray() })
					: a && a.isVector3
					? (t.uniforms[r] = { type: "v3", value: a.toArray() })
					: a && a.isVector4
					? (t.uniforms[r] = { type: "v4", value: a.toArray() })
					: a && a.isMatrix3
					? (t.uniforms[r] = { type: "m3", value: a.toArray() })
					: a && a.isMatrix4
					? (t.uniforms[r] = { type: "m4", value: a.toArray() })
					: (t.uniforms[r] = { value: a });
			}
			Object.keys(this.defines).length > 0 && (t.defines = this.defines), (t.vertexShader = this.vertexShader), (t.fragmentShader = this.fragmentShader), (t.lights = this.lights), (t.clipping = this.clipping);
			const i = {};
			for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
			return Object.keys(i).length > 0 && (t.extensions = i), t;
		}
	}
	class sx extends on {
		constructor() {
			super(), (this.isCamera = !0), (this.type = "Camera"), (this.matrixWorldInverse = new pt()), (this.projectionMatrix = new pt()), (this.projectionMatrixInverse = new pt()), (this.coordinateSystem = Gr);
		}
		copy(e, t) {
			return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), (this.coordinateSystem = e.coordinateSystem), this;
		}
		getWorldDirection(e) {
			return super.getWorldDirection(e).negate();
		}
		updateMatrixWorld(e) {
			super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}
		updateWorldMatrix(e, t) {
			super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const ds = new D(),
		kv = new Se(),
		Bv = new Se();
	class fi extends sx {
		constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
			super(), (this.isPerspectiveCamera = !0), (this.type = "PerspectiveCamera"), (this.fov = e), (this.zoom = 1), (this.near = i), (this.far = r), (this.focus = 10), (this.aspect = t), (this.view = null), (this.filmGauge = 35), (this.filmOffset = 0), this.updateProjectionMatrix();
		}
		copy(e, t) {
			return super.copy(e, t), (this.fov = e.fov), (this.zoom = e.zoom), (this.near = e.near), (this.far = e.far), (this.focus = e.focus), (this.aspect = e.aspect), (this.view = e.view === null ? null : Object.assign({}, e.view)), (this.filmGauge = e.filmGauge), (this.filmOffset = e.filmOffset), this;
		}
		setFocalLength(e) {
			const t = (0.5 * this.getFilmHeight()) / e;
			(this.fov = Ol * 2 * Math.atan(t)), this.updateProjectionMatrix();
		}
		getFocalLength() {
			const e = Math.tan(Ml * 0.5 * this.fov);
			return (0.5 * this.getFilmHeight()) / e;
		}
		getEffectiveFOV() {
			return Ol * 2 * Math.atan(Math.tan(Ml * 0.5 * this.fov) / this.zoom);
		}
		getFilmWidth() {
			return this.filmGauge * Math.min(this.aspect, 1);
		}
		getFilmHeight() {
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		getViewBounds(e, t, i) {
			ds.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(ds.x, ds.y).multiplyScalar(-e / ds.z), ds.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(ds.x, ds.y).multiplyScalar(-e / ds.z);
		}
		getViewSize(e, t) {
			return this.getViewBounds(e, kv, Bv), t.subVectors(Bv, kv);
		}
		setViewOffset(e, t, i, r, s, a) {
			(this.aspect = e / t), this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = e), (this.view.fullHeight = t), (this.view.offsetX = i), (this.view.offsetY = r), (this.view.width = s), (this.view.height = a), this.updateProjectionMatrix();
		}
		clearViewOffset() {
			this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
		}
		updateProjectionMatrix() {
			const e = this.near;
			let t = (e * Math.tan(Ml * 0.5 * this.fov)) / this.zoom,
				i = 2 * t,
				r = this.aspect * i,
				s = -0.5 * r;
			const a = this.view;
			if (this.view !== null && this.view.enabled) {
				const l = a.fullWidth,
					c = a.fullHeight;
				(s += (a.offsetX * r) / l), (t -= (a.offsetY * i) / c), (r *= a.width / l), (i *= a.height / c);
			}
			const o = this.filmOffset;
			o !== 0 && (s += (e * o) / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}
		toJSON(e) {
			const t = super.toJSON(e);
			return (t.object.fov = this.fov), (t.object.zoom = this.zoom), (t.object.near = this.near), (t.object.far = this.far), (t.object.focus = this.focus), (t.object.aspect = this.aspect), this.view !== null && (t.object.view = Object.assign({}, this.view)), (t.object.filmGauge = this.filmGauge), (t.object.filmOffset = this.filmOffset), t;
		}
	}
	const Qa = -90,
		eo = 1;
	class dL extends on {
		constructor(e, t, i) {
			super(), (this.type = "CubeCamera"), (this.renderTarget = i), (this.coordinateSystem = null), (this.activeMipmapLevel = 0);
			const r = new fi(Qa, eo, e, t);
			(r.layers = this.layers), this.add(r);
			const s = new fi(Qa, eo, e, t);
			(s.layers = this.layers), this.add(s);
			const a = new fi(Qa, eo, e, t);
			(a.layers = this.layers), this.add(a);
			const o = new fi(Qa, eo, e, t);
			(o.layers = this.layers), this.add(o);
			const l = new fi(Qa, eo, e, t);
			(l.layers = this.layers), this.add(l);
			const c = new fi(Qa, eo, e, t);
			(c.layers = this.layers), this.add(c);
		}
		updateCoordinateSystem() {
			const e = this.coordinateSystem,
				t = this.children.concat(),
				[i, r, s, a, o, l] = t;
			for (const c of t) this.remove(c);
			if (e === Gr) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
			else if (e === Yu) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
			else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
			for (const c of t) this.add(c), c.updateMatrixWorld();
		}
		update(e, t) {
			this.parent === null && this.updateMatrixWorld();
			const { renderTarget: i, activeMipmapLevel: r } = this;
			this.coordinateSystem !== e.coordinateSystem && ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem());
			const [s, a, o, l, c, u] = this.children,
				h = e.getRenderTarget(),
				d = e.getActiveCubeFace(),
				f = e.getActiveMipmapLevel(),
				v = e.xr.enabled;
			e.xr.enabled = !1;
			const _ = i.texture.generateMipmaps;
			(i.texture.generateMipmaps = !1), e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, a), e.setRenderTarget(i, 2, r), e.render(t, o), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, c), (i.texture.generateMipmaps = _), e.setRenderTarget(i, 5, r), e.render(t, u), e.setRenderTarget(h, d, f), (e.xr.enabled = v), (i.texture.needsPMREMUpdate = !0);
		}
	}
	class ax extends jn {
		constructor(e, t, i, r, s, a, o, l, c, u) {
			(e = e !== void 0 ? e : []), (t = t !== void 0 ? t : No), super(e, t, i, r, s, a, o, l, c, u), (this.isCubeTexture = !0), (this.flipY = !1);
		}
		get images() {
			return this.image;
		}
		set images(e) {
			this.image = e;
		}
	}
	class fL extends ya {
		constructor(e = 1, t = {}) {
			super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
			const i = { width: e, height: e, depth: 1 },
				r = [i, i, i, i, i, i];
			(this.texture = new ax(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace)), (this.texture.isRenderTargetTexture = !0), (this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1), (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Zi);
		}
		fromEquirectangularTexture(e, t) {
			(this.texture.type = t.type), (this.texture.colorSpace = t.colorSpace), (this.texture.generateMipmaps = t.generateMipmaps), (this.texture.minFilter = t.minFilter), (this.texture.magFilter = t.magFilter);
			const i = {
					uniforms: { tEquirect: { value: null } },
					vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
					fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
				},
				r = new yn(5, 5, 5),
				s = new wr({ name: "CubemapFromEquirect", uniforms: zo(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: li, blending: ws });
			s.uniforms.tEquirect.value = t;
			const a = new Re(r, s),
				o = t.minFilter;
			return t.minFilter === fa && (t.minFilter = Zi), new dL(1, 10, this).update(e, a), (t.minFilter = o), a.geometry.dispose(), a.material.dispose(), this;
		}
		clear(e, t, i, r) {
			const s = e.getRenderTarget();
			for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, r);
			e.setRenderTarget(s);
		}
	}
	const Rd = new D(),
		pL = new D(),
		mL = new wt();
	class ia {
		constructor(e = new D(1, 0, 0), t = 0) {
			(this.isPlane = !0), (this.normal = e), (this.constant = t);
		}
		set(e, t) {
			return this.normal.copy(e), (this.constant = t), this;
		}
		setComponents(e, t, i, r) {
			return this.normal.set(e, t, i), (this.constant = r), this;
		}
		setFromNormalAndCoplanarPoint(e, t) {
			return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
		}
		setFromCoplanarPoints(e, t, i) {
			const r = Rd.subVectors(i, t).cross(pL.subVectors(e, t)).normalize();
			return this.setFromNormalAndCoplanarPoint(r, e), this;
		}
		copy(e) {
			return this.normal.copy(e.normal), (this.constant = e.constant), this;
		}
		normalize() {
			const e = 1 / this.normal.length();
			return this.normal.multiplyScalar(e), (this.constant *= e), this;
		}
		negate() {
			return (this.constant *= -1), this.normal.negate(), this;
		}
		distanceToPoint(e) {
			return this.normal.dot(e) + this.constant;
		}
		distanceToSphere(e) {
			return this.distanceToPoint(e.center) - e.radius;
		}
		projectPoint(e, t) {
			return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
		}
		intersectLine(e, t) {
			const i = e.delta(Rd),
				r = this.normal.dot(i);
			if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
			const s = -(e.start.dot(this.normal) + this.constant) / r;
			return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
		}
		intersectsLine(e) {
			const t = this.distanceToPoint(e.start),
				i = this.distanceToPoint(e.end);
			return (t < 0 && i > 0) || (i < 0 && t > 0);
		}
		intersectsBox(e) {
			return e.intersectsPlane(this);
		}
		intersectsSphere(e) {
			return e.intersectsPlane(this);
		}
		coplanarPoint(e) {
			return e.copy(this.normal).multiplyScalar(-this.constant);
		}
		applyMatrix4(e, t) {
			const i = t || mL.getNormalMatrix(e),
				r = this.coplanarPoint(Rd).applyMatrix4(e),
				s = this.normal.applyMatrix3(i).normalize();
			return (this.constant = -r.dot(s)), this;
		}
		translate(e) {
			return (this.constant -= e.dot(this.normal)), this;
		}
		equals(e) {
			return e.normal.equals(this.normal) && e.constant === this.constant;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const Ks = new $o(),
		Zc = new D();
	class qp {
		constructor(e = new ia(), t = new ia(), i = new ia(), r = new ia(), s = new ia(), a = new ia()) {
			this.planes = [e, t, i, r, s, a];
		}
		set(e, t, i, r, s, a) {
			const o = this.planes;
			return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
		}
		copy(e) {
			const t = this.planes;
			for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
			return this;
		}
		setFromProjectionMatrix(e, t = Gr) {
			const i = this.planes,
				r = e.elements,
				s = r[0],
				a = r[1],
				o = r[2],
				l = r[3],
				c = r[4],
				u = r[5],
				h = r[6],
				d = r[7],
				f = r[8],
				v = r[9],
				_ = r[10],
				p = r[11],
				g = r[12],
				x = r[13],
				b = r[14],
				T = r[15];
			if ((i[0].setComponents(l - s, d - c, p - f, T - g).normalize(), i[1].setComponents(l + s, d + c, p + f, T + g).normalize(), i[2].setComponents(l + a, d + u, p + v, T + x).normalize(), i[3].setComponents(l - a, d - u, p - v, T - x).normalize(), i[4].setComponents(l - o, d - h, p - _, T - b).normalize(), t === Gr)) i[5].setComponents(l + o, d + h, p + _, T + b).normalize();
			else if (t === Yu) i[5].setComponents(o, h, _, b).normalize();
			else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
			return this;
		}
		intersectsObject(e) {
			if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ks.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
			else {
				const t = e.geometry;
				t.boundingSphere === null && t.computeBoundingSphere(), Ks.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
			}
			return this.intersectsSphere(Ks);
		}
		intersectsSprite(e) {
			return Ks.center.set(0, 0, 0), (Ks.radius = 0.7071067811865476), Ks.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ks);
		}
		intersectsSphere(e) {
			const t = this.planes,
				i = e.center,
				r = -e.radius;
			for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
			return !0;
		}
		intersectsBox(e) {
			const t = this.planes;
			for (let i = 0; i < 6; i++) {
				const r = t[i];
				if (((Zc.x = r.normal.x > 0 ? e.max.x : e.min.x), (Zc.y = r.normal.y > 0 ? e.max.y : e.min.y), (Zc.z = r.normal.z > 0 ? e.max.z : e.min.z), r.distanceToPoint(Zc) < 0)) return !1;
			}
			return !0;
		}
		containsPoint(e) {
			const t = this.planes;
			for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
			return !0;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	function ox() {
		let n = null,
			e = !1,
			t = null,
			i = null;
		function r(s, a) {
			t(s, a), (i = n.requestAnimationFrame(r));
		}
		return {
			start: function () {
				e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
			},
			stop: function () {
				n.cancelAnimationFrame(i), (e = !1);
			},
			setAnimationLoop: function (s) {
				t = s;
			},
			setContext: function (s) {
				n = s;
			}
		};
	}
	function gL(n) {
		const e = new WeakMap();
		function t(o, l) {
			const c = o.array,
				u = o.usage,
				h = c.byteLength,
				d = n.createBuffer();
			n.bindBuffer(l, d), n.bufferData(l, c, u), o.onUploadCallback();
			let f;
			if (c instanceof Float32Array) f = n.FLOAT;
			else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? (f = n.HALF_FLOAT) : (f = n.UNSIGNED_SHORT);
			else if (c instanceof Int16Array) f = n.SHORT;
			else if (c instanceof Uint32Array) f = n.UNSIGNED_INT;
			else if (c instanceof Int32Array) f = n.INT;
			else if (c instanceof Int8Array) f = n.BYTE;
			else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE;
			else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE;
			else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
			return { buffer: d, type: f, bytesPerElement: c.BYTES_PER_ELEMENT, version: o.version, size: h };
		}
		function i(o, l, c) {
			const u = l.array,
				h = l._updateRange,
				d = l.updateRanges;
			if ((n.bindBuffer(c, o), h.count === -1 && d.length === 0 && n.bufferSubData(c, 0, u), d.length !== 0)) {
				for (let f = 0, v = d.length; f < v; f++) {
					const _ = d[f];
					n.bufferSubData(c, _.start * u.BYTES_PER_ELEMENT, u, _.start, _.count);
				}
				l.clearUpdateRanges();
			}
			h.count !== -1 && (n.bufferSubData(c, h.offset * u.BYTES_PER_ELEMENT, u, h.offset, h.count), (h.count = -1)), l.onUploadCallback();
		}
		function r(o) {
			return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
		}
		function s(o) {
			o.isInterleavedBufferAttribute && (o = o.data);
			const l = e.get(o);
			l && (n.deleteBuffer(l.buffer), e.delete(o));
		}
		function a(o, l) {
			if ((o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute)) {
				const u = e.get(o);
				(!u || u.version < o.version) && e.set(o, { buffer: o.buffer, type: o.type, bytesPerElement: o.elementSize, version: o.version });
				return;
			}
			const c = e.get(o);
			if (c === void 0) e.set(o, t(o, l));
			else if (c.version < o.version) {
				if (c.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
				i(c.buffer, o, l), (c.version = o.version);
			}
		}
		return { get: r, remove: s, update: a };
	}
	class Ql extends bt {
		constructor(e = 1, t = 1, i = 1, r = 1) {
			super(), (this.type = "PlaneGeometry"), (this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r });
			const s = e / 2,
				a = t / 2,
				o = Math.floor(i),
				l = Math.floor(r),
				c = o + 1,
				u = l + 1,
				h = e / o,
				d = t / l,
				f = [],
				v = [],
				_ = [],
				p = [];
			for (let g = 0; g < u; g++) {
				const x = g * d - a;
				for (let b = 0; b < c; b++) {
					const T = b * h - s;
					v.push(T, -x, 0), _.push(0, 0, 1), p.push(b / o), p.push(1 - g / l);
				}
			}
			for (let g = 0; g < l; g++)
				for (let x = 0; x < o; x++) {
					const b = x + c * g,
						T = x + c * (g + 1),
						P = x + 1 + c * (g + 1),
						A = x + 1 + c * g;
					f.push(b, T, A), f.push(T, P, A);
				}
			this.setIndex(f), this.setAttribute("position", new Tt(v, 3)), this.setAttribute("normal", new Tt(_, 3)), this.setAttribute("uv", new Tt(p, 2));
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new Ql(e.width, e.height, e.widthSegments, e.heightSegments);
		}
	}
	var vL = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
		_L = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
		yL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
		xL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		bL = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
		SL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
		EL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
		wL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
		TL = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
		ML = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
		AL = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
		CL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
		LL = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
		RL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
		PL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
		DL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
		OL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
		IL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
		FL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
		NL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
		UL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
		kL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
		BL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
		zL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
		HL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
		GL = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
		VL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
		WL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
		XL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
		$L = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
		qL = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
		jL = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
		YL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
		KL = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
		ZL = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
		JL = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
		QL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
		eR = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
		tR = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
		nR = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
		iR = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
		rR = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
		sR = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
		aR = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
		oR = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
		lR = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
		cR = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
		uR = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
		hR = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
		dR = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
		fR = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
		pR = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
		mR = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
		gR = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
		vR = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
		_R = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
		yR = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
		xR = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
		bR = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
		SR = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
		ER = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
		wR = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
		TR = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
		MR = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		AR = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
		CR = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
		LR = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
		RR = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
		PR = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
		DR = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
		OR = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
		IR = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
		FR = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
		NR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		UR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		kR = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
		BR = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
		zR = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
		HR = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
		GR = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
		VR = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
		WR = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
		XR = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
		$R = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
		qR = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
		jR = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
		YR = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
		KR = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
		ZR = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
		JR = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
		QR = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
		eP = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
		tP = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
		nP = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
		iP = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
		rP = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
		sP = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
		aP = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
		oP = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
		lP = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
		cP = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
		uP = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
		hP = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
		dP = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		fP = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		pP = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
		mP = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
	const gP = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
		vP = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		_P = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		yP = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		xP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		bP = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		SP = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
		EP = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
		wP = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
		TP = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
		MP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
		AP = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		CP = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		LP = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		RP = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
		PP = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		DP = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		OP = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		IP = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
		FP = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		NP = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
		UP = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
		kP = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		BP = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		zP = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
		HP = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		GP = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		VP = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		WP = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
		XP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		$P = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		qP = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
		jP = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		YP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
		st = {
			alphahash_fragment: vL,
			alphahash_pars_fragment: _L,
			alphamap_fragment: yL,
			alphamap_pars_fragment: xL,
			alphatest_fragment: bL,
			alphatest_pars_fragment: SL,
			aomap_fragment: EL,
			aomap_pars_fragment: wL,
			batching_pars_vertex: TL,
			batching_vertex: ML,
			begin_vertex: AL,
			beginnormal_vertex: CL,
			bsdfs: LL,
			iridescence_fragment: RL,
			bumpmap_pars_fragment: PL,
			clipping_planes_fragment: DL,
			clipping_planes_pars_fragment: OL,
			clipping_planes_pars_vertex: IL,
			clipping_planes_vertex: FL,
			color_fragment: NL,
			color_pars_fragment: UL,
			color_pars_vertex: kL,
			color_vertex: BL,
			common: zL,
			cube_uv_reflection_fragment: HL,
			defaultnormal_vertex: GL,
			displacementmap_pars_vertex: VL,
			displacementmap_vertex: WL,
			emissivemap_fragment: XL,
			emissivemap_pars_fragment: $L,
			colorspace_fragment: qL,
			colorspace_pars_fragment: jL,
			envmap_fragment: YL,
			envmap_common_pars_fragment: KL,
			envmap_pars_fragment: ZL,
			envmap_pars_vertex: JL,
			envmap_physical_pars_fragment: cR,
			envmap_vertex: QL,
			fog_vertex: eR,
			fog_pars_vertex: tR,
			fog_fragment: nR,
			fog_pars_fragment: iR,
			gradientmap_pars_fragment: rR,
			lightmap_pars_fragment: sR,
			lights_lambert_fragment: aR,
			lights_lambert_pars_fragment: oR,
			lights_pars_begin: lR,
			lights_toon_fragment: uR,
			lights_toon_pars_fragment: hR,
			lights_phong_fragment: dR,
			lights_phong_pars_fragment: fR,
			lights_physical_fragment: pR,
			lights_physical_pars_fragment: mR,
			lights_fragment_begin: gR,
			lights_fragment_maps: vR,
			lights_fragment_end: _R,
			logdepthbuf_fragment: yR,
			logdepthbuf_pars_fragment: xR,
			logdepthbuf_pars_vertex: bR,
			logdepthbuf_vertex: SR,
			map_fragment: ER,
			map_pars_fragment: wR,
			map_particle_fragment: TR,
			map_particle_pars_fragment: MR,
			metalnessmap_fragment: AR,
			metalnessmap_pars_fragment: CR,
			morphinstance_vertex: LR,
			morphcolor_vertex: RR,
			morphnormal_vertex: PR,
			morphtarget_pars_vertex: DR,
			morphtarget_vertex: OR,
			normal_fragment_begin: IR,
			normal_fragment_maps: FR,
			normal_pars_fragment: NR,
			normal_pars_vertex: UR,
			normal_vertex: kR,
			normalmap_pars_fragment: BR,
			clearcoat_normal_fragment_begin: zR,
			clearcoat_normal_fragment_maps: HR,
			clearcoat_pars_fragment: GR,
			iridescence_pars_fragment: VR,
			opaque_fragment: WR,
			packing: XR,
			premultiplied_alpha_fragment: $R,
			project_vertex: qR,
			dithering_fragment: jR,
			dithering_pars_fragment: YR,
			roughnessmap_fragment: KR,
			roughnessmap_pars_fragment: ZR,
			shadowmap_pars_fragment: JR,
			shadowmap_pars_vertex: QR,
			shadowmap_vertex: eP,
			shadowmask_pars_fragment: tP,
			skinbase_vertex: nP,
			skinning_pars_vertex: iP,
			skinning_vertex: rP,
			skinnormal_vertex: sP,
			specularmap_fragment: aP,
			specularmap_pars_fragment: oP,
			tonemapping_fragment: lP,
			tonemapping_pars_fragment: cP,
			transmission_fragment: uP,
			transmission_pars_fragment: hP,
			uv_pars_fragment: dP,
			uv_pars_vertex: fP,
			uv_vertex: pP,
			worldpos_vertex: mP,
			background_vert: gP,
			background_frag: vP,
			backgroundCube_vert: _P,
			backgroundCube_frag: yP,
			cube_vert: xP,
			cube_frag: bP,
			depth_vert: SP,
			depth_frag: EP,
			distanceRGBA_vert: wP,
			distanceRGBA_frag: TP,
			equirect_vert: MP,
			equirect_frag: AP,
			linedashed_vert: CP,
			linedashed_frag: LP,
			meshbasic_vert: RP,
			meshbasic_frag: PP,
			meshlambert_vert: DP,
			meshlambert_frag: OP,
			meshmatcap_vert: IP,
			meshmatcap_frag: FP,
			meshnormal_vert: NP,
			meshnormal_frag: UP,
			meshphong_vert: kP,
			meshphong_frag: BP,
			meshphysical_vert: zP,
			meshphysical_frag: HP,
			meshtoon_vert: GP,
			meshtoon_frag: VP,
			points_vert: WP,
			points_frag: XP,
			shadow_vert: $P,
			shadow_frag: qP,
			sprite_vert: jP,
			sprite_frag: YP
		},
		Be = {
			common: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new wt() }, alphaMap: { value: null }, alphaMapTransform: { value: new wt() }, alphaTest: { value: 0 } },
			specularmap: { specularMap: { value: null }, specularMapTransform: { value: new wt() } },
			envmap: { envMap: { value: null }, envMapRotation: { value: new wt() }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } },
			aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new wt() } },
			lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new wt() } },
			bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new wt() }, bumpScale: { value: 1 } },
			normalmap: { normalMap: { value: null }, normalMapTransform: { value: new wt() }, normalScale: { value: new Se(1, 1) } },
			displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new wt() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } },
			emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new wt() } },
			metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new wt() } },
			roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new wt() } },
			gradientmap: { gradientMap: { value: null } },
			fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new rt(16777215) } },
			lights: {
				ambientLightColor: { value: [] },
				lightProbe: { value: [] },
				directionalLights: { value: [], properties: { direction: {}, color: {} } },
				directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
				spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
				spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
				spotLightMap: { value: [] },
				spotShadowMap: { value: [] },
				spotLightMatrix: { value: [] },
				pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
				pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
				hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
				rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
				ltc_1: { value: null },
				ltc_2: { value: null }
			},
			points: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new wt() }, alphaTest: { value: 0 }, uvTransform: { value: new wt() } },
			sprite: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, center: { value: new Se(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new wt() }, alphaMap: { value: null }, alphaMapTransform: { value: new wt() }, alphaTest: { value: 0 } }
		},
		gr = {
			basic: { uniforms: ei([Be.common, Be.specularmap, Be.envmap, Be.aomap, Be.lightmap, Be.fog]), vertexShader: st.meshbasic_vert, fragmentShader: st.meshbasic_frag },
			lambert: { uniforms: ei([Be.common, Be.specularmap, Be.envmap, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.fog, Be.lights, { emissive: { value: new rt(0) } }]), vertexShader: st.meshlambert_vert, fragmentShader: st.meshlambert_frag },
			phong: { uniforms: ei([Be.common, Be.specularmap, Be.envmap, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.fog, Be.lights, { emissive: { value: new rt(0) }, specular: { value: new rt(1118481) }, shininess: { value: 30 } }]), vertexShader: st.meshphong_vert, fragmentShader: st.meshphong_frag },
			standard: { uniforms: ei([Be.common, Be.envmap, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.roughnessmap, Be.metalnessmap, Be.fog, Be.lights, { emissive: { value: new rt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: st.meshphysical_vert, fragmentShader: st.meshphysical_frag },
			toon: { uniforms: ei([Be.common, Be.aomap, Be.lightmap, Be.emissivemap, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.gradientmap, Be.fog, Be.lights, { emissive: { value: new rt(0) } }]), vertexShader: st.meshtoon_vert, fragmentShader: st.meshtoon_frag },
			matcap: { uniforms: ei([Be.common, Be.bumpmap, Be.normalmap, Be.displacementmap, Be.fog, { matcap: { value: null } }]), vertexShader: st.meshmatcap_vert, fragmentShader: st.meshmatcap_frag },
			points: { uniforms: ei([Be.points, Be.fog]), vertexShader: st.points_vert, fragmentShader: st.points_frag },
			dashed: { uniforms: ei([Be.common, Be.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: st.linedashed_vert, fragmentShader: st.linedashed_frag },
			depth: { uniforms: ei([Be.common, Be.displacementmap]), vertexShader: st.depth_vert, fragmentShader: st.depth_frag },
			normal: { uniforms: ei([Be.common, Be.bumpmap, Be.normalmap, Be.displacementmap, { opacity: { value: 1 } }]), vertexShader: st.meshnormal_vert, fragmentShader: st.meshnormal_frag },
			sprite: { uniforms: ei([Be.sprite, Be.fog]), vertexShader: st.sprite_vert, fragmentShader: st.sprite_frag },
			background: { uniforms: { uvTransform: { value: new wt() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: st.background_vert, fragmentShader: st.background_frag },
			backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new wt() } }, vertexShader: st.backgroundCube_vert, fragmentShader: st.backgroundCube_frag },
			cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: st.cube_vert, fragmentShader: st.cube_frag },
			equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: st.equirect_vert, fragmentShader: st.equirect_frag },
			distanceRGBA: { uniforms: ei([Be.common, Be.displacementmap, { referencePosition: { value: new D() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: st.distanceRGBA_vert, fragmentShader: st.distanceRGBA_frag },
			shadow: { uniforms: ei([Be.lights, Be.fog, { color: { value: new rt(0) }, opacity: { value: 1 } }]), vertexShader: st.shadow_vert, fragmentShader: st.shadow_frag }
		};
	gr.physical = {
		uniforms: ei([
			gr.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatMapTransform: { value: new wt() },
				clearcoatNormalMap: { value: null },
				clearcoatNormalMapTransform: { value: new wt() },
				clearcoatNormalScale: { value: new Se(1, 1) },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatRoughnessMapTransform: { value: new wt() },
				dispersion: { value: 0 },
				iridescence: { value: 0 },
				iridescenceMap: { value: null },
				iridescenceMapTransform: { value: new wt() },
				iridescenceIOR: { value: 1.3 },
				iridescenceThicknessMinimum: { value: 100 },
				iridescenceThicknessMaximum: { value: 400 },
				iridescenceThicknessMap: { value: null },
				iridescenceThicknessMapTransform: { value: new wt() },
				sheen: { value: 0 },
				sheenColor: { value: new rt(0) },
				sheenColorMap: { value: null },
				sheenColorMapTransform: { value: new wt() },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				sheenRoughnessMapTransform: { value: new wt() },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionMapTransform: { value: new wt() },
				transmissionSamplerSize: { value: new Se() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				thicknessMapTransform: { value: new wt() },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: new rt(0) },
				specularColor: { value: new rt(1, 1, 1) },
				specularColorMap: { value: null },
				specularColorMapTransform: { value: new wt() },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularIntensityMapTransform: { value: new wt() },
				anisotropyVector: { value: new Se() },
				anisotropyMap: { value: null },
				anisotropyMapTransform: { value: new wt() }
			}
		]),
		vertexShader: st.meshphysical_vert,
		fragmentShader: st.meshphysical_frag
	};
	const Jc = { r: 0, b: 0, g: 0 },
		Zs = new Un(),
		KP = new pt();
	function ZP(n, e, t, i, r, s, a) {
		const o = new rt(0);
		let l = s === !0 ? 0 : 1,
			c,
			u,
			h = null,
			d = 0,
			f = null;
		function v(x) {
			let b = x.isScene === !0 ? x.background : null;
			return b && b.isTexture && (b = (x.backgroundBlurriness > 0 ? t : e).get(b)), b;
		}
		function _(x) {
			let b = !1;
			const T = v(x);
			T === null ? g(o, l) : T && T.isColor && (g(T, 1), (b = !0));
			const P = n.xr.getEnvironmentBlendMode();
			P === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : P === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || b) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
		}
		function p(x, b) {
			const T = v(b);
			T && (T.isCubeTexture || T.mapping === gh)
				? (u === void 0 &&
						((u = new Re(new yn(1, 1, 1), new wr({ name: "BackgroundCubeMaterial", uniforms: zo(gr.backgroundCube.uniforms), vertexShader: gr.backgroundCube.vertexShader, fragmentShader: gr.backgroundCube.fragmentShader, side: li, depthTest: !1, depthWrite: !1, fog: !1 }))),
						u.geometry.deleteAttribute("normal"),
						u.geometry.deleteAttribute("uv"),
						(u.onBeforeRender = function (P, A, M) {
							this.matrixWorld.copyPosition(M.matrixWorld);
						}),
						Object.defineProperty(u.material, "envMap", {
							get: function () {
								return this.uniforms.envMap.value;
							}
						}),
						r.update(u)),
				  Zs.copy(b.backgroundRotation),
				  (Zs.x *= -1),
				  (Zs.y *= -1),
				  (Zs.z *= -1),
				  T.isCubeTexture && T.isRenderTargetTexture === !1 && ((Zs.y *= -1), (Zs.z *= -1)),
				  (u.material.uniforms.envMap.value = T),
				  (u.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1),
				  (u.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness),
				  (u.material.uniforms.backgroundIntensity.value = b.backgroundIntensity),
				  u.material.uniforms.backgroundRotation.value.setFromMatrix4(KP.makeRotationFromEuler(Zs)),
				  (u.material.toneMapped = zt.getTransfer(T.colorSpace) !== nn),
				  (h !== T || d !== T.version || f !== n.toneMapping) && ((u.material.needsUpdate = !0), (h = T), (d = T.version), (f = n.toneMapping)),
				  u.layers.enableAll(),
				  x.unshift(u, u.geometry, u.material, 0, 0, null))
				: T &&
				  T.isTexture &&
				  (c === void 0 &&
						((c = new Re(new Ql(2, 2), new wr({ name: "BackgroundMaterial", uniforms: zo(gr.background.uniforms), vertexShader: gr.background.vertexShader, fragmentShader: gr.background.fragmentShader, side: Kr, depthTest: !1, depthWrite: !1, fog: !1 }))),
						c.geometry.deleteAttribute("normal"),
						Object.defineProperty(c.material, "map", {
							get: function () {
								return this.uniforms.t2D.value;
							}
						}),
						r.update(c)),
				  (c.material.uniforms.t2D.value = T),
				  (c.material.uniforms.backgroundIntensity.value = b.backgroundIntensity),
				  (c.material.toneMapped = zt.getTransfer(T.colorSpace) !== nn),
				  T.matrixAutoUpdate === !0 && T.updateMatrix(),
				  c.material.uniforms.uvTransform.value.copy(T.matrix),
				  (h !== T || d !== T.version || f !== n.toneMapping) && ((c.material.needsUpdate = !0), (h = T), (d = T.version), (f = n.toneMapping)),
				  c.layers.enableAll(),
				  x.unshift(c, c.geometry, c.material, 0, 0, null));
		}
		function g(x, b) {
			x.getRGB(Jc, rx(n)), i.buffers.color.setClear(Jc.r, Jc.g, Jc.b, b, a);
		}
		return {
			getClearColor: function () {
				return o;
			},
			setClearColor: function (x, b = 1) {
				o.set(x), (l = b), g(o, l);
			},
			getClearAlpha: function () {
				return l;
			},
			setClearAlpha: function (x) {
				(l = x), g(o, l);
			},
			render: _,
			addToRenderList: p
		};
	}
	function JP(n, e) {
		const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
			i = {},
			r = d(null);
		let s = r,
			a = !1;
		function o(S, L, N, k, B) {
			let W = !1;
			const H = h(k, N, L);
			s !== H && ((s = H), c(s.object)), (W = f(S, k, N, B)), W && v(S, k, N, B), B !== null && e.update(B, n.ELEMENT_ARRAY_BUFFER), (W || a) && ((a = !1), T(S, L, N, k), B !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(B).buffer));
		}
		function l() {
			return n.createVertexArray();
		}
		function c(S) {
			return n.bindVertexArray(S);
		}
		function u(S) {
			return n.deleteVertexArray(S);
		}
		function h(S, L, N) {
			const k = N.wireframe === !0;
			let B = i[S.id];
			B === void 0 && ((B = {}), (i[S.id] = B));
			let W = B[L.id];
			W === void 0 && ((W = {}), (B[L.id] = W));
			let H = W[k];
			return H === void 0 && ((H = d(l())), (W[k] = H)), H;
		}
		function d(S) {
			const L = [],
				N = [],
				k = [];
			for (let B = 0; B < t; B++) (L[B] = 0), (N[B] = 0), (k[B] = 0);
			return { geometry: null, program: null, wireframe: !1, newAttributes: L, enabledAttributes: N, attributeDivisors: k, object: S, attributes: {}, index: null };
		}
		function f(S, L, N, k) {
			const B = s.attributes,
				W = L.attributes;
			let H = 0;
			const z = N.getAttributes();
			for (const X in z)
				if (z[X].location >= 0) {
					const G = B[X];
					let ue = W[X];
					if ((ue === void 0 && (X === "instanceMatrix" && S.instanceMatrix && (ue = S.instanceMatrix), X === "instanceColor" && S.instanceColor && (ue = S.instanceColor)), G === void 0 || G.attribute !== ue || (ue && G.data !== ue.data))) return !0;
					H++;
				}
			return s.attributesNum !== H || s.index !== k;
		}
		function v(S, L, N, k) {
			const B = {},
				W = L.attributes;
			let H = 0;
			const z = N.getAttributes();
			for (const X in z)
				if (z[X].location >= 0) {
					let G = W[X];
					G === void 0 && (X === "instanceMatrix" && S.instanceMatrix && (G = S.instanceMatrix), X === "instanceColor" && S.instanceColor && (G = S.instanceColor));
					const ue = {};
					(ue.attribute = G), G && G.data && (ue.data = G.data), (B[X] = ue), H++;
				}
			(s.attributes = B), (s.attributesNum = H), (s.index = k);
		}
		function _() {
			const S = s.newAttributes;
			for (let L = 0, N = S.length; L < N; L++) S[L] = 0;
		}
		function p(S) {
			g(S, 0);
		}
		function g(S, L) {
			const N = s.newAttributes,
				k = s.enabledAttributes,
				B = s.attributeDivisors;
			(N[S] = 1), k[S] === 0 && (n.enableVertexAttribArray(S), (k[S] = 1)), B[S] !== L && (n.vertexAttribDivisor(S, L), (B[S] = L));
		}
		function x() {
			const S = s.newAttributes,
				L = s.enabledAttributes;
			for (let N = 0, k = L.length; N < k; N++) L[N] !== S[N] && (n.disableVertexAttribArray(N), (L[N] = 0));
		}
		function b(S, L, N, k, B, W, H) {
			H === !0 ? n.vertexAttribIPointer(S, L, N, B, W) : n.vertexAttribPointer(S, L, N, k, B, W);
		}
		function T(S, L, N, k) {
			_();
			const B = k.attributes,
				W = N.getAttributes(),
				H = L.defaultAttributeValues;
			for (const z in W) {
				const X = W[z];
				if (X.location >= 0) {
					let K = B[z];
					if ((K === void 0 && (z === "instanceMatrix" && S.instanceMatrix && (K = S.instanceMatrix), z === "instanceColor" && S.instanceColor && (K = S.instanceColor)), K !== void 0)) {
						const G = K.normalized,
							ue = K.itemSize,
							ae = e.get(K);
						if (ae === void 0) continue;
						const Ue = ae.buffer,
							Z = ae.type,
							ie = ae.bytesPerElement,
							ge = Z === n.INT || Z === n.UNSIGNED_INT || K.gpuType === kp;
						if (K.isInterleavedBufferAttribute) {
							const V = K.data,
								j = V.stride,
								he = K.offset;
							if (V.isInstancedInterleavedBuffer) {
								for (let xe = 0; xe < X.locationSize; xe++) g(X.location + xe, V.meshPerAttribute);
								S.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = V.meshPerAttribute * V.count);
							} else for (let xe = 0; xe < X.locationSize; xe++) p(X.location + xe);
							n.bindBuffer(n.ARRAY_BUFFER, Ue);
							for (let xe = 0; xe < X.locationSize; xe++) b(X.location + xe, ue / X.locationSize, Z, G, j * ie, (he + (ue / X.locationSize) * xe) * ie, ge);
						} else {
							if (K.isInstancedBufferAttribute) {
								for (let V = 0; V < X.locationSize; V++) g(X.location + V, K.meshPerAttribute);
								S.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = K.meshPerAttribute * K.count);
							} else for (let V = 0; V < X.locationSize; V++) p(X.location + V);
							n.bindBuffer(n.ARRAY_BUFFER, Ue);
							for (let V = 0; V < X.locationSize; V++) b(X.location + V, ue / X.locationSize, Z, G, ue * ie, (ue / X.locationSize) * V * ie, ge);
						}
					} else if (H !== void 0) {
						const G = H[z];
						if (G !== void 0)
							switch (G.length) {
								case 2:
									n.vertexAttrib2fv(X.location, G);
									break;
								case 3:
									n.vertexAttrib3fv(X.location, G);
									break;
								case 4:
									n.vertexAttrib4fv(X.location, G);
									break;
								default:
									n.vertexAttrib1fv(X.location, G);
							}
					}
				}
			}
			x();
		}
		function P() {
			w();
			for (const S in i) {
				const L = i[S];
				for (const N in L) {
					const k = L[N];
					for (const B in k) u(k[B].object), delete k[B];
					delete L[N];
				}
				delete i[S];
			}
		}
		function A(S) {
			if (i[S.id] === void 0) return;
			const L = i[S.id];
			for (const N in L) {
				const k = L[N];
				for (const B in k) u(k[B].object), delete k[B];
				delete L[N];
			}
			delete i[S.id];
		}
		function M(S) {
			for (const L in i) {
				const N = i[L];
				if (N[S.id] === void 0) continue;
				const k = N[S.id];
				for (const B in k) u(k[B].object), delete k[B];
				delete N[S.id];
			}
		}
		function w() {
			y(), (a = !0), s !== r && ((s = r), c(s.object));
		}
		function y() {
			(r.geometry = null), (r.program = null), (r.wireframe = !1);
		}
		return { setup: o, reset: w, resetDefaultState: y, dispose: P, releaseStatesOfGeometry: A, releaseStatesOfProgram: M, initAttributes: _, enableAttribute: p, disableUnusedAttributes: x };
	}
	function QP(n, e, t) {
		let i;
		function r(c) {
			i = c;
		}
		function s(c, u) {
			n.drawArrays(i, c, u), t.update(u, i, 1);
		}
		function a(c, u, h) {
			h !== 0 && (n.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
		}
		function o(c, u, h) {
			if (h === 0) return;
			e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
			let f = 0;
			for (let v = 0; v < h; v++) f += u[v];
			t.update(f, i, 1);
		}
		function l(c, u, h, d) {
			if (h === 0) return;
			const f = e.get("WEBGL_multi_draw");
			if (f === null) for (let v = 0; v < c.length; v++) a(c[v], u[v], d[v]);
			else {
				f.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
				let v = 0;
				for (let _ = 0; _ < h; _++) v += u[_];
				for (let _ = 0; _ < d.length; _++) t.update(v, i, d[_]);
			}
		}
		(this.setMode = r), (this.render = s), (this.renderInstances = a), (this.renderMultiDraw = o), (this.renderMultiDrawInstances = l);
	}
	function e2(n, e, t, i) {
		let r;
		function s() {
			if (r !== void 0) return r;
			if (e.has("EXT_texture_filter_anisotropic") === !0) {
				const A = e.get("EXT_texture_filter_anisotropic");
				r = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else r = 0;
			return r;
		}
		function a(A) {
			return !(A !== er && i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
		}
		function o(A) {
			const M = A === Jl && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
			return !(A !== Zr && i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && A !== Hr && !M);
		}
		function l(A) {
			if (A === "highp") {
				if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
				A = "mediump";
			}
			return A === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
		}
		let c = t.precision !== void 0 ? t.precision : "highp";
		const u = l(c);
		u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), (c = u));
		const h = t.logarithmicDepthBuffer === !0,
			d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
			f = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
			v = n.getParameter(n.MAX_TEXTURE_SIZE),
			_ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
			p = n.getParameter(n.MAX_VERTEX_ATTRIBS),
			g = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
			x = n.getParameter(n.MAX_VARYING_VECTORS),
			b = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
			T = f > 0,
			P = n.getParameter(n.MAX_SAMPLES);
		return { isWebGL2: !0, getMaxAnisotropy: s, getMaxPrecision: l, textureFormatReadable: a, textureTypeReadable: o, precision: c, logarithmicDepthBuffer: h, maxTextures: d, maxVertexTextures: f, maxTextureSize: v, maxCubemapSize: _, maxAttributes: p, maxVertexUniforms: g, maxVaryings: x, maxFragmentUniforms: b, vertexTextures: T, maxSamples: P };
	}
	function t2(n) {
		const e = this;
		let t = null,
			i = 0,
			r = !1,
			s = !1;
		const a = new ia(),
			o = new wt(),
			l = { value: null, needsUpdate: !1 };
		(this.uniform = l),
			(this.numPlanes = 0),
			(this.numIntersection = 0),
			(this.init = function (h, d) {
				const f = h.length !== 0 || d || i !== 0 || r;
				return (r = d), (i = h.length), f;
			}),
			(this.beginShadows = function () {
				(s = !0), u(null);
			}),
			(this.endShadows = function () {
				s = !1;
			}),
			(this.setGlobalState = function (h, d) {
				t = u(h, d, 0);
			}),
			(this.setState = function (h, d, f) {
				const v = h.clippingPlanes,
					_ = h.clipIntersection,
					p = h.clipShadows,
					g = n.get(h);
				if (!r || v === null || v.length === 0 || (s && !p)) s ? u(null) : c();
				else {
					const x = s ? 0 : i,
						b = x * 4;
					let T = g.clippingState || null;
					(l.value = T), (T = u(v, d, b, f));
					for (let P = 0; P !== b; ++P) T[P] = t[P];
					(g.clippingState = T), (this.numIntersection = _ ? this.numPlanes : 0), (this.numPlanes += x);
				}
			});
		function c() {
			l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)), (e.numPlanes = i), (e.numIntersection = 0);
		}
		function u(h, d, f, v) {
			const _ = h !== null ? h.length : 0;
			let p = null;
			if (_ !== 0) {
				if (((p = l.value), v !== !0 || p === null)) {
					const g = f + _ * 4,
						x = d.matrixWorldInverse;
					o.getNormalMatrix(x), (p === null || p.length < g) && (p = new Float32Array(g));
					for (let b = 0, T = f; b !== _; ++b, T += 4) a.copy(h[b]).applyMatrix4(x, o), a.normal.toArray(p, T), (p[T + 3] = a.constant);
				}
				(l.value = p), (l.needsUpdate = !0);
			}
			return (e.numPlanes = _), (e.numIntersection = 0), p;
		}
	}
	function n2(n) {
		let e = new WeakMap();
		function t(a, o) {
			return o === Sf ? (a.mapping = No) : o === Ef && (a.mapping = Uo), a;
		}
		function i(a) {
			if (a && a.isTexture) {
				const o = a.mapping;
				if (o === Sf || o === Ef)
					if (e.has(a)) {
						const l = e.get(a).texture;
						return t(l, a.mapping);
					} else {
						const l = a.image;
						if (l && l.height > 0) {
							const c = new fL(l.height);
							return c.fromEquirectangularTexture(n, a), e.set(a, c), a.addEventListener("dispose", r), t(c.texture, a.mapping);
						} else return null;
					}
			}
			return a;
		}
		function r(a) {
			const o = a.target;
			o.removeEventListener("dispose", r);
			const l = e.get(o);
			l !== void 0 && (e.delete(o), l.dispose());
		}
		function s() {
			e = new WeakMap();
		}
		return { get: i, dispose: s };
	}
	class ec extends sx {
		constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
			super(), (this.isOrthographicCamera = !0), (this.type = "OrthographicCamera"), (this.zoom = 1), (this.view = null), (this.left = e), (this.right = t), (this.top = i), (this.bottom = r), (this.near = s), (this.far = a), this.updateProjectionMatrix();
		}
		copy(e, t) {
			return super.copy(e, t), (this.left = e.left), (this.right = e.right), (this.top = e.top), (this.bottom = e.bottom), (this.near = e.near), (this.far = e.far), (this.zoom = e.zoom), (this.view = e.view === null ? null : Object.assign({}, e.view)), this;
		}
		setViewOffset(e, t, i, r, s, a) {
			this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = e), (this.view.fullHeight = t), (this.view.offsetX = i), (this.view.offsetY = r), (this.view.width = s), (this.view.height = a), this.updateProjectionMatrix();
		}
		clearViewOffset() {
			this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
		}
		updateProjectionMatrix() {
			const e = (this.right - this.left) / (2 * this.zoom),
				t = (this.top - this.bottom) / (2 * this.zoom),
				i = (this.right + this.left) / 2,
				r = (this.top + this.bottom) / 2;
			let s = i - e,
				a = i + e,
				o = r + t,
				l = r - t;
			if (this.view !== null && this.view.enabled) {
				const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
					u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				(s += c * this.view.offsetX), (a = s + c * this.view.width), (o -= u * this.view.offsetY), (l = o - u * this.view.height);
			}
			this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}
		toJSON(e) {
			const t = super.toJSON(e);
			return (t.object.zoom = this.zoom), (t.object.left = this.left), (t.object.right = this.right), (t.object.top = this.top), (t.object.bottom = this.bottom), (t.object.near = this.near), (t.object.far = this.far), this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
		}
	}
	const go = 4,
		zv = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
		oa = 20,
		Pd = new ec(),
		Hv = new rt();
	let Dd = null,
		Od = 0,
		Id = 0,
		Fd = !1;
	const ra = (1 + Math.sqrt(5)) / 2,
		to = 1 / ra,
		Gv = [new D(-ra, to, 0), new D(ra, to, 0), new D(-to, 0, ra), new D(to, 0, ra), new D(0, ra, -to), new D(0, ra, to), new D(-1, 1, -1), new D(1, 1, -1), new D(-1, 1, 1), new D(1, 1, 1)];
	class Vv {
		constructor(e) {
			(this._renderer = e), (this._pingPongRenderTarget = null), (this._lodMax = 0), (this._cubeSize = 0), (this._lodPlanes = []), (this._sizeLods = []), (this._sigmas = []), (this._blurMaterial = null), (this._cubemapMaterial = null), (this._equirectMaterial = null), this._compileMaterial(this._blurMaterial);
		}
		fromScene(e, t = 0, i = 0.1, r = 100) {
			(Dd = this._renderer.getRenderTarget()), (Od = this._renderer.getActiveCubeFace()), (Id = this._renderer.getActiveMipmapLevel()), (Fd = this._renderer.xr.enabled), (this._renderer.xr.enabled = !1), this._setSize(256);
			const s = this._allocateTargets();
			return (s.depthBuffer = !0), this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
		}
		fromEquirectangular(e, t = null) {
			return this._fromTexture(e, t);
		}
		fromCubemap(e, t = null) {
			return this._fromTexture(e, t);
		}
		compileCubemapShader() {
			this._cubemapMaterial === null && ((this._cubemapMaterial = $v()), this._compileMaterial(this._cubemapMaterial));
		}
		compileEquirectangularShader() {
			this._equirectMaterial === null && ((this._equirectMaterial = Xv()), this._compileMaterial(this._equirectMaterial));
		}
		dispose() {
			this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
		}
		_setSize(e) {
			(this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
		}
		_dispose() {
			this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
			for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
		}
		_cleanup(e) {
			this._renderer.setRenderTarget(Dd, Od, Id), (this._renderer.xr.enabled = Fd), (e.scissorTest = !1), Qc(e, 0, 0, e.width, e.height);
		}
		_fromTexture(e, t) {
			e.mapping === No || e.mapping === Uo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), (Dd = this._renderer.getRenderTarget()), (Od = this._renderer.getActiveCubeFace()), (Id = this._renderer.getActiveMipmapLevel()), (Fd = this._renderer.xr.enabled), (this._renderer.xr.enabled = !1);
			const i = t || this._allocateTargets();
			return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
		}
		_allocateTargets() {
			const e = 3 * Math.max(this._cubeSize, 112),
				t = 4 * this._cubeSize,
				i = { magFilter: Zi, minFilter: Zi, generateMipmaps: !1, type: Jl, format: er, colorSpace: Fs, depthBuffer: !1 },
				r = Wv(e, t, i);
			if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
				this._pingPongRenderTarget !== null && this._dispose(), (this._pingPongRenderTarget = Wv(e, t, i));
				const { _lodMax: s } = this;
				({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = i2(s)), (this._blurMaterial = r2(s, e, t));
			}
			return r;
		}
		_compileMaterial(e) {
			const t = new Re(this._lodPlanes[0], e);
			this._renderer.compile(t, Pd);
		}
		_sceneToCubeUV(e, t, i, r) {
			const o = new fi(90, 1, t, i),
				l = [1, -1, 1, 1, 1, 1],
				c = [1, 1, 1, -1, -1, -1],
				u = this._renderer,
				h = u.autoClear,
				d = u.toneMapping;
			u.getClearColor(Hv), (u.toneMapping = Ts), (u.autoClear = !1);
			const f = new Kt({ name: "PMREM.Background", side: li, depthWrite: !1, depthTest: !1 }),
				v = new Re(new yn(), f);
			let _ = !1;
			const p = e.background;
			p ? p.isColor && (f.color.copy(p), (e.background = null), (_ = !0)) : (f.color.copy(Hv), (_ = !0));
			for (let g = 0; g < 6; g++) {
				const x = g % 3;
				x === 0 ? (o.up.set(0, l[g], 0), o.lookAt(c[g], 0, 0)) : x === 1 ? (o.up.set(0, 0, l[g]), o.lookAt(0, c[g], 0)) : (o.up.set(0, l[g], 0), o.lookAt(0, 0, c[g]));
				const b = this._cubeSize;
				Qc(r, x * b, g > 2 ? b : 0, b, b), u.setRenderTarget(r), _ && u.render(v, o), u.render(e, o);
			}
			v.geometry.dispose(), v.material.dispose(), (u.toneMapping = d), (u.autoClear = h), (e.background = p);
		}
		_textureToCubeUV(e, t) {
			const i = this._renderer,
				r = e.mapping === No || e.mapping === Uo;
			r ? (this._cubemapMaterial === null && (this._cubemapMaterial = $v()), (this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1)) : this._equirectMaterial === null && (this._equirectMaterial = Xv());
			const s = r ? this._cubemapMaterial : this._equirectMaterial,
				a = new Re(this._lodPlanes[0], s),
				o = s.uniforms;
			o.envMap.value = e;
			const l = this._cubeSize;
			Qc(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, Pd);
		}
		_applyPMREM(e) {
			const t = this._renderer,
				i = t.autoClear;
			t.autoClear = !1;
			const r = this._lodPlanes.length;
			for (let s = 1; s < r; s++) {
				const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
					o = Gv[(r - s - 1) % Gv.length];
				this._blur(e, s - 1, s, a, o);
			}
			t.autoClear = i;
		}
		_blur(e, t, i, r, s) {
			const a = this._pingPongRenderTarget;
			this._halfBlur(e, a, t, i, r, "latitudinal", s), this._halfBlur(a, e, i, i, r, "longitudinal", s);
		}
		_halfBlur(e, t, i, r, s, a, o) {
			const l = this._renderer,
				c = this._blurMaterial;
			a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
			const u = 3,
				h = new Re(this._lodPlanes[r], c),
				d = c.uniforms,
				f = this._sizeLods[i] - 1,
				v = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * oa - 1),
				_ = s / v,
				p = isFinite(s) ? 1 + Math.floor(u * _) : oa;
			p > oa && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${oa}`);
			const g = [];
			let x = 0;
			for (let M = 0; M < oa; ++M) {
				const w = M / _,
					y = Math.exp((-w * w) / 2);
				g.push(y), M === 0 ? (x += y) : M < p && (x += 2 * y);
			}
			for (let M = 0; M < g.length; M++) g[M] = g[M] / x;
			(d.envMap.value = e.texture), (d.samples.value = p), (d.weights.value = g), (d.latitudinal.value = a === "latitudinal"), o && (d.poleAxis.value = o);
			const { _lodMax: b } = this;
			(d.dTheta.value = v), (d.mipInt.value = b - i);
			const T = this._sizeLods[r],
				P = 3 * T * (r > b - go ? r - b + go : 0),
				A = 4 * (this._cubeSize - T);
			Qc(t, P, A, 3 * T, 2 * T), l.setRenderTarget(t), l.render(h, Pd);
		}
	}
	function i2(n) {
		const e = [],
			t = [],
			i = [];
		let r = n;
		const s = n - go + 1 + zv.length;
		for (let a = 0; a < s; a++) {
			const o = Math.pow(2, r);
			t.push(o);
			let l = 1 / o;
			a > n - go ? (l = zv[a - n + go - 1]) : a === 0 && (l = 0), i.push(l);
			const c = 1 / (o - 2),
				u = -c,
				h = 1 + c,
				d = [u, u, h, u, h, h, u, u, h, h, u, h],
				f = 6,
				v = 6,
				_ = 3,
				p = 2,
				g = 1,
				x = new Float32Array(_ * v * f),
				b = new Float32Array(p * v * f),
				T = new Float32Array(g * v * f);
			for (let A = 0; A < f; A++) {
				const M = ((A % 3) * 2) / 3 - 1,
					w = A > 2 ? 0 : -1,
					y = [M, w, 0, M + 2 / 3, w, 0, M + 2 / 3, w + 1, 0, M, w, 0, M + 2 / 3, w + 1, 0, M, w + 1, 0];
				x.set(y, _ * v * A), b.set(d, p * v * A);
				const S = [A, A, A, A, A, A];
				T.set(S, g * v * A);
			}
			const P = new bt();
			P.setAttribute("position", new mn(x, _)), P.setAttribute("uv", new mn(b, p)), P.setAttribute("faceIndex", new mn(T, g)), e.push(P), r > go && r--;
		}
		return { lodPlanes: e, sizeLods: t, sigmas: i };
	}
	function Wv(n, e, t) {
		const i = new ya(n, e, t);
		return (i.texture.mapping = gh), (i.texture.name = "PMREM.cubeUv"), (i.scissorTest = !0), i;
	}
	function Qc(n, e, t, i, r) {
		n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
	}
	function r2(n, e, t) {
		const i = new Float32Array(oa),
			r = new D(0, 1, 0);
		return new wr({
			name: "SphericalGaussianBlur",
			defines: { n: oa, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` },
			uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } },
			vertexShader: jp(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
			blending: ws,
			depthTest: !1,
			depthWrite: !1
		});
	}
	function Xv() {
		return new wr({
			name: "EquirectangularToCubeUV",
			uniforms: { envMap: { value: null } },
			vertexShader: jp(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
			blending: ws,
			depthTest: !1,
			depthWrite: !1
		});
	}
	function $v() {
		return new wr({
			name: "CubemapToCubeUV",
			uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
			vertexShader: jp(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
			blending: ws,
			depthTest: !1,
			depthWrite: !1
		});
	}
	function jp() {
		return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
	}
	function s2(n) {
		let e = new WeakMap(),
			t = null;
		function i(o) {
			if (o && o.isTexture) {
				const l = o.mapping,
					c = l === Sf || l === Ef,
					u = l === No || l === Uo;
				if (c || u) {
					let h = e.get(o);
					const d = h !== void 0 ? h.texture.pmremVersion : 0;
					if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new Vv(n)), (h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h)), (h.texture.pmremVersion = o.pmremVersion), e.set(o, h), h.texture;
					if (h !== void 0) return h.texture;
					{
						const f = o.image;
						return (c && f && f.height > 0) || (u && f && r(f)) ? (t === null && (t = new Vv(n)), (h = c ? t.fromEquirectangular(o) : t.fromCubemap(o)), (h.texture.pmremVersion = o.pmremVersion), e.set(o, h), o.addEventListener("dispose", s), h.texture) : null;
					}
				}
			}
			return o;
		}
		function r(o) {
			let l = 0;
			const c = 6;
			for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
			return l === c;
		}
		function s(o) {
			const l = o.target;
			l.removeEventListener("dispose", s);
			const c = e.get(l);
			c !== void 0 && (e.delete(l), c.dispose());
		}
		function a() {
			(e = new WeakMap()), t !== null && (t.dispose(), (t = null));
		}
		return { get: i, dispose: a };
	}
	function a2(n) {
		const e = {};
		function t(i) {
			if (e[i] !== void 0) return e[i];
			let r;
			switch (i) {
				case "WEBGL_depth_texture":
					r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
					break;
				case "EXT_texture_filter_anisotropic":
					r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
					break;
				case "WEBGL_compressed_texture_s3tc":
					r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
					break;
				case "WEBGL_compressed_texture_pvrtc":
					r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
					break;
				default:
					r = n.getExtension(i);
			}
			return (e[i] = r), r;
		}
		return {
			has: function (i) {
				return t(i) !== null;
			},
			init: function () {
				t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
			},
			get: function (i) {
				const r = t(i);
				return r === null && Eo("THREE.WebGLRenderer: " + i + " extension not supported."), r;
			}
		};
	}
	function o2(n, e, t, i) {
		const r = {},
			s = new WeakMap();
		function a(h) {
			const d = h.target;
			d.index !== null && e.remove(d.index);
			for (const v in d.attributes) e.remove(d.attributes[v]);
			for (const v in d.morphAttributes) {
				const _ = d.morphAttributes[v];
				for (let p = 0, g = _.length; p < g; p++) e.remove(_[p]);
			}
			d.removeEventListener("dispose", a), delete r[d.id];
			const f = s.get(d);
			f && (e.remove(f), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
		}
		function o(h, d) {
			return r[d.id] === !0 || (d.addEventListener("dispose", a), (r[d.id] = !0), t.memory.geometries++), d;
		}
		function l(h) {
			const d = h.attributes;
			for (const v in d) e.update(d[v], n.ARRAY_BUFFER);
			const f = h.morphAttributes;
			for (const v in f) {
				const _ = f[v];
				for (let p = 0, g = _.length; p < g; p++) e.update(_[p], n.ARRAY_BUFFER);
			}
		}
		function c(h) {
			const d = [],
				f = h.index,
				v = h.attributes.position;
			let _ = 0;
			if (f !== null) {
				const x = f.array;
				_ = f.version;
				for (let b = 0, T = x.length; b < T; b += 3) {
					const P = x[b + 0],
						A = x[b + 1],
						M = x[b + 2];
					d.push(P, A, A, M, M, P);
				}
			} else if (v !== void 0) {
				const x = v.array;
				_ = v.version;
				for (let b = 0, T = x.length / 3 - 1; b < T; b += 3) {
					const P = b + 0,
						A = b + 1,
						M = b + 2;
					d.push(P, A, A, M, M, P);
				}
			} else return;
			const p = new (Jy(d) ? ix : nx)(d, 1);
			p.version = _;
			const g = s.get(h);
			g && e.remove(g), s.set(h, p);
		}
		function u(h) {
			const d = s.get(h);
			if (d) {
				const f = h.index;
				f !== null && d.version < f.version && c(h);
			} else c(h);
			return s.get(h);
		}
		return { get: o, update: l, getWireframeAttribute: u };
	}
	function l2(n, e, t) {
		let i;
		function r(d) {
			i = d;
		}
		let s, a;
		function o(d) {
			(s = d.type), (a = d.bytesPerElement);
		}
		function l(d, f) {
			n.drawElements(i, f, s, d * a), t.update(f, i, 1);
		}
		function c(d, f, v) {
			v !== 0 && (n.drawElementsInstanced(i, f, s, d * a, v), t.update(f, i, v));
		}
		function u(d, f, v) {
			if (v === 0) return;
			e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, s, d, 0, v);
			let p = 0;
			for (let g = 0; g < v; g++) p += f[g];
			t.update(p, i, 1);
		}
		function h(d, f, v, _) {
			if (v === 0) return;
			const p = e.get("WEBGL_multi_draw");
			if (p === null) for (let g = 0; g < d.length; g++) c(d[g] / a, f[g], _[g]);
			else {
				p.multiDrawElementsInstancedWEBGL(i, f, 0, s, d, 0, _, 0, v);
				let g = 0;
				for (let x = 0; x < v; x++) g += f[x];
				for (let x = 0; x < _.length; x++) t.update(g, i, _[x]);
			}
		}
		(this.setMode = r), (this.setIndex = o), (this.render = l), (this.renderInstances = c), (this.renderMultiDraw = u), (this.renderMultiDrawInstances = h);
	}
	function c2(n) {
		const e = { geometries: 0, textures: 0 },
			t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
		function i(s, a, o) {
			switch ((t.calls++, a)) {
				case n.TRIANGLES:
					t.triangles += o * (s / 3);
					break;
				case n.LINES:
					t.lines += o * (s / 2);
					break;
				case n.LINE_STRIP:
					t.lines += o * (s - 1);
					break;
				case n.LINE_LOOP:
					t.lines += o * s;
					break;
				case n.POINTS:
					t.points += o * s;
					break;
				default:
					console.error("THREE.WebGLInfo: Unknown draw mode:", a);
					break;
			}
		}
		function r() {
			(t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
		}
		return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: i };
	}
	function u2(n, e, t) {
		const i = new WeakMap(),
			r = new wn();
		function s(a, o, l) {
			const c = a.morphTargetInfluences,
				u = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
				h = u !== void 0 ? u.length : 0;
			let d = i.get(o);
			if (d === void 0 || d.count !== h) {
				let S = function () {
					w.dispose(), i.delete(o), o.removeEventListener("dispose", S);
				};
				var f = S;
				d !== void 0 && d.texture.dispose();
				const v = o.morphAttributes.position !== void 0,
					_ = o.morphAttributes.normal !== void 0,
					p = o.morphAttributes.color !== void 0,
					g = o.morphAttributes.position || [],
					x = o.morphAttributes.normal || [],
					b = o.morphAttributes.color || [];
				let T = 0;
				v === !0 && (T = 1), _ === !0 && (T = 2), p === !0 && (T = 3);
				let P = o.attributes.position.count * T,
					A = 1;
				P > e.maxTextureSize && ((A = Math.ceil(P / e.maxTextureSize)), (P = e.maxTextureSize));
				const M = new Float32Array(P * A * 4 * h),
					w = new ex(M, P, A, h);
				(w.type = Hr), (w.needsUpdate = !0);
				const y = T * 4;
				for (let L = 0; L < h; L++) {
					const N = g[L],
						k = x[L],
						B = b[L],
						W = P * A * 4 * L;
					for (let H = 0; H < N.count; H++) {
						const z = H * y;
						v === !0 && (r.fromBufferAttribute(N, H), (M[W + z + 0] = r.x), (M[W + z + 1] = r.y), (M[W + z + 2] = r.z), (M[W + z + 3] = 0)), _ === !0 && (r.fromBufferAttribute(k, H), (M[W + z + 4] = r.x), (M[W + z + 5] = r.y), (M[W + z + 6] = r.z), (M[W + z + 7] = 0)), p === !0 && (r.fromBufferAttribute(B, H), (M[W + z + 8] = r.x), (M[W + z + 9] = r.y), (M[W + z + 10] = r.z), (M[W + z + 11] = B.itemSize === 4 ? r.w : 1));
					}
				}
				(d = { count: h, texture: w, size: new Se(P, A) }), i.set(o, d), o.addEventListener("dispose", S);
			}
			if (a.isInstancedMesh === !0 && a.morphTexture !== null) l.getUniforms().setValue(n, "morphTexture", a.morphTexture, t);
			else {
				let v = 0;
				for (let p = 0; p < c.length; p++) v += c[p];
				const _ = o.morphTargetsRelative ? 1 : 1 - v;
				l.getUniforms().setValue(n, "morphTargetBaseInfluence", _), l.getUniforms().setValue(n, "morphTargetInfluences", c);
			}
			l.getUniforms().setValue(n, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(n, "morphTargetsTextureSize", d.size);
		}
		return { update: s };
	}
	function h2(n, e, t, i) {
		let r = new WeakMap();
		function s(l) {
			const c = i.render.frame,
				u = l.geometry,
				h = e.get(l, u);
			if ((r.get(h) !== c && (e.update(h), r.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh)) {
				const d = l.skeleton;
				r.get(d) !== c && (d.update(), r.set(d, c));
			}
			return h;
		}
		function a() {
			r = new WeakMap();
		}
		function o(l) {
			const c = l.target;
			c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
		}
		return { update: s, dispose: a };
	}
	class lx extends jn {
		constructor(e, t, i, r, s, a, o, l, c, u = So) {
			if (u !== So && u !== Bo) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
			i === void 0 && u === So && (i = _a), i === void 0 && u === Bo && (i = ko), super(null, r, s, a, o, l, u, i, c), (this.isDepthTexture = !0), (this.image = { width: e, height: t }), (this.magFilter = o !== void 0 ? o : Di), (this.minFilter = l !== void 0 ? l : Di), (this.flipY = !1), (this.generateMipmaps = !1), (this.compareFunction = null);
		}
		copy(e) {
			return super.copy(e), (this.compareFunction = e.compareFunction), this;
		}
		toJSON(e) {
			const t = super.toJSON(e);
			return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
		}
	}
	const cx = new jn(),
		qv = new lx(1, 1),
		ux = new ex(),
		hx = new ZC(),
		dx = new ax(),
		jv = [],
		Yv = [],
		Kv = new Float32Array(16),
		Zv = new Float32Array(9),
		Jv = new Float32Array(4);
	function qo(n, e, t) {
		const i = n[0];
		if (i <= 0 || i > 0) return n;
		const r = e * t;
		let s = jv[r];
		if ((s === void 0 && ((s = new Float32Array(r)), (jv[r] = s)), e !== 0)) {
			i.toArray(s, 0);
			for (let a = 1, o = 0; a !== e; ++a) (o += t), n[a].toArray(s, o);
		}
		return s;
	}
	function Cn(n, e) {
		if (n.length !== e.length) return !1;
		for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
		return !0;
	}
	function Ln(n, e) {
		for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
	}
	function yh(n, e) {
		let t = Yv[e];
		t === void 0 && ((t = new Int32Array(e)), (Yv[e] = t));
		for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
		return t;
	}
	function d2(n, e) {
		const t = this.cache;
		t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
	}
	function f2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
		else {
			if (Cn(t, e)) return;
			n.uniform2fv(this.addr, e), Ln(t, e);
		}
	}
	function p2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
		else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b));
		else {
			if (Cn(t, e)) return;
			n.uniform3fv(this.addr, e), Ln(t, e);
		}
	}
	function m2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
		else {
			if (Cn(t, e)) return;
			n.uniform4fv(this.addr, e), Ln(t, e);
		}
	}
	function g2(n, e) {
		const t = this.cache,
			i = e.elements;
		if (i === void 0) {
			if (Cn(t, e)) return;
			n.uniformMatrix2fv(this.addr, !1, e), Ln(t, e);
		} else {
			if (Cn(t, i)) return;
			Jv.set(i), n.uniformMatrix2fv(this.addr, !1, Jv), Ln(t, i);
		}
	}
	function v2(n, e) {
		const t = this.cache,
			i = e.elements;
		if (i === void 0) {
			if (Cn(t, e)) return;
			n.uniformMatrix3fv(this.addr, !1, e), Ln(t, e);
		} else {
			if (Cn(t, i)) return;
			Zv.set(i), n.uniformMatrix3fv(this.addr, !1, Zv), Ln(t, i);
		}
	}
	function _2(n, e) {
		const t = this.cache,
			i = e.elements;
		if (i === void 0) {
			if (Cn(t, e)) return;
			n.uniformMatrix4fv(this.addr, !1, e), Ln(t, e);
		} else {
			if (Cn(t, i)) return;
			Kv.set(i), n.uniformMatrix4fv(this.addr, !1, Kv), Ln(t, i);
		}
	}
	function y2(n, e) {
		const t = this.cache;
		t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
	}
	function x2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
		else {
			if (Cn(t, e)) return;
			n.uniform2iv(this.addr, e), Ln(t, e);
		}
	}
	function b2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
		else {
			if (Cn(t, e)) return;
			n.uniform3iv(this.addr, e), Ln(t, e);
		}
	}
	function S2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
		else {
			if (Cn(t, e)) return;
			n.uniform4iv(this.addr, e), Ln(t, e);
		}
	}
	function E2(n, e) {
		const t = this.cache;
		t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
	}
	function w2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
		else {
			if (Cn(t, e)) return;
			n.uniform2uiv(this.addr, e), Ln(t, e);
		}
	}
	function T2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
		else {
			if (Cn(t, e)) return;
			n.uniform3uiv(this.addr, e), Ln(t, e);
		}
	}
	function M2(n, e) {
		const t = this.cache;
		if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
		else {
			if (Cn(t, e)) return;
			n.uniform4uiv(this.addr, e), Ln(t, e);
		}
	}
	function A2(n, e, t) {
		const i = this.cache,
			r = t.allocateTextureUnit();
		i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
		let s;
		this.type === n.SAMPLER_2D_SHADOW ? ((qv.compareFunction = Zy), (s = qv)) : (s = cx), t.setTexture2D(e || s, r);
	}
	function C2(n, e, t) {
		const i = this.cache,
			r = t.allocateTextureUnit();
		i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture3D(e || hx, r);
	}
	function L2(n, e, t) {
		const i = this.cache,
			r = t.allocateTextureUnit();
		i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTextureCube(e || dx, r);
	}
	function R2(n, e, t) {
		const i = this.cache,
			r = t.allocateTextureUnit();
		i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture2DArray(e || ux, r);
	}
	function P2(n) {
		switch (n) {
			case 5126:
				return d2;
			case 35664:
				return f2;
			case 35665:
				return p2;
			case 35666:
				return m2;
			case 35674:
				return g2;
			case 35675:
				return v2;
			case 35676:
				return _2;
			case 5124:
			case 35670:
				return y2;
			case 35667:
			case 35671:
				return x2;
			case 35668:
			case 35672:
				return b2;
			case 35669:
			case 35673:
				return S2;
			case 5125:
				return E2;
			case 36294:
				return w2;
			case 36295:
				return T2;
			case 36296:
				return M2;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return A2;
			case 35679:
			case 36299:
			case 36307:
				return C2;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return L2;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return R2;
		}
	}
	function D2(n, e) {
		n.uniform1fv(this.addr, e);
	}
	function O2(n, e) {
		const t = qo(e, this.size, 2);
		n.uniform2fv(this.addr, t);
	}
	function I2(n, e) {
		const t = qo(e, this.size, 3);
		n.uniform3fv(this.addr, t);
	}
	function F2(n, e) {
		const t = qo(e, this.size, 4);
		n.uniform4fv(this.addr, t);
	}
	function N2(n, e) {
		const t = qo(e, this.size, 4);
		n.uniformMatrix2fv(this.addr, !1, t);
	}
	function U2(n, e) {
		const t = qo(e, this.size, 9);
		n.uniformMatrix3fv(this.addr, !1, t);
	}
	function k2(n, e) {
		const t = qo(e, this.size, 16);
		n.uniformMatrix4fv(this.addr, !1, t);
	}
	function B2(n, e) {
		n.uniform1iv(this.addr, e);
	}
	function z2(n, e) {
		n.uniform2iv(this.addr, e);
	}
	function H2(n, e) {
		n.uniform3iv(this.addr, e);
	}
	function G2(n, e) {
		n.uniform4iv(this.addr, e);
	}
	function V2(n, e) {
		n.uniform1uiv(this.addr, e);
	}
	function W2(n, e) {
		n.uniform2uiv(this.addr, e);
	}
	function X2(n, e) {
		n.uniform3uiv(this.addr, e);
	}
	function $2(n, e) {
		n.uniform4uiv(this.addr, e);
	}
	function q2(n, e, t) {
		const i = this.cache,
			r = e.length,
			s = yh(t, r);
		Cn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
		for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || cx, s[a]);
	}
	function j2(n, e, t) {
		const i = this.cache,
			r = e.length,
			s = yh(t, r);
		Cn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
		for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || hx, s[a]);
	}
	function Y2(n, e, t) {
		const i = this.cache,
			r = e.length,
			s = yh(t, r);
		Cn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
		for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || dx, s[a]);
	}
	function K2(n, e, t) {
		const i = this.cache,
			r = e.length,
			s = yh(t, r);
		Cn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
		for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || ux, s[a]);
	}
	function Z2(n) {
		switch (n) {
			case 5126:
				return D2;
			case 35664:
				return O2;
			case 35665:
				return I2;
			case 35666:
				return F2;
			case 35674:
				return N2;
			case 35675:
				return U2;
			case 35676:
				return k2;
			case 5124:
			case 35670:
				return B2;
			case 35667:
			case 35671:
				return z2;
			case 35668:
			case 35672:
				return H2;
			case 35669:
			case 35673:
				return G2;
			case 5125:
				return V2;
			case 36294:
				return W2;
			case 36295:
				return X2;
			case 36296:
				return $2;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return q2;
			case 35679:
			case 36299:
			case 36307:
				return j2;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return Y2;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return K2;
		}
	}
	class J2 {
		constructor(e, t, i) {
			(this.id = e), (this.addr = i), (this.cache = []), (this.type = t.type), (this.setValue = P2(t.type));
		}
	}
	class Q2 {
		constructor(e, t, i) {
			(this.id = e), (this.addr = i), (this.cache = []), (this.type = t.type), (this.size = t.size), (this.setValue = Z2(t.type));
		}
	}
	class eD {
		constructor(e) {
			(this.id = e), (this.seq = []), (this.map = {});
		}
		setValue(e, t, i) {
			const r = this.seq;
			for (let s = 0, a = r.length; s !== a; ++s) {
				const o = r[s];
				o.setValue(e, t[o.id], i);
			}
		}
	}
	const Nd = /(\w+)(\])?(\[|\.)?/g;
	function Qv(n, e) {
		n.seq.push(e), (n.map[e.id] = e);
	}
	function tD(n, e, t) {
		const i = n.name,
			r = i.length;
		for (Nd.lastIndex = 0; ; ) {
			const s = Nd.exec(i),
				a = Nd.lastIndex;
			let o = s[1];
			const l = s[2] === "]",
				c = s[3];
			if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
				Qv(t, c === void 0 ? new J2(o, n, e) : new Q2(o, n, e));
				break;
			} else {
				let h = t.map[o];
				h === void 0 && ((h = new eD(o)), Qv(t, h)), (t = h);
			}
		}
	}
	class Ou {
		constructor(e, t) {
			(this.seq = []), (this.map = {});
			const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
			for (let r = 0; r < i; ++r) {
				const s = e.getActiveUniform(t, r),
					a = e.getUniformLocation(t, s.name);
				tD(s, a, this);
			}
		}
		setValue(e, t, i, r) {
			const s = this.map[t];
			s !== void 0 && s.setValue(e, i, r);
		}
		setOptional(e, t, i) {
			const r = t[i];
			r !== void 0 && this.setValue(e, i, r);
		}
		static upload(e, t, i, r) {
			for (let s = 0, a = t.length; s !== a; ++s) {
				const o = t[s],
					l = i[o.id];
				l.needsUpdate !== !1 && o.setValue(e, l.value, r);
			}
		}
		static seqWithValue(e, t) {
			const i = [];
			for (let r = 0, s = e.length; r !== s; ++r) {
				const a = e[r];
				a.id in t && i.push(a);
			}
			return i;
		}
	}
	function e0(n, e, t) {
		const i = n.createShader(e);
		return n.shaderSource(i, t), n.compileShader(i), i;
	}
	const nD = 37297;
	let iD = 0;
	function rD(n, e) {
		const t = n.split(`
`),
			i = [],
			r = Math.max(e - 6, 0),
			s = Math.min(e + 6, t.length);
		for (let a = r; a < s; a++) {
			const o = a + 1;
			i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
		}
		return i.join(`
`);
	}
	function sD(n) {
		const e = zt.getPrimaries(zt.workingColorSpace),
			t = zt.getPrimaries(n);
		let i;
		switch ((e === t ? (i = "") : e === ju && t === qu ? (i = "LinearDisplayP3ToLinearSRGB") : e === qu && t === ju && (i = "LinearSRGBToLinearDisplayP3"), n)) {
			case Fs:
			case vh:
				return [i, "LinearTransferOETF"];
			case ni:
			case Wp:
				return [i, "sRGBTransferOETF"];
			default:
				return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [i, "LinearTransferOETF"];
		}
	}
	function t0(n, e, t) {
		const i = n.getShaderParameter(e, n.COMPILE_STATUS),
			r = n.getShaderInfoLog(e).trim();
		if (i && r === "") return "";
		const s = /ERROR: 0:(\d+)/.exec(r);
		if (s) {
			const a = parseInt(s[1]);
			return (
				t.toUpperCase() +
				`

` +
				r +
				`

` +
				rD(n.getShaderSource(e), a)
			);
		} else return r;
	}
	function aD(n, e) {
		const t = sD(e);
		return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
	}
	function oD(n, e) {
		let t;
		switch (e) {
			case uC:
				t = "Linear";
				break;
			case hC:
				t = "Reinhard";
				break;
			case dC:
				t = "OptimizedCineon";
				break;
			case fC:
				t = "ACESFilmic";
				break;
			case mC:
				t = "AgX";
				break;
			case gC:
				t = "Neutral";
				break;
			case pC:
				t = "Custom";
				break;
			default:
				console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), (t = "Linear");
		}
		return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
	}
	const eu = new D();
	function lD() {
		zt.getLuminanceCoefficients(eu);
		const n = eu.x.toFixed(4),
			e = eu.y.toFixed(4),
			t = eu.z.toFixed(4);
		return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`);
	}
	function cD(n) {
		return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(bl).join(`
`);
	}
	function uD(n) {
		const e = [];
		for (const t in n) {
			const i = n[t];
			i !== !1 && e.push("#define " + t + " " + i);
		}
		return e.join(`
`);
	}
	function hD(n, e) {
		const t = {},
			i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
		for (let r = 0; r < i; r++) {
			const s = n.getActiveAttrib(e, r),
				a = s.name;
			let o = 1;
			s.type === n.FLOAT_MAT2 && (o = 2), s.type === n.FLOAT_MAT3 && (o = 3), s.type === n.FLOAT_MAT4 && (o = 4), (t[a] = { type: s.type, location: n.getAttribLocation(e, a), locationSize: o });
		}
		return t;
	}
	function bl(n) {
		return n !== "";
	}
	function n0(n, e) {
		const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
		return n
			.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
			.replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
			.replace(/NUM_SPOT_LIGHT_COORDS/g, t)
			.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
	}
	function i0(n, e) {
		return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
	}
	const dD = /^[ \t]*#include +<([\w\d./]+)>/gm;
	function Jf(n) {
		return n.replace(dD, pD);
	}
	const fD = new Map();
	function pD(n, e) {
		let t = st[e];
		if (t === void 0) {
			const i = fD.get(e);
			if (i !== void 0) (t = st[i]), console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
			else throw new Error("Can not resolve #include <" + e + ">");
		}
		return Jf(t);
	}
	const mD = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
	function r0(n) {
		return n.replace(mD, gD);
	}
	function gD(n, e, t, i) {
		let r = "";
		for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
		return r;
	}
	function s0(n) {
		let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
		return (
			n.precision === "highp"
				? (e += `
#define HIGH_PRECISION`)
				: n.precision === "mediump"
				? (e += `
#define MEDIUM_PRECISION`)
				: n.precision === "lowp" &&
				  (e += `
#define LOW_PRECISION`),
			e
		);
	}
	function vD(n) {
		let e = "SHADOWMAP_TYPE_BASIC";
		return n.shadowMapType === ky ? (e = "SHADOWMAP_TYPE_PCF") : n.shadowMapType === NA ? (e = "SHADOWMAP_TYPE_PCF_SOFT") : n.shadowMapType === Br && (e = "SHADOWMAP_TYPE_VSM"), e;
	}
	function _D(n) {
		let e = "ENVMAP_TYPE_CUBE";
		if (n.envMap)
			switch (n.envMapMode) {
				case No:
				case Uo:
					e = "ENVMAP_TYPE_CUBE";
					break;
				case gh:
					e = "ENVMAP_TYPE_CUBE_UV";
					break;
			}
		return e;
	}
	function yD(n) {
		let e = "ENVMAP_MODE_REFLECTION";
		if (n.envMap)
			switch (n.envMapMode) {
				case Uo:
					e = "ENVMAP_MODE_REFRACTION";
					break;
			}
		return e;
	}
	function xD(n) {
		let e = "ENVMAP_BLENDING_NONE";
		if (n.envMap)
			switch (n.combine) {
				case Up:
					e = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case lC:
					e = "ENVMAP_BLENDING_MIX";
					break;
				case cC:
					e = "ENVMAP_BLENDING_ADD";
					break;
			}
		return e;
	}
	function bD(n) {
		const e = n.envMapCubeUVHeight;
		if (e === null) return null;
		const t = Math.log2(e) - 2,
			i = 1 / e;
		return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
	}
	function SD(n, e, t, i) {
		const r = n.getContext(),
			s = t.defines;
		let a = t.vertexShader,
			o = t.fragmentShader;
		const l = vD(t),
			c = _D(t),
			u = yD(t),
			h = xD(t),
			d = bD(t),
			f = cD(t),
			v = uD(s),
			_ = r.createProgram();
		let p,
			g,
			x = t.glslVersion
				? "#version " +
				  t.glslVersion +
				  `
`
				: "";
		t.isRawShaderMaterial
			? ((p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v].filter(bl).join(`
`)),
			  p.length > 0 &&
					(p += `
`),
			  (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, v].filter(bl).join(`
`)),
			  g.length > 0 &&
					(g += `
`))
			: ((p = [
					s0(t),
					"#define SHADER_TYPE " + t.shaderType,
					"#define SHADER_NAME " + t.shaderName,
					v,
					t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
					t.batching ? "#define USE_BATCHING" : "",
					t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
					t.instancing ? "#define USE_INSTANCING" : "",
					t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
					t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
					t.useFog && t.fog ? "#define USE_FOG" : "",
					t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
					t.map ? "#define USE_MAP" : "",
					t.envMap ? "#define USE_ENVMAP" : "",
					t.envMap ? "#define " + u : "",
					t.lightMap ? "#define USE_LIGHTMAP" : "",
					t.aoMap ? "#define USE_AOMAP" : "",
					t.bumpMap ? "#define USE_BUMPMAP" : "",
					t.normalMap ? "#define USE_NORMALMAP" : "",
					t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
					t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
					t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
					t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
					t.anisotropy ? "#define USE_ANISOTROPY" : "",
					t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
					t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
					t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
					t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
					t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
					t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
					t.specularMap ? "#define USE_SPECULARMAP" : "",
					t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
					t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
					t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
					t.metalnessMap ? "#define USE_METALNESSMAP" : "",
					t.alphaMap ? "#define USE_ALPHAMAP" : "",
					t.alphaHash ? "#define USE_ALPHAHASH" : "",
					t.transmission ? "#define USE_TRANSMISSION" : "",
					t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
					t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
					t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
					t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
					t.mapUv ? "#define MAP_UV " + t.mapUv : "",
					t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
					t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
					t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
					t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
					t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
					t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
					t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
					t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
					t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
					t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
					t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
					t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
					t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
					t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
					t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
					t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
					t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
					t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
					t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
					t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
					t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
					t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
					t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
					t.vertexColors ? "#define USE_COLOR" : "",
					t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
					t.vertexUv1s ? "#define USE_UV1" : "",
					t.vertexUv2s ? "#define USE_UV2" : "",
					t.vertexUv3s ? "#define USE_UV3" : "",
					t.pointsUvs ? "#define USE_POINTS_UV" : "",
					t.flatShading ? "#define FLAT_SHADED" : "",
					t.skinning ? "#define USE_SKINNING" : "",
					t.morphTargets ? "#define USE_MORPHTARGETS" : "",
					t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
					t.morphColors ? "#define USE_MORPHCOLORS" : "",
					t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
					t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
					t.doubleSided ? "#define DOUBLE_SIDED" : "",
					t.flipSided ? "#define FLIP_SIDED" : "",
					t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
					t.shadowMapEnabled ? "#define " + l : "",
					t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
					t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
					t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
					"uniform mat4 modelMatrix;",
					"uniform mat4 modelViewMatrix;",
					"uniform mat4 projectionMatrix;",
					"uniform mat4 viewMatrix;",
					"uniform mat3 normalMatrix;",
					"uniform vec3 cameraPosition;",
					"uniform bool isOrthographic;",
					"#ifdef USE_INSTANCING",
					"	attribute mat4 instanceMatrix;",
					"#endif",
					"#ifdef USE_INSTANCING_COLOR",
					"	attribute vec3 instanceColor;",
					"#endif",
					"#ifdef USE_INSTANCING_MORPH",
					"	uniform sampler2D morphTexture;",
					"#endif",
					"attribute vec3 position;",
					"attribute vec3 normal;",
					"attribute vec2 uv;",
					"#ifdef USE_UV1",
					"	attribute vec2 uv1;",
					"#endif",
					"#ifdef USE_UV2",
					"	attribute vec2 uv2;",
					"#endif",
					"#ifdef USE_UV3",
					"	attribute vec2 uv3;",
					"#endif",
					"#ifdef USE_TANGENT",
					"	attribute vec4 tangent;",
					"#endif",
					"#if defined( USE_COLOR_ALPHA )",
					"	attribute vec4 color;",
					"#elif defined( USE_COLOR )",
					"	attribute vec3 color;",
					"#endif",
					"#ifdef USE_SKINNING",
					"	attribute vec4 skinIndex;",
					"	attribute vec4 skinWeight;",
					"#endif",
					`
`
			  ].filter(bl).join(`
`)),
			  (g = [
					s0(t),
					"#define SHADER_TYPE " + t.shaderType,
					"#define SHADER_NAME " + t.shaderName,
					v,
					t.useFog && t.fog ? "#define USE_FOG" : "",
					t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
					t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
					t.map ? "#define USE_MAP" : "",
					t.matcap ? "#define USE_MATCAP" : "",
					t.envMap ? "#define USE_ENVMAP" : "",
					t.envMap ? "#define " + c : "",
					t.envMap ? "#define " + u : "",
					t.envMap ? "#define " + h : "",
					d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
					d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
					d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
					t.lightMap ? "#define USE_LIGHTMAP" : "",
					t.aoMap ? "#define USE_AOMAP" : "",
					t.bumpMap ? "#define USE_BUMPMAP" : "",
					t.normalMap ? "#define USE_NORMALMAP" : "",
					t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
					t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
					t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
					t.anisotropy ? "#define USE_ANISOTROPY" : "",
					t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
					t.clearcoat ? "#define USE_CLEARCOAT" : "",
					t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
					t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
					t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
					t.dispersion ? "#define USE_DISPERSION" : "",
					t.iridescence ? "#define USE_IRIDESCENCE" : "",
					t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
					t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
					t.specularMap ? "#define USE_SPECULARMAP" : "",
					t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
					t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
					t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
					t.metalnessMap ? "#define USE_METALNESSMAP" : "",
					t.alphaMap ? "#define USE_ALPHAMAP" : "",
					t.alphaTest ? "#define USE_ALPHATEST" : "",
					t.alphaHash ? "#define USE_ALPHAHASH" : "",
					t.sheen ? "#define USE_SHEEN" : "",
					t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
					t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
					t.transmission ? "#define USE_TRANSMISSION" : "",
					t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
					t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
					t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
					t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
					t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
					t.vertexUv1s ? "#define USE_UV1" : "",
					t.vertexUv2s ? "#define USE_UV2" : "",
					t.vertexUv3s ? "#define USE_UV3" : "",
					t.pointsUvs ? "#define USE_POINTS_UV" : "",
					t.gradientMap ? "#define USE_GRADIENTMAP" : "",
					t.flatShading ? "#define FLAT_SHADED" : "",
					t.doubleSided ? "#define DOUBLE_SIDED" : "",
					t.flipSided ? "#define FLIP_SIDED" : "",
					t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
					t.shadowMapEnabled ? "#define " + l : "",
					t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
					t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
					t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
					t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
					"uniform mat4 viewMatrix;",
					"uniform vec3 cameraPosition;",
					"uniform bool isOrthographic;",
					t.toneMapping !== Ts ? "#define TONE_MAPPING" : "",
					t.toneMapping !== Ts ? st.tonemapping_pars_fragment : "",
					t.toneMapping !== Ts ? oD("toneMapping", t.toneMapping) : "",
					t.dithering ? "#define DITHERING" : "",
					t.opaque ? "#define OPAQUE" : "",
					st.colorspace_pars_fragment,
					aD("linearToOutputTexel", t.outputColorSpace),
					lD(),
					t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
					`
`
			  ].filter(bl).join(`
`))),
			(a = Jf(a)),
			(a = n0(a, t)),
			(a = i0(a, t)),
			(o = Jf(o)),
			(o = n0(o, t)),
			(o = i0(o, t)),
			(a = r0(a)),
			(o = r0(o)),
			t.isRawShaderMaterial !== !0 &&
				((x = `#version 300 es
`),
				(p =
					[f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) +
					`
` +
					p),
				(g =
					[
						"#define varying in",
						t.glslVersion === yv ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
						t.glslVersion === yv ? "" : "#define gl_FragColor pc_fragColor",
						"#define gl_FragDepthEXT gl_FragDepth",
						"#define texture2D texture",
						"#define textureCube texture",
						"#define texture2DProj textureProj",
						"#define texture2DLodEXT textureLod",
						"#define texture2DProjLodEXT textureProjLod",
						"#define textureCubeLodEXT textureLod",
						"#define texture2DGradEXT textureGrad",
						"#define texture2DProjGradEXT textureProjGrad",
						"#define textureCubeGradEXT textureGrad"
					].join(`
`) +
					`
` +
					g));
		const b = x + p + a,
			T = x + g + o,
			P = e0(r, r.VERTEX_SHADER, b),
			A = e0(r, r.FRAGMENT_SHADER, T);
		r.attachShader(_, P), r.attachShader(_, A), t.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_);
		function M(L) {
			if (n.debug.checkShaderErrors) {
				const N = r.getProgramInfoLog(_).trim(),
					k = r.getShaderInfoLog(P).trim(),
					B = r.getShaderInfoLog(A).trim();
				let W = !0,
					H = !0;
				if (r.getProgramParameter(_, r.LINK_STATUS) === !1)
					if (((W = !1), typeof n.debug.onShaderError == "function")) n.debug.onShaderError(r, _, P, A);
					else {
						const z = t0(r, P, "vertex"),
							X = t0(r, A, "fragment");
						console.error(
							"THREE.WebGLProgram: Shader Error " +
								r.getError() +
								" - VALIDATE_STATUS " +
								r.getProgramParameter(_, r.VALIDATE_STATUS) +
								`

Material Name: ` +
								L.name +
								`
Material Type: ` +
								L.type +
								`

Program Info Log: ` +
								N +
								`
` +
								z +
								`
` +
								X
						);
					}
				else N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (k === "" || B === "") && (H = !1);
				H && (L.diagnostics = { runnable: W, programLog: N, vertexShader: { log: k, prefix: p }, fragmentShader: { log: B, prefix: g } });
			}
			r.deleteShader(P), r.deleteShader(A), (w = new Ou(r, _)), (y = hD(r, _));
		}
		let w;
		this.getUniforms = function () {
			return w === void 0 && M(this), w;
		};
		let y;
		this.getAttributes = function () {
			return y === void 0 && M(this), y;
		};
		let S = t.rendererExtensionParallelShaderCompile === !1;
		return (
			(this.isReady = function () {
				return S === !1 && (S = r.getProgramParameter(_, nD)), S;
			}),
			(this.destroy = function () {
				i.releaseStatesOfProgram(this), r.deleteProgram(_), (this.program = void 0);
			}),
			(this.type = t.shaderType),
			(this.name = t.shaderName),
			(this.id = iD++),
			(this.cacheKey = e),
			(this.usedTimes = 1),
			(this.program = _),
			(this.vertexShader = P),
			(this.fragmentShader = A),
			this
		);
	}
	let ED = 0;
	class wD {
		constructor() {
			(this.shaderCache = new Map()), (this.materialCache = new Map());
		}
		update(e) {
			const t = e.vertexShader,
				i = e.fragmentShader,
				r = this._getShaderStage(t),
				s = this._getShaderStage(i),
				a = this._getShaderCacheForMaterial(e);
			return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
		}
		remove(e) {
			const t = this.materialCache.get(e);
			for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
			return this.materialCache.delete(e), this;
		}
		getVertexShaderID(e) {
			return this._getShaderStage(e.vertexShader).id;
		}
		getFragmentShaderID(e) {
			return this._getShaderStage(e.fragmentShader).id;
		}
		dispose() {
			this.shaderCache.clear(), this.materialCache.clear();
		}
		_getShaderCacheForMaterial(e) {
			const t = this.materialCache;
			let i = t.get(e);
			return i === void 0 && ((i = new Set()), t.set(e, i)), i;
		}
		_getShaderStage(e) {
			const t = this.shaderCache;
			let i = t.get(e);
			return i === void 0 && ((i = new TD(e)), t.set(e, i)), i;
		}
	}
	class TD {
		constructor(e) {
			(this.id = ED++), (this.code = e), (this.usedTimes = 0);
		}
	}
	function MD(n, e, t, i, r, s, a) {
		const o = new $p(),
			l = new wD(),
			c = new Set(),
			u = [],
			h = r.logarithmicDepthBuffer,
			d = r.vertexTextures;
		let f = r.precision;
		const v = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
		function _(y) {
			return c.add(y), y === 0 ? "uv" : `uv${y}`;
		}
		function p(y, S, L, N, k) {
			const B = N.fog,
				W = k.geometry,
				H = y.isMeshStandardMaterial ? N.environment : null,
				z = (y.isMeshStandardMaterial ? t : e).get(y.envMap || H),
				X = z && z.mapping === gh ? z.image.height : null,
				K = v[y.type];
			y.precision !== null && ((f = r.getMaxPrecision(y.precision)), f !== y.precision && console.warn("THREE.WebGLProgram.getParameters:", y.precision, "not supported, using", f, "instead."));
			const G = W.morphAttributes.position || W.morphAttributes.normal || W.morphAttributes.color,
				ue = G !== void 0 ? G.length : 0;
			let ae = 0;
			W.morphAttributes.position !== void 0 && (ae = 1), W.morphAttributes.normal !== void 0 && (ae = 2), W.morphAttributes.color !== void 0 && (ae = 3);
			let Ue, Z, ie, ge;
			if (K) {
				const At = gr[K];
				(Ue = At.vertexShader), (Z = At.fragmentShader);
			} else (Ue = y.vertexShader), (Z = y.fragmentShader), l.update(y), (ie = l.getVertexShaderID(y)), (ge = l.getFragmentShaderID(y));
			const V = n.getRenderTarget(),
				j = k.isInstancedMesh === !0,
				he = k.isBatchedMesh === !0,
				xe = !!y.map,
				He = !!y.matcap,
				F = !!z,
				fe = !!y.aoMap,
				pe = !!y.lightMap,
				Ee = !!y.bumpMap,
				re = !!y.normalMap,
				We = !!y.displacementMap,
				Ce = !!y.emissiveMap,
				Ie = !!y.metalnessMap,
				U = !!y.roughnessMap,
				R = y.anisotropy > 0,
				ee = y.clearcoat > 0,
				de = y.dispersion > 0,
				me = y.iridescence > 0,
				oe = y.sheen > 0,
				Xe = y.transmission > 0,
				Me = R && !!y.anisotropyMap,
				Pe = ee && !!y.clearcoatMap,
				Je = ee && !!y.clearcoatNormalMap,
				we = ee && !!y.clearcoatRoughnessMap,
				Fe = me && !!y.iridescenceMap,
				lt = me && !!y.iridescenceThicknessMap,
				ot = oe && !!y.sheenColorMap,
				Ne = oe && !!y.sheenRoughnessMap,
				dt = !!y.specularMap,
				vt = !!y.specularColorMap,
				Qt = !!y.specularIntensityMap,
				Y = Xe && !!y.transmissionMap,
				Le = Xe && !!y.thicknessMap,
				ve = !!y.gradientMap,
				ye = !!y.alphaMap,
				De = y.alphaTest > 0,
				ct = !!y.alphaHash,
				Lt = !!y.extensions;
			let hn = Ts;
			y.toneMapped && (V === null || V.isXRRenderTarget === !0) && (hn = n.toneMapping);
			const Mn = {
				shaderID: K,
				shaderType: y.type,
				shaderName: y.name,
				vertexShader: Ue,
				fragmentShader: Z,
				defines: y.defines,
				customVertexShaderID: ie,
				customFragmentShaderID: ge,
				isRawShaderMaterial: y.isRawShaderMaterial === !0,
				glslVersion: y.glslVersion,
				precision: f,
				batching: he,
				batchingColor: he && k._colorsTexture !== null,
				instancing: j,
				instancingColor: j && k.instanceColor !== null,
				instancingMorph: j && k.morphTexture !== null,
				supportsVertexTextures: d,
				outputColorSpace: V === null ? n.outputColorSpace : V.isXRRenderTarget === !0 ? V.texture.colorSpace : Fs,
				alphaToCoverage: !!y.alphaToCoverage,
				map: xe,
				matcap: He,
				envMap: F,
				envMapMode: F && z.mapping,
				envMapCubeUVHeight: X,
				aoMap: fe,
				lightMap: pe,
				bumpMap: Ee,
				normalMap: re,
				displacementMap: d && We,
				emissiveMap: Ce,
				normalMapObjectSpace: re && y.normalMapType === xC,
				normalMapTangentSpace: re && y.normalMapType === Ky,
				metalnessMap: Ie,
				roughnessMap: U,
				anisotropy: R,
				anisotropyMap: Me,
				clearcoat: ee,
				clearcoatMap: Pe,
				clearcoatNormalMap: Je,
				clearcoatRoughnessMap: we,
				dispersion: de,
				iridescence: me,
				iridescenceMap: Fe,
				iridescenceThicknessMap: lt,
				sheen: oe,
				sheenColorMap: ot,
				sheenRoughnessMap: Ne,
				specularMap: dt,
				specularColorMap: vt,
				specularIntensityMap: Qt,
				transmission: Xe,
				transmissionMap: Y,
				thicknessMap: Le,
				gradientMap: ve,
				opaque: y.transparent === !1 && y.blending === bo && y.alphaToCoverage === !1,
				alphaMap: ye,
				alphaTest: De,
				alphaHash: ct,
				combine: y.combine,
				mapUv: xe && _(y.map.channel),
				aoMapUv: fe && _(y.aoMap.channel),
				lightMapUv: pe && _(y.lightMap.channel),
				bumpMapUv: Ee && _(y.bumpMap.channel),
				normalMapUv: re && _(y.normalMap.channel),
				displacementMapUv: We && _(y.displacementMap.channel),
				emissiveMapUv: Ce && _(y.emissiveMap.channel),
				metalnessMapUv: Ie && _(y.metalnessMap.channel),
				roughnessMapUv: U && _(y.roughnessMap.channel),
				anisotropyMapUv: Me && _(y.anisotropyMap.channel),
				clearcoatMapUv: Pe && _(y.clearcoatMap.channel),
				clearcoatNormalMapUv: Je && _(y.clearcoatNormalMap.channel),
				clearcoatRoughnessMapUv: we && _(y.clearcoatRoughnessMap.channel),
				iridescenceMapUv: Fe && _(y.iridescenceMap.channel),
				iridescenceThicknessMapUv: lt && _(y.iridescenceThicknessMap.channel),
				sheenColorMapUv: ot && _(y.sheenColorMap.channel),
				sheenRoughnessMapUv: Ne && _(y.sheenRoughnessMap.channel),
				specularMapUv: dt && _(y.specularMap.channel),
				specularColorMapUv: vt && _(y.specularColorMap.channel),
				specularIntensityMapUv: Qt && _(y.specularIntensityMap.channel),
				transmissionMapUv: Y && _(y.transmissionMap.channel),
				thicknessMapUv: Le && _(y.thicknessMap.channel),
				alphaMapUv: ye && _(y.alphaMap.channel),
				vertexTangents: !!W.attributes.tangent && (re || R),
				vertexColors: y.vertexColors,
				vertexAlphas: y.vertexColors === !0 && !!W.attributes.color && W.attributes.color.itemSize === 4,
				pointsUvs: k.isPoints === !0 && !!W.attributes.uv && (xe || ye),
				fog: !!B,
				useFog: y.fog === !0,
				fogExp2: !!B && B.isFogExp2,
				flatShading: y.flatShading === !0,
				sizeAttenuation: y.sizeAttenuation === !0,
				logarithmicDepthBuffer: h,
				skinning: k.isSkinnedMesh === !0,
				morphTargets: W.morphAttributes.position !== void 0,
				morphNormals: W.morphAttributes.normal !== void 0,
				morphColors: W.morphAttributes.color !== void 0,
				morphTargetsCount: ue,
				morphTextureStride: ae,
				numDirLights: S.directional.length,
				numPointLights: S.point.length,
				numSpotLights: S.spot.length,
				numSpotLightMaps: S.spotLightMap.length,
				numRectAreaLights: S.rectArea.length,
				numHemiLights: S.hemi.length,
				numDirLightShadows: S.directionalShadowMap.length,
				numPointLightShadows: S.pointShadowMap.length,
				numSpotLightShadows: S.spotShadowMap.length,
				numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
				numLightProbes: S.numLightProbes,
				numClippingPlanes: a.numPlanes,
				numClipIntersection: a.numIntersection,
				dithering: y.dithering,
				shadowMapEnabled: n.shadowMap.enabled && L.length > 0,
				shadowMapType: n.shadowMap.type,
				toneMapping: hn,
				decodeVideoTexture: xe && y.map.isVideoTexture === !0 && zt.getTransfer(y.map.colorSpace) === nn,
				premultipliedAlpha: y.premultipliedAlpha,
				doubleSided: y.side === An,
				flipSided: y.side === li,
				useDepthPacking: y.depthPacking >= 0,
				depthPacking: y.depthPacking || 0,
				index0AttributeName: y.index0AttributeName,
				extensionClipCullDistance: Lt && y.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
				extensionMultiDraw: ((Lt && y.extensions.multiDraw === !0) || he) && i.has("WEBGL_multi_draw"),
				rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
				customProgramCacheKey: y.customProgramCacheKey()
			};
			return (Mn.vertexUv1s = c.has(1)), (Mn.vertexUv2s = c.has(2)), (Mn.vertexUv3s = c.has(3)), c.clear(), Mn;
		}
		function g(y) {
			const S = [];
			if ((y.shaderID ? S.push(y.shaderID) : (S.push(y.customVertexShaderID), S.push(y.customFragmentShaderID)), y.defines !== void 0)) for (const L in y.defines) S.push(L), S.push(y.defines[L]);
			return y.isRawShaderMaterial === !1 && (x(S, y), b(S, y), S.push(n.outputColorSpace)), S.push(y.customProgramCacheKey), S.join();
		}
		function x(y, S) {
			y.push(S.precision),
				y.push(S.outputColorSpace),
				y.push(S.envMapMode),
				y.push(S.envMapCubeUVHeight),
				y.push(S.mapUv),
				y.push(S.alphaMapUv),
				y.push(S.lightMapUv),
				y.push(S.aoMapUv),
				y.push(S.bumpMapUv),
				y.push(S.normalMapUv),
				y.push(S.displacementMapUv),
				y.push(S.emissiveMapUv),
				y.push(S.metalnessMapUv),
				y.push(S.roughnessMapUv),
				y.push(S.anisotropyMapUv),
				y.push(S.clearcoatMapUv),
				y.push(S.clearcoatNormalMapUv),
				y.push(S.clearcoatRoughnessMapUv),
				y.push(S.iridescenceMapUv),
				y.push(S.iridescenceThicknessMapUv),
				y.push(S.sheenColorMapUv),
				y.push(S.sheenRoughnessMapUv),
				y.push(S.specularMapUv),
				y.push(S.specularColorMapUv),
				y.push(S.specularIntensityMapUv),
				y.push(S.transmissionMapUv),
				y.push(S.thicknessMapUv),
				y.push(S.combine),
				y.push(S.fogExp2),
				y.push(S.sizeAttenuation),
				y.push(S.morphTargetsCount),
				y.push(S.morphAttributeCount),
				y.push(S.numDirLights),
				y.push(S.numPointLights),
				y.push(S.numSpotLights),
				y.push(S.numSpotLightMaps),
				y.push(S.numHemiLights),
				y.push(S.numRectAreaLights),
				y.push(S.numDirLightShadows),
				y.push(S.numPointLightShadows),
				y.push(S.numSpotLightShadows),
				y.push(S.numSpotLightShadowsWithMaps),
				y.push(S.numLightProbes),
				y.push(S.shadowMapType),
				y.push(S.toneMapping),
				y.push(S.numClippingPlanes),
				y.push(S.numClipIntersection),
				y.push(S.depthPacking);
		}
		function b(y, S) {
			o.disableAll(),
				S.supportsVertexTextures && o.enable(0),
				S.instancing && o.enable(1),
				S.instancingColor && o.enable(2),
				S.instancingMorph && o.enable(3),
				S.matcap && o.enable(4),
				S.envMap && o.enable(5),
				S.normalMapObjectSpace && o.enable(6),
				S.normalMapTangentSpace && o.enable(7),
				S.clearcoat && o.enable(8),
				S.iridescence && o.enable(9),
				S.alphaTest && o.enable(10),
				S.vertexColors && o.enable(11),
				S.vertexAlphas && o.enable(12),
				S.vertexUv1s && o.enable(13),
				S.vertexUv2s && o.enable(14),
				S.vertexUv3s && o.enable(15),
				S.vertexTangents && o.enable(16),
				S.anisotropy && o.enable(17),
				S.alphaHash && o.enable(18),
				S.batching && o.enable(19),
				S.dispersion && o.enable(20),
				S.batchingColor && o.enable(21),
				y.push(o.mask),
				o.disableAll(),
				S.fog && o.enable(0),
				S.useFog && o.enable(1),
				S.flatShading && o.enable(2),
				S.logarithmicDepthBuffer && o.enable(3),
				S.skinning && o.enable(4),
				S.morphTargets && o.enable(5),
				S.morphNormals && o.enable(6),
				S.morphColors && o.enable(7),
				S.premultipliedAlpha && o.enable(8),
				S.shadowMapEnabled && o.enable(9),
				S.doubleSided && o.enable(10),
				S.flipSided && o.enable(11),
				S.useDepthPacking && o.enable(12),
				S.dithering && o.enable(13),
				S.transmission && o.enable(14),
				S.sheen && o.enable(15),
				S.opaque && o.enable(16),
				S.pointsUvs && o.enable(17),
				S.decodeVideoTexture && o.enable(18),
				S.alphaToCoverage && o.enable(19),
				y.push(o.mask);
		}
		function T(y) {
			const S = v[y.type];
			let L;
			if (S) {
				const N = gr[S];
				L = cL.clone(N.uniforms);
			} else L = y.uniforms;
			return L;
		}
		function P(y, S) {
			let L;
			for (let N = 0, k = u.length; N < k; N++) {
				const B = u[N];
				if (B.cacheKey === S) {
					(L = B), ++L.usedTimes;
					break;
				}
			}
			return L === void 0 && ((L = new SD(n, S, y, s)), u.push(L)), L;
		}
		function A(y) {
			if (--y.usedTimes === 0) {
				const S = u.indexOf(y);
				(u[S] = u[u.length - 1]), u.pop(), y.destroy();
			}
		}
		function M(y) {
			l.remove(y);
		}
		function w() {
			l.dispose();
		}
		return { getParameters: p, getProgramCacheKey: g, getUniforms: T, acquireProgram: P, releaseProgram: A, releaseShaderCache: M, programs: u, dispose: w };
	}
	function AD() {
		let n = new WeakMap();
		function e(s) {
			let a = n.get(s);
			return a === void 0 && ((a = {}), n.set(s, a)), a;
		}
		function t(s) {
			n.delete(s);
		}
		function i(s, a, o) {
			n.get(s)[a] = o;
		}
		function r() {
			n = new WeakMap();
		}
		return { get: e, remove: t, update: i, dispose: r };
	}
	function CD(n, e) {
		return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
	}
	function a0(n, e) {
		return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
	}
	function o0() {
		const n = [];
		let e = 0;
		const t = [],
			i = [],
			r = [];
		function s() {
			(e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
		}
		function a(h, d, f, v, _, p) {
			let g = n[e];
			return g === void 0 ? ((g = { id: h.id, object: h, geometry: d, material: f, groupOrder: v, renderOrder: h.renderOrder, z: _, group: p }), (n[e] = g)) : ((g.id = h.id), (g.object = h), (g.geometry = d), (g.material = f), (g.groupOrder = v), (g.renderOrder = h.renderOrder), (g.z = _), (g.group = p)), e++, g;
		}
		function o(h, d, f, v, _, p) {
			const g = a(h, d, f, v, _, p);
			f.transmission > 0 ? i.push(g) : f.transparent === !0 ? r.push(g) : t.push(g);
		}
		function l(h, d, f, v, _, p) {
			const g = a(h, d, f, v, _, p);
			f.transmission > 0 ? i.unshift(g) : f.transparent === !0 ? r.unshift(g) : t.unshift(g);
		}
		function c(h, d) {
			t.length > 1 && t.sort(h || CD), i.length > 1 && i.sort(d || a0), r.length > 1 && r.sort(d || a0);
		}
		function u() {
			for (let h = e, d = n.length; h < d; h++) {
				const f = n[h];
				if (f.id === null) break;
				(f.id = null), (f.object = null), (f.geometry = null), (f.material = null), (f.group = null);
			}
		}
		return { opaque: t, transmissive: i, transparent: r, init: s, push: o, unshift: l, finish: u, sort: c };
	}
	function LD() {
		let n = new WeakMap();
		function e(i, r) {
			const s = n.get(i);
			let a;
			return s === void 0 ? ((a = new o0()), n.set(i, [a])) : r >= s.length ? ((a = new o0()), s.push(a)) : (a = s[r]), a;
		}
		function t() {
			n = new WeakMap();
		}
		return { get: e, dispose: t };
	}
	function RD() {
		const n = {};
		return {
			get: function (e) {
				if (n[e.id] !== void 0) return n[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = { direction: new D(), color: new rt() };
						break;
					case "SpotLight":
						t = { position: new D(), direction: new D(), color: new rt(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
						break;
					case "PointLight":
						t = { position: new D(), color: new rt(), distance: 0, decay: 0 };
						break;
					case "HemisphereLight":
						t = { direction: new D(), skyColor: new rt(), groundColor: new rt() };
						break;
					case "RectAreaLight":
						t = { color: new rt(), position: new D(), halfWidth: new D(), halfHeight: new D() };
						break;
				}
				return (n[e.id] = t), t;
			}
		};
	}
	function PD() {
		const n = {};
		return {
			get: function (e) {
				if (n[e.id] !== void 0) return n[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se() };
						break;
					case "SpotLight":
						t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se() };
						break;
					case "PointLight":
						t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
						break;
				}
				return (n[e.id] = t), t;
			}
		};
	}
	let DD = 0;
	function OD(n, e) {
		return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
	}
	function ID(n) {
		const e = new RD(),
			t = PD(),
			i = {
				version: 0,
				hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 },
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadow: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotLightMap: [],
				spotShadow: [],
				spotShadowMap: [],
				spotLightMatrix: [],
				rectArea: [],
				rectAreaLTC1: null,
				rectAreaLTC2: null,
				point: [],
				pointShadow: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
				numSpotLightShadowsWithMaps: 0,
				numLightProbes: 0
			};
		for (let c = 0; c < 9; c++) i.probe.push(new D());
		const r = new D(),
			s = new pt(),
			a = new pt();
		function o(c) {
			let u = 0,
				h = 0,
				d = 0;
			for (let y = 0; y < 9; y++) i.probe[y].set(0, 0, 0);
			let f = 0,
				v = 0,
				_ = 0,
				p = 0,
				g = 0,
				x = 0,
				b = 0,
				T = 0,
				P = 0,
				A = 0,
				M = 0;
			c.sort(OD);
			for (let y = 0, S = c.length; y < S; y++) {
				const L = c[y],
					N = L.color,
					k = L.intensity,
					B = L.distance,
					W = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
				if (L.isAmbientLight) (u += N.r * k), (h += N.g * k), (d += N.b * k);
				else if (L.isLightProbe) {
					for (let H = 0; H < 9; H++) i.probe[H].addScaledVector(L.sh.coefficients[H], k);
					M++;
				} else if (L.isDirectionalLight) {
					const H = e.get(L);
					if ((H.color.copy(L.color).multiplyScalar(L.intensity), L.castShadow)) {
						const z = L.shadow,
							X = t.get(L);
						(X.shadowIntensity = z.intensity), (X.shadowBias = z.bias), (X.shadowNormalBias = z.normalBias), (X.shadowRadius = z.radius), (X.shadowMapSize = z.mapSize), (i.directionalShadow[f] = X), (i.directionalShadowMap[f] = W), (i.directionalShadowMatrix[f] = L.shadow.matrix), x++;
					}
					(i.directional[f] = H), f++;
				} else if (L.isSpotLight) {
					const H = e.get(L);
					H.position.setFromMatrixPosition(L.matrixWorld), H.color.copy(N).multiplyScalar(k), (H.distance = B), (H.coneCos = Math.cos(L.angle)), (H.penumbraCos = Math.cos(L.angle * (1 - L.penumbra))), (H.decay = L.decay), (i.spot[_] = H);
					const z = L.shadow;
					if ((L.map && ((i.spotLightMap[P] = L.map), P++, z.updateMatrices(L), L.castShadow && A++), (i.spotLightMatrix[_] = z.matrix), L.castShadow)) {
						const X = t.get(L);
						(X.shadowIntensity = z.intensity), (X.shadowBias = z.bias), (X.shadowNormalBias = z.normalBias), (X.shadowRadius = z.radius), (X.shadowMapSize = z.mapSize), (i.spotShadow[_] = X), (i.spotShadowMap[_] = W), T++;
					}
					_++;
				} else if (L.isRectAreaLight) {
					const H = e.get(L);
					H.color.copy(N).multiplyScalar(k), H.halfWidth.set(L.width * 0.5, 0, 0), H.halfHeight.set(0, L.height * 0.5, 0), (i.rectArea[p] = H), p++;
				} else if (L.isPointLight) {
					const H = e.get(L);
					if ((H.color.copy(L.color).multiplyScalar(L.intensity), (H.distance = L.distance), (H.decay = L.decay), L.castShadow)) {
						const z = L.shadow,
							X = t.get(L);
						(X.shadowIntensity = z.intensity), (X.shadowBias = z.bias), (X.shadowNormalBias = z.normalBias), (X.shadowRadius = z.radius), (X.shadowMapSize = z.mapSize), (X.shadowCameraNear = z.camera.near), (X.shadowCameraFar = z.camera.far), (i.pointShadow[v] = X), (i.pointShadowMap[v] = W), (i.pointShadowMatrix[v] = L.shadow.matrix), b++;
					}
					(i.point[v] = H), v++;
				} else if (L.isHemisphereLight) {
					const H = e.get(L);
					H.skyColor.copy(L.color).multiplyScalar(k), H.groundColor.copy(L.groundColor).multiplyScalar(k), (i.hemi[g] = H), g++;
				}
			}
			p > 0 && (n.has("OES_texture_float_linear") === !0 ? ((i.rectAreaLTC1 = Be.LTC_FLOAT_1), (i.rectAreaLTC2 = Be.LTC_FLOAT_2)) : ((i.rectAreaLTC1 = Be.LTC_HALF_1), (i.rectAreaLTC2 = Be.LTC_HALF_2))), (i.ambient[0] = u), (i.ambient[1] = h), (i.ambient[2] = d);
			const w = i.hash;
			(w.directionalLength !== f || w.pointLength !== v || w.spotLength !== _ || w.rectAreaLength !== p || w.hemiLength !== g || w.numDirectionalShadows !== x || w.numPointShadows !== b || w.numSpotShadows !== T || w.numSpotMaps !== P || w.numLightProbes !== M) &&
				((i.directional.length = f),
				(i.spot.length = _),
				(i.rectArea.length = p),
				(i.point.length = v),
				(i.hemi.length = g),
				(i.directionalShadow.length = x),
				(i.directionalShadowMap.length = x),
				(i.pointShadow.length = b),
				(i.pointShadowMap.length = b),
				(i.spotShadow.length = T),
				(i.spotShadowMap.length = T),
				(i.directionalShadowMatrix.length = x),
				(i.pointShadowMatrix.length = b),
				(i.spotLightMatrix.length = T + P - A),
				(i.spotLightMap.length = P),
				(i.numSpotLightShadowsWithMaps = A),
				(i.numLightProbes = M),
				(w.directionalLength = f),
				(w.pointLength = v),
				(w.spotLength = _),
				(w.rectAreaLength = p),
				(w.hemiLength = g),
				(w.numDirectionalShadows = x),
				(w.numPointShadows = b),
				(w.numSpotShadows = T),
				(w.numSpotMaps = P),
				(w.numLightProbes = M),
				(i.version = DD++));
		}
		function l(c, u) {
			let h = 0,
				d = 0,
				f = 0,
				v = 0,
				_ = 0;
			const p = u.matrixWorldInverse;
			for (let g = 0, x = c.length; g < x; g++) {
				const b = c[g];
				if (b.isDirectionalLight) {
					const T = i.directional[h];
					T.direction.setFromMatrixPosition(b.matrixWorld), r.setFromMatrixPosition(b.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(p), h++;
				} else if (b.isSpotLight) {
					const T = i.spot[f];
					T.position.setFromMatrixPosition(b.matrixWorld), T.position.applyMatrix4(p), T.direction.setFromMatrixPosition(b.matrixWorld), r.setFromMatrixPosition(b.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(p), f++;
				} else if (b.isRectAreaLight) {
					const T = i.rectArea[v];
					T.position.setFromMatrixPosition(b.matrixWorld), T.position.applyMatrix4(p), a.identity(), s.copy(b.matrixWorld), s.premultiply(p), a.extractRotation(s), T.halfWidth.set(b.width * 0.5, 0, 0), T.halfHeight.set(0, b.height * 0.5, 0), T.halfWidth.applyMatrix4(a), T.halfHeight.applyMatrix4(a), v++;
				} else if (b.isPointLight) {
					const T = i.point[d];
					T.position.setFromMatrixPosition(b.matrixWorld), T.position.applyMatrix4(p), d++;
				} else if (b.isHemisphereLight) {
					const T = i.hemi[_];
					T.direction.setFromMatrixPosition(b.matrixWorld), T.direction.transformDirection(p), _++;
				}
			}
		}
		return { setup: o, setupView: l, state: i };
	}
	function l0(n) {
		const e = new ID(n),
			t = [],
			i = [];
		function r(u) {
			(c.camera = u), (t.length = 0), (i.length = 0);
		}
		function s(u) {
			t.push(u);
		}
		function a(u) {
			i.push(u);
		}
		function o() {
			e.setup(t);
		}
		function l(u) {
			e.setupView(t, u);
		}
		const c = { lightsArray: t, shadowsArray: i, camera: null, lights: e, transmissionRenderTarget: {} };
		return { init: r, state: c, setupLights: o, setupLightsView: l, pushLight: s, pushShadow: a };
	}
	function FD(n) {
		let e = new WeakMap();
		function t(r, s = 0) {
			const a = e.get(r);
			let o;
			return a === void 0 ? ((o = new l0(n)), e.set(r, [o])) : s >= a.length ? ((o = new l0(n)), a.push(o)) : (o = a[s]), o;
		}
		function i() {
			e = new WeakMap();
		}
		return { get: t, dispose: i };
	}
	class ND extends Er {
		constructor(e) {
			super(), (this.isMeshDepthMaterial = !0), (this.type = "MeshDepthMaterial"), (this.depthPacking = _C), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.wireframe = !1), (this.wireframeLinewidth = 1), this.setValues(e);
		}
		copy(e) {
			return super.copy(e), (this.depthPacking = e.depthPacking), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.displacementMap = e.displacementMap), (this.displacementScale = e.displacementScale), (this.displacementBias = e.displacementBias), (this.wireframe = e.wireframe), (this.wireframeLinewidth = e.wireframeLinewidth), this;
		}
	}
	class UD extends Er {
		constructor(e) {
			super(), (this.isMeshDistanceMaterial = !0), (this.type = "MeshDistanceMaterial"), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), this.setValues(e);
		}
		copy(e) {
			return super.copy(e), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.displacementMap = e.displacementMap), (this.displacementScale = e.displacementScale), (this.displacementBias = e.displacementBias), this;
		}
	}
	const kD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
		BD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
	function zD(n, e, t) {
		let i = new qp();
		const r = new Se(),
			s = new Se(),
			a = new wn(),
			o = new ND({ depthPacking: yC }),
			l = new UD(),
			c = {},
			u = t.maxTextureSize,
			h = { [Kr]: li, [li]: Kr, [An]: An },
			d = new wr({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Se() }, radius: { value: 4 } }, vertexShader: kD, fragmentShader: BD }),
			f = d.clone();
		f.defines.HORIZONTAL_PASS = 1;
		const v = new bt();
		v.setAttribute("position", new mn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		const _ = new Re(v, d),
			p = this;
		(this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = ky);
		let g = this.type;
		this.render = function (A, M, w) {
			if (p.enabled === !1 || (p.autoUpdate === !1 && p.needsUpdate === !1) || A.length === 0) return;
			const y = n.getRenderTarget(),
				S = n.getActiveCubeFace(),
				L = n.getActiveMipmapLevel(),
				N = n.state;
			N.setBlending(ws), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(!0), N.setScissorTest(!1);
			const k = g !== Br && this.type === Br,
				B = g === Br && this.type !== Br;
			for (let W = 0, H = A.length; W < H; W++) {
				const z = A[W],
					X = z.shadow;
				if (X === void 0) {
					console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
					continue;
				}
				if (X.autoUpdate === !1 && X.needsUpdate === !1) continue;
				r.copy(X.mapSize);
				const K = X.getFrameExtents();
				if ((r.multiply(K), s.copy(X.mapSize), (r.x > u || r.y > u) && (r.x > u && ((s.x = Math.floor(u / K.x)), (r.x = s.x * K.x), (X.mapSize.x = s.x)), r.y > u && ((s.y = Math.floor(u / K.y)), (r.y = s.y * K.y), (X.mapSize.y = s.y))), X.map === null || k === !0 || B === !0)) {
					const ue = this.type !== Br ? { minFilter: Di, magFilter: Di } : {};
					X.map !== null && X.map.dispose(), (X.map = new ya(r.x, r.y, ue)), (X.map.texture.name = z.name + ".shadowMap"), X.camera.updateProjectionMatrix();
				}
				n.setRenderTarget(X.map), n.clear();
				const G = X.getViewportCount();
				for (let ue = 0; ue < G; ue++) {
					const ae = X.getViewport(ue);
					a.set(s.x * ae.x, s.y * ae.y, s.x * ae.z, s.y * ae.w), N.viewport(a), X.updateMatrices(z, ue), (i = X.getFrustum()), T(M, w, X.camera, z, this.type);
				}
				X.isPointLightShadow !== !0 && this.type === Br && x(X, w), (X.needsUpdate = !1);
			}
			(g = this.type), (p.needsUpdate = !1), n.setRenderTarget(y, S, L);
		};
		function x(A, M) {
			const w = e.update(_);
			d.defines.VSM_SAMPLES !== A.blurSamples && ((d.defines.VSM_SAMPLES = A.blurSamples), (f.defines.VSM_SAMPLES = A.blurSamples), (d.needsUpdate = !0), (f.needsUpdate = !0)),
				A.mapPass === null && (A.mapPass = new ya(r.x, r.y)),
				(d.uniforms.shadow_pass.value = A.map.texture),
				(d.uniforms.resolution.value = A.mapSize),
				(d.uniforms.radius.value = A.radius),
				n.setRenderTarget(A.mapPass),
				n.clear(),
				n.renderBufferDirect(M, null, w, d, _, null),
				(f.uniforms.shadow_pass.value = A.mapPass.texture),
				(f.uniforms.resolution.value = A.mapSize),
				(f.uniforms.radius.value = A.radius),
				n.setRenderTarget(A.map),
				n.clear(),
				n.renderBufferDirect(M, null, w, f, _, null);
		}
		function b(A, M, w, y) {
			let S = null;
			const L = w.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
			if (L !== void 0) S = L;
			else if (((S = w.isPointLight === !0 ? l : o), (n.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0) || (M.displacementMap && M.displacementScale !== 0) || (M.alphaMap && M.alphaTest > 0) || (M.map && M.alphaTest > 0))) {
				const N = S.uuid,
					k = M.uuid;
				let B = c[N];
				B === void 0 && ((B = {}), (c[N] = B));
				let W = B[k];
				W === void 0 && ((W = S.clone()), (B[k] = W), M.addEventListener("dispose", P)), (S = W);
			}
			if (
				((S.visible = M.visible),
				(S.wireframe = M.wireframe),
				y === Br ? (S.side = M.shadowSide !== null ? M.shadowSide : M.side) : (S.side = M.shadowSide !== null ? M.shadowSide : h[M.side]),
				(S.alphaMap = M.alphaMap),
				(S.alphaTest = M.alphaTest),
				(S.map = M.map),
				(S.clipShadows = M.clipShadows),
				(S.clippingPlanes = M.clippingPlanes),
				(S.clipIntersection = M.clipIntersection),
				(S.displacementMap = M.displacementMap),
				(S.displacementScale = M.displacementScale),
				(S.displacementBias = M.displacementBias),
				(S.wireframeLinewidth = M.wireframeLinewidth),
				(S.linewidth = M.linewidth),
				w.isPointLight === !0 && S.isMeshDistanceMaterial === !0)
			) {
				const N = n.properties.get(S);
				N.light = w;
			}
			return S;
		}
		function T(A, M, w, y, S) {
			if (A.visible === !1) return;
			if (A.layers.test(M.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || (A.receiveShadow && S === Br)) && (!A.frustumCulled || i.intersectsObject(A))) {
				A.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, A.matrixWorld);
				const k = e.update(A),
					B = A.material;
				if (Array.isArray(B)) {
					const W = k.groups;
					for (let H = 0, z = W.length; H < z; H++) {
						const X = W[H],
							K = B[X.materialIndex];
						if (K && K.visible) {
							const G = b(A, K, y, S);
							A.onBeforeShadow(n, A, M, w, k, G, X), n.renderBufferDirect(w, null, k, G, A, X), A.onAfterShadow(n, A, M, w, k, G, X);
						}
					}
				} else if (B.visible) {
					const W = b(A, B, y, S);
					A.onBeforeShadow(n, A, M, w, k, W, null), n.renderBufferDirect(w, null, k, W, A, null), A.onAfterShadow(n, A, M, w, k, W, null);
				}
			}
			const N = A.children;
			for (let k = 0, B = N.length; k < B; k++) T(N[k], M, w, y, S);
		}
		function P(A) {
			A.target.removeEventListener("dispose", P);
			for (const w in c) {
				const y = c[w],
					S = A.target.uuid;
				S in y && (y[S].dispose(), delete y[S]);
			}
		}
	}
	function HD(n) {
		function e() {
			let Y = !1;
			const Le = new wn();
			let ve = null;
			const ye = new wn(0, 0, 0, 0);
			return {
				setMask: function (De) {
					ve !== De && !Y && (n.colorMask(De, De, De, De), (ve = De));
				},
				setLocked: function (De) {
					Y = De;
				},
				setClear: function (De, ct, Lt, hn, Mn) {
					Mn === !0 && ((De *= hn), (ct *= hn), (Lt *= hn)), Le.set(De, ct, Lt, hn), ye.equals(Le) === !1 && (n.clearColor(De, ct, Lt, hn), ye.copy(Le));
				},
				reset: function () {
					(Y = !1), (ve = null), ye.set(-1, 0, 0, 0);
				}
			};
		}
		function t() {
			let Y = !1,
				Le = null,
				ve = null,
				ye = null;
			return {
				setTest: function (De) {
					De ? ge(n.DEPTH_TEST) : V(n.DEPTH_TEST);
				},
				setMask: function (De) {
					Le !== De && !Y && (n.depthMask(De), (Le = De));
				},
				setFunc: function (De) {
					if (ve !== De) {
						switch (De) {
							case tC:
								n.depthFunc(n.NEVER);
								break;
							case nC:
								n.depthFunc(n.ALWAYS);
								break;
							case iC:
								n.depthFunc(n.LESS);
								break;
							case Wu:
								n.depthFunc(n.LEQUAL);
								break;
							case rC:
								n.depthFunc(n.EQUAL);
								break;
							case sC:
								n.depthFunc(n.GEQUAL);
								break;
							case aC:
								n.depthFunc(n.GREATER);
								break;
							case oC:
								n.depthFunc(n.NOTEQUAL);
								break;
							default:
								n.depthFunc(n.LEQUAL);
						}
						ve = De;
					}
				},
				setLocked: function (De) {
					Y = De;
				},
				setClear: function (De) {
					ye !== De && (n.clearDepth(De), (ye = De));
				},
				reset: function () {
					(Y = !1), (Le = null), (ve = null), (ye = null);
				}
			};
		}
		function i() {
			let Y = !1,
				Le = null,
				ve = null,
				ye = null,
				De = null,
				ct = null,
				Lt = null,
				hn = null,
				Mn = null;
			return {
				setTest: function (At) {
					Y || (At ? ge(n.STENCIL_TEST) : V(n.STENCIL_TEST));
				},
				setMask: function (At) {
					Le !== At && !Y && (n.stencilMask(At), (Le = At));
				},
				setFunc: function (At, Yn, xi) {
					(ve !== At || ye !== Yn || De !== xi) && (n.stencilFunc(At, Yn, xi), (ve = At), (ye = Yn), (De = xi));
				},
				setOp: function (At, Yn, xi) {
					(ct !== At || Lt !== Yn || hn !== xi) && (n.stencilOp(At, Yn, xi), (ct = At), (Lt = Yn), (hn = xi));
				},
				setLocked: function (At) {
					Y = At;
				},
				setClear: function (At) {
					Mn !== At && (n.clearStencil(At), (Mn = At));
				},
				reset: function () {
					(Y = !1), (Le = null), (ve = null), (ye = null), (De = null), (ct = null), (Lt = null), (hn = null), (Mn = null);
				}
			};
		}
		const r = new e(),
			s = new t(),
			a = new i(),
			o = new WeakMap(),
			l = new WeakMap();
		let c = {},
			u = {},
			h = new WeakMap(),
			d = [],
			f = null,
			v = !1,
			_ = null,
			p = null,
			g = null,
			x = null,
			b = null,
			T = null,
			P = null,
			A = new rt(0, 0, 0),
			M = 0,
			w = !1,
			y = null,
			S = null,
			L = null,
			N = null,
			k = null;
		const B = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let W = !1,
			H = 0;
		const z = n.getParameter(n.VERSION);
		z.indexOf("WebGL") !== -1 ? ((H = parseFloat(/^WebGL (\d)/.exec(z)[1])), (W = H >= 1)) : z.indexOf("OpenGL ES") !== -1 && ((H = parseFloat(/^OpenGL ES (\d)/.exec(z)[1])), (W = H >= 2));
		let X = null,
			K = {};
		const G = n.getParameter(n.SCISSOR_BOX),
			ue = n.getParameter(n.VIEWPORT),
			ae = new wn().fromArray(G),
			Ue = new wn().fromArray(ue);
		function Z(Y, Le, ve, ye) {
			const De = new Uint8Array(4),
				ct = n.createTexture();
			n.bindTexture(Y, ct), n.texParameteri(Y, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(Y, n.TEXTURE_MAG_FILTER, n.NEAREST);
			for (let Lt = 0; Lt < ve; Lt++) Y === n.TEXTURE_3D || Y === n.TEXTURE_2D_ARRAY ? n.texImage3D(Le, 0, n.RGBA, 1, 1, ye, 0, n.RGBA, n.UNSIGNED_BYTE, De) : n.texImage2D(Le + Lt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, De);
			return ct;
		}
		const ie = {};
		(ie[n.TEXTURE_2D] = Z(n.TEXTURE_2D, n.TEXTURE_2D, 1)), (ie[n.TEXTURE_CUBE_MAP] = Z(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6)), (ie[n.TEXTURE_2D_ARRAY] = Z(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)), (ie[n.TEXTURE_3D] = Z(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), ge(n.DEPTH_TEST), s.setFunc(Wu), Ee(!1), re(pv), ge(n.CULL_FACE), fe(ws);
		function ge(Y) {
			c[Y] !== !0 && (n.enable(Y), (c[Y] = !0));
		}
		function V(Y) {
			c[Y] !== !1 && (n.disable(Y), (c[Y] = !1));
		}
		function j(Y, Le) {
			return u[Y] !== Le ? (n.bindFramebuffer(Y, Le), (u[Y] = Le), Y === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = Le), Y === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = Le), !0) : !1;
		}
		function he(Y, Le) {
			let ve = d,
				ye = !1;
			if (Y) {
				(ve = h.get(Le)), ve === void 0 && ((ve = []), h.set(Le, ve));
				const De = Y.textures;
				if (ve.length !== De.length || ve[0] !== n.COLOR_ATTACHMENT0) {
					for (let ct = 0, Lt = De.length; ct < Lt; ct++) ve[ct] = n.COLOR_ATTACHMENT0 + ct;
					(ve.length = De.length), (ye = !0);
				}
			} else ve[0] !== n.BACK && ((ve[0] = n.BACK), (ye = !0));
			ye && n.drawBuffers(ve);
		}
		function xe(Y) {
			return f !== Y ? (n.useProgram(Y), (f = Y), !0) : !1;
		}
		const He = { [aa]: n.FUNC_ADD, [kA]: n.FUNC_SUBTRACT, [BA]: n.FUNC_REVERSE_SUBTRACT };
		(He[zA] = n.MIN), (He[HA] = n.MAX);
		const F = { [GA]: n.ZERO, [VA]: n.ONE, [WA]: n.SRC_COLOR, [xf]: n.SRC_ALPHA, [KA]: n.SRC_ALPHA_SATURATE, [jA]: n.DST_COLOR, [$A]: n.DST_ALPHA, [XA]: n.ONE_MINUS_SRC_COLOR, [bf]: n.ONE_MINUS_SRC_ALPHA, [YA]: n.ONE_MINUS_DST_COLOR, [qA]: n.ONE_MINUS_DST_ALPHA, [ZA]: n.CONSTANT_COLOR, [JA]: n.ONE_MINUS_CONSTANT_COLOR, [QA]: n.CONSTANT_ALPHA, [eC]: n.ONE_MINUS_CONSTANT_ALPHA };
		function fe(Y, Le, ve, ye, De, ct, Lt, hn, Mn, At) {
			if (Y === ws) {
				v === !0 && (V(n.BLEND), (v = !1));
				return;
			}
			if ((v === !1 && (ge(n.BLEND), (v = !0)), Y !== UA)) {
				if (Y !== _ || At !== w) {
					if (((p !== aa || b !== aa) && (n.blendEquation(n.FUNC_ADD), (p = aa), (b = aa)), At))
						switch (Y) {
							case bo:
								n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
								break;
							case mv:
								n.blendFunc(n.ONE, n.ONE);
								break;
							case gv:
								n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
								break;
							case vv:
								n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
								break;
							default:
								console.error("THREE.WebGLState: Invalid blending: ", Y);
								break;
						}
					else
						switch (Y) {
							case bo:
								n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
								break;
							case mv:
								n.blendFunc(n.SRC_ALPHA, n.ONE);
								break;
							case gv:
								n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
								break;
							case vv:
								n.blendFunc(n.ZERO, n.SRC_COLOR);
								break;
							default:
								console.error("THREE.WebGLState: Invalid blending: ", Y);
								break;
						}
					(g = null), (x = null), (T = null), (P = null), A.set(0, 0, 0), (M = 0), (_ = Y), (w = At);
				}
				return;
			}
			(De = De || Le), (ct = ct || ve), (Lt = Lt || ye), (Le !== p || De !== b) && (n.blendEquationSeparate(He[Le], He[De]), (p = Le), (b = De)), (ve !== g || ye !== x || ct !== T || Lt !== P) && (n.blendFuncSeparate(F[ve], F[ye], F[ct], F[Lt]), (g = ve), (x = ye), (T = ct), (P = Lt)), (hn.equals(A) === !1 || Mn !== M) && (n.blendColor(hn.r, hn.g, hn.b, Mn), A.copy(hn), (M = Mn)), (_ = Y), (w = !1);
		}
		function pe(Y, Le) {
			Y.side === An ? V(n.CULL_FACE) : ge(n.CULL_FACE);
			let ve = Y.side === li;
			Le && (ve = !ve), Ee(ve), Y.blending === bo && Y.transparent === !1 ? fe(ws) : fe(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.blendColor, Y.blendAlpha, Y.premultipliedAlpha), s.setFunc(Y.depthFunc), s.setTest(Y.depthTest), s.setMask(Y.depthWrite), r.setMask(Y.colorWrite);
			const ye = Y.stencilWrite;
			a.setTest(ye), ye && (a.setMask(Y.stencilWriteMask), a.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask), a.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)), Ce(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits), Y.alphaToCoverage === !0 ? ge(n.SAMPLE_ALPHA_TO_COVERAGE) : V(n.SAMPLE_ALPHA_TO_COVERAGE);
		}
		function Ee(Y) {
			y !== Y && (Y ? n.frontFace(n.CW) : n.frontFace(n.CCW), (y = Y));
		}
		function re(Y) {
			Y !== IA ? (ge(n.CULL_FACE), Y !== S && (Y === pv ? n.cullFace(n.BACK) : Y === FA ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : V(n.CULL_FACE), (S = Y);
		}
		function We(Y) {
			Y !== L && (W && n.lineWidth(Y), (L = Y));
		}
		function Ce(Y, Le, ve) {
			Y ? (ge(n.POLYGON_OFFSET_FILL), (N !== Le || k !== ve) && (n.polygonOffset(Le, ve), (N = Le), (k = ve))) : V(n.POLYGON_OFFSET_FILL);
		}
		function Ie(Y) {
			Y ? ge(n.SCISSOR_TEST) : V(n.SCISSOR_TEST);
		}
		function U(Y) {
			Y === void 0 && (Y = n.TEXTURE0 + B - 1), X !== Y && (n.activeTexture(Y), (X = Y));
		}
		function R(Y, Le, ve) {
			ve === void 0 && (X === null ? (ve = n.TEXTURE0 + B - 1) : (ve = X));
			let ye = K[ve];
			ye === void 0 && ((ye = { type: void 0, texture: void 0 }), (K[ve] = ye)), (ye.type !== Y || ye.texture !== Le) && (X !== ve && (n.activeTexture(ve), (X = ve)), n.bindTexture(Y, Le || ie[Y]), (ye.type = Y), (ye.texture = Le));
		}
		function ee() {
			const Y = K[X];
			Y !== void 0 && Y.type !== void 0 && (n.bindTexture(Y.type, null), (Y.type = void 0), (Y.texture = void 0));
		}
		function de() {
			try {
				n.compressedTexImage2D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function me() {
			try {
				n.compressedTexImage3D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function oe() {
			try {
				n.texSubImage2D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function Xe() {
			try {
				n.texSubImage3D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function Me() {
			try {
				n.compressedTexSubImage2D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function Pe() {
			try {
				n.compressedTexSubImage3D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function Je() {
			try {
				n.texStorage2D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function we() {
			try {
				n.texStorage3D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function Fe() {
			try {
				n.texImage2D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function lt() {
			try {
				n.texImage3D.apply(n, arguments);
			} catch (Y) {
				console.error("THREE.WebGLState:", Y);
			}
		}
		function ot(Y) {
			ae.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w), ae.copy(Y));
		}
		function Ne(Y) {
			Ue.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w), Ue.copy(Y));
		}
		function dt(Y, Le) {
			let ve = l.get(Le);
			ve === void 0 && ((ve = new WeakMap()), l.set(Le, ve));
			let ye = ve.get(Y);
			ye === void 0 && ((ye = n.getUniformBlockIndex(Le, Y.name)), ve.set(Y, ye));
		}
		function vt(Y, Le) {
			const ye = l.get(Le).get(Y);
			o.get(Le) !== ye && (n.uniformBlockBinding(Le, ye, Y.__bindingPointIndex), o.set(Le, ye));
		}
		function Qt() {
			n.disable(n.BLEND),
				n.disable(n.CULL_FACE),
				n.disable(n.DEPTH_TEST),
				n.disable(n.POLYGON_OFFSET_FILL),
				n.disable(n.SCISSOR_TEST),
				n.disable(n.STENCIL_TEST),
				n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
				n.blendEquation(n.FUNC_ADD),
				n.blendFunc(n.ONE, n.ZERO),
				n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
				n.blendColor(0, 0, 0, 0),
				n.colorMask(!0, !0, !0, !0),
				n.clearColor(0, 0, 0, 0),
				n.depthMask(!0),
				n.depthFunc(n.LESS),
				n.clearDepth(1),
				n.stencilMask(4294967295),
				n.stencilFunc(n.ALWAYS, 0, 4294967295),
				n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
				n.clearStencil(0),
				n.cullFace(n.BACK),
				n.frontFace(n.CCW),
				n.polygonOffset(0, 0),
				n.activeTexture(n.TEXTURE0),
				n.bindFramebuffer(n.FRAMEBUFFER, null),
				n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
				n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
				n.useProgram(null),
				n.lineWidth(1),
				n.scissor(0, 0, n.canvas.width, n.canvas.height),
				n.viewport(0, 0, n.canvas.width, n.canvas.height),
				(c = {}),
				(X = null),
				(K = {}),
				(u = {}),
				(h = new WeakMap()),
				(d = []),
				(f = null),
				(v = !1),
				(_ = null),
				(p = null),
				(g = null),
				(x = null),
				(b = null),
				(T = null),
				(P = null),
				(A = new rt(0, 0, 0)),
				(M = 0),
				(w = !1),
				(y = null),
				(S = null),
				(L = null),
				(N = null),
				(k = null),
				ae.set(0, 0, n.canvas.width, n.canvas.height),
				Ue.set(0, 0, n.canvas.width, n.canvas.height),
				r.reset(),
				s.reset(),
				a.reset();
		}
		return {
			buffers: { color: r, depth: s, stencil: a },
			enable: ge,
			disable: V,
			bindFramebuffer: j,
			drawBuffers: he,
			useProgram: xe,
			setBlending: fe,
			setMaterial: pe,
			setFlipSided: Ee,
			setCullFace: re,
			setLineWidth: We,
			setPolygonOffset: Ce,
			setScissorTest: Ie,
			activeTexture: U,
			bindTexture: R,
			unbindTexture: ee,
			compressedTexImage2D: de,
			compressedTexImage3D: me,
			texImage2D: Fe,
			texImage3D: lt,
			updateUBOMapping: dt,
			uniformBlockBinding: vt,
			texStorage2D: Je,
			texStorage3D: we,
			texSubImage2D: oe,
			texSubImage3D: Xe,
			compressedTexSubImage2D: Me,
			compressedTexSubImage3D: Pe,
			scissor: ot,
			viewport: Ne,
			reset: Qt
		};
	}
	function c0(n, e, t, i) {
		const r = GD(i);
		switch (t) {
			case Vy:
				return n * e;
			case Xy:
				return n * e;
			case $y:
				return n * e * 2;
			case qy:
				return ((n * e) / r.components) * r.byteLength;
			case Hp:
				return ((n * e) / r.components) * r.byteLength;
			case jy:
				return ((n * e * 2) / r.components) * r.byteLength;
			case Gp:
				return ((n * e * 2) / r.components) * r.byteLength;
			case Wy:
				return ((n * e * 3) / r.components) * r.byteLength;
			case er:
				return ((n * e * 4) / r.components) * r.byteLength;
			case Vp:
				return ((n * e * 4) / r.components) * r.byteLength;
			case Cu:
			case Lu:
				return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
			case Ru:
			case Pu:
				return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
			case Mf:
			case Cf:
				return (Math.max(n, 16) * Math.max(e, 8)) / 4;
			case Tf:
			case Af:
				return (Math.max(n, 8) * Math.max(e, 8)) / 2;
			case Lf:
			case Rf:
				return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
			case Pf:
				return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
			case Df:
				return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
			case Of:
				return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
			case If:
				return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
			case Ff:
				return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
			case Nf:
				return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
			case Uf:
				return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
			case kf:
				return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
			case Bf:
				return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
			case zf:
				return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
			case Hf:
				return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
			case Gf:
				return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
			case Vf:
				return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
			case Wf:
				return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
			case Xf:
				return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
			case Du:
			case $f:
			case qf:
				return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
			case Yy:
			case jf:
				return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
			case Yf:
			case Kf:
				return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
		}
		throw new Error(`Unable to determine texture byte length for ${t} format.`);
	}
	function GD(n) {
		switch (n) {
			case Zr:
			case zy:
				return { byteLength: 1, components: 1 };
			case Dl:
			case Hy:
			case Jl:
				return { byteLength: 2, components: 1 };
			case Bp:
			case zp:
				return { byteLength: 2, components: 4 };
			case _a:
			case kp:
			case Hr:
				return { byteLength: 4, components: 1 };
			case Gy:
				return { byteLength: 4, components: 3 };
		}
		throw new Error(`Unknown texture type ${n}.`);
	}
	function VD(n, e, t, i, r, s, a) {
		const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
			l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
			c = new Se(),
			u = new WeakMap();
		let h;
		const d = new WeakMap();
		let f = !1;
		try {
			f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
		} catch {}
		function v(U, R) {
			return f ? new OffscreenCanvas(U, R) : Il("canvas");
		}
		function _(U, R, ee) {
			let de = 1;
			const me = Ie(U);
			if (((me.width > ee || me.height > ee) && (de = ee / Math.max(me.width, me.height)), de < 1))
				if ((typeof HTMLImageElement < "u" && U instanceof HTMLImageElement) || (typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement) || (typeof ImageBitmap < "u" && U instanceof ImageBitmap) || (typeof VideoFrame < "u" && U instanceof VideoFrame)) {
					const oe = Math.floor(de * me.width),
						Xe = Math.floor(de * me.height);
					h === void 0 && (h = v(oe, Xe));
					const Me = R ? v(oe, Xe) : h;
					return (Me.width = oe), (Me.height = Xe), Me.getContext("2d").drawImage(U, 0, 0, oe, Xe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + me.width + "x" + me.height + ") to (" + oe + "x" + Xe + ")."), Me;
				} else return "data" in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + me.width + "x" + me.height + ")."), U;
			return U;
		}
		function p(U) {
			return U.generateMipmaps && U.minFilter !== Di && U.minFilter !== Zi;
		}
		function g(U) {
			n.generateMipmap(U);
		}
		function x(U, R, ee, de, me = !1) {
			if (U !== null) {
				if (n[U] !== void 0) return n[U];
				console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'");
			}
			let oe = R;
			if (
				(R === n.RED && (ee === n.FLOAT && (oe = n.R32F), ee === n.HALF_FLOAT && (oe = n.R16F), ee === n.UNSIGNED_BYTE && (oe = n.R8)),
				R === n.RED_INTEGER && (ee === n.UNSIGNED_BYTE && (oe = n.R8UI), ee === n.UNSIGNED_SHORT && (oe = n.R16UI), ee === n.UNSIGNED_INT && (oe = n.R32UI), ee === n.BYTE && (oe = n.R8I), ee === n.SHORT && (oe = n.R16I), ee === n.INT && (oe = n.R32I)),
				R === n.RG && (ee === n.FLOAT && (oe = n.RG32F), ee === n.HALF_FLOAT && (oe = n.RG16F), ee === n.UNSIGNED_BYTE && (oe = n.RG8)),
				R === n.RG_INTEGER && (ee === n.UNSIGNED_BYTE && (oe = n.RG8UI), ee === n.UNSIGNED_SHORT && (oe = n.RG16UI), ee === n.UNSIGNED_INT && (oe = n.RG32UI), ee === n.BYTE && (oe = n.RG8I), ee === n.SHORT && (oe = n.RG16I), ee === n.INT && (oe = n.RG32I)),
				R === n.RGB && ee === n.UNSIGNED_INT_5_9_9_9_REV && (oe = n.RGB9_E5),
				R === n.RGBA)
			) {
				const Xe = me ? $u : zt.getTransfer(de);
				ee === n.FLOAT && (oe = n.RGBA32F), ee === n.HALF_FLOAT && (oe = n.RGBA16F), ee === n.UNSIGNED_BYTE && (oe = Xe === nn ? n.SRGB8_ALPHA8 : n.RGBA8), ee === n.UNSIGNED_SHORT_4_4_4_4 && (oe = n.RGBA4), ee === n.UNSIGNED_SHORT_5_5_5_1 && (oe = n.RGB5_A1);
			}
			return (oe === n.R16F || oe === n.R32F || oe === n.RG16F || oe === n.RG32F || oe === n.RGBA16F || oe === n.RGBA32F) && e.get("EXT_color_buffer_float"), oe;
		}
		function b(U, R) {
			let ee;
			return U ? (R === null || R === _a || R === ko ? (ee = n.DEPTH24_STENCIL8) : R === Hr ? (ee = n.DEPTH32F_STENCIL8) : R === Dl && ((ee = n.DEPTH24_STENCIL8), console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."))) : R === null || R === _a || R === ko ? (ee = n.DEPTH_COMPONENT24) : R === Hr ? (ee = n.DEPTH_COMPONENT32F) : R === Dl && (ee = n.DEPTH_COMPONENT16), ee;
		}
		function T(U, R) {
			return p(U) === !0 || (U.isFramebufferTexture && U.minFilter !== Di && U.minFilter !== Zi) ? Math.log2(Math.max(R.width, R.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? R.mipmaps.length : 1;
		}
		function P(U) {
			const R = U.target;
			R.removeEventListener("dispose", P), M(R), R.isVideoTexture && u.delete(R);
		}
		function A(U) {
			const R = U.target;
			R.removeEventListener("dispose", A), y(R);
		}
		function M(U) {
			const R = i.get(U);
			if (R.__webglInit === void 0) return;
			const ee = U.source,
				de = d.get(ee);
			if (de) {
				const me = de[R.__cacheKey];
				me.usedTimes--, me.usedTimes === 0 && w(U), Object.keys(de).length === 0 && d.delete(ee);
			}
			i.remove(U);
		}
		function w(U) {
			const R = i.get(U);
			n.deleteTexture(R.__webglTexture);
			const ee = U.source,
				de = d.get(ee);
			delete de[R.__cacheKey], a.memory.textures--;
		}
		function y(U) {
			const R = i.get(U);
			if ((U.depthTexture && U.depthTexture.dispose(), U.isWebGLCubeRenderTarget))
				for (let de = 0; de < 6; de++) {
					if (Array.isArray(R.__webglFramebuffer[de])) for (let me = 0; me < R.__webglFramebuffer[de].length; me++) n.deleteFramebuffer(R.__webglFramebuffer[de][me]);
					else n.deleteFramebuffer(R.__webglFramebuffer[de]);
					R.__webglDepthbuffer && n.deleteRenderbuffer(R.__webglDepthbuffer[de]);
				}
			else {
				if (Array.isArray(R.__webglFramebuffer)) for (let de = 0; de < R.__webglFramebuffer.length; de++) n.deleteFramebuffer(R.__webglFramebuffer[de]);
				else n.deleteFramebuffer(R.__webglFramebuffer);
				if ((R.__webglDepthbuffer && n.deleteRenderbuffer(R.__webglDepthbuffer), R.__webglMultisampledFramebuffer && n.deleteFramebuffer(R.__webglMultisampledFramebuffer), R.__webglColorRenderbuffer)) for (let de = 0; de < R.__webglColorRenderbuffer.length; de++) R.__webglColorRenderbuffer[de] && n.deleteRenderbuffer(R.__webglColorRenderbuffer[de]);
				R.__webglDepthRenderbuffer && n.deleteRenderbuffer(R.__webglDepthRenderbuffer);
			}
			const ee = U.textures;
			for (let de = 0, me = ee.length; de < me; de++) {
				const oe = i.get(ee[de]);
				oe.__webglTexture && (n.deleteTexture(oe.__webglTexture), a.memory.textures--), i.remove(ee[de]);
			}
			i.remove(U);
		}
		let S = 0;
		function L() {
			S = 0;
		}
		function N() {
			const U = S;
			return U >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + r.maxTextures), (S += 1), U;
		}
		function k(U) {
			const R = [];
			return R.push(U.wrapS), R.push(U.wrapT), R.push(U.wrapR || 0), R.push(U.magFilter), R.push(U.minFilter), R.push(U.anisotropy), R.push(U.internalFormat), R.push(U.format), R.push(U.type), R.push(U.generateMipmaps), R.push(U.premultiplyAlpha), R.push(U.flipY), R.push(U.unpackAlignment), R.push(U.colorSpace), R.join();
		}
		function B(U, R) {
			const ee = i.get(U);
			if ((U.isVideoTexture && We(U), U.isRenderTargetTexture === !1 && U.version > 0 && ee.__version !== U.version)) {
				const de = U.image;
				if (de === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
				else if (de.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
				else {
					Ue(ee, U, R);
					return;
				}
			}
			t.bindTexture(n.TEXTURE_2D, ee.__webglTexture, n.TEXTURE0 + R);
		}
		function W(U, R) {
			const ee = i.get(U);
			if (U.version > 0 && ee.__version !== U.version) {
				Ue(ee, U, R);
				return;
			}
			t.bindTexture(n.TEXTURE_2D_ARRAY, ee.__webglTexture, n.TEXTURE0 + R);
		}
		function H(U, R) {
			const ee = i.get(U);
			if (U.version > 0 && ee.__version !== U.version) {
				Ue(ee, U, R);
				return;
			}
			t.bindTexture(n.TEXTURE_3D, ee.__webglTexture, n.TEXTURE0 + R);
		}
		function z(U, R) {
			const ee = i.get(U);
			if (U.version > 0 && ee.__version !== U.version) {
				Z(ee, U, R);
				return;
			}
			t.bindTexture(n.TEXTURE_CUBE_MAP, ee.__webglTexture, n.TEXTURE0 + R);
		}
		const X = { [Xu]: n.REPEAT, [da]: n.CLAMP_TO_EDGE, [wf]: n.MIRRORED_REPEAT },
			K = { [Di]: n.NEAREST, [vC]: n.NEAREST_MIPMAP_NEAREST, [Oc]: n.NEAREST_MIPMAP_LINEAR, [Zi]: n.LINEAR, [dd]: n.LINEAR_MIPMAP_NEAREST, [fa]: n.LINEAR_MIPMAP_LINEAR },
			G = { [bC]: n.NEVER, [AC]: n.ALWAYS, [SC]: n.LESS, [Zy]: n.LEQUAL, [EC]: n.EQUAL, [MC]: n.GEQUAL, [wC]: n.GREATER, [TC]: n.NOTEQUAL };
		function ue(U, R) {
			if (
				(R.type === Hr && e.has("OES_texture_float_linear") === !1 && (R.magFilter === Zi || R.magFilter === dd || R.magFilter === Oc || R.magFilter === fa || R.minFilter === Zi || R.minFilter === dd || R.minFilter === Oc || R.minFilter === fa) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
				n.texParameteri(U, n.TEXTURE_WRAP_S, X[R.wrapS]),
				n.texParameteri(U, n.TEXTURE_WRAP_T, X[R.wrapT]),
				(U === n.TEXTURE_3D || U === n.TEXTURE_2D_ARRAY) && n.texParameteri(U, n.TEXTURE_WRAP_R, X[R.wrapR]),
				n.texParameteri(U, n.TEXTURE_MAG_FILTER, K[R.magFilter]),
				n.texParameteri(U, n.TEXTURE_MIN_FILTER, K[R.minFilter]),
				R.compareFunction && (n.texParameteri(U, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(U, n.TEXTURE_COMPARE_FUNC, G[R.compareFunction])),
				e.has("EXT_texture_filter_anisotropic") === !0)
			) {
				if (R.magFilter === Di || (R.minFilter !== Oc && R.minFilter !== fa) || (R.type === Hr && e.has("OES_texture_float_linear") === !1)) return;
				if (R.anisotropy > 1 || i.get(R).__currentAnisotropy) {
					const ee = e.get("EXT_texture_filter_anisotropic");
					n.texParameterf(U, ee.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(R.anisotropy, r.getMaxAnisotropy())), (i.get(R).__currentAnisotropy = R.anisotropy);
				}
			}
		}
		function ae(U, R) {
			let ee = !1;
			U.__webglInit === void 0 && ((U.__webglInit = !0), R.addEventListener("dispose", P));
			const de = R.source;
			let me = d.get(de);
			me === void 0 && ((me = {}), d.set(de, me));
			const oe = k(R);
			if (oe !== U.__cacheKey) {
				me[oe] === void 0 && ((me[oe] = { texture: n.createTexture(), usedTimes: 0 }), a.memory.textures++, (ee = !0)), me[oe].usedTimes++;
				const Xe = me[U.__cacheKey];
				Xe !== void 0 && (me[U.__cacheKey].usedTimes--, Xe.usedTimes === 0 && w(R)), (U.__cacheKey = oe), (U.__webglTexture = me[oe].texture);
			}
			return ee;
		}
		function Ue(U, R, ee) {
			let de = n.TEXTURE_2D;
			(R.isDataArrayTexture || R.isCompressedArrayTexture) && (de = n.TEXTURE_2D_ARRAY), R.isData3DTexture && (de = n.TEXTURE_3D);
			const me = ae(U, R),
				oe = R.source;
			t.bindTexture(de, U.__webglTexture, n.TEXTURE0 + ee);
			const Xe = i.get(oe);
			if (oe.version !== Xe.__version || me === !0) {
				t.activeTexture(n.TEXTURE0 + ee);
				const Me = zt.getPrimaries(zt.workingColorSpace),
					Pe = R.colorSpace === xs ? null : zt.getPrimaries(R.colorSpace),
					Je = R.colorSpace === xs || Me === Pe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
				n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, R.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, R.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Je);
				let we = _(R.image, !1, r.maxTextureSize);
				we = Ce(R, we);
				const Fe = s.convert(R.format, R.colorSpace),
					lt = s.convert(R.type);
				let ot = x(R.internalFormat, Fe, lt, R.colorSpace, R.isVideoTexture);
				ue(de, R);
				let Ne;
				const dt = R.mipmaps,
					vt = R.isVideoTexture !== !0,
					Qt = Xe.__version === void 0 || me === !0,
					Y = oe.dataReady,
					Le = T(R, we);
				if (R.isDepthTexture) (ot = b(R.format === Bo, R.type)), Qt && (vt ? t.texStorage2D(n.TEXTURE_2D, 1, ot, we.width, we.height) : t.texImage2D(n.TEXTURE_2D, 0, ot, we.width, we.height, 0, Fe, lt, null));
				else if (R.isDataTexture)
					if (dt.length > 0) {
						vt && Qt && t.texStorage2D(n.TEXTURE_2D, Le, ot, dt[0].width, dt[0].height);
						for (let ve = 0, ye = dt.length; ve < ye; ve++) (Ne = dt[ve]), vt ? Y && t.texSubImage2D(n.TEXTURE_2D, ve, 0, 0, Ne.width, Ne.height, Fe, lt, Ne.data) : t.texImage2D(n.TEXTURE_2D, ve, ot, Ne.width, Ne.height, 0, Fe, lt, Ne.data);
						R.generateMipmaps = !1;
					} else vt ? (Qt && t.texStorage2D(n.TEXTURE_2D, Le, ot, we.width, we.height), Y && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, we.width, we.height, Fe, lt, we.data)) : t.texImage2D(n.TEXTURE_2D, 0, ot, we.width, we.height, 0, Fe, lt, we.data);
				else if (R.isCompressedTexture)
					if (R.isCompressedArrayTexture) {
						vt && Qt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Le, ot, dt[0].width, dt[0].height, we.depth);
						for (let ve = 0, ye = dt.length; ve < ye; ve++)
							if (((Ne = dt[ve]), R.format !== er))
								if (Fe !== null)
									if (vt) {
										if (Y)
											if (R.layerUpdates.size > 0) {
												const De = c0(Ne.width, Ne.height, R.format, R.type);
												for (const ct of R.layerUpdates) {
													const Lt = Ne.data.subarray((ct * De) / Ne.data.BYTES_PER_ELEMENT, ((ct + 1) * De) / Ne.data.BYTES_PER_ELEMENT);
													t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ve, 0, 0, ct, Ne.width, Ne.height, 1, Fe, Lt, 0, 0);
												}
												R.clearLayerUpdates();
											} else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ve, 0, 0, 0, Ne.width, Ne.height, we.depth, Fe, Ne.data, 0, 0);
									} else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ve, ot, Ne.width, Ne.height, we.depth, 0, Ne.data, 0, 0);
								else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
							else vt ? Y && t.texSubImage3D(n.TEXTURE_2D_ARRAY, ve, 0, 0, 0, Ne.width, Ne.height, we.depth, Fe, lt, Ne.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ve, ot, Ne.width, Ne.height, we.depth, 0, Fe, lt, Ne.data);
					} else {
						vt && Qt && t.texStorage2D(n.TEXTURE_2D, Le, ot, dt[0].width, dt[0].height);
						for (let ve = 0, ye = dt.length; ve < ye; ve++)
							(Ne = dt[ve]),
								R.format !== er
									? Fe !== null
										? vt
											? Y && t.compressedTexSubImage2D(n.TEXTURE_2D, ve, 0, 0, Ne.width, Ne.height, Fe, Ne.data)
											: t.compressedTexImage2D(n.TEXTURE_2D, ve, ot, Ne.width, Ne.height, 0, Ne.data)
										: console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")
									: vt
									? Y && t.texSubImage2D(n.TEXTURE_2D, ve, 0, 0, Ne.width, Ne.height, Fe, lt, Ne.data)
									: t.texImage2D(n.TEXTURE_2D, ve, ot, Ne.width, Ne.height, 0, Fe, lt, Ne.data);
					}
				else if (R.isDataArrayTexture)
					if (vt) {
						if ((Qt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Le, ot, we.width, we.height, we.depth), Y))
							if (R.layerUpdates.size > 0) {
								const ve = c0(we.width, we.height, R.format, R.type);
								for (const ye of R.layerUpdates) {
									const De = we.data.subarray((ye * ve) / we.data.BYTES_PER_ELEMENT, ((ye + 1) * ve) / we.data.BYTES_PER_ELEMENT);
									t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, ye, we.width, we.height, 1, Fe, lt, De);
								}
								R.clearLayerUpdates();
							} else t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, we.width, we.height, we.depth, Fe, lt, we.data);
					} else t.texImage3D(n.TEXTURE_2D_ARRAY, 0, ot, we.width, we.height, we.depth, 0, Fe, lt, we.data);
				else if (R.isData3DTexture) vt ? (Qt && t.texStorage3D(n.TEXTURE_3D, Le, ot, we.width, we.height, we.depth), Y && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, we.width, we.height, we.depth, Fe, lt, we.data)) : t.texImage3D(n.TEXTURE_3D, 0, ot, we.width, we.height, we.depth, 0, Fe, lt, we.data);
				else if (R.isFramebufferTexture) {
					if (Qt)
						if (vt) t.texStorage2D(n.TEXTURE_2D, Le, ot, we.width, we.height);
						else {
							let ve = we.width,
								ye = we.height;
							for (let De = 0; De < Le; De++) t.texImage2D(n.TEXTURE_2D, De, ot, ve, ye, 0, Fe, lt, null), (ve >>= 1), (ye >>= 1);
						}
				} else if (dt.length > 0) {
					if (vt && Qt) {
						const ve = Ie(dt[0]);
						t.texStorage2D(n.TEXTURE_2D, Le, ot, ve.width, ve.height);
					}
					for (let ve = 0, ye = dt.length; ve < ye; ve++) (Ne = dt[ve]), vt ? Y && t.texSubImage2D(n.TEXTURE_2D, ve, 0, 0, Fe, lt, Ne) : t.texImage2D(n.TEXTURE_2D, ve, ot, Fe, lt, Ne);
					R.generateMipmaps = !1;
				} else if (vt) {
					if (Qt) {
						const ve = Ie(we);
						t.texStorage2D(n.TEXTURE_2D, Le, ot, ve.width, ve.height);
					}
					Y && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Fe, lt, we);
				} else t.texImage2D(n.TEXTURE_2D, 0, ot, Fe, lt, we);
				p(R) && g(de), (Xe.__version = oe.version), R.onUpdate && R.onUpdate(R);
			}
			U.__version = R.version;
		}
		function Z(U, R, ee) {
			if (R.image.length !== 6) return;
			const de = ae(U, R),
				me = R.source;
			t.bindTexture(n.TEXTURE_CUBE_MAP, U.__webglTexture, n.TEXTURE0 + ee);
			const oe = i.get(me);
			if (me.version !== oe.__version || de === !0) {
				t.activeTexture(n.TEXTURE0 + ee);
				const Xe = zt.getPrimaries(zt.workingColorSpace),
					Me = R.colorSpace === xs ? null : zt.getPrimaries(R.colorSpace),
					Pe = R.colorSpace === xs || Xe === Me ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
				n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, R.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, R.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pe);
				const Je = R.isCompressedTexture || R.image[0].isCompressedTexture,
					we = R.image[0] && R.image[0].isDataTexture,
					Fe = [];
				for (let ye = 0; ye < 6; ye++) !Je && !we ? (Fe[ye] = _(R.image[ye], !0, r.maxCubemapSize)) : (Fe[ye] = we ? R.image[ye].image : R.image[ye]), (Fe[ye] = Ce(R, Fe[ye]));
				const lt = Fe[0],
					ot = s.convert(R.format, R.colorSpace),
					Ne = s.convert(R.type),
					dt = x(R.internalFormat, ot, Ne, R.colorSpace),
					vt = R.isVideoTexture !== !0,
					Qt = oe.__version === void 0 || de === !0,
					Y = me.dataReady;
				let Le = T(R, lt);
				ue(n.TEXTURE_CUBE_MAP, R);
				let ve;
				if (Je) {
					vt && Qt && t.texStorage2D(n.TEXTURE_CUBE_MAP, Le, dt, lt.width, lt.height);
					for (let ye = 0; ye < 6; ye++) {
						ve = Fe[ye].mipmaps;
						for (let De = 0; De < ve.length; De++) {
							const ct = ve[De];
							R.format !== er
								? ot !== null
									? vt
										? Y && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De, 0, 0, ct.width, ct.height, ot, ct.data)
										: t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De, dt, ct.width, ct.height, 0, ct.data)
									: console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()")
								: vt
								? Y && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De, 0, 0, ct.width, ct.height, ot, Ne, ct.data)
								: t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De, dt, ct.width, ct.height, 0, ot, Ne, ct.data);
						}
					}
				} else {
					if (((ve = R.mipmaps), vt && Qt)) {
						ve.length > 0 && Le++;
						const ye = Ie(Fe[0]);
						t.texStorage2D(n.TEXTURE_CUBE_MAP, Le, dt, ye.width, ye.height);
					}
					for (let ye = 0; ye < 6; ye++)
						if (we) {
							vt ? Y && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0, 0, 0, Fe[ye].width, Fe[ye].height, ot, Ne, Fe[ye].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0, dt, Fe[ye].width, Fe[ye].height, 0, ot, Ne, Fe[ye].data);
							for (let De = 0; De < ve.length; De++) {
								const Lt = ve[De].image[ye].image;
								vt ? Y && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De + 1, 0, 0, Lt.width, Lt.height, ot, Ne, Lt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De + 1, dt, Lt.width, Lt.height, 0, ot, Ne, Lt.data);
							}
						} else {
							vt ? Y && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0, 0, 0, ot, Ne, Fe[ye]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, 0, dt, ot, Ne, Fe[ye]);
							for (let De = 0; De < ve.length; De++) {
								const ct = ve[De];
								vt ? Y && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De + 1, 0, 0, ot, Ne, ct.image[ye]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ye, De + 1, dt, ot, Ne, ct.image[ye]);
							}
						}
				}
				p(R) && g(n.TEXTURE_CUBE_MAP), (oe.__version = me.version), R.onUpdate && R.onUpdate(R);
			}
			U.__version = R.version;
		}
		function ie(U, R, ee, de, me, oe) {
			const Xe = s.convert(ee.format, ee.colorSpace),
				Me = s.convert(ee.type),
				Pe = x(ee.internalFormat, Xe, Me, ee.colorSpace);
			if (!i.get(R).__hasExternalTextures) {
				const we = Math.max(1, R.width >> oe),
					Fe = Math.max(1, R.height >> oe);
				me === n.TEXTURE_3D || me === n.TEXTURE_2D_ARRAY ? t.texImage3D(me, oe, Pe, we, Fe, R.depth, 0, Xe, Me, null) : t.texImage2D(me, oe, Pe, we, Fe, 0, Xe, Me, null);
			}
			t.bindFramebuffer(n.FRAMEBUFFER, U), re(R) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, de, me, i.get(ee).__webglTexture, 0, Ee(R)) : (me === n.TEXTURE_2D || (me >= n.TEXTURE_CUBE_MAP_POSITIVE_X && me <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) && n.framebufferTexture2D(n.FRAMEBUFFER, de, me, i.get(ee).__webglTexture, oe), t.bindFramebuffer(n.FRAMEBUFFER, null);
		}
		function ge(U, R, ee) {
			if ((n.bindRenderbuffer(n.RENDERBUFFER, U), R.depthBuffer)) {
				const de = R.depthTexture,
					me = de && de.isDepthTexture ? de.type : null,
					oe = b(R.stencilBuffer, me),
					Xe = R.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
					Me = Ee(R);
				re(R) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Me, oe, R.width, R.height) : ee ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Me, oe, R.width, R.height) : n.renderbufferStorage(n.RENDERBUFFER, oe, R.width, R.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, Xe, n.RENDERBUFFER, U);
			} else {
				const de = R.textures;
				for (let me = 0; me < de.length; me++) {
					const oe = de[me],
						Xe = s.convert(oe.format, oe.colorSpace),
						Me = s.convert(oe.type),
						Pe = x(oe.internalFormat, Xe, Me, oe.colorSpace),
						Je = Ee(R);
					ee && re(R) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Je, Pe, R.width, R.height) : re(R) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Je, Pe, R.width, R.height) : n.renderbufferStorage(n.RENDERBUFFER, Pe, R.width, R.height);
				}
			}
			n.bindRenderbuffer(n.RENDERBUFFER, null);
		}
		function V(U, R) {
			if (R && R.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
			if ((t.bindFramebuffer(n.FRAMEBUFFER, U), !(R.depthTexture && R.depthTexture.isDepthTexture))) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
			(!i.get(R.depthTexture).__webglTexture || R.depthTexture.image.width !== R.width || R.depthTexture.image.height !== R.height) && ((R.depthTexture.image.width = R.width), (R.depthTexture.image.height = R.height), (R.depthTexture.needsUpdate = !0)), B(R.depthTexture, 0);
			const de = i.get(R.depthTexture).__webglTexture,
				me = Ee(R);
			if (R.depthTexture.format === So) re(R) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, de, 0, me) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, de, 0);
			else if (R.depthTexture.format === Bo) re(R) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, de, 0, me) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, de, 0);
			else throw new Error("Unknown depthTexture format");
		}
		function j(U) {
			const R = i.get(U),
				ee = U.isWebGLCubeRenderTarget === !0;
			if (U.depthTexture && !R.__autoAllocateDepthBuffer) {
				if (ee) throw new Error("target.depthTexture not supported in Cube render targets");
				V(R.__webglFramebuffer, U);
			} else if (ee) {
				R.__webglDepthbuffer = [];
				for (let de = 0; de < 6; de++) t.bindFramebuffer(n.FRAMEBUFFER, R.__webglFramebuffer[de]), (R.__webglDepthbuffer[de] = n.createRenderbuffer()), ge(R.__webglDepthbuffer[de], U, !1);
			} else t.bindFramebuffer(n.FRAMEBUFFER, R.__webglFramebuffer), (R.__webglDepthbuffer = n.createRenderbuffer()), ge(R.__webglDepthbuffer, U, !1);
			t.bindFramebuffer(n.FRAMEBUFFER, null);
		}
		function he(U, R, ee) {
			const de = i.get(U);
			R !== void 0 && ie(de.__webglFramebuffer, U, U.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), ee !== void 0 && j(U);
		}
		function xe(U) {
			const R = U.texture,
				ee = i.get(U),
				de = i.get(R);
			U.addEventListener("dispose", A);
			const me = U.textures,
				oe = U.isWebGLCubeRenderTarget === !0,
				Xe = me.length > 1;
			if ((Xe || (de.__webglTexture === void 0 && (de.__webglTexture = n.createTexture()), (de.__version = R.version), a.memory.textures++), oe)) {
				ee.__webglFramebuffer = [];
				for (let Me = 0; Me < 6; Me++)
					if (R.mipmaps && R.mipmaps.length > 0) {
						ee.__webglFramebuffer[Me] = [];
						for (let Pe = 0; Pe < R.mipmaps.length; Pe++) ee.__webglFramebuffer[Me][Pe] = n.createFramebuffer();
					} else ee.__webglFramebuffer[Me] = n.createFramebuffer();
			} else {
				if (R.mipmaps && R.mipmaps.length > 0) {
					ee.__webglFramebuffer = [];
					for (let Me = 0; Me < R.mipmaps.length; Me++) ee.__webglFramebuffer[Me] = n.createFramebuffer();
				} else ee.__webglFramebuffer = n.createFramebuffer();
				if (Xe)
					for (let Me = 0, Pe = me.length; Me < Pe; Me++) {
						const Je = i.get(me[Me]);
						Je.__webglTexture === void 0 && ((Je.__webglTexture = n.createTexture()), a.memory.textures++);
					}
				if (U.samples > 0 && re(U) === !1) {
					(ee.__webglMultisampledFramebuffer = n.createFramebuffer()), (ee.__webglColorRenderbuffer = []), t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglMultisampledFramebuffer);
					for (let Me = 0; Me < me.length; Me++) {
						const Pe = me[Me];
						(ee.__webglColorRenderbuffer[Me] = n.createRenderbuffer()), n.bindRenderbuffer(n.RENDERBUFFER, ee.__webglColorRenderbuffer[Me]);
						const Je = s.convert(Pe.format, Pe.colorSpace),
							we = s.convert(Pe.type),
							Fe = x(Pe.internalFormat, Je, we, Pe.colorSpace, U.isXRRenderTarget === !0),
							lt = Ee(U);
						n.renderbufferStorageMultisample(n.RENDERBUFFER, lt, Fe, U.width, U.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Me, n.RENDERBUFFER, ee.__webglColorRenderbuffer[Me]);
					}
					n.bindRenderbuffer(n.RENDERBUFFER, null), U.depthBuffer && ((ee.__webglDepthRenderbuffer = n.createRenderbuffer()), ge(ee.__webglDepthRenderbuffer, U, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
				}
			}
			if (oe) {
				t.bindTexture(n.TEXTURE_CUBE_MAP, de.__webglTexture), ue(n.TEXTURE_CUBE_MAP, R);
				for (let Me = 0; Me < 6; Me++)
					if (R.mipmaps && R.mipmaps.length > 0) for (let Pe = 0; Pe < R.mipmaps.length; Pe++) ie(ee.__webglFramebuffer[Me][Pe], U, R, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Me, Pe);
					else ie(ee.__webglFramebuffer[Me], U, R, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Me, 0);
				p(R) && g(n.TEXTURE_CUBE_MAP), t.unbindTexture();
			} else if (Xe) {
				for (let Me = 0, Pe = me.length; Me < Pe; Me++) {
					const Je = me[Me],
						we = i.get(Je);
					t.bindTexture(n.TEXTURE_2D, we.__webglTexture), ue(n.TEXTURE_2D, Je), ie(ee.__webglFramebuffer, U, Je, n.COLOR_ATTACHMENT0 + Me, n.TEXTURE_2D, 0), p(Je) && g(n.TEXTURE_2D);
				}
				t.unbindTexture();
			} else {
				let Me = n.TEXTURE_2D;
				if (((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (Me = U.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(Me, de.__webglTexture), ue(Me, R), R.mipmaps && R.mipmaps.length > 0)) for (let Pe = 0; Pe < R.mipmaps.length; Pe++) ie(ee.__webglFramebuffer[Pe], U, R, n.COLOR_ATTACHMENT0, Me, Pe);
				else ie(ee.__webglFramebuffer, U, R, n.COLOR_ATTACHMENT0, Me, 0);
				p(R) && g(Me), t.unbindTexture();
			}
			U.depthBuffer && j(U);
		}
		function He(U) {
			const R = U.textures;
			for (let ee = 0, de = R.length; ee < de; ee++) {
				const me = R[ee];
				if (p(me)) {
					const oe = U.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D,
						Xe = i.get(me).__webglTexture;
					t.bindTexture(oe, Xe), g(oe), t.unbindTexture();
				}
			}
		}
		const F = [],
			fe = [];
		function pe(U) {
			if (U.samples > 0) {
				if (re(U) === !1) {
					const R = U.textures,
						ee = U.width,
						de = U.height;
					let me = n.COLOR_BUFFER_BIT;
					const oe = U.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
						Xe = i.get(U),
						Me = R.length > 1;
					if (Me) for (let Pe = 0; Pe < R.length; Pe++) t.bindFramebuffer(n.FRAMEBUFFER, Xe.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Pe, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Xe.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Pe, n.TEXTURE_2D, null, 0);
					t.bindFramebuffer(n.READ_FRAMEBUFFER, Xe.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Xe.__webglFramebuffer);
					for (let Pe = 0; Pe < R.length; Pe++) {
						if ((U.resolveDepthBuffer && (U.depthBuffer && (me |= n.DEPTH_BUFFER_BIT), U.stencilBuffer && U.resolveStencilBuffer && (me |= n.STENCIL_BUFFER_BIT)), Me)) {
							n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Xe.__webglColorRenderbuffer[Pe]);
							const Je = i.get(R[Pe]).__webglTexture;
							n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Je, 0);
						}
						n.blitFramebuffer(0, 0, ee, de, 0, 0, ee, de, me, n.NEAREST), l === !0 && ((F.length = 0), (fe.length = 0), F.push(n.COLOR_ATTACHMENT0 + Pe), U.depthBuffer && U.resolveDepthBuffer === !1 && (F.push(oe), fe.push(oe), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, fe)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, F));
					}
					if ((t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), Me))
						for (let Pe = 0; Pe < R.length; Pe++) {
							t.bindFramebuffer(n.FRAMEBUFFER, Xe.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Pe, n.RENDERBUFFER, Xe.__webglColorRenderbuffer[Pe]);
							const Je = i.get(R[Pe]).__webglTexture;
							t.bindFramebuffer(n.FRAMEBUFFER, Xe.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Pe, n.TEXTURE_2D, Je, 0);
						}
					t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Xe.__webglMultisampledFramebuffer);
				} else if (U.depthBuffer && U.resolveDepthBuffer === !1 && l) {
					const R = U.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
					n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [R]);
				}
			}
		}
		function Ee(U) {
			return Math.min(r.maxSamples, U.samples);
		}
		function re(U) {
			const R = i.get(U);
			return U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && R.__useRenderToTexture !== !1;
		}
		function We(U) {
			const R = a.render.frame;
			u.get(U) !== R && (u.set(U, R), U.update());
		}
		function Ce(U, R) {
			const ee = U.colorSpace,
				de = U.format,
				me = U.type;
			return U.isCompressedTexture === !0 || U.isVideoTexture === !0 || (ee !== Fs && ee !== xs && (zt.getTransfer(ee) === nn ? (de !== er || me !== Zr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ee))), R;
		}
		function Ie(U) {
			return typeof HTMLImageElement < "u" && U instanceof HTMLImageElement ? ((c.width = U.naturalWidth || U.width), (c.height = U.naturalHeight || U.height)) : typeof VideoFrame < "u" && U instanceof VideoFrame ? ((c.width = U.displayWidth), (c.height = U.displayHeight)) : ((c.width = U.width), (c.height = U.height)), c;
		}
		(this.allocateTextureUnit = N), (this.resetTextureUnits = L), (this.setTexture2D = B), (this.setTexture2DArray = W), (this.setTexture3D = H), (this.setTextureCube = z), (this.rebindTextures = he), (this.setupRenderTarget = xe), (this.updateRenderTargetMipmap = He), (this.updateMultisampleRenderTarget = pe), (this.setupDepthRenderbuffer = j), (this.setupFrameBufferTexture = ie), (this.useMultisampledRTT = re);
	}
	function WD(n, e) {
		function t(i, r = xs) {
			let s;
			const a = zt.getTransfer(r);
			if (i === Zr) return n.UNSIGNED_BYTE;
			if (i === Bp) return n.UNSIGNED_SHORT_4_4_4_4;
			if (i === zp) return n.UNSIGNED_SHORT_5_5_5_1;
			if (i === Gy) return n.UNSIGNED_INT_5_9_9_9_REV;
			if (i === zy) return n.BYTE;
			if (i === Hy) return n.SHORT;
			if (i === Dl) return n.UNSIGNED_SHORT;
			if (i === kp) return n.INT;
			if (i === _a) return n.UNSIGNED_INT;
			if (i === Hr) return n.FLOAT;
			if (i === Jl) return n.HALF_FLOAT;
			if (i === Vy) return n.ALPHA;
			if (i === Wy) return n.RGB;
			if (i === er) return n.RGBA;
			if (i === Xy) return n.LUMINANCE;
			if (i === $y) return n.LUMINANCE_ALPHA;
			if (i === So) return n.DEPTH_COMPONENT;
			if (i === Bo) return n.DEPTH_STENCIL;
			if (i === qy) return n.RED;
			if (i === Hp) return n.RED_INTEGER;
			if (i === jy) return n.RG;
			if (i === Gp) return n.RG_INTEGER;
			if (i === Vp) return n.RGBA_INTEGER;
			if (i === Cu || i === Lu || i === Ru || i === Pu)
				if (a === nn)
					if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
						if (i === Cu) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if (i === Lu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if (i === Ru) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if (i === Pu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
					} else return null;
				else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
					if (i === Cu) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (i === Lu) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (i === Ru) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (i === Pu) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else return null;
			if (i === Tf || i === Mf || i === Af || i === Cf)
				if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
					if (i === Tf) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (i === Mf) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (i === Af) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (i === Cf) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else return null;
			if (i === Lf || i === Rf || i === Pf)
				if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
					if (i === Lf || i === Rf) return a === nn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
					if (i === Pf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
				} else return null;
			if (i === Df || i === Of || i === If || i === Ff || i === Nf || i === Uf || i === kf || i === Bf || i === zf || i === Hf || i === Gf || i === Vf || i === Wf || i === Xf)
				if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
					if (i === Df) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if (i === Of) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if (i === If) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if (i === Ff) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if (i === Nf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if (i === Uf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if (i === kf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if (i === Bf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if (i === zf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if (i === Hf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if (i === Gf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if (i === Vf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if (i === Wf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if (i === Xf) return a === nn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
				} else return null;
			if (i === Du || i === $f || i === qf)
				if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
					if (i === Du) return a === nn ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
					if (i === $f) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
					if (i === qf) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
				} else return null;
			if (i === Yy || i === jf || i === Yf || i === Kf)
				if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
					if (i === Du) return s.COMPRESSED_RED_RGTC1_EXT;
					if (i === jf) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if (i === Yf) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if (i === Kf) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
				} else return null;
			return i === ko ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
		}
		return { convert: t };
	}
	class XD extends fi {
		constructor(e = []) {
			super(), (this.isArrayCamera = !0), (this.cameras = e);
		}
	}
	class Ot extends on {
		constructor() {
			super(), (this.isGroup = !0), (this.type = "Group");
		}
	}
	const $D = { type: "move" };
	class Ud {
		constructor() {
			(this._targetRay = null), (this._grip = null), (this._hand = null);
		}
		getHandSpace() {
			return this._hand === null && ((this._hand = new Ot()), (this._hand.matrixAutoUpdate = !1), (this._hand.visible = !1), (this._hand.joints = {}), (this._hand.inputState = { pinching: !1 })), this._hand;
		}
		getTargetRaySpace() {
			return this._targetRay === null && ((this._targetRay = new Ot()), (this._targetRay.matrixAutoUpdate = !1), (this._targetRay.visible = !1), (this._targetRay.hasLinearVelocity = !1), (this._targetRay.linearVelocity = new D()), (this._targetRay.hasAngularVelocity = !1), (this._targetRay.angularVelocity = new D())), this._targetRay;
		}
		getGripSpace() {
			return this._grip === null && ((this._grip = new Ot()), (this._grip.matrixAutoUpdate = !1), (this._grip.visible = !1), (this._grip.hasLinearVelocity = !1), (this._grip.linearVelocity = new D()), (this._grip.hasAngularVelocity = !1), (this._grip.angularVelocity = new D())), this._grip;
		}
		dispatchEvent(e) {
			return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
		}
		connect(e) {
			if (e && e.hand) {
				const t = this._hand;
				if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
			}
			return this.dispatchEvent({ type: "connected", data: e }), this;
		}
		disconnect(e) {
			return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
		}
		update(e, t, i) {
			let r = null,
				s = null,
				a = null;
			const o = this._targetRay,
				l = this._grip,
				c = this._hand;
			if (e && t.session.visibilityState !== "visible-blurred") {
				if (c && e.hand) {
					a = !0;
					for (const _ of e.hand.values()) {
						const p = t.getJointPose(_, i),
							g = this._getHandJoint(c, _);
						p !== null && (g.matrix.fromArray(p.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), (g.matrixWorldNeedsUpdate = !0), (g.jointRadius = p.radius)), (g.visible = p !== null);
					}
					const u = c.joints["index-finger-tip"],
						h = c.joints["thumb-tip"],
						d = u.position.distanceTo(h.position),
						f = 0.02,
						v = 0.005;
					c.inputState.pinching && d > f + v ? ((c.inputState.pinching = !1), this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && d <= f - v && ((c.inputState.pinching = !0), this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
				} else l !== null && e.gripSpace && ((s = t.getPose(e.gripSpace, i)), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), (l.matrixWorldNeedsUpdate = !0), s.linearVelocity ? ((l.hasLinearVelocity = !0), l.linearVelocity.copy(s.linearVelocity)) : (l.hasLinearVelocity = !1), s.angularVelocity ? ((l.hasAngularVelocity = !0), l.angularVelocity.copy(s.angularVelocity)) : (l.hasAngularVelocity = !1)));
				o !== null &&
					((r = t.getPose(e.targetRaySpace, i)),
					r === null && s !== null && (r = s),
					r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), (o.matrixWorldNeedsUpdate = !0), r.linearVelocity ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(r.linearVelocity)) : (o.hasLinearVelocity = !1), r.angularVelocity ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(r.angularVelocity)) : (o.hasAngularVelocity = !1), this.dispatchEvent($D)));
			}
			return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
		}
		_getHandJoint(e, t) {
			if (e.joints[t.jointName] === void 0) {
				const i = new Ot();
				(i.matrixAutoUpdate = !1), (i.visible = !1), (e.joints[t.jointName] = i), e.add(i);
			}
			return e.joints[t.jointName];
		}
	}
	const qD = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
		jD = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
	class YD {
		constructor() {
			(this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
		}
		init(e, t, i) {
			if (this.texture === null) {
				const r = new jn(),
					s = e.properties.get(r);
				(s.__webglTexture = t.texture), (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)), (this.texture = r);
			}
		}
		getMesh(e) {
			if (this.texture !== null && this.mesh === null) {
				const t = e.cameras[0].viewport,
					i = new wr({ vertexShader: qD, fragmentShader: jD, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } });
				this.mesh = new Re(new Ql(20, 20), i);
			}
			return this.mesh;
		}
		reset() {
			(this.texture = null), (this.mesh = null);
		}
		getDepthTexture() {
			return this.texture;
		}
	}
	class KD extends Ns {
		constructor(e, t) {
			super();
			const i = this;
			let r = null,
				s = 1,
				a = null,
				o = "local-floor",
				l = 1,
				c = null,
				u = null,
				h = null,
				d = null,
				f = null,
				v = null;
			const _ = new YD(),
				p = t.getContextAttributes();
			let g = null,
				x = null;
			const b = [],
				T = [],
				P = new Se();
			let A = null;
			const M = new fi();
			M.layers.enable(1), (M.viewport = new wn());
			const w = new fi();
			w.layers.enable(2), (w.viewport = new wn());
			const y = [M, w],
				S = new XD();
			S.layers.enable(1), S.layers.enable(2);
			let L = null,
				N = null;
			(this.cameraAutoUpdate = !0),
				(this.enabled = !1),
				(this.isPresenting = !1),
				(this.getController = function (Z) {
					let ie = b[Z];
					return ie === void 0 && ((ie = new Ud()), (b[Z] = ie)), ie.getTargetRaySpace();
				}),
				(this.getControllerGrip = function (Z) {
					let ie = b[Z];
					return ie === void 0 && ((ie = new Ud()), (b[Z] = ie)), ie.getGripSpace();
				}),
				(this.getHand = function (Z) {
					let ie = b[Z];
					return ie === void 0 && ((ie = new Ud()), (b[Z] = ie)), ie.getHandSpace();
				});
			function k(Z) {
				const ie = T.indexOf(Z.inputSource);
				if (ie === -1) return;
				const ge = b[ie];
				ge !== void 0 && (ge.update(Z.inputSource, Z.frame, c || a), ge.dispatchEvent({ type: Z.type, data: Z.inputSource }));
			}
			function B() {
				r.removeEventListener("select", k), r.removeEventListener("selectstart", k), r.removeEventListener("selectend", k), r.removeEventListener("squeeze", k), r.removeEventListener("squeezestart", k), r.removeEventListener("squeezeend", k), r.removeEventListener("end", B), r.removeEventListener("inputsourceschange", W);
				for (let Z = 0; Z < b.length; Z++) {
					const ie = T[Z];
					ie !== null && ((T[Z] = null), b[Z].disconnect(ie));
				}
				(L = null), (N = null), _.reset(), e.setRenderTarget(g), (f = null), (d = null), (h = null), (r = null), (x = null), Ue.stop(), (i.isPresenting = !1), e.setPixelRatio(A), e.setSize(P.width, P.height, !1), i.dispatchEvent({ type: "sessionend" });
			}
			(this.setFramebufferScaleFactor = function (Z) {
				(s = Z), i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
			}),
				(this.setReferenceSpaceType = function (Z) {
					(o = Z), i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
				}),
				(this.getReferenceSpace = function () {
					return c || a;
				}),
				(this.setReferenceSpace = function (Z) {
					c = Z;
				}),
				(this.getBaseLayer = function () {
					return d !== null ? d : f;
				}),
				(this.getBinding = function () {
					return h;
				}),
				(this.getFrame = function () {
					return v;
				}),
				(this.getSession = function () {
					return r;
				}),
				(this.setSession = async function (Z) {
					if (((r = Z), r !== null)) {
						if (((g = e.getRenderTarget()), r.addEventListener("select", k), r.addEventListener("selectstart", k), r.addEventListener("selectend", k), r.addEventListener("squeeze", k), r.addEventListener("squeezestart", k), r.addEventListener("squeezeend", k), r.addEventListener("end", B), r.addEventListener("inputsourceschange", W), p.xrCompatible !== !0 && (await t.makeXRCompatible()), (A = e.getPixelRatio()), e.getSize(P), r.renderState.layers === void 0)) {
							const ie = { antialias: p.antialias, alpha: !0, depth: p.depth, stencil: p.stencil, framebufferScaleFactor: s };
							(f = new XRWebGLLayer(r, t, ie)), r.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), (x = new ya(f.framebufferWidth, f.framebufferHeight, { format: er, type: Zr, colorSpace: e.outputColorSpace, stencilBuffer: p.stencil }));
						} else {
							let ie = null,
								ge = null,
								V = null;
							p.depth && ((V = p.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24), (ie = p.stencil ? Bo : So), (ge = p.stencil ? ko : _a));
							const j = { colorFormat: t.RGBA8, depthFormat: V, scaleFactor: s };
							(h = new XRWebGLBinding(r, t)),
								(d = h.createProjectionLayer(j)),
								r.updateRenderState({ layers: [d] }),
								e.setPixelRatio(1),
								e.setSize(d.textureWidth, d.textureHeight, !1),
								(x = new ya(d.textureWidth, d.textureHeight, { format: er, type: Zr, depthTexture: new lx(d.textureWidth, d.textureHeight, ge, void 0, void 0, void 0, void 0, void 0, void 0, ie), stencilBuffer: p.stencil, colorSpace: e.outputColorSpace, samples: p.antialias ? 4 : 0, resolveDepthBuffer: d.ignoreDepthValues === !1 }));
						}
						(x.isXRRenderTarget = !0), this.setFoveation(l), (c = null), (a = await r.requestReferenceSpace(o)), Ue.setContext(r), Ue.start(), (i.isPresenting = !0), i.dispatchEvent({ type: "sessionstart" });
					}
				}),
				(this.getEnvironmentBlendMode = function () {
					if (r !== null) return r.environmentBlendMode;
				}),
				(this.getDepthTexture = function () {
					return _.getDepthTexture();
				});
			function W(Z) {
				for (let ie = 0; ie < Z.removed.length; ie++) {
					const ge = Z.removed[ie],
						V = T.indexOf(ge);
					V >= 0 && ((T[V] = null), b[V].disconnect(ge));
				}
				for (let ie = 0; ie < Z.added.length; ie++) {
					const ge = Z.added[ie];
					let V = T.indexOf(ge);
					if (V === -1) {
						for (let he = 0; he < b.length; he++)
							if (he >= T.length) {
								T.push(ge), (V = he);
								break;
							} else if (T[he] === null) {
								(T[he] = ge), (V = he);
								break;
							}
						if (V === -1) break;
					}
					const j = b[V];
					j && j.connect(ge);
				}
			}
			const H = new D(),
				z = new D();
			function X(Z, ie, ge) {
				H.setFromMatrixPosition(ie.matrixWorld), z.setFromMatrixPosition(ge.matrixWorld);
				const V = H.distanceTo(z),
					j = ie.projectionMatrix.elements,
					he = ge.projectionMatrix.elements,
					xe = j[14] / (j[10] - 1),
					He = j[14] / (j[10] + 1),
					F = (j[9] + 1) / j[5],
					fe = (j[9] - 1) / j[5],
					pe = (j[8] - 1) / j[0],
					Ee = (he[8] + 1) / he[0],
					re = xe * pe,
					We = xe * Ee,
					Ce = V / (-pe + Ee),
					Ie = Ce * -pe;
				ie.matrixWorld.decompose(Z.position, Z.quaternion, Z.scale), Z.translateX(Ie), Z.translateZ(Ce), Z.matrixWorld.compose(Z.position, Z.quaternion, Z.scale), Z.matrixWorldInverse.copy(Z.matrixWorld).invert();
				const U = xe + Ce,
					R = He + Ce,
					ee = re - Ie,
					de = We + (V - Ie),
					me = ((F * He) / R) * U,
					oe = ((fe * He) / R) * U;
				Z.projectionMatrix.makePerspective(ee, de, me, oe, U, R), Z.projectionMatrixInverse.copy(Z.projectionMatrix).invert();
			}
			function K(Z, ie) {
				ie === null ? Z.matrixWorld.copy(Z.matrix) : Z.matrixWorld.multiplyMatrices(ie.matrixWorld, Z.matrix), Z.matrixWorldInverse.copy(Z.matrixWorld).invert();
			}
			this.updateCamera = function (Z) {
				if (r === null) return;
				_.texture !== null && ((Z.near = _.depthNear), (Z.far = _.depthFar)), (S.near = w.near = M.near = Z.near), (S.far = w.far = M.far = Z.far), (L !== S.near || N !== S.far) && (r.updateRenderState({ depthNear: S.near, depthFar: S.far }), (L = S.near), (N = S.far), (M.near = L), (M.far = N), (w.near = L), (w.far = N), M.updateProjectionMatrix(), w.updateProjectionMatrix(), Z.updateProjectionMatrix());
				const ie = Z.parent,
					ge = S.cameras;
				K(S, ie);
				for (let V = 0; V < ge.length; V++) K(ge[V], ie);
				ge.length === 2 ? X(S, M, w) : S.projectionMatrix.copy(M.projectionMatrix), G(Z, S, ie);
			};
			function G(Z, ie, ge) {
				ge === null ? Z.matrix.copy(ie.matrixWorld) : (Z.matrix.copy(ge.matrixWorld), Z.matrix.invert(), Z.matrix.multiply(ie.matrixWorld)), Z.matrix.decompose(Z.position, Z.quaternion, Z.scale), Z.updateMatrixWorld(!0), Z.projectionMatrix.copy(ie.projectionMatrix), Z.projectionMatrixInverse.copy(ie.projectionMatrixInverse), Z.isPerspectiveCamera && ((Z.fov = Ol * 2 * Math.atan(1 / Z.projectionMatrix.elements[5])), (Z.zoom = 1));
			}
			(this.getCamera = function () {
				return S;
			}),
				(this.getFoveation = function () {
					if (!(d === null && f === null)) return l;
				}),
				(this.setFoveation = function (Z) {
					(l = Z), d !== null && (d.fixedFoveation = Z), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Z);
				}),
				(this.hasDepthSensing = function () {
					return _.texture !== null;
				}),
				(this.getDepthSensingMesh = function () {
					return _.getMesh(S);
				});
			let ue = null;
			function ae(Z, ie) {
				if (((u = ie.getViewerPose(c || a)), (v = ie), u !== null)) {
					const ge = u.views;
					f !== null && (e.setRenderTargetFramebuffer(x, f.framebuffer), e.setRenderTarget(x));
					let V = !1;
					ge.length !== S.cameras.length && ((S.cameras.length = 0), (V = !0));
					for (let he = 0; he < ge.length; he++) {
						const xe = ge[he];
						let He = null;
						if (f !== null) He = f.getViewport(xe);
						else {
							const fe = h.getViewSubImage(d, xe);
							(He = fe.viewport), he === 0 && (e.setRenderTargetTextures(x, fe.colorTexture, d.ignoreDepthValues ? void 0 : fe.depthStencilTexture), e.setRenderTarget(x));
						}
						let F = y[he];
						F === void 0 && ((F = new fi()), F.layers.enable(he), (F.viewport = new wn()), (y[he] = F)), F.matrix.fromArray(xe.transform.matrix), F.matrix.decompose(F.position, F.quaternion, F.scale), F.projectionMatrix.fromArray(xe.projectionMatrix), F.projectionMatrixInverse.copy(F.projectionMatrix).invert(), F.viewport.set(He.x, He.y, He.width, He.height), he === 0 && (S.matrix.copy(F.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), V === !0 && S.cameras.push(F);
					}
					const j = r.enabledFeatures;
					if (j && j.includes("depth-sensing")) {
						const he = h.getDepthInformation(ge[0]);
						he && he.isValid && he.texture && _.init(e, he, r.renderState);
					}
				}
				for (let ge = 0; ge < b.length; ge++) {
					const V = T[ge],
						j = b[ge];
					V !== null && j !== void 0 && j.update(V, ie, c || a);
				}
				ue && ue(Z, ie), ie.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ie }), (v = null);
			}
			const Ue = new ox();
			Ue.setAnimationLoop(ae),
				(this.setAnimationLoop = function (Z) {
					ue = Z;
				}),
				(this.dispose = function () {});
		}
	}
	const Js = new Un(),
		ZD = new pt();
	function JD(n, e) {
		function t(p, g) {
			p.matrixAutoUpdate === !0 && p.updateMatrix(), g.value.copy(p.matrix);
		}
		function i(p, g) {
			g.color.getRGB(p.fogColor.value, rx(n)), g.isFog ? ((p.fogNear.value = g.near), (p.fogFar.value = g.far)) : g.isFogExp2 && (p.fogDensity.value = g.density);
		}
		function r(p, g, x, b, T) {
			g.isMeshBasicMaterial || g.isMeshLambertMaterial
				? s(p, g)
				: g.isMeshToonMaterial
				? (s(p, g), h(p, g))
				: g.isMeshPhongMaterial
				? (s(p, g), u(p, g))
				: g.isMeshStandardMaterial
				? (s(p, g), d(p, g), g.isMeshPhysicalMaterial && f(p, g, T))
				: g.isMeshMatcapMaterial
				? (s(p, g), v(p, g))
				: g.isMeshDepthMaterial
				? s(p, g)
				: g.isMeshDistanceMaterial
				? (s(p, g), _(p, g))
				: g.isMeshNormalMaterial
				? s(p, g)
				: g.isLineBasicMaterial
				? (a(p, g), g.isLineDashedMaterial && o(p, g))
				: g.isPointsMaterial
				? l(p, g, x, b)
				: g.isSpriteMaterial
				? c(p, g)
				: g.isShadowMaterial
				? (p.color.value.copy(g.color), (p.opacity.value = g.opacity))
				: g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
		}
		function s(p, g) {
			(p.opacity.value = g.opacity),
				g.color && p.diffuse.value.copy(g.color),
				g.emissive && p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
				g.map && ((p.map.value = g.map), t(g.map, p.mapTransform)),
				g.alphaMap && ((p.alphaMap.value = g.alphaMap), t(g.alphaMap, p.alphaMapTransform)),
				g.bumpMap && ((p.bumpMap.value = g.bumpMap), t(g.bumpMap, p.bumpMapTransform), (p.bumpScale.value = g.bumpScale), g.side === li && (p.bumpScale.value *= -1)),
				g.normalMap && ((p.normalMap.value = g.normalMap), t(g.normalMap, p.normalMapTransform), p.normalScale.value.copy(g.normalScale), g.side === li && p.normalScale.value.negate()),
				g.displacementMap && ((p.displacementMap.value = g.displacementMap), t(g.displacementMap, p.displacementMapTransform), (p.displacementScale.value = g.displacementScale), (p.displacementBias.value = g.displacementBias)),
				g.emissiveMap && ((p.emissiveMap.value = g.emissiveMap), t(g.emissiveMap, p.emissiveMapTransform)),
				g.specularMap && ((p.specularMap.value = g.specularMap), t(g.specularMap, p.specularMapTransform)),
				g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
			const x = e.get(g),
				b = x.envMap,
				T = x.envMapRotation;
			b && ((p.envMap.value = b), Js.copy(T), (Js.x *= -1), (Js.y *= -1), (Js.z *= -1), b.isCubeTexture && b.isRenderTargetTexture === !1 && ((Js.y *= -1), (Js.z *= -1)), p.envMapRotation.value.setFromMatrix4(ZD.makeRotationFromEuler(Js)), (p.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1), (p.reflectivity.value = g.reflectivity), (p.ior.value = g.ior), (p.refractionRatio.value = g.refractionRatio)),
				g.lightMap && ((p.lightMap.value = g.lightMap), (p.lightMapIntensity.value = g.lightMapIntensity), t(g.lightMap, p.lightMapTransform)),
				g.aoMap && ((p.aoMap.value = g.aoMap), (p.aoMapIntensity.value = g.aoMapIntensity), t(g.aoMap, p.aoMapTransform));
		}
		function a(p, g) {
			p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity), g.map && ((p.map.value = g.map), t(g.map, p.mapTransform));
		}
		function o(p, g) {
			(p.dashSize.value = g.dashSize), (p.totalSize.value = g.dashSize + g.gapSize), (p.scale.value = g.scale);
		}
		function l(p, g, x, b) {
			p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity), (p.size.value = g.size * x), (p.scale.value = b * 0.5), g.map && ((p.map.value = g.map), t(g.map, p.uvTransform)), g.alphaMap && ((p.alphaMap.value = g.alphaMap), t(g.alphaMap, p.alphaMapTransform)), g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
		}
		function c(p, g) {
			p.diffuse.value.copy(g.color), (p.opacity.value = g.opacity), (p.rotation.value = g.rotation), g.map && ((p.map.value = g.map), t(g.map, p.mapTransform)), g.alphaMap && ((p.alphaMap.value = g.alphaMap), t(g.alphaMap, p.alphaMapTransform)), g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
		}
		function u(p, g) {
			p.specular.value.copy(g.specular), (p.shininess.value = Math.max(g.shininess, 1e-4));
		}
		function h(p, g) {
			g.gradientMap && (p.gradientMap.value = g.gradientMap);
		}
		function d(p, g) {
			(p.metalness.value = g.metalness), g.metalnessMap && ((p.metalnessMap.value = g.metalnessMap), t(g.metalnessMap, p.metalnessMapTransform)), (p.roughness.value = g.roughness), g.roughnessMap && ((p.roughnessMap.value = g.roughnessMap), t(g.roughnessMap, p.roughnessMapTransform)), g.envMap && (p.envMapIntensity.value = g.envMapIntensity);
		}
		function f(p, g, x) {
			(p.ior.value = g.ior),
				g.sheen > 0 && (p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), (p.sheenRoughness.value = g.sheenRoughness), g.sheenColorMap && ((p.sheenColorMap.value = g.sheenColorMap), t(g.sheenColorMap, p.sheenColorMapTransform)), g.sheenRoughnessMap && ((p.sheenRoughnessMap.value = g.sheenRoughnessMap), t(g.sheenRoughnessMap, p.sheenRoughnessMapTransform))),
				g.clearcoat > 0 &&
					((p.clearcoat.value = g.clearcoat),
					(p.clearcoatRoughness.value = g.clearcoatRoughness),
					g.clearcoatMap && ((p.clearcoatMap.value = g.clearcoatMap), t(g.clearcoatMap, p.clearcoatMapTransform)),
					g.clearcoatRoughnessMap && ((p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), t(g.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)),
					g.clearcoatNormalMap && ((p.clearcoatNormalMap.value = g.clearcoatNormalMap), t(g.clearcoatNormalMap, p.clearcoatNormalMapTransform), p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === li && p.clearcoatNormalScale.value.negate())),
				g.dispersion > 0 && (p.dispersion.value = g.dispersion),
				g.iridescence > 0 &&
					((p.iridescence.value = g.iridescence),
					(p.iridescenceIOR.value = g.iridescenceIOR),
					(p.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
					(p.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
					g.iridescenceMap && ((p.iridescenceMap.value = g.iridescenceMap), t(g.iridescenceMap, p.iridescenceMapTransform)),
					g.iridescenceThicknessMap && ((p.iridescenceThicknessMap.value = g.iridescenceThicknessMap), t(g.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))),
				g.transmission > 0 &&
					((p.transmission.value = g.transmission),
					(p.transmissionSamplerMap.value = x.texture),
					p.transmissionSamplerSize.value.set(x.width, x.height),
					g.transmissionMap && ((p.transmissionMap.value = g.transmissionMap), t(g.transmissionMap, p.transmissionMapTransform)),
					(p.thickness.value = g.thickness),
					g.thicknessMap && ((p.thicknessMap.value = g.thicknessMap), t(g.thicknessMap, p.thicknessMapTransform)),
					(p.attenuationDistance.value = g.attenuationDistance),
					p.attenuationColor.value.copy(g.attenuationColor)),
				g.anisotropy > 0 && (p.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && ((p.anisotropyMap.value = g.anisotropyMap), t(g.anisotropyMap, p.anisotropyMapTransform))),
				(p.specularIntensity.value = g.specularIntensity),
				p.specularColor.value.copy(g.specularColor),
				g.specularColorMap && ((p.specularColorMap.value = g.specularColorMap), t(g.specularColorMap, p.specularColorMapTransform)),
				g.specularIntensityMap && ((p.specularIntensityMap.value = g.specularIntensityMap), t(g.specularIntensityMap, p.specularIntensityMapTransform));
		}
		function v(p, g) {
			g.matcap && (p.matcap.value = g.matcap);
		}
		function _(p, g) {
			const x = e.get(g).light;
			p.referencePosition.value.setFromMatrixPosition(x.matrixWorld), (p.nearDistance.value = x.shadow.camera.near), (p.farDistance.value = x.shadow.camera.far);
		}
		return { refreshFogUniforms: i, refreshMaterialUniforms: r };
	}
	function QD(n, e, t, i) {
		let r = {},
			s = {},
			a = [];
		const o = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
		function l(x, b) {
			const T = b.program;
			i.uniformBlockBinding(x, T);
		}
		function c(x, b) {
			let T = r[x.id];
			T === void 0 && (v(x), (T = u(x)), (r[x.id] = T), x.addEventListener("dispose", p));
			const P = b.program;
			i.updateUBOMapping(x, P);
			const A = e.render.frame;
			s[x.id] !== A && (d(x), (s[x.id] = A));
		}
		function u(x) {
			const b = h();
			x.__bindingPointIndex = b;
			const T = n.createBuffer(),
				P = x.__size,
				A = x.usage;
			return n.bindBuffer(n.UNIFORM_BUFFER, T), n.bufferData(n.UNIFORM_BUFFER, P, A), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, b, T), T;
		}
		function h() {
			for (let x = 0; x < o; x++) if (a.indexOf(x) === -1) return a.push(x), x;
			return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
		}
		function d(x) {
			const b = r[x.id],
				T = x.uniforms,
				P = x.__cache;
			n.bindBuffer(n.UNIFORM_BUFFER, b);
			for (let A = 0, M = T.length; A < M; A++) {
				const w = Array.isArray(T[A]) ? T[A] : [T[A]];
				for (let y = 0, S = w.length; y < S; y++) {
					const L = w[y];
					if (f(L, A, y, P) === !0) {
						const N = L.__offset,
							k = Array.isArray(L.value) ? L.value : [L.value];
						let B = 0;
						for (let W = 0; W < k.length; W++) {
							const H = k[W],
								z = _(H);
							typeof H == "number" || typeof H == "boolean"
								? ((L.__data[0] = H), n.bufferSubData(n.UNIFORM_BUFFER, N + B, L.__data))
								: H.isMatrix3
								? ((L.__data[0] = H.elements[0]), (L.__data[1] = H.elements[1]), (L.__data[2] = H.elements[2]), (L.__data[3] = 0), (L.__data[4] = H.elements[3]), (L.__data[5] = H.elements[4]), (L.__data[6] = H.elements[5]), (L.__data[7] = 0), (L.__data[8] = H.elements[6]), (L.__data[9] = H.elements[7]), (L.__data[10] = H.elements[8]), (L.__data[11] = 0))
								: (H.toArray(L.__data, B), (B += z.storage / Float32Array.BYTES_PER_ELEMENT));
						}
						n.bufferSubData(n.UNIFORM_BUFFER, N, L.__data);
					}
				}
			}
			n.bindBuffer(n.UNIFORM_BUFFER, null);
		}
		function f(x, b, T, P) {
			const A = x.value,
				M = b + "_" + T;
			if (P[M] === void 0) return typeof A == "number" || typeof A == "boolean" ? (P[M] = A) : (P[M] = A.clone()), !0;
			{
				const w = P[M];
				if (typeof A == "number" || typeof A == "boolean") {
					if (w !== A) return (P[M] = A), !0;
				} else if (w.equals(A) === !1) return w.copy(A), !0;
			}
			return !1;
		}
		function v(x) {
			const b = x.uniforms;
			let T = 0;
			const P = 16;
			for (let M = 0, w = b.length; M < w; M++) {
				const y = Array.isArray(b[M]) ? b[M] : [b[M]];
				for (let S = 0, L = y.length; S < L; S++) {
					const N = y[S],
						k = Array.isArray(N.value) ? N.value : [N.value];
					for (let B = 0, W = k.length; B < W; B++) {
						const H = k[B],
							z = _(H),
							X = T % P,
							K = X % z.boundary,
							G = X + K;
						(T += K), G !== 0 && P - G < z.storage && (T += P - G), (N.__data = new Float32Array(z.storage / Float32Array.BYTES_PER_ELEMENT)), (N.__offset = T), (T += z.storage);
					}
				}
			}
			const A = T % P;
			return A > 0 && (T += P - A), (x.__size = T), (x.__cache = {}), this;
		}
		function _(x) {
			const b = { boundary: 0, storage: 0 };
			return (
				typeof x == "number" || typeof x == "boolean"
					? ((b.boundary = 4), (b.storage = 4))
					: x.isVector2
					? ((b.boundary = 8), (b.storage = 8))
					: x.isVector3 || x.isColor
					? ((b.boundary = 16), (b.storage = 12))
					: x.isVector4
					? ((b.boundary = 16), (b.storage = 16))
					: x.isMatrix3
					? ((b.boundary = 48), (b.storage = 48))
					: x.isMatrix4
					? ((b.boundary = 64), (b.storage = 64))
					: x.isTexture
					? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.")
					: console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x),
				b
			);
		}
		function p(x) {
			const b = x.target;
			b.removeEventListener("dispose", p);
			const T = a.indexOf(b.__bindingPointIndex);
			a.splice(T, 1), n.deleteBuffer(r[b.id]), delete r[b.id], delete s[b.id];
		}
		function g() {
			for (const x in r) n.deleteBuffer(r[x]);
			(a = []), (r = {}), (s = {});
		}
		return { bind: l, update: c, dispose: g };
	}
	class eO {
		constructor(e = {}) {
			const { canvas: t = WC(), context: i = null, depth: r = !0, stencil: s = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: c = !1, powerPreference: u = "default", failIfMajorPerformanceCaveat: h = !1 } = e;
			this.isWebGLRenderer = !0;
			let d;
			if (i !== null) {
				if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
				d = i.getContextAttributes().alpha;
			} else d = a;
			const f = new Uint32Array(4),
				v = new Int32Array(4);
			let _ = null,
				p = null;
			const g = [],
				x = [];
			(this.domElement = t), (this.debug = { checkShaderErrors: !0, onShaderError: null }), (this.autoClear = !0), (this.autoClearColor = !0), (this.autoClearDepth = !0), (this.autoClearStencil = !0), (this.sortObjects = !0), (this.clippingPlanes = []), (this.localClippingEnabled = !1), (this._outputColorSpace = ni), (this.toneMapping = Ts), (this.toneMappingExposure = 1);
			const b = this;
			let T = !1,
				P = 0,
				A = 0,
				M = null,
				w = -1,
				y = null;
			const S = new wn(),
				L = new wn();
			let N = null;
			const k = new rt(0);
			let B = 0,
				W = t.width,
				H = t.height,
				z = 1,
				X = null,
				K = null;
			const G = new wn(0, 0, W, H),
				ue = new wn(0, 0, W, H);
			let ae = !1;
			const Ue = new qp();
			let Z = !1,
				ie = !1;
			const ge = new pt(),
				V = new D(),
				j = new wn(),
				he = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
			let xe = !1;
			function He() {
				return M === null ? z : 1;
			}
			let F = i;
			function fe(O, $) {
				return t.getContext(O, $);
			}
			try {
				const O = { alpha: !0, depth: r, stencil: s, antialias: o, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: u, failIfMajorPerformanceCaveat: h };
				if (("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Np}`), t.addEventListener("webglcontextlost", ve, !1), t.addEventListener("webglcontextrestored", ye, !1), t.addEventListener("webglcontextcreationerror", De, !1), F === null)) {
					const $ = "webgl2";
					if (((F = fe($, O)), F === null)) throw fe($) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
				}
			} catch (O) {
				throw (console.error("THREE.WebGLRenderer: " + O.message), O);
			}
			let pe, Ee, re, We, Ce, Ie, U, R, ee, de, me, oe, Xe, Me, Pe, Je, we, Fe, lt, ot, Ne, dt, vt, Qt;
			function Y() {
				(pe = new a2(F)),
					pe.init(),
					(dt = new WD(F, pe)),
					(Ee = new e2(F, pe, e, dt)),
					(re = new HD(F)),
					(We = new c2(F)),
					(Ce = new AD()),
					(Ie = new VD(F, pe, re, Ce, Ee, dt, We)),
					(U = new n2(b)),
					(R = new s2(b)),
					(ee = new gL(F)),
					(vt = new JP(F, ee)),
					(de = new o2(F, ee, We, vt)),
					(me = new h2(F, de, ee, We)),
					(lt = new u2(F, Ee, Ie)),
					(Je = new t2(Ce)),
					(oe = new MD(b, U, R, pe, Ee, vt, Je)),
					(Xe = new JD(b, Ce)),
					(Me = new LD()),
					(Pe = new FD(pe)),
					(Fe = new ZP(b, U, R, re, me, d, l)),
					(we = new zD(b, me, Ee)),
					(Qt = new QD(F, We, Ee, re)),
					(ot = new QP(F, pe, We)),
					(Ne = new l2(F, pe, We)),
					(We.programs = oe.programs),
					(b.capabilities = Ee),
					(b.extensions = pe),
					(b.properties = Ce),
					(b.renderLists = Me),
					(b.shadowMap = we),
					(b.state = re),
					(b.info = We);
			}
			Y();
			const Le = new KD(b, F);
			(this.xr = Le),
				(this.getContext = function () {
					return F;
				}),
				(this.getContextAttributes = function () {
					return F.getContextAttributes();
				}),
				(this.forceContextLoss = function () {
					const O = pe.get("WEBGL_lose_context");
					O && O.loseContext();
				}),
				(this.forceContextRestore = function () {
					const O = pe.get("WEBGL_lose_context");
					O && O.restoreContext();
				}),
				(this.getPixelRatio = function () {
					return z;
				}),
				(this.setPixelRatio = function (O) {
					O !== void 0 && ((z = O), this.setSize(W, H, !1));
				}),
				(this.getSize = function (O) {
					return O.set(W, H);
				}),
				(this.setSize = function (O, $, te = !0) {
					if (Le.isPresenting) {
						console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
						return;
					}
					(W = O), (H = $), (t.width = Math.floor(O * z)), (t.height = Math.floor($ * z)), te === !0 && ((t.style.width = O + "px"), (t.style.height = $ + "px")), this.setViewport(0, 0, O, $);
				}),
				(this.getDrawingBufferSize = function (O) {
					return O.set(W * z, H * z).floor();
				}),
				(this.setDrawingBufferSize = function (O, $, te) {
					(W = O), (H = $), (z = te), (t.width = Math.floor(O * te)), (t.height = Math.floor($ * te)), this.setViewport(0, 0, O, $);
				}),
				(this.getCurrentViewport = function (O) {
					return O.copy(S);
				}),
				(this.getViewport = function (O) {
					return O.copy(G);
				}),
				(this.setViewport = function (O, $, te, se) {
					O.isVector4 ? G.set(O.x, O.y, O.z, O.w) : G.set(O, $, te, se), re.viewport(S.copy(G).multiplyScalar(z).round());
				}),
				(this.getScissor = function (O) {
					return O.copy(ue);
				}),
				(this.setScissor = function (O, $, te, se) {
					O.isVector4 ? ue.set(O.x, O.y, O.z, O.w) : ue.set(O, $, te, se), re.scissor(L.copy(ue).multiplyScalar(z).round());
				}),
				(this.getScissorTest = function () {
					return ae;
				}),
				(this.setScissorTest = function (O) {
					re.setScissorTest((ae = O));
				}),
				(this.setOpaqueSort = function (O) {
					X = O;
				}),
				(this.setTransparentSort = function (O) {
					K = O;
				}),
				(this.getClearColor = function (O) {
					return O.copy(Fe.getClearColor());
				}),
				(this.setClearColor = function () {
					Fe.setClearColor.apply(Fe, arguments);
				}),
				(this.getClearAlpha = function () {
					return Fe.getClearAlpha();
				}),
				(this.setClearAlpha = function () {
					Fe.setClearAlpha.apply(Fe, arguments);
				}),
				(this.clear = function (O = !0, $ = !0, te = !0) {
					let se = 0;
					if (O) {
						let Q = !1;
						if (M !== null) {
							const Ae = M.texture.format;
							Q = Ae === Vp || Ae === Gp || Ae === Hp;
						}
						if (Q) {
							const Ae = M.texture.type,
								ke = Ae === Zr || Ae === _a || Ae === Dl || Ae === ko || Ae === Bp || Ae === zp,
								je = Fe.getClearColor(),
								Ye = Fe.getClearAlpha(),
								nt = je.r,
								ut = je.g,
								it = je.b;
							ke ? ((f[0] = nt), (f[1] = ut), (f[2] = it), (f[3] = Ye), F.clearBufferuiv(F.COLOR, 0, f)) : ((v[0] = nt), (v[1] = ut), (v[2] = it), (v[3] = Ye), F.clearBufferiv(F.COLOR, 0, v));
						} else se |= F.COLOR_BUFFER_BIT;
					}
					$ && (se |= F.DEPTH_BUFFER_BIT), te && ((se |= F.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)), F.clear(se);
				}),
				(this.clearColor = function () {
					this.clear(!0, !1, !1);
				}),
				(this.clearDepth = function () {
					this.clear(!1, !0, !1);
				}),
				(this.clearStencil = function () {
					this.clear(!1, !1, !0);
				}),
				(this.dispose = function () {
					t.removeEventListener("webglcontextlost", ve, !1), t.removeEventListener("webglcontextrestored", ye, !1), t.removeEventListener("webglcontextcreationerror", De, !1), Me.dispose(), Pe.dispose(), Ce.dispose(), U.dispose(), R.dispose(), me.dispose(), vt.dispose(), Qt.dispose(), oe.dispose(), Le.dispose(), Le.removeEventListener("sessionstart", xi), Le.removeEventListener("sessionend", oc), Cr.stop();
				});
			function ve(O) {
				O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (T = !0);
			}
			function ye() {
				console.log("THREE.WebGLRenderer: Context Restored."), (T = !1);
				const O = We.autoReset,
					$ = we.enabled,
					te = we.autoUpdate,
					se = we.needsUpdate,
					Q = we.type;
				Y(), (We.autoReset = O), (we.enabled = $), (we.autoUpdate = te), (we.needsUpdate = se), (we.type = Q);
			}
			function De(O) {
				console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", O.statusMessage);
			}
			function ct(O) {
				const $ = O.target;
				$.removeEventListener("dispose", ct), Lt($);
			}
			function Lt(O) {
				hn(O), Ce.remove(O);
			}
			function hn(O) {
				const $ = Ce.get(O).programs;
				$ !== void 0 &&
					($.forEach(function (te) {
						oe.releaseProgram(te);
					}),
					O.isShaderMaterial && oe.releaseShaderCache(O));
			}
			this.renderBufferDirect = function (O, $, te, se, Q, Ae) {
				$ === null && ($ = he);
				const ke = Q.isMesh && Q.matrixWorld.determinant() < 0,
					je = Eh(O, $, te, se, Q);
				re.setMaterial(se, ke);
				let Ye = te.index,
					nt = 1;
				if (se.wireframe === !0) {
					if (((Ye = de.getWireframeAttribute(te)), Ye === void 0)) return;
					nt = 2;
				}
				const ut = te.drawRange,
					it = te.attributes.position;
				let It = ut.start * nt,
					en = (ut.start + ut.count) * nt;
				Ae !== null && ((It = Math.max(It, Ae.start * nt)), (en = Math.min(en, (Ae.start + Ae.count) * nt))), Ye !== null ? ((It = Math.max(It, 0)), (en = Math.min(en, Ye.count))) : it != null && ((It = Math.max(It, 0)), (en = Math.min(en, it.count)));
				const tn = en - It;
				if (tn < 0 || tn === 1 / 0) return;
				vt.setup(Q, se, je, te, Ye);
				let Bn,
					Nt = ot;
				if ((Ye !== null && ((Bn = ee.get(Ye)), (Nt = Ne), Nt.setIndex(Bn)), Q.isMesh)) se.wireframe === !0 ? (re.setLineWidth(se.wireframeLinewidth * He()), Nt.setMode(F.LINES)) : Nt.setMode(F.TRIANGLES);
				else if (Q.isLine) {
					let Qe = se.linewidth;
					Qe === void 0 && (Qe = 1), re.setLineWidth(Qe * He()), Q.isLineSegments ? Nt.setMode(F.LINES) : Q.isLineLoop ? Nt.setMode(F.LINE_LOOP) : Nt.setMode(F.LINE_STRIP);
				} else Q.isPoints ? Nt.setMode(F.POINTS) : Q.isSprite && Nt.setMode(F.TRIANGLES);
				if (Q.isBatchedMesh)
					if (Q._multiDrawInstances !== null) Nt.renderMultiDrawInstances(Q._multiDrawStarts, Q._multiDrawCounts, Q._multiDrawCount, Q._multiDrawInstances);
					else if (pe.get("WEBGL_multi_draw")) Nt.renderMultiDraw(Q._multiDrawStarts, Q._multiDrawCounts, Q._multiDrawCount);
					else {
						const Qe = Q._multiDrawStarts,
							gn = Q._multiDrawCounts,
							Ut = Q._multiDrawCount,
							si = Ye ? ee.get(Ye).bytesPerElement : 1,
							Lr = Ce.get(se).currentProgram.getUniforms();
						for (let zn = 0; zn < Ut; zn++) Lr.setValue(F, "_gl_DrawID", zn), Nt.render(Qe[zn] / si, gn[zn]);
					}
				else if (Q.isInstancedMesh) Nt.renderInstances(It, tn, Q.count);
				else if (te.isInstancedBufferGeometry) {
					const Qe = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0,
						gn = Math.min(te.instanceCount, Qe);
					Nt.renderInstances(It, tn, gn);
				} else Nt.render(It, tn);
			};
			function Mn(O, $, te) {
				O.transparent === !0 && O.side === An && O.forceSinglePass === !1 ? ((O.side = li), (O.needsUpdate = !0), Ca(O, $, te), (O.side = Kr), (O.needsUpdate = !0), Ca(O, $, te), (O.side = An)) : Ca(O, $, te);
			}
			(this.compile = function (O, $, te = null) {
				te === null && (te = O),
					(p = Pe.get(te)),
					p.init($),
					x.push(p),
					te.traverseVisible(function (Q) {
						Q.isLight && Q.layers.test($.layers) && (p.pushLight(Q), Q.castShadow && p.pushShadow(Q));
					}),
					O !== te &&
						O.traverseVisible(function (Q) {
							Q.isLight && Q.layers.test($.layers) && (p.pushLight(Q), Q.castShadow && p.pushShadow(Q));
						}),
					p.setupLights();
				const se = new Set();
				return (
					O.traverse(function (Q) {
						const Ae = Q.material;
						if (Ae)
							if (Array.isArray(Ae))
								for (let ke = 0; ke < Ae.length; ke++) {
									const je = Ae[ke];
									Mn(je, te, Q), se.add(je);
								}
							else Mn(Ae, te, Q), se.add(Ae);
					}),
					x.pop(),
					(p = null),
					se
				);
			}),
				(this.compileAsync = function (O, $, te = null) {
					const se = this.compile(O, $, te);
					return new Promise((Q) => {
						function Ae() {
							if (
								(se.forEach(function (ke) {
									Ce.get(ke).currentProgram.isReady() && se.delete(ke);
								}),
								se.size === 0)
							) {
								Q(O);
								return;
							}
							setTimeout(Ae, 10);
						}
						pe.get("KHR_parallel_shader_compile") !== null ? Ae() : setTimeout(Ae, 10);
					});
				});
			let At = null;
			function Yn(O) {
				At && At(O);
			}
			function xi() {
				Cr.stop();
			}
			function oc() {
				Cr.start();
			}
			const Cr = new ox();
			Cr.setAnimationLoop(Yn),
				typeof self < "u" && Cr.setContext(self),
				(this.setAnimationLoop = function (O) {
					(At = O), Le.setAnimationLoop(O), O === null ? Cr.stop() : Cr.start();
				}),
				Le.addEventListener("sessionstart", xi),
				Le.addEventListener("sessionend", oc),
				(this.render = function (O, $) {
					if ($ !== void 0 && $.isCamera !== !0) {
						console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
						return;
					}
					if (T === !0) return;
					if (
						(O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(),
						$.parent === null && $.matrixWorldAutoUpdate === !0 && $.updateMatrixWorld(),
						Le.enabled === !0 && Le.isPresenting === !0 && (Le.cameraAutoUpdate === !0 && Le.updateCamera($), ($ = Le.getCamera())),
						O.isScene === !0 && O.onBeforeRender(b, O, $, M),
						(p = Pe.get(O, x.length)),
						p.init($),
						x.push(p),
						ge.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
						Ue.setFromProjectionMatrix(ge),
						(ie = this.localClippingEnabled),
						(Z = Je.init(this.clippingPlanes, ie)),
						(_ = Me.get(O, g.length)),
						_.init(),
						g.push(_),
						Le.enabled === !0 && Le.isPresenting === !0)
					) {
						const Ae = b.xr.getDepthSensingMesh();
						Ae !== null && Zo(Ae, $, -1 / 0, b.sortObjects);
					}
					Zo(O, $, 0, b.sortObjects), _.finish(), b.sortObjects === !0 && _.sort(X, K), (xe = Le.enabled === !1 || Le.isPresenting === !1 || Le.hasDepthSensing() === !1), xe && Fe.addToRenderList(_, O), this.info.render.frame++, Z === !0 && Je.beginShadows();
					const te = p.state.shadowsArray;
					we.render(te, O, $), Z === !0 && Je.endShadows(), this.info.autoReset === !0 && this.info.reset();
					const se = _.opaque,
						Q = _.transmissive;
					if ((p.setupLights(), $.isArrayCamera)) {
						const Ae = $.cameras;
						if (Q.length > 0)
							for (let ke = 0, je = Ae.length; ke < je; ke++) {
								const Ye = Ae[ke];
								Aa(se, Q, O, Ye);
							}
						xe && Fe.render(O);
						for (let ke = 0, je = Ae.length; ke < je; ke++) {
							const Ye = Ae[ke];
							lc(_, O, Ye, Ye.viewport);
						}
					} else Q.length > 0 && Aa(se, Q, O, $), xe && Fe.render(O), lc(_, O, $);
					M !== null && (Ie.updateMultisampleRenderTarget(M), Ie.updateRenderTargetMipmap(M)), O.isScene === !0 && O.onAfterRender(b, O, $), vt.resetDefaultState(), (w = -1), (y = null), x.pop(), x.length > 0 ? ((p = x[x.length - 1]), Z === !0 && Je.setGlobalState(b.clippingPlanes, p.state.camera)) : (p = null), g.pop(), g.length > 0 ? (_ = g[g.length - 1]) : (_ = null);
				});
			function Zo(O, $, te, se) {
				if (O.visible === !1) return;
				if (O.layers.test($.layers)) {
					if (O.isGroup) te = O.renderOrder;
					else if (O.isLOD) O.autoUpdate === !0 && O.update($);
					else if (O.isLight) p.pushLight(O), O.castShadow && p.pushShadow(O);
					else if (O.isSprite) {
						if (!O.frustumCulled || Ue.intersectsSprite(O)) {
							se && j.setFromMatrixPosition(O.matrixWorld).applyMatrix4(ge);
							const ke = me.update(O),
								je = O.material;
							je.visible && _.push(O, ke, je, te, j.z, null);
						}
					} else if ((O.isMesh || O.isLine || O.isPoints) && (!O.frustumCulled || Ue.intersectsObject(O))) {
						const ke = me.update(O),
							je = O.material;
						if ((se && (O.boundingSphere !== void 0 ? (O.boundingSphere === null && O.computeBoundingSphere(), j.copy(O.boundingSphere.center)) : (ke.boundingSphere === null && ke.computeBoundingSphere(), j.copy(ke.boundingSphere.center)), j.applyMatrix4(O.matrixWorld).applyMatrix4(ge)), Array.isArray(je))) {
							const Ye = ke.groups;
							for (let nt = 0, ut = Ye.length; nt < ut; nt++) {
								const it = Ye[nt],
									It = je[it.materialIndex];
								It && It.visible && _.push(O, ke, It, te, j.z, it);
							}
						} else je.visible && _.push(O, ke, je, te, j.z, null);
					}
				}
				const Ae = O.children;
				for (let ke = 0, je = Ae.length; ke < je; ke++) Zo(Ae[ke], $, te, se);
			}
			function lc(O, $, te, se) {
				const Q = O.opaque,
					Ae = O.transmissive,
					ke = O.transparent;
				p.setupLightsView(te), Z === !0 && Je.setGlobalState(b.clippingPlanes, te), se && re.viewport(S.copy(se)), Q.length > 0 && Bi(Q, $, te), Ae.length > 0 && Bi(Ae, $, te), ke.length > 0 && Bi(ke, $, te), re.buffers.depth.setTest(!0), re.buffers.depth.setMask(!0), re.buffers.color.setMask(!0), re.setPolygonOffset(!1);
			}
			function Aa(O, $, te, se) {
				if ((te.isScene === !0 ? te.overrideMaterial : null) !== null) return;
				p.state.transmissionRenderTarget[se.id] === void 0 && (p.state.transmissionRenderTarget[se.id] = new ya(1, 1, { generateMipmaps: !0, type: pe.has("EXT_color_buffer_half_float") || pe.has("EXT_color_buffer_float") ? Jl : Zr, minFilter: fa, samples: 4, stencilBuffer: s, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: zt.workingColorSpace }));
				const Ae = p.state.transmissionRenderTarget[se.id],
					ke = se.viewport || S;
				Ae.setSize(ke.z, ke.w);
				const je = b.getRenderTarget();
				b.setRenderTarget(Ae), b.getClearColor(k), (B = b.getClearAlpha()), B < 1 && b.setClearColor(16777215, 0.5), b.clear(), xe && Fe.render(te);
				const Ye = b.toneMapping;
				b.toneMapping = Ts;
				const nt = se.viewport;
				if ((se.viewport !== void 0 && (se.viewport = void 0), p.setupLightsView(se), Z === !0 && Je.setGlobalState(b.clippingPlanes, se), Bi(O, te, se), Ie.updateMultisampleRenderTarget(Ae), Ie.updateRenderTargetMipmap(Ae), pe.has("WEBGL_multisampled_render_to_texture") === !1)) {
					let ut = !1;
					for (let it = 0, It = $.length; it < It; it++) {
						const en = $[it],
							tn = en.object,
							Bn = en.geometry,
							Nt = en.material,
							Qe = en.group;
						if (Nt.side === An && tn.layers.test(se.layers)) {
							const gn = Nt.side;
							(Nt.side = li), (Nt.needsUpdate = !0), Us(tn, te, se, Bn, Nt, Qe), (Nt.side = gn), (Nt.needsUpdate = !0), (ut = !0);
						}
					}
					ut === !0 && (Ie.updateMultisampleRenderTarget(Ae), Ie.updateRenderTargetMipmap(Ae));
				}
				b.setRenderTarget(je), b.setClearColor(k, B), nt !== void 0 && (se.viewport = nt), (b.toneMapping = Ye);
			}
			function Bi(O, $, te) {
				const se = $.isScene === !0 ? $.overrideMaterial : null;
				for (let Q = 0, Ae = O.length; Q < Ae; Q++) {
					const ke = O[Q],
						je = ke.object,
						Ye = ke.geometry,
						nt = se === null ? ke.material : se,
						ut = ke.group;
					je.layers.test(te.layers) && Us(je, $, te, Ye, nt, ut);
				}
			}
			function Us(O, $, te, se, Q, Ae) {
				O.onBeforeRender(b, $, te, se, Q, Ae),
					O.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, O.matrixWorld),
					O.normalMatrix.getNormalMatrix(O.modelViewMatrix),
					Q.transparent === !0 && Q.side === An && Q.forceSinglePass === !1 ? ((Q.side = li), (Q.needsUpdate = !0), b.renderBufferDirect(te, $, se, Q, O, Ae), (Q.side = Kr), (Q.needsUpdate = !0), b.renderBufferDirect(te, $, se, Q, O, Ae), (Q.side = An)) : b.renderBufferDirect(te, $, se, Q, O, Ae),
					O.onAfterRender(b, $, te, se, Q, Ae);
			}
			function Ca(O, $, te) {
				$.isScene !== !0 && ($ = he);
				const se = Ce.get(O),
					Q = p.state.lights,
					Ae = p.state.shadowsArray,
					ke = Q.state.version,
					je = oe.getParameters(O, Q.state, Ae, $, te),
					Ye = oe.getProgramCacheKey(je);
				let nt = se.programs;
				(se.environment = O.isMeshStandardMaterial ? $.environment : null), (se.fog = $.fog), (se.envMap = (O.isMeshStandardMaterial ? R : U).get(O.envMap || se.environment)), (se.envMapRotation = se.environment !== null && O.envMap === null ? $.environmentRotation : O.envMapRotation), nt === void 0 && (O.addEventListener("dispose", ct), (nt = new Map()), (se.programs = nt));
				let ut = nt.get(Ye);
				if (ut !== void 0) {
					if (se.currentProgram === ut && se.lightsStateVersion === ke) return cc(O, je), ut;
				} else (je.uniforms = oe.getUniforms(O)), O.onBeforeCompile(je, b), (ut = oe.acquireProgram(je, Ye)), nt.set(Ye, ut), (se.uniforms = je.uniforms);
				const it = se.uniforms;
				return (
					((!O.isShaderMaterial && !O.isRawShaderMaterial) || O.clipping === !0) && (it.clippingPlanes = Je.uniform),
					cc(O, je),
					(se.needsLights = In(O)),
					(se.lightsStateVersion = ke),
					se.needsLights &&
						((it.ambientLightColor.value = Q.state.ambient),
						(it.lightProbe.value = Q.state.probe),
						(it.directionalLights.value = Q.state.directional),
						(it.directionalLightShadows.value = Q.state.directionalShadow),
						(it.spotLights.value = Q.state.spot),
						(it.spotLightShadows.value = Q.state.spotShadow),
						(it.rectAreaLights.value = Q.state.rectArea),
						(it.ltc_1.value = Q.state.rectAreaLTC1),
						(it.ltc_2.value = Q.state.rectAreaLTC2),
						(it.pointLights.value = Q.state.point),
						(it.pointLightShadows.value = Q.state.pointShadow),
						(it.hemisphereLights.value = Q.state.hemi),
						(it.directionalShadowMap.value = Q.state.directionalShadowMap),
						(it.directionalShadowMatrix.value = Q.state.directionalShadowMatrix),
						(it.spotShadowMap.value = Q.state.spotShadowMap),
						(it.spotLightMatrix.value = Q.state.spotLightMatrix),
						(it.spotLightMap.value = Q.state.spotLightMap),
						(it.pointShadowMap.value = Q.state.pointShadowMap),
						(it.pointShadowMatrix.value = Q.state.pointShadowMatrix)),
					(se.currentProgram = ut),
					(se.uniformsList = null),
					ut
				);
			}
			function La(O) {
				if (O.uniformsList === null) {
					const $ = O.currentProgram.getUniforms();
					O.uniformsList = Ou.seqWithValue($.seq, O.uniforms);
				}
				return O.uniformsList;
			}
			function cc(O, $) {
				const te = Ce.get(O);
				(te.outputColorSpace = $.outputColorSpace),
					(te.batching = $.batching),
					(te.batchingColor = $.batchingColor),
					(te.instancing = $.instancing),
					(te.instancingColor = $.instancingColor),
					(te.instancingMorph = $.instancingMorph),
					(te.skinning = $.skinning),
					(te.morphTargets = $.morphTargets),
					(te.morphNormals = $.morphNormals),
					(te.morphColors = $.morphColors),
					(te.morphTargetsCount = $.morphTargetsCount),
					(te.numClippingPlanes = $.numClippingPlanes),
					(te.numIntersection = $.numClipIntersection),
					(te.vertexAlphas = $.vertexAlphas),
					(te.vertexTangents = $.vertexTangents),
					(te.toneMapping = $.toneMapping);
			}
			function Eh(O, $, te, se, Q) {
				$.isScene !== !0 && ($ = he), Ie.resetTextureUnits();
				const Ae = $.fog,
					ke = se.isMeshStandardMaterial ? $.environment : null,
					je = M === null ? b.outputColorSpace : M.isXRRenderTarget === !0 ? M.texture.colorSpace : Fs,
					Ye = (se.isMeshStandardMaterial ? R : U).get(se.envMap || ke),
					nt = se.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4,
					ut = !!te.attributes.tangent && (!!se.normalMap || se.anisotropy > 0),
					it = !!te.morphAttributes.position,
					It = !!te.morphAttributes.normal,
					en = !!te.morphAttributes.color;
				let tn = Ts;
				se.toneMapped && (M === null || M.isXRRenderTarget === !0) && (tn = b.toneMapping);
				const Bn = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color,
					Nt = Bn !== void 0 ? Bn.length : 0,
					Qe = Ce.get(se),
					gn = p.state.lights;
				if (Z === !0 && (ie === !0 || O !== y)) {
					const Vn = O === y && se.id === w;
					Je.setState(se, O, Vn);
				}
				let Ut = !1;
				se.version === Qe.__version
					? ((Qe.needsLights && Qe.lightsStateVersion !== gn.state.version) ||
							Qe.outputColorSpace !== je ||
							(Q.isBatchedMesh && Qe.batching === !1) ||
							(!Q.isBatchedMesh && Qe.batching === !0) ||
							(Q.isBatchedMesh && Qe.batchingColor === !0 && Q.colorTexture === null) ||
							(Q.isBatchedMesh && Qe.batchingColor === !1 && Q.colorTexture !== null) ||
							(Q.isInstancedMesh && Qe.instancing === !1) ||
							(!Q.isInstancedMesh && Qe.instancing === !0) ||
							(Q.isSkinnedMesh && Qe.skinning === !1) ||
							(!Q.isSkinnedMesh && Qe.skinning === !0) ||
							(Q.isInstancedMesh && Qe.instancingColor === !0 && Q.instanceColor === null) ||
							(Q.isInstancedMesh && Qe.instancingColor === !1 && Q.instanceColor !== null) ||
							(Q.isInstancedMesh && Qe.instancingMorph === !0 && Q.morphTexture === null) ||
							(Q.isInstancedMesh && Qe.instancingMorph === !1 && Q.morphTexture !== null) ||
							Qe.envMap !== Ye ||
							(se.fog === !0 && Qe.fog !== Ae) ||
							(Qe.numClippingPlanes !== void 0 && (Qe.numClippingPlanes !== Je.numPlanes || Qe.numIntersection !== Je.numIntersection)) ||
							Qe.vertexAlphas !== nt ||
							Qe.vertexTangents !== ut ||
							Qe.morphTargets !== it ||
							Qe.morphNormals !== It ||
							Qe.morphColors !== en ||
							Qe.toneMapping !== tn ||
							Qe.morphTargetsCount !== Nt) &&
					  (Ut = !0)
					: ((Ut = !0), (Qe.__version = se.version));
				let si = Qe.currentProgram;
				Ut === !0 && (si = Ca(se, $, Q));
				let Lr = !1,
					zn = !1,
					ai = !1;
				const Ft = si.getUniforms(),
					Hn = Qe.uniforms;
				if ((re.useProgram(si.program) && ((Lr = !0), (zn = !0), (ai = !0)), se.id !== w && ((w = se.id), (zn = !0)), Lr || y !== O)) {
					Ft.setValue(F, "projectionMatrix", O.projectionMatrix), Ft.setValue(F, "viewMatrix", O.matrixWorldInverse);
					const Vn = Ft.map.cameraPosition;
					Vn !== void 0 && Vn.setValue(F, V.setFromMatrixPosition(O.matrixWorld)), Ee.logarithmicDepthBuffer && Ft.setValue(F, "logDepthBufFC", 2 / (Math.log(O.far + 1) / Math.LN2)), (se.isMeshPhongMaterial || se.isMeshToonMaterial || se.isMeshLambertMaterial || se.isMeshBasicMaterial || se.isMeshStandardMaterial || se.isShaderMaterial) && Ft.setValue(F, "isOrthographic", O.isOrthographicCamera === !0), y !== O && ((y = O), (zn = !0), (ai = !0));
				}
				if (Q.isSkinnedMesh) {
					Ft.setOptional(F, Q, "bindMatrix"), Ft.setOptional(F, Q, "bindMatrixInverse");
					const Vn = Q.skeleton;
					Vn && (Vn.boneTexture === null && Vn.computeBoneTexture(), Ft.setValue(F, "boneTexture", Vn.boneTexture, Ie));
				}
				Q.isBatchedMesh && (Ft.setOptional(F, Q, "batchingTexture"), Ft.setValue(F, "batchingTexture", Q._matricesTexture, Ie), Ft.setOptional(F, Q, "batchingIdTexture"), Ft.setValue(F, "batchingIdTexture", Q._indirectTexture, Ie), Ft.setOptional(F, Q, "batchingColorTexture"), Q._colorsTexture !== null && Ft.setValue(F, "batchingColorTexture", Q._colorsTexture, Ie));
				const Gn = te.morphAttributes;
				if (
					((Gn.position !== void 0 || Gn.normal !== void 0 || Gn.color !== void 0) && lt.update(Q, te, si),
					(zn || Qe.receiveShadow !== Q.receiveShadow) && ((Qe.receiveShadow = Q.receiveShadow), Ft.setValue(F, "receiveShadow", Q.receiveShadow)),
					se.isMeshGouraudMaterial && se.envMap !== null && ((Hn.envMap.value = Ye), (Hn.flipEnvMap.value = Ye.isCubeTexture && Ye.isRenderTargetTexture === !1 ? -1 : 1)),
					se.isMeshStandardMaterial && se.envMap === null && $.environment !== null && (Hn.envMapIntensity.value = $.environmentIntensity),
					zn && (Ft.setValue(F, "toneMappingExposure", b.toneMappingExposure), Qe.needsLights && ts(Hn, ai), Ae && se.fog === !0 && Xe.refreshFogUniforms(Hn, Ae), Xe.refreshMaterialUniforms(Hn, se, z, H, p.state.transmissionRenderTarget[O.id]), Ou.upload(F, La(Qe), Hn, Ie)),
					se.isShaderMaterial && se.uniformsNeedUpdate === !0 && (Ou.upload(F, La(Qe), Hn, Ie), (se.uniformsNeedUpdate = !1)),
					se.isSpriteMaterial && Ft.setValue(F, "center", Q.center),
					Ft.setValue(F, "modelViewMatrix", Q.modelViewMatrix),
					Ft.setValue(F, "normalMatrix", Q.normalMatrix),
					Ft.setValue(F, "modelMatrix", Q.matrixWorld),
					se.isShaderMaterial || se.isRawShaderMaterial)
				) {
					const Vn = se.uniformsGroups;
					for (let ks = 0, bi = Vn.length; ks < bi; ks++) {
						const cr = Vn[ks];
						Qt.update(cr, si), Qt.bind(cr, si);
					}
				}
				return si;
			}
			function ts(O, $) {
				(O.ambientLightColor.needsUpdate = $), (O.lightProbe.needsUpdate = $), (O.directionalLights.needsUpdate = $), (O.directionalLightShadows.needsUpdate = $), (O.pointLights.needsUpdate = $), (O.pointLightShadows.needsUpdate = $), (O.spotLights.needsUpdate = $), (O.spotLightShadows.needsUpdate = $), (O.rectAreaLights.needsUpdate = $), (O.hemisphereLights.needsUpdate = $);
			}
			function In(O) {
				return O.isMeshLambertMaterial || O.isMeshToonMaterial || O.isMeshPhongMaterial || O.isMeshStandardMaterial || O.isShadowMaterial || (O.isShaderMaterial && O.lights === !0);
			}
			(this.getActiveCubeFace = function () {
				return P;
			}),
				(this.getActiveMipmapLevel = function () {
					return A;
				}),
				(this.getRenderTarget = function () {
					return M;
				}),
				(this.setRenderTargetTextures = function (O, $, te) {
					(Ce.get(O.texture).__webglTexture = $), (Ce.get(O.depthTexture).__webglTexture = te);
					const se = Ce.get(O);
					(se.__hasExternalTextures = !0), (se.__autoAllocateDepthBuffer = te === void 0), se.__autoAllocateDepthBuffer || (pe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), (se.__useRenderToTexture = !1)));
				}),
				(this.setRenderTargetFramebuffer = function (O, $) {
					const te = Ce.get(O);
					(te.__webglFramebuffer = $), (te.__useDefaultFramebuffer = $ === void 0);
				}),
				(this.setRenderTarget = function (O, $ = 0, te = 0) {
					(M = O), (P = $), (A = te);
					let se = !0,
						Q = null,
						Ae = !1,
						ke = !1;
					if (O) {
						const Ye = Ce.get(O);
						Ye.__useDefaultFramebuffer !== void 0 ? (re.bindFramebuffer(F.FRAMEBUFFER, null), (se = !1)) : Ye.__webglFramebuffer === void 0 ? Ie.setupRenderTarget(O) : Ye.__hasExternalTextures && Ie.rebindTextures(O, Ce.get(O.texture).__webglTexture, Ce.get(O.depthTexture).__webglTexture);
						const nt = O.texture;
						(nt.isData3DTexture || nt.isDataArrayTexture || nt.isCompressedArrayTexture) && (ke = !0);
						const ut = Ce.get(O).__webglFramebuffer;
						O.isWebGLCubeRenderTarget ? (Array.isArray(ut[$]) ? (Q = ut[$][te]) : (Q = ut[$]), (Ae = !0)) : O.samples > 0 && Ie.useMultisampledRTT(O) === !1 ? (Q = Ce.get(O).__webglMultisampledFramebuffer) : Array.isArray(ut) ? (Q = ut[te]) : (Q = ut), S.copy(O.viewport), L.copy(O.scissor), (N = O.scissorTest);
					} else S.copy(G).multiplyScalar(z).floor(), L.copy(ue).multiplyScalar(z).floor(), (N = ae);
					if ((re.bindFramebuffer(F.FRAMEBUFFER, Q) && se && re.drawBuffers(O, Q), re.viewport(S), re.scissor(L), re.setScissorTest(N), Ae)) {
						const Ye = Ce.get(O.texture);
						F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + $, Ye.__webglTexture, te);
					} else if (ke) {
						const Ye = Ce.get(O.texture),
							nt = $ || 0;
						F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ye.__webglTexture, te || 0, nt);
					}
					w = -1;
				}),
				(this.readRenderTargetPixels = function (O, $, te, se, Q, Ae, ke) {
					if (!(O && O.isWebGLRenderTarget)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
						return;
					}
					let je = Ce.get(O).__webglFramebuffer;
					if ((O.isWebGLCubeRenderTarget && ke !== void 0 && (je = je[ke]), je)) {
						re.bindFramebuffer(F.FRAMEBUFFER, je);
						try {
							const Ye = O.texture,
								nt = Ye.format,
								ut = Ye.type;
							if (!Ee.textureFormatReadable(nt)) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
								return;
							}
							if (!Ee.textureTypeReadable(ut)) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
								return;
							}
							$ >= 0 && $ <= O.width - se && te >= 0 && te <= O.height - Q && F.readPixels($, te, se, Q, dt.convert(nt), dt.convert(ut), Ae);
						} finally {
							const Ye = M !== null ? Ce.get(M).__webglFramebuffer : null;
							re.bindFramebuffer(F.FRAMEBUFFER, Ye);
						}
					}
				}),
				(this.readRenderTargetPixelsAsync = async function (O, $, te, se, Q, Ae, ke) {
					if (!(O && O.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
					let je = Ce.get(O).__webglFramebuffer;
					if ((O.isWebGLCubeRenderTarget && ke !== void 0 && (je = je[ke]), je)) {
						re.bindFramebuffer(F.FRAMEBUFFER, je);
						try {
							const Ye = O.texture,
								nt = Ye.format,
								ut = Ye.type;
							if (!Ee.textureFormatReadable(nt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
							if (!Ee.textureTypeReadable(ut)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
							if ($ >= 0 && $ <= O.width - se && te >= 0 && te <= O.height - Q) {
								const it = F.createBuffer();
								F.bindBuffer(F.PIXEL_PACK_BUFFER, it), F.bufferData(F.PIXEL_PACK_BUFFER, Ae.byteLength, F.STREAM_READ), F.readPixels($, te, se, Q, dt.convert(nt), dt.convert(ut), 0), F.flush();
								const It = F.fenceSync(F.SYNC_GPU_COMMANDS_COMPLETE, 0);
								await XC(F, It, 4);
								try {
									F.bindBuffer(F.PIXEL_PACK_BUFFER, it), F.getBufferSubData(F.PIXEL_PACK_BUFFER, 0, Ae);
								} finally {
									F.deleteBuffer(it), F.deleteSync(It);
								}
								return Ae;
							}
						} finally {
							const Ye = M !== null ? Ce.get(M).__webglFramebuffer : null;
							re.bindFramebuffer(F.FRAMEBUFFER, Ye);
						}
					}
				}),
				(this.copyFramebufferToTexture = function (O, $ = null, te = 0) {
					O.isTexture !== !0 && (Eo("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ($ = arguments[0] || null), (O = arguments[1]));
					const se = Math.pow(2, -te),
						Q = Math.floor(O.image.width * se),
						Ae = Math.floor(O.image.height * se),
						ke = $ !== null ? $.x : 0,
						je = $ !== null ? $.y : 0;
					Ie.setTexture2D(O, 0), F.copyTexSubImage2D(F.TEXTURE_2D, te, 0, 0, ke, je, Q, Ae), re.unbindTexture();
				}),
				(this.copyTextureToTexture = function (O, $, te = null, se = null, Q = 0) {
					O.isTexture !== !0 && (Eo("WebGLRenderer: copyTextureToTexture function signature has changed."), (se = arguments[0] || null), (O = arguments[1]), ($ = arguments[2]), (Q = arguments[3] || 0), (te = null));
					let Ae, ke, je, Ye, nt, ut;
					te !== null ? ((Ae = te.max.x - te.min.x), (ke = te.max.y - te.min.y), (je = te.min.x), (Ye = te.min.y)) : ((Ae = O.image.width), (ke = O.image.height), (je = 0), (Ye = 0)), se !== null ? ((nt = se.x), (ut = se.y)) : ((nt = 0), (ut = 0));
					const it = dt.convert($.format),
						It = dt.convert($.type);
					Ie.setTexture2D($, 0), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, $.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, $.unpackAlignment);
					const en = F.getParameter(F.UNPACK_ROW_LENGTH),
						tn = F.getParameter(F.UNPACK_IMAGE_HEIGHT),
						Bn = F.getParameter(F.UNPACK_SKIP_PIXELS),
						Nt = F.getParameter(F.UNPACK_SKIP_ROWS),
						Qe = F.getParameter(F.UNPACK_SKIP_IMAGES),
						gn = O.isCompressedTexture ? O.mipmaps[Q] : O.image;
					F.pixelStorei(F.UNPACK_ROW_LENGTH, gn.width),
						F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, gn.height),
						F.pixelStorei(F.UNPACK_SKIP_PIXELS, je),
						F.pixelStorei(F.UNPACK_SKIP_ROWS, Ye),
						O.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, Q, nt, ut, Ae, ke, it, It, gn.data) : O.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, Q, nt, ut, gn.width, gn.height, it, gn.data) : F.texSubImage2D(F.TEXTURE_2D, Q, nt, ut, Ae, ke, it, It, gn),
						F.pixelStorei(F.UNPACK_ROW_LENGTH, en),
						F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, tn),
						F.pixelStorei(F.UNPACK_SKIP_PIXELS, Bn),
						F.pixelStorei(F.UNPACK_SKIP_ROWS, Nt),
						F.pixelStorei(F.UNPACK_SKIP_IMAGES, Qe),
						Q === 0 && $.generateMipmaps && F.generateMipmap(F.TEXTURE_2D),
						re.unbindTexture();
				}),
				(this.copyTextureToTexture3D = function (O, $, te = null, se = null, Q = 0) {
					O.isTexture !== !0 && (Eo("WebGLRenderer: copyTextureToTexture3D function signature has changed."), (te = arguments[0] || null), (se = arguments[1] || null), (O = arguments[2]), ($ = arguments[3]), (Q = arguments[4] || 0));
					let Ae, ke, je, Ye, nt, ut, it, It, en;
					const tn = O.isCompressedTexture ? O.mipmaps[Q] : O.image;
					te !== null ? ((Ae = te.max.x - te.min.x), (ke = te.max.y - te.min.y), (je = te.max.z - te.min.z), (Ye = te.min.x), (nt = te.min.y), (ut = te.min.z)) : ((Ae = tn.width), (ke = tn.height), (je = tn.depth), (Ye = 0), (nt = 0), (ut = 0)), se !== null ? ((it = se.x), (It = se.y), (en = se.z)) : ((it = 0), (It = 0), (en = 0));
					const Bn = dt.convert($.format),
						Nt = dt.convert($.type);
					let Qe;
					if ($.isData3DTexture) Ie.setTexture3D($, 0), (Qe = F.TEXTURE_3D);
					else if ($.isDataArrayTexture || $.isCompressedArrayTexture) Ie.setTexture2DArray($, 0), (Qe = F.TEXTURE_2D_ARRAY);
					else {
						console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
						return;
					}
					F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, $.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, $.unpackAlignment);
					const gn = F.getParameter(F.UNPACK_ROW_LENGTH),
						Ut = F.getParameter(F.UNPACK_IMAGE_HEIGHT),
						si = F.getParameter(F.UNPACK_SKIP_PIXELS),
						Lr = F.getParameter(F.UNPACK_SKIP_ROWS),
						zn = F.getParameter(F.UNPACK_SKIP_IMAGES);
					F.pixelStorei(F.UNPACK_ROW_LENGTH, tn.width),
						F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, tn.height),
						F.pixelStorei(F.UNPACK_SKIP_PIXELS, Ye),
						F.pixelStorei(F.UNPACK_SKIP_ROWS, nt),
						F.pixelStorei(F.UNPACK_SKIP_IMAGES, ut),
						O.isDataTexture || O.isData3DTexture ? F.texSubImage3D(Qe, Q, it, It, en, Ae, ke, je, Bn, Nt, tn.data) : $.isCompressedArrayTexture ? F.compressedTexSubImage3D(Qe, Q, it, It, en, Ae, ke, je, Bn, tn.data) : F.texSubImage3D(Qe, Q, it, It, en, Ae, ke, je, Bn, Nt, tn),
						F.pixelStorei(F.UNPACK_ROW_LENGTH, gn),
						F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, Ut),
						F.pixelStorei(F.UNPACK_SKIP_PIXELS, si),
						F.pixelStorei(F.UNPACK_SKIP_ROWS, Lr),
						F.pixelStorei(F.UNPACK_SKIP_IMAGES, zn),
						Q === 0 && $.generateMipmaps && F.generateMipmap(Qe),
						re.unbindTexture();
				}),
				(this.initRenderTarget = function (O) {
					Ce.get(O).__webglFramebuffer === void 0 && Ie.setupRenderTarget(O);
				}),
				(this.initTexture = function (O) {
					O.isCubeTexture ? Ie.setTextureCube(O, 0) : O.isData3DTexture ? Ie.setTexture3D(O, 0) : O.isDataArrayTexture || O.isCompressedArrayTexture ? Ie.setTexture2DArray(O, 0) : Ie.setTexture2D(O, 0), re.unbindTexture();
				}),
				(this.resetState = function () {
					(P = 0), (A = 0), (M = null), re.reset(), vt.reset();
				}),
				typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
		}
		get coordinateSystem() {
			return Gr;
		}
		get outputColorSpace() {
			return this._outputColorSpace;
		}
		set outputColorSpace(e) {
			this._outputColorSpace = e;
			const t = this.getContext();
			(t.drawingBufferColorSpace = e === Wp ? "display-p3" : "srgb"), (t.unpackColorSpace = zt.workingColorSpace === vh ? "display-p3" : "srgb");
		}
	}
	class tO extends on {
		constructor() {
			super(), (this.isScene = !0), (this.type = "Scene"), (this.background = null), (this.environment = null), (this.fog = null), (this.backgroundBlurriness = 0), (this.backgroundIntensity = 1), (this.backgroundRotation = new Un()), (this.environmentIntensity = 1), (this.environmentRotation = new Un()), (this.overrideMaterial = null), typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
		}
		copy(e, t) {
			return (
				super.copy(e, t),
				e.background !== null && (this.background = e.background.clone()),
				e.environment !== null && (this.environment = e.environment.clone()),
				e.fog !== null && (this.fog = e.fog.clone()),
				(this.backgroundBlurriness = e.backgroundBlurriness),
				(this.backgroundIntensity = e.backgroundIntensity),
				this.backgroundRotation.copy(e.backgroundRotation),
				(this.environmentIntensity = e.environmentIntensity),
				this.environmentRotation.copy(e.environmentRotation),
				e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
				(this.matrixAutoUpdate = e.matrixAutoUpdate),
				this
			);
		}
		toJSON(e) {
			const t = super.toJSON(e);
			return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), (t.object.backgroundRotation = this.backgroundRotation.toArray()), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), (t.object.environmentRotation = this.environmentRotation.toArray()), t;
		}
	}
	class nO {
		constructor(e, t) {
			(this.isInterleavedBuffer = !0), (this.array = e), (this.stride = t), (this.count = e !== void 0 ? e.length / t : 0), (this.usage = Zf), (this._updateRange = { offset: 0, count: -1 }), (this.updateRanges = []), (this.version = 0), (this.uuid = yr());
		}
		onUploadCallback() {}
		set needsUpdate(e) {
			e === !0 && this.version++;
		}
		get updateRange() {
			return Eo("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
		}
		setUsage(e) {
			return (this.usage = e), this;
		}
		addUpdateRange(e, t) {
			this.updateRanges.push({ start: e, count: t });
		}
		clearUpdateRanges() {
			this.updateRanges.length = 0;
		}
		copy(e) {
			return (this.array = new e.array.constructor(e.array)), (this.count = e.count), (this.stride = e.stride), (this.usage = e.usage), this;
		}
		copyAt(e, t, i) {
			(e *= this.stride), (i *= t.stride);
			for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
			return this;
		}
		set(e, t = 0) {
			return this.array.set(e, t), this;
		}
		clone(e) {
			e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
			const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
				i = new this.constructor(t, this.stride);
			return i.setUsage(this.usage), i;
		}
		onUpload(e) {
			return (this.onUploadCallback = e), this;
		}
		toJSON(e) {
			return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
		}
	}
	const Jn = new D();
	class Ku {
		constructor(e, t, i, r = !1) {
			(this.isInterleavedBufferAttribute = !0), (this.name = ""), (this.data = e), (this.itemSize = t), (this.offset = i), (this.normalized = r);
		}
		get count() {
			return this.data.count;
		}
		get array() {
			return this.data.array;
		}
		set needsUpdate(e) {
			this.data.needsUpdate = e;
		}
		applyMatrix4(e) {
			for (let t = 0, i = this.data.count; t < i; t++) Jn.fromBufferAttribute(this, t), Jn.applyMatrix4(e), this.setXYZ(t, Jn.x, Jn.y, Jn.z);
			return this;
		}
		applyNormalMatrix(e) {
			for (let t = 0, i = this.count; t < i; t++) Jn.fromBufferAttribute(this, t), Jn.applyNormalMatrix(e), this.setXYZ(t, Jn.x, Jn.y, Jn.z);
			return this;
		}
		transformDirection(e) {
			for (let t = 0, i = this.count; t < i; t++) Jn.fromBufferAttribute(this, t), Jn.transformDirection(e), this.setXYZ(t, Jn.x, Jn.y, Jn.z);
			return this;
		}
		getComponent(e, t) {
			let i = this.array[e * this.data.stride + this.offset + t];
			return this.normalized && (i = Ji(i, this.array)), i;
		}
		setComponent(e, t, i) {
			return this.normalized && (i = Vt(i, this.array)), (this.data.array[e * this.data.stride + this.offset + t] = i), this;
		}
		setX(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.data.array[e * this.data.stride + this.offset] = t), this;
		}
		setY(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
		}
		setZ(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
		}
		setW(e, t) {
			return this.normalized && (t = Vt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
		}
		getX(e) {
			let t = this.data.array[e * this.data.stride + this.offset];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		getY(e) {
			let t = this.data.array[e * this.data.stride + this.offset + 1];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		getZ(e) {
			let t = this.data.array[e * this.data.stride + this.offset + 2];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		getW(e) {
			let t = this.data.array[e * this.data.stride + this.offset + 3];
			return this.normalized && (t = Ji(t, this.array)), t;
		}
		setXY(e, t, i) {
			return (e = e * this.data.stride + this.offset), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array))), (this.data.array[e + 0] = t), (this.data.array[e + 1] = i), this;
		}
		setXYZ(e, t, i, r) {
			return (e = e * this.data.stride + this.offset), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array)), (r = Vt(r, this.array))), (this.data.array[e + 0] = t), (this.data.array[e + 1] = i), (this.data.array[e + 2] = r), this;
		}
		setXYZW(e, t, i, r, s) {
			return (e = e * this.data.stride + this.offset), this.normalized && ((t = Vt(t, this.array)), (i = Vt(i, this.array)), (r = Vt(r, this.array)), (s = Vt(s, this.array))), (this.data.array[e + 0] = t), (this.data.array[e + 1] = i), (this.data.array[e + 2] = r), (this.data.array[e + 3] = s), this;
		}
		clone(e) {
			if (e === void 0) {
				console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
				const t = [];
				for (let i = 0; i < this.count; i++) {
					const r = i * this.data.stride + this.offset;
					for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
				}
				return new mn(new this.array.constructor(t), this.itemSize, this.normalized);
			} else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Ku(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
		}
		toJSON(e) {
			if (e === void 0) {
				console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
				const t = [];
				for (let i = 0; i < this.count; i++) {
					const r = i * this.data.stride + this.offset;
					for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
				}
				return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
			} else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
		}
	}
	class fx extends Er {
		constructor(e) {
			super(), (this.isSpriteMaterial = !0), (this.type = "SpriteMaterial"), (this.color = new rt(16777215)), (this.map = null), (this.alphaMap = null), (this.rotation = 0), (this.sizeAttenuation = !0), (this.transparent = !0), (this.fog = !0), this.setValues(e);
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.rotation = e.rotation), (this.sizeAttenuation = e.sizeAttenuation), (this.fog = e.fog), this;
		}
	}
	let no;
	const hl = new D(),
		io = new D(),
		ro = new D(),
		so = new Se(),
		dl = new Se(),
		px = new pt(),
		tu = new D(),
		fl = new D(),
		nu = new D(),
		u0 = new Se(),
		kd = new Se(),
		h0 = new Se();
	class ao extends on {
		constructor(e = new fx()) {
			if ((super(), (this.isSprite = !0), (this.type = "Sprite"), no === void 0)) {
				no = new bt();
				const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
					i = new nO(t, 5);
				no.setIndex([0, 1, 2, 0, 2, 3]), no.setAttribute("position", new Ku(i, 3, 0, !1)), no.setAttribute("uv", new Ku(i, 2, 3, !1));
			}
			(this.geometry = no), (this.material = e), (this.center = new Se(0.5, 0.5));
		}
		raycast(e, t) {
			e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), io.setFromMatrixScale(this.matrixWorld), px.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ro.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && io.multiplyScalar(-ro.z);
			const i = this.material.rotation;
			let r, s;
			i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
			const a = this.center;
			iu(tu.set(-0.5, -0.5, 0), ro, a, io, r, s), iu(fl.set(0.5, -0.5, 0), ro, a, io, r, s), iu(nu.set(0.5, 0.5, 0), ro, a, io, r, s), u0.set(0, 0), kd.set(1, 0), h0.set(1, 1);
			let o = e.ray.intersectTriangle(tu, fl, nu, !1, hl);
			if (o === null && (iu(fl.set(-0.5, 0.5, 0), ro, a, io, r, s), kd.set(0, 1), (o = e.ray.intersectTriangle(tu, nu, fl, !1, hl)), o === null)) return;
			const l = e.ray.origin.distanceTo(hl);
			l < e.near || l > e.far || t.push({ distance: l, point: hl.clone(), uv: Qi.getInterpolation(hl, tu, fl, nu, u0, kd, h0, new Se()), face: null, object: this });
		}
		copy(e, t) {
			return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), (this.material = e.material), this;
		}
	}
	function iu(n, e, t, i, r, s) {
		so.subVectors(n, t).addScalar(0.5).multiply(i), r !== void 0 ? ((dl.x = s * so.x - r * so.y), (dl.y = r * so.x + s * so.y)) : dl.copy(so), n.copy(e), (n.x += dl.x), (n.y += dl.y), n.applyMatrix4(px);
	}
	class Fi extends Er {
		constructor(e) {
			super(), (this.isLineBasicMaterial = !0), (this.type = "LineBasicMaterial"), (this.color = new rt(16777215)), (this.map = null), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), (this.fog = !0), this.setValues(e);
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), (this.map = e.map), (this.linewidth = e.linewidth), (this.linecap = e.linecap), (this.linejoin = e.linejoin), (this.fog = e.fog), this;
		}
	}
	const Zu = new D(),
		Ju = new D(),
		d0 = new pt(),
		pl = new _h(),
		ru = new $o(),
		Bd = new D(),
		f0 = new D();
	let Sn = class extends on {
		constructor(e = new bt(), t = new Fi()) {
			super(), (this.isLine = !0), (this.type = "Line"), (this.geometry = e), (this.material = t), this.updateMorphTargets();
		}
		copy(e, t) {
			return super.copy(e, t), (this.material = Array.isArray(e.material) ? e.material.slice() : e.material), (this.geometry = e.geometry), this;
		}
		computeLineDistances() {
			const e = this.geometry;
			if (e.index === null) {
				const t = e.attributes.position,
					i = [0];
				for (let r = 1, s = t.count; r < s; r++) Zu.fromBufferAttribute(t, r - 1), Ju.fromBufferAttribute(t, r), (i[r] = i[r - 1]), (i[r] += Zu.distanceTo(Ju));
				e.setAttribute("lineDistance", new Tt(i, 1));
			} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
			return this;
		}
		raycast(e, t) {
			const i = this.geometry,
				r = this.matrixWorld,
				s = e.params.Line.threshold,
				a = i.drawRange;
			if ((i.boundingSphere === null && i.computeBoundingSphere(), ru.copy(i.boundingSphere), ru.applyMatrix4(r), (ru.radius += s), e.ray.intersectsSphere(ru) === !1)) return;
			d0.copy(r).invert(), pl.copy(e.ray).applyMatrix4(d0);
			const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
				l = o * o,
				c = this.isLineSegments ? 2 : 1,
				u = i.index,
				d = i.attributes.position;
			if (u !== null) {
				const f = Math.max(0, a.start),
					v = Math.min(u.count, a.start + a.count);
				for (let _ = f, p = v - 1; _ < p; _ += c) {
					const g = u.getX(_),
						x = u.getX(_ + 1),
						b = su(this, e, pl, l, g, x);
					b && t.push(b);
				}
				if (this.isLineLoop) {
					const _ = u.getX(v - 1),
						p = u.getX(f),
						g = su(this, e, pl, l, _, p);
					g && t.push(g);
				}
			} else {
				const f = Math.max(0, a.start),
					v = Math.min(d.count, a.start + a.count);
				for (let _ = f, p = v - 1; _ < p; _ += c) {
					const g = su(this, e, pl, l, _, _ + 1);
					g && t.push(g);
				}
				if (this.isLineLoop) {
					const _ = su(this, e, pl, l, v - 1, f);
					_ && t.push(_);
				}
			}
		}
		updateMorphTargets() {
			const t = this.geometry.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const r = t[i[0]];
				if (r !== void 0) {
					(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
					for (let s = 0, a = r.length; s < a; s++) {
						const o = r[s].name || String(s);
						this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = s);
					}
				}
			}
		}
	};
	function su(n, e, t, i, r, s) {
		const a = n.geometry.attributes.position;
		if ((Zu.fromBufferAttribute(a, r), Ju.fromBufferAttribute(a, s), t.distanceSqToSegment(Zu, Ju, Bd, f0) > i)) return;
		Bd.applyMatrix4(n.matrixWorld);
		const l = e.ray.origin.distanceTo(Bd);
		if (!(l < e.near || l > e.far)) return { distance: l, point: f0.clone().applyMatrix4(n.matrixWorld), index: r, face: null, faceIndex: null, object: n };
	}
	const p0 = new D(),
		m0 = new D();
	class Fl extends Sn {
		constructor(e, t) {
			super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
		}
		computeLineDistances() {
			const e = this.geometry;
			if (e.index === null) {
				const t = e.attributes.position,
					i = [];
				for (let r = 0, s = t.count; r < s; r += 2) p0.fromBufferAttribute(t, r), m0.fromBufferAttribute(t, r + 1), (i[r] = r === 0 ? 0 : i[r - 1]), (i[r + 1] = i[r] + p0.distanceTo(m0));
				e.setAttribute("lineDistance", new Tt(i, 1));
			} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
			return this;
		}
	}
	class vo extends Er {
		constructor(e) {
			super(), (this.isPointsMaterial = !0), (this.type = "PointsMaterial"), (this.color = new rt(16777215)), (this.map = null), (this.alphaMap = null), (this.size = 1), (this.sizeAttenuation = !0), (this.fog = !0), this.setValues(e);
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.size = e.size), (this.sizeAttenuation = e.sizeAttenuation), (this.fog = e.fog), this;
		}
	}
	const g0 = new pt(),
		Qf = new _h(),
		au = new $o(),
		ou = new D();
	class bs extends on {
		constructor(e = new bt(), t = new vo()) {
			super(), (this.isPoints = !0), (this.type = "Points"), (this.geometry = e), (this.material = t), this.updateMorphTargets();
		}
		copy(e, t) {
			return super.copy(e, t), (this.material = Array.isArray(e.material) ? e.material.slice() : e.material), (this.geometry = e.geometry), this;
		}
		raycast(e, t) {
			const i = this.geometry,
				r = this.matrixWorld,
				s = e.params.Points.threshold,
				a = i.drawRange;
			if ((i.boundingSphere === null && i.computeBoundingSphere(), au.copy(i.boundingSphere), au.applyMatrix4(r), (au.radius += s), e.ray.intersectsSphere(au) === !1)) return;
			g0.copy(r).invert(), Qf.copy(e.ray).applyMatrix4(g0);
			const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
				l = o * o,
				c = i.index,
				h = i.attributes.position;
			if (c !== null) {
				const d = Math.max(0, a.start),
					f = Math.min(c.count, a.start + a.count);
				for (let v = d, _ = f; v < _; v++) {
					const p = c.getX(v);
					ou.fromBufferAttribute(h, p), v0(ou, p, l, r, e, t, this);
				}
			} else {
				const d = Math.max(0, a.start),
					f = Math.min(h.count, a.start + a.count);
				for (let v = d, _ = f; v < _; v++) ou.fromBufferAttribute(h, v), v0(ou, v, l, r, e, t, this);
			}
		}
		updateMorphTargets() {
			const t = this.geometry.morphAttributes,
				i = Object.keys(t);
			if (i.length > 0) {
				const r = t[i[0]];
				if (r !== void 0) {
					(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
					for (let s = 0, a = r.length; s < a; s++) {
						const o = r[s].name || String(s);
						this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = s);
					}
				}
			}
		}
	}
	function v0(n, e, t, i, r, s, a) {
		const o = Qf.distanceSqToPoint(n);
		if (o < t) {
			const l = new D();
			Qf.closestPointToPoint(n, l), l.applyMatrix4(i);
			const c = r.ray.origin.distanceTo(l);
			if (c < r.near || c > r.far) return;
			s.push({ distance: c, distanceToRay: Math.sqrt(o), point: l, index: e, face: null, object: a });
		}
	}
	class iO extends jn {
		constructor(e, t, i, r, s, a, o, l, c) {
			super(e, t, i, r, s, a, o, l, c), (this.isCanvasTexture = !0), (this.needsUpdate = !0);
		}
	}
	class Mr {
		constructor() {
			(this.type = "Curve"), (this.arcLengthDivisions = 200);
		}
		getPoint() {
			return console.warn("THREE.Curve: .getPoint() not implemented."), null;
		}
		getPointAt(e, t) {
			const i = this.getUtoTmapping(e);
			return this.getPoint(i, t);
		}
		getPoints(e = 5) {
			const t = [];
			for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
			return t;
		}
		getSpacedPoints(e = 5) {
			const t = [];
			for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
			return t;
		}
		getLength() {
			const e = this.getLengths();
			return e[e.length - 1];
		}
		getLengths(e = this.arcLengthDivisions) {
			if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
			this.needsUpdate = !1;
			const t = [];
			let i,
				r = this.getPoint(0),
				s = 0;
			t.push(0);
			for (let a = 1; a <= e; a++) (i = this.getPoint(a / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
			return (this.cacheArcLengths = t), t;
		}
		updateArcLengths() {
			(this.needsUpdate = !0), this.getLengths();
		}
		getUtoTmapping(e, t) {
			const i = this.getLengths();
			let r = 0;
			const s = i.length;
			let a;
			t ? (a = t) : (a = e * i[s - 1]);
			let o = 0,
				l = s - 1,
				c;
			for (; o <= l; )
				if (((r = Math.floor(o + (l - o) / 2)), (c = i[r] - a), c < 0)) o = r + 1;
				else if (c > 0) l = r - 1;
				else {
					l = r;
					break;
				}
			if (((r = l), i[r] === a)) return r / (s - 1);
			const u = i[r],
				d = i[r + 1] - u,
				f = (a - u) / d;
			return (r + f) / (s - 1);
		}
		getTangent(e, t) {
			let r = e - 1e-4,
				s = e + 1e-4;
			r < 0 && (r = 0), s > 1 && (s = 1);
			const a = this.getPoint(r),
				o = this.getPoint(s),
				l = t || (a.isVector2 ? new Se() : new D());
			return l.copy(o).sub(a).normalize(), l;
		}
		getTangentAt(e, t) {
			const i = this.getUtoTmapping(e);
			return this.getTangent(i, t);
		}
		computeFrenetFrames(e, t) {
			const i = new D(),
				r = [],
				s = [],
				a = [],
				o = new D(),
				l = new pt();
			for (let f = 0; f <= e; f++) {
				const v = f / e;
				r[f] = this.getTangentAt(v, new D());
			}
			(s[0] = new D()), (a[0] = new D());
			let c = Number.MAX_VALUE;
			const u = Math.abs(r[0].x),
				h = Math.abs(r[0].y),
				d = Math.abs(r[0].z);
			u <= c && ((c = u), i.set(1, 0, 0)), h <= c && ((c = h), i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), o.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
			for (let f = 1; f <= e; f++) {
				if (((s[f] = s[f - 1].clone()), (a[f] = a[f - 1].clone()), o.crossVectors(r[f - 1], r[f]), o.length() > Number.EPSILON)) {
					o.normalize();
					const v = Math.acos(Nn(r[f - 1].dot(r[f]), -1, 1));
					s[f].applyMatrix4(l.makeRotationAxis(o, v));
				}
				a[f].crossVectors(r[f], s[f]);
			}
			if (t === !0) {
				let f = Math.acos(Nn(s[0].dot(s[e]), -1, 1));
				(f /= e), r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (f = -f);
				for (let v = 1; v <= e; v++) s[v].applyMatrix4(l.makeRotationAxis(r[v], f * v)), a[v].crossVectors(r[v], s[v]);
			}
			return { tangents: r, normals: s, binormals: a };
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(e) {
			return (this.arcLengthDivisions = e.arcLengthDivisions), this;
		}
		toJSON() {
			const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
			return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
		}
		fromJSON(e) {
			return (this.arcLengthDivisions = e.arcLengthDivisions), this;
		}
	}
	class Ms extends Mr {
		constructor(e = 0, t = 0, i = 1, r = 1, s = 0, a = Math.PI * 2, o = !1, l = 0) {
			super(), (this.isEllipseCurve = !0), (this.type = "EllipseCurve"), (this.aX = e), (this.aY = t), (this.xRadius = i), (this.yRadius = r), (this.aStartAngle = s), (this.aEndAngle = a), (this.aClockwise = o), (this.aRotation = l);
		}
		getPoint(e, t = new Se()) {
			const i = t,
				r = Math.PI * 2;
			let s = this.aEndAngle - this.aStartAngle;
			const a = Math.abs(s) < Number.EPSILON;
			for (; s < 0; ) s += r;
			for (; s > r; ) s -= r;
			s < Number.EPSILON && (a ? (s = 0) : (s = r)), this.aClockwise === !0 && !a && (s === r ? (s = -r) : (s = s - r));
			const o = this.aStartAngle + e * s;
			let l = this.aX + this.xRadius * Math.cos(o),
				c = this.aY + this.yRadius * Math.sin(o);
			if (this.aRotation !== 0) {
				const u = Math.cos(this.aRotation),
					h = Math.sin(this.aRotation),
					d = l - this.aX,
					f = c - this.aY;
				(l = d * u - f * h + this.aX), (c = d * h + f * u + this.aY);
			}
			return i.set(l, c);
		}
		copy(e) {
			return super.copy(e), (this.aX = e.aX), (this.aY = e.aY), (this.xRadius = e.xRadius), (this.yRadius = e.yRadius), (this.aStartAngle = e.aStartAngle), (this.aEndAngle = e.aEndAngle), (this.aClockwise = e.aClockwise), (this.aRotation = e.aRotation), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.aX = this.aX), (e.aY = this.aY), (e.xRadius = this.xRadius), (e.yRadius = this.yRadius), (e.aStartAngle = this.aStartAngle), (e.aEndAngle = this.aEndAngle), (e.aClockwise = this.aClockwise), (e.aRotation = this.aRotation), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), (this.aX = e.aX), (this.aY = e.aY), (this.xRadius = e.xRadius), (this.yRadius = e.yRadius), (this.aStartAngle = e.aStartAngle), (this.aEndAngle = e.aEndAngle), (this.aClockwise = e.aClockwise), (this.aRotation = e.aRotation), this;
		}
	}
	class rO extends Ms {
		constructor(e, t, i, r, s, a) {
			super(e, t, i, i, r, s, a), (this.isArcCurve = !0), (this.type = "ArcCurve");
		}
	}
	function Yp() {
		let n = 0,
			e = 0,
			t = 0,
			i = 0;
		function r(s, a, o, l) {
			(n = s), (e = o), (t = -3 * s + 3 * a - 2 * o - l), (i = 2 * s - 2 * a + o + l);
		}
		return {
			initCatmullRom: function (s, a, o, l, c) {
				r(a, o, c * (o - s), c * (l - a));
			},
			initNonuniformCatmullRom: function (s, a, o, l, c, u, h) {
				let d = (a - s) / c - (o - s) / (c + u) + (o - a) / u,
					f = (o - a) / u - (l - a) / (u + h) + (l - o) / h;
				(d *= u), (f *= u), r(a, o, d, f);
			},
			calc: function (s) {
				const a = s * s,
					o = a * s;
				return n + e * s + t * a + i * o;
			}
		};
	}
	const lu = new D(),
		zd = new Yp(),
		Hd = new Yp(),
		Gd = new Yp();
	class mx extends Mr {
		constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
			super(), (this.isCatmullRomCurve3 = !0), (this.type = "CatmullRomCurve3"), (this.points = e), (this.closed = t), (this.curveType = i), (this.tension = r);
		}
		getPoint(e, t = new D()) {
			const i = t,
				r = this.points,
				s = r.length,
				a = (s - (this.closed ? 0 : 1)) * e;
			let o = Math.floor(a),
				l = a - o;
			this.closed ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s) : l === 0 && o === s - 1 && ((o = s - 2), (l = 1));
			let c, u;
			this.closed || o > 0 ? (c = r[(o - 1) % s]) : (lu.subVectors(r[0], r[1]).add(r[0]), (c = lu));
			const h = r[o % s],
				d = r[(o + 1) % s];
			if ((this.closed || o + 2 < s ? (u = r[(o + 2) % s]) : (lu.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (u = lu)), this.curveType === "centripetal" || this.curveType === "chordal")) {
				const f = this.curveType === "chordal" ? 0.5 : 0.25;
				let v = Math.pow(c.distanceToSquared(h), f),
					_ = Math.pow(h.distanceToSquared(d), f),
					p = Math.pow(d.distanceToSquared(u), f);
				_ < 1e-4 && (_ = 1), v < 1e-4 && (v = _), p < 1e-4 && (p = _), zd.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, v, _, p), Hd.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, v, _, p), Gd.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, v, _, p);
			} else this.curveType === "catmullrom" && (zd.initCatmullRom(c.x, h.x, d.x, u.x, this.tension), Hd.initCatmullRom(c.y, h.y, d.y, u.y, this.tension), Gd.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
			return i.set(zd.calc(l), Hd.calc(l), Gd.calc(l)), i;
		}
		copy(e) {
			super.copy(e), (this.points = []);
			for (let t = 0, i = e.points.length; t < i; t++) {
				const r = e.points[t];
				this.points.push(r.clone());
			}
			return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
		}
		toJSON() {
			const e = super.toJSON();
			e.points = [];
			for (let t = 0, i = this.points.length; t < i; t++) {
				const r = this.points[t];
				e.points.push(r.toArray());
			}
			return (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e;
		}
		fromJSON(e) {
			super.fromJSON(e), (this.points = []);
			for (let t = 0, i = e.points.length; t < i; t++) {
				const r = e.points[t];
				this.points.push(new D().fromArray(r));
			}
			return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
		}
	}
	function _0(n, e, t, i, r) {
		const s = (i - e) * 0.5,
			a = (r - t) * 0.5,
			o = n * n,
			l = n * o;
		return (2 * t - 2 * i + s + a) * l + (-3 * t + 3 * i - 2 * s - a) * o + s * n + t;
	}
	function sO(n, e) {
		const t = 1 - n;
		return t * t * e;
	}
	function aO(n, e) {
		return 2 * (1 - n) * n * e;
	}
	function oO(n, e) {
		return n * n * e;
	}
	function Cl(n, e, t, i) {
		return sO(n, e) + aO(n, t) + oO(n, i);
	}
	function lO(n, e) {
		const t = 1 - n;
		return t * t * t * e;
	}
	function cO(n, e) {
		const t = 1 - n;
		return 3 * t * t * n * e;
	}
	function uO(n, e) {
		return 3 * (1 - n) * n * n * e;
	}
	function hO(n, e) {
		return n * n * n * e;
	}
	function Ll(n, e, t, i, r) {
		return lO(n, e) + cO(n, t) + uO(n, i) + hO(n, r);
	}
	class gx extends Mr {
		constructor(e = new Se(), t = new Se(), i = new Se(), r = new Se()) {
			super(), (this.isCubicBezierCurve = !0), (this.type = "CubicBezierCurve"), (this.v0 = e), (this.v1 = t), (this.v2 = i), (this.v3 = r);
		}
		getPoint(e, t = new Se()) {
			const i = t,
				r = this.v0,
				s = this.v1,
				a = this.v2,
				o = this.v3;
			return i.set(Ll(e, r.x, s.x, a.x, o.x), Ll(e, r.y, s.y, a.y, o.y)), i;
		}
		copy(e) {
			return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
		}
	}
	class dO extends Mr {
		constructor(e = new D(), t = new D(), i = new D(), r = new D()) {
			super(), (this.isCubicBezierCurve3 = !0), (this.type = "CubicBezierCurve3"), (this.v0 = e), (this.v1 = t), (this.v2 = i), (this.v3 = r);
		}
		getPoint(e, t = new D()) {
			const i = t,
				r = this.v0,
				s = this.v1,
				a = this.v2,
				o = this.v3;
			return i.set(Ll(e, r.x, s.x, a.x, o.x), Ll(e, r.y, s.y, a.y, o.y), Ll(e, r.z, s.z, a.z, o.z)), i;
		}
		copy(e) {
			return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
		}
	}
	class vx extends Mr {
		constructor(e = new Se(), t = new Se()) {
			super(), (this.isLineCurve = !0), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
		}
		getPoint(e, t = new Se()) {
			const i = t;
			return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
		}
		getPointAt(e, t) {
			return this.getPoint(e, t);
		}
		getTangent(e, t = new Se()) {
			return t.subVectors(this.v2, this.v1).normalize();
		}
		getTangentAt(e, t) {
			return this.getTangent(e, t);
		}
		copy(e) {
			return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
		}
	}
	class fO extends Mr {
		constructor(e = new D(), t = new D()) {
			super(), (this.isLineCurve3 = !0), (this.type = "LineCurve3"), (this.v1 = e), (this.v2 = t);
		}
		getPoint(e, t = new D()) {
			const i = t;
			return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
		}
		getPointAt(e, t) {
			return this.getPoint(e, t);
		}
		getTangent(e, t = new D()) {
			return t.subVectors(this.v2, this.v1).normalize();
		}
		getTangentAt(e, t) {
			return this.getTangent(e, t);
		}
		copy(e) {
			return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
		}
	}
	class _x extends Mr {
		constructor(e = new Se(), t = new Se(), i = new Se()) {
			super(), (this.isQuadraticBezierCurve = !0), (this.type = "QuadraticBezierCurve"), (this.v0 = e), (this.v1 = t), (this.v2 = i);
		}
		getPoint(e, t = new Se()) {
			const i = t,
				r = this.v0,
				s = this.v1,
				a = this.v2;
			return i.set(Cl(e, r.x, s.x, a.x), Cl(e, r.y, s.y, a.y)), i;
		}
		copy(e) {
			return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
		}
	}
	class pO extends Mr {
		constructor(e = new D(), t = new D(), i = new D()) {
			super(), (this.isQuadraticBezierCurve3 = !0), (this.type = "QuadraticBezierCurve3"), (this.v0 = e), (this.v1 = t), (this.v2 = i);
		}
		getPoint(e, t = new D()) {
			const i = t,
				r = this.v0,
				s = this.v1,
				a = this.v2;
			return i.set(Cl(e, r.x, s.x, a.x), Cl(e, r.y, s.y, a.y), Cl(e, r.z, s.z, a.z)), i;
		}
		copy(e) {
			return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
		}
	}
	class yx extends Mr {
		constructor(e = []) {
			super(), (this.isSplineCurve = !0), (this.type = "SplineCurve"), (this.points = e);
		}
		getPoint(e, t = new Se()) {
			const i = t,
				r = this.points,
				s = (r.length - 1) * e,
				a = Math.floor(s),
				o = s - a,
				l = r[a === 0 ? a : a - 1],
				c = r[a],
				u = r[a > r.length - 2 ? r.length - 1 : a + 1],
				h = r[a > r.length - 3 ? r.length - 1 : a + 2];
			return i.set(_0(o, l.x, c.x, u.x, h.x), _0(o, l.y, c.y, u.y, h.y)), i;
		}
		copy(e) {
			super.copy(e), (this.points = []);
			for (let t = 0, i = e.points.length; t < i; t++) {
				const r = e.points[t];
				this.points.push(r.clone());
			}
			return this;
		}
		toJSON() {
			const e = super.toJSON();
			e.points = [];
			for (let t = 0, i = this.points.length; t < i; t++) {
				const r = this.points[t];
				e.points.push(r.toArray());
			}
			return e;
		}
		fromJSON(e) {
			super.fromJSON(e), (this.points = []);
			for (let t = 0, i = e.points.length; t < i; t++) {
				const r = e.points[t];
				this.points.push(new Se().fromArray(r));
			}
			return this;
		}
	}
	var ep = Object.freeze({ __proto__: null, ArcCurve: rO, CatmullRomCurve3: mx, CubicBezierCurve: gx, CubicBezierCurve3: dO, EllipseCurve: Ms, LineCurve: vx, LineCurve3: fO, QuadraticBezierCurve: _x, QuadraticBezierCurve3: pO, SplineCurve: yx });
	class mO extends Mr {
		constructor() {
			super(), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
		}
		add(e) {
			this.curves.push(e);
		}
		closePath() {
			const e = this.curves[0].getPoint(0),
				t = this.curves[this.curves.length - 1].getPoint(1);
			if (!e.equals(t)) {
				const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
				this.curves.push(new ep[i](t, e));
			}
			return this;
		}
		getPoint(e, t) {
			const i = e * this.getLength(),
				r = this.getCurveLengths();
			let s = 0;
			for (; s < r.length; ) {
				if (r[s] >= i) {
					const a = r[s] - i,
						o = this.curves[s],
						l = o.getLength(),
						c = l === 0 ? 0 : 1 - a / l;
					return o.getPointAt(c, t);
				}
				s++;
			}
			return null;
		}
		getLength() {
			const e = this.getCurveLengths();
			return e[e.length - 1];
		}
		updateArcLengths() {
			(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
		}
		getCurveLengths() {
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
			const e = [];
			let t = 0;
			for (let i = 0, r = this.curves.length; i < r; i++) (t += this.curves[i].getLength()), e.push(t);
			return (this.cacheLengths = e), e;
		}
		getSpacedPoints(e = 40) {
			const t = [];
			for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
			return this.autoClose && t.push(t[0]), t;
		}
		getPoints(e = 12) {
			const t = [];
			let i;
			for (let r = 0, s = this.curves; r < s.length; r++) {
				const a = s[r],
					o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e,
					l = a.getPoints(o);
				for (let c = 0; c < l.length; c++) {
					const u = l[c];
					(i && i.equals(u)) || (t.push(u), (i = u));
				}
			}
			return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
		}
		copy(e) {
			super.copy(e), (this.curves = []);
			for (let t = 0, i = e.curves.length; t < i; t++) {
				const r = e.curves[t];
				this.curves.push(r.clone());
			}
			return (this.autoClose = e.autoClose), this;
		}
		toJSON() {
			const e = super.toJSON();
			(e.autoClose = this.autoClose), (e.curves = []);
			for (let t = 0, i = this.curves.length; t < i; t++) {
				const r = this.curves[t];
				e.curves.push(r.toJSON());
			}
			return e;
		}
		fromJSON(e) {
			super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
			for (let t = 0, i = e.curves.length; t < i; t++) {
				const r = e.curves[t];
				this.curves.push(new ep[r.type]().fromJSON(r));
			}
			return this;
		}
	}
	let tp = class extends mO {
		constructor(e) {
			super(), (this.type = "Path"), (this.currentPoint = new Se()), e && this.setFromPoints(e);
		}
		setFromPoints(e) {
			this.moveTo(e[0].x, e[0].y);
			for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
			return this;
		}
		moveTo(e, t) {
			return this.currentPoint.set(e, t), this;
		}
		lineTo(e, t) {
			const i = new vx(this.currentPoint.clone(), new Se(e, t));
			return this.curves.push(i), this.currentPoint.set(e, t), this;
		}
		quadraticCurveTo(e, t, i, r) {
			const s = new _x(this.currentPoint.clone(), new Se(e, t), new Se(i, r));
			return this.curves.push(s), this.currentPoint.set(i, r), this;
		}
		bezierCurveTo(e, t, i, r, s, a) {
			const o = new gx(this.currentPoint.clone(), new Se(e, t), new Se(i, r), new Se(s, a));
			return this.curves.push(o), this.currentPoint.set(s, a), this;
		}
		splineThru(e) {
			const t = [this.currentPoint.clone()].concat(e),
				i = new yx(t);
			return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
		}
		arc(e, t, i, r, s, a) {
			const o = this.currentPoint.x,
				l = this.currentPoint.y;
			return this.absarc(e + o, t + l, i, r, s, a), this;
		}
		absarc(e, t, i, r, s, a) {
			return this.absellipse(e, t, i, i, r, s, a), this;
		}
		ellipse(e, t, i, r, s, a, o, l) {
			const c = this.currentPoint.x,
				u = this.currentPoint.y;
			return this.absellipse(e + c, t + u, i, r, s, a, o, l), this;
		}
		absellipse(e, t, i, r, s, a, o, l) {
			const c = new Ms(e, t, i, r, s, a, o, l);
			if (this.curves.length > 0) {
				const h = c.getPoint(0);
				h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
			}
			this.curves.push(c);
			const u = c.getPoint(1);
			return this.currentPoint.copy(u), this;
		}
		copy(e) {
			return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
		}
		toJSON() {
			const e = super.toJSON();
			return (e.currentPoint = this.currentPoint.toArray()), e;
		}
		fromJSON(e) {
			return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
		}
	};
	class xa extends bt {
		constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
			super(), (this.type = "CircleGeometry"), (this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }), (t = Math.max(3, t));
			const s = [],
				a = [],
				o = [],
				l = [],
				c = new D(),
				u = new Se();
			a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
			for (let h = 0, d = 3; h <= t; h++, d += 3) {
				const f = i + (h / t) * r;
				(c.x = e * Math.cos(f)), (c.y = e * Math.sin(f)), a.push(c.x, c.y, c.z), o.push(0, 0, 1), (u.x = (a[d] / e + 1) / 2), (u.y = (a[d + 1] / e + 1) / 2), l.push(u.x, u.y);
			}
			for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
			this.setIndex(s), this.setAttribute("position", new Tt(a, 3)), this.setAttribute("normal", new Tt(o, 3)), this.setAttribute("uv", new Tt(l, 2));
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new xa(e.radius, e.segments, e.thetaStart, e.thetaLength);
		}
	}
	class xn extends bt {
		constructor(e = 1, t = 1, i = 1, r = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
			super(), (this.type = "CylinderGeometry"), (this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: a, thetaStart: o, thetaLength: l });
			const c = this;
			(r = Math.floor(r)), (s = Math.floor(s));
			const u = [],
				h = [],
				d = [],
				f = [];
			let v = 0;
			const _ = [],
				p = i / 2;
			let g = 0;
			x(), a === !1 && (e > 0 && b(!0), t > 0 && b(!1)), this.setIndex(u), this.setAttribute("position", new Tt(h, 3)), this.setAttribute("normal", new Tt(d, 3)), this.setAttribute("uv", new Tt(f, 2));
			function x() {
				const T = new D(),
					P = new D();
				let A = 0;
				const M = (t - e) / i;
				for (let w = 0; w <= s; w++) {
					const y = [],
						S = w / s,
						L = S * (t - e) + e;
					for (let N = 0; N <= r; N++) {
						const k = N / r,
							B = k * l + o,
							W = Math.sin(B),
							H = Math.cos(B);
						(P.x = L * W), (P.y = -S * i + p), (P.z = L * H), h.push(P.x, P.y, P.z), T.set(W, M, H).normalize(), d.push(T.x, T.y, T.z), f.push(k, 1 - S), y.push(v++);
					}
					_.push(y);
				}
				for (let w = 0; w < r; w++)
					for (let y = 0; y < s; y++) {
						const S = _[y][w],
							L = _[y + 1][w],
							N = _[y + 1][w + 1],
							k = _[y][w + 1];
						u.push(S, L, k), u.push(L, N, k), (A += 6);
					}
				c.addGroup(g, A, 0), (g += A);
			}
			function b(T) {
				const P = v,
					A = new Se(),
					M = new D();
				let w = 0;
				const y = T === !0 ? e : t,
					S = T === !0 ? 1 : -1;
				for (let N = 1; N <= r; N++) h.push(0, p * S, 0), d.push(0, S, 0), f.push(0.5, 0.5), v++;
				const L = v;
				for (let N = 0; N <= r; N++) {
					const B = (N / r) * l + o,
						W = Math.cos(B),
						H = Math.sin(B);
					(M.x = y * H), (M.y = p * S), (M.z = y * W), h.push(M.x, M.y, M.z), d.push(0, S, 0), (A.x = W * 0.5 + 0.5), (A.y = H * 0.5 * S + 0.5), f.push(A.x, A.y), v++;
				}
				for (let N = 0; N < r; N++) {
					const k = P + N,
						B = L + N;
					T === !0 ? u.push(B, B + 1, k) : u.push(B + 1, B, k), (w += 3);
				}
				c.addGroup(g, w, T === !0 ? 1 : 2), (g += w);
			}
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new xn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
		}
	}
	class Kp extends xn {
		constructor(e = 1, t = 1, i = 32, r = 1, s = !1, a = 0, o = Math.PI * 2) {
			super(0, e, t, i, r, s, a, o), (this.type = "ConeGeometry"), (this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: a, thetaLength: o });
		}
		static fromJSON(e) {
			return new Kp(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
		}
	}
	class Zp extends bt {
		constructor(e = [], t = [], i = 1, r = 0) {
			super(), (this.type = "PolyhedronGeometry"), (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
			const s = [],
				a = [];
			o(r), c(i), u(), this.setAttribute("position", new Tt(s, 3)), this.setAttribute("normal", new Tt(s.slice(), 3)), this.setAttribute("uv", new Tt(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
			function o(x) {
				const b = new D(),
					T = new D(),
					P = new D();
				for (let A = 0; A < t.length; A += 3) f(t[A + 0], b), f(t[A + 1], T), f(t[A + 2], P), l(b, T, P, x);
			}
			function l(x, b, T, P) {
				const A = P + 1,
					M = [];
				for (let w = 0; w <= A; w++) {
					M[w] = [];
					const y = x.clone().lerp(T, w / A),
						S = b.clone().lerp(T, w / A),
						L = A - w;
					for (let N = 0; N <= L; N++) N === 0 && w === A ? (M[w][N] = y) : (M[w][N] = y.clone().lerp(S, N / L));
				}
				for (let w = 0; w < A; w++)
					for (let y = 0; y < 2 * (A - w) - 1; y++) {
						const S = Math.floor(y / 2);
						y % 2 === 0 ? (d(M[w][S + 1]), d(M[w + 1][S]), d(M[w][S])) : (d(M[w][S + 1]), d(M[w + 1][S + 1]), d(M[w + 1][S]));
					}
			}
			function c(x) {
				const b = new D();
				for (let T = 0; T < s.length; T += 3) (b.x = s[T + 0]), (b.y = s[T + 1]), (b.z = s[T + 2]), b.normalize().multiplyScalar(x), (s[T + 0] = b.x), (s[T + 1] = b.y), (s[T + 2] = b.z);
			}
			function u() {
				const x = new D();
				for (let b = 0; b < s.length; b += 3) {
					(x.x = s[b + 0]), (x.y = s[b + 1]), (x.z = s[b + 2]);
					const T = p(x) / 2 / Math.PI + 0.5,
						P = g(x) / Math.PI + 0.5;
					a.push(T, 1 - P);
				}
				v(), h();
			}
			function h() {
				for (let x = 0; x < a.length; x += 6) {
					const b = a[x + 0],
						T = a[x + 2],
						P = a[x + 4],
						A = Math.max(b, T, P),
						M = Math.min(b, T, P);
					A > 0.9 && M < 0.1 && (b < 0.2 && (a[x + 0] += 1), T < 0.2 && (a[x + 2] += 1), P < 0.2 && (a[x + 4] += 1));
				}
			}
			function d(x) {
				s.push(x.x, x.y, x.z);
			}
			function f(x, b) {
				const T = x * 3;
				(b.x = e[T + 0]), (b.y = e[T + 1]), (b.z = e[T + 2]);
			}
			function v() {
				const x = new D(),
					b = new D(),
					T = new D(),
					P = new D(),
					A = new Se(),
					M = new Se(),
					w = new Se();
				for (let y = 0, S = 0; y < s.length; y += 9, S += 6) {
					x.set(s[y + 0], s[y + 1], s[y + 2]), b.set(s[y + 3], s[y + 4], s[y + 5]), T.set(s[y + 6], s[y + 7], s[y + 8]), A.set(a[S + 0], a[S + 1]), M.set(a[S + 2], a[S + 3]), w.set(a[S + 4], a[S + 5]), P.copy(x).add(b).add(T).divideScalar(3);
					const L = p(P);
					_(A, S + 0, x, L), _(M, S + 2, b, L), _(w, S + 4, T, L);
				}
			}
			function _(x, b, T, P) {
				P < 0 && x.x === 1 && (a[b] = x.x - 1), T.x === 0 && T.z === 0 && (a[b] = P / 2 / Math.PI + 0.5);
			}
			function p(x) {
				return Math.atan2(x.z, -x.x);
			}
			function g(x) {
				return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
			}
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new Zp(e.vertices, e.indices, e.radius, e.details);
		}
	}
	class Iu extends tp {
		constructor(e) {
			super(e), (this.uuid = yr()), (this.type = "Shape"), (this.holes = []);
		}
		getPointsHoles(e) {
			const t = [];
			for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
			return t;
		}
		extractPoints(e) {
			return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
		}
		copy(e) {
			super.copy(e), (this.holes = []);
			for (let t = 0, i = e.holes.length; t < i; t++) {
				const r = e.holes[t];
				this.holes.push(r.clone());
			}
			return this;
		}
		toJSON() {
			const e = super.toJSON();
			(e.uuid = this.uuid), (e.holes = []);
			for (let t = 0, i = this.holes.length; t < i; t++) {
				const r = this.holes[t];
				e.holes.push(r.toJSON());
			}
			return e;
		}
		fromJSON(e) {
			super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
			for (let t = 0, i = e.holes.length; t < i; t++) {
				const r = e.holes[t];
				this.holes.push(new tp().fromJSON(r));
			}
			return this;
		}
	}
	const gO = {
		triangulate: function (n, e, t = 2) {
			const i = e && e.length,
				r = i ? e[0] * t : n.length;
			let s = xx(n, 0, r, t, !0);
			const a = [];
			if (!s || s.next === s.prev) return a;
			let o, l, c, u, h, d, f;
			if ((i && (s = bO(n, e, s, t)), n.length > 80 * t)) {
				(o = c = n[0]), (l = u = n[1]);
				for (let v = t; v < r; v += t) (h = n[v]), (d = n[v + 1]), h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
				(f = Math.max(c - o, u - l)), (f = f !== 0 ? 32767 / f : 0);
			}
			return Nl(s, a, t, o, l, f, 0), a;
		}
	};
	function xx(n, e, t, i, r) {
		let s, a;
		if (r === DO(n, e, t, i) > 0) for (s = e; s < t; s += i) a = y0(s, n[s], n[s + 1], a);
		else for (s = t - i; s >= e; s -= i) a = y0(s, n[s], n[s + 1], a);
		return a && xh(a, a.next) && (kl(a), (a = a.next)), a;
	}
	function ba(n, e) {
		if (!n) return n;
		e || (e = n);
		let t = n,
			i;
		do
			if (((i = !1), !t.steiner && (xh(t, t.next) || un(t.prev, t, t.next) === 0))) {
				if ((kl(t), (t = e = t.prev), t === t.next)) break;
				i = !0;
			} else t = t.next;
		while (i || t !== e);
		return e;
	}
	function Nl(n, e, t, i, r, s, a) {
		if (!n) return;
		!a && s && MO(n, i, r, s);
		let o = n,
			l,
			c;
		for (; n.prev !== n.next; ) {
			if (((l = n.prev), (c = n.next), s ? _O(n, i, r, s) : vO(n))) {
				e.push((l.i / t) | 0), e.push((n.i / t) | 0), e.push((c.i / t) | 0), kl(n), (n = c.next), (o = c.next);
				continue;
			}
			if (((n = c), n === o)) {
				a ? (a === 1 ? ((n = yO(ba(n), e, t)), Nl(n, e, t, i, r, s, 2)) : a === 2 && xO(n, e, t, i, r, s)) : Nl(ba(n), e, t, i, r, s, 1);
				break;
			}
		}
	}
	function vO(n) {
		const e = n.prev,
			t = n,
			i = n.next;
		if (un(e, t, i) >= 0) return !1;
		const r = e.x,
			s = t.x,
			a = i.x,
			o = e.y,
			l = t.y,
			c = i.y,
			u = r < s ? (r < a ? r : a) : s < a ? s : a,
			h = o < l ? (o < c ? o : c) : l < c ? l : c,
			d = r > s ? (r > a ? r : a) : s > a ? s : a,
			f = o > l ? (o > c ? o : c) : l > c ? l : c;
		let v = i.next;
		for (; v !== e; ) {
			if (v.x >= u && v.x <= d && v.y >= h && v.y <= f && _o(r, o, s, l, a, c, v.x, v.y) && un(v.prev, v, v.next) >= 0) return !1;
			v = v.next;
		}
		return !0;
	}
	function _O(n, e, t, i) {
		const r = n.prev,
			s = n,
			a = n.next;
		if (un(r, s, a) >= 0) return !1;
		const o = r.x,
			l = s.x,
			c = a.x,
			u = r.y,
			h = s.y,
			d = a.y,
			f = o < l ? (o < c ? o : c) : l < c ? l : c,
			v = u < h ? (u < d ? u : d) : h < d ? h : d,
			_ = o > l ? (o > c ? o : c) : l > c ? l : c,
			p = u > h ? (u > d ? u : d) : h > d ? h : d,
			g = np(f, v, e, t, i),
			x = np(_, p, e, t, i);
		let b = n.prevZ,
			T = n.nextZ;
		for (; b && b.z >= g && T && T.z <= x; ) {
			if ((b.x >= f && b.x <= _ && b.y >= v && b.y <= p && b !== r && b !== a && _o(o, u, l, h, c, d, b.x, b.y) && un(b.prev, b, b.next) >= 0) || ((b = b.prevZ), T.x >= f && T.x <= _ && T.y >= v && T.y <= p && T !== r && T !== a && _o(o, u, l, h, c, d, T.x, T.y) && un(T.prev, T, T.next) >= 0)) return !1;
			T = T.nextZ;
		}
		for (; b && b.z >= g; ) {
			if (b.x >= f && b.x <= _ && b.y >= v && b.y <= p && b !== r && b !== a && _o(o, u, l, h, c, d, b.x, b.y) && un(b.prev, b, b.next) >= 0) return !1;
			b = b.prevZ;
		}
		for (; T && T.z <= x; ) {
			if (T.x >= f && T.x <= _ && T.y >= v && T.y <= p && T !== r && T !== a && _o(o, u, l, h, c, d, T.x, T.y) && un(T.prev, T, T.next) >= 0) return !1;
			T = T.nextZ;
		}
		return !0;
	}
	function yO(n, e, t) {
		let i = n;
		do {
			const r = i.prev,
				s = i.next.next;
			!xh(r, s) && bx(r, i, i.next, s) && Ul(r, s) && Ul(s, r) && (e.push((r.i / t) | 0), e.push((i.i / t) | 0), e.push((s.i / t) | 0), kl(i), kl(i.next), (i = n = s)), (i = i.next);
		} while (i !== n);
		return ba(i);
	}
	function xO(n, e, t, i, r, s) {
		let a = n;
		do {
			let o = a.next.next;
			for (; o !== a.prev; ) {
				if (a.i !== o.i && LO(a, o)) {
					let l = Sx(a, o);
					(a = ba(a, a.next)), (l = ba(l, l.next)), Nl(a, e, t, i, r, s, 0), Nl(l, e, t, i, r, s, 0);
					return;
				}
				o = o.next;
			}
			a = a.next;
		} while (a !== n);
	}
	function bO(n, e, t, i) {
		const r = [];
		let s, a, o, l, c;
		for (s = 0, a = e.length; s < a; s++) (o = e[s] * i), (l = s < a - 1 ? e[s + 1] * i : n.length), (c = xx(n, o, l, i, !1)), c === c.next && (c.steiner = !0), r.push(CO(c));
		for (r.sort(SO), s = 0; s < r.length; s++) t = EO(r[s], t);
		return t;
	}
	function SO(n, e) {
		return n.x - e.x;
	}
	function EO(n, e) {
		const t = wO(n, e);
		if (!t) return e;
		const i = Sx(t, n);
		return ba(i, i.next), ba(t, t.next);
	}
	function wO(n, e) {
		let t = e,
			i = -1 / 0,
			r;
		const s = n.x,
			a = n.y;
		do {
			if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
				const d = t.x + ((a - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
				if (d <= s && d > i && ((i = d), (r = t.x < t.next.x ? t : t.next), d === s)) return r;
			}
			t = t.next;
		} while (t !== e);
		if (!r) return null;
		const o = r,
			l = r.x,
			c = r.y;
		let u = 1 / 0,
			h;
		t = r;
		do s >= t.x && t.x >= l && s !== t.x && _o(a < c ? s : i, a, l, c, a < c ? i : s, a, t.x, t.y) && ((h = Math.abs(a - t.y) / (s - t.x)), Ul(t, n) && (h < u || (h === u && (t.x > r.x || (t.x === r.x && TO(r, t))))) && ((r = t), (u = h))), (t = t.next);
		while (t !== o);
		return r;
	}
	function TO(n, e) {
		return un(n.prev, n, e.prev) < 0 && un(e.next, n, n.next) < 0;
	}
	function MO(n, e, t, i) {
		let r = n;
		do r.z === 0 && (r.z = np(r.x, r.y, e, t, i)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next);
		while (r !== n);
		(r.prevZ.nextZ = null), (r.prevZ = null), AO(r);
	}
	function AO(n) {
		let e,
			t,
			i,
			r,
			s,
			a,
			o,
			l,
			c = 1;
		do {
			for (t = n, n = null, s = null, a = 0; t; ) {
				for (a++, i = t, o = 0, e = 0; e < c && (o++, (i = i.nextZ), !!i); e++);
				for (l = c; o > 0 || (l > 0 && i); ) o !== 0 && (l === 0 || !i || t.z <= i.z) ? ((r = t), (t = t.nextZ), o--) : ((r = i), (i = i.nextZ), l--), s ? (s.nextZ = r) : (n = r), (r.prevZ = s), (s = r);
				t = i;
			}
			(s.nextZ = null), (c *= 2);
		} while (a > 1);
		return n;
	}
	function np(n, e, t, i, r) {
		return (n = ((n - t) * r) | 0), (e = ((e - i) * r) | 0), (n = (n | (n << 8)) & 16711935), (n = (n | (n << 4)) & 252645135), (n = (n | (n << 2)) & 858993459), (n = (n | (n << 1)) & 1431655765), (e = (e | (e << 8)) & 16711935), (e = (e | (e << 4)) & 252645135), (e = (e | (e << 2)) & 858993459), (e = (e | (e << 1)) & 1431655765), n | (e << 1);
	}
	function CO(n) {
		let e = n,
			t = n;
		do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
		while (e !== n);
		return t;
	}
	function _o(n, e, t, i, r, s, a, o) {
		return (r - a) * (e - o) >= (n - a) * (s - o) && (n - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (r - a) * (i - o);
	}
	function LO(n, e) {
		return n.next.i !== e.i && n.prev.i !== e.i && !RO(n, e) && ((Ul(n, e) && Ul(e, n) && PO(n, e) && (un(n.prev, n, e.prev) || un(n, e.prev, e))) || (xh(n, e) && un(n.prev, n, n.next) > 0 && un(e.prev, e, e.next) > 0));
	}
	function un(n, e, t) {
		return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
	}
	function xh(n, e) {
		return n.x === e.x && n.y === e.y;
	}
	function bx(n, e, t, i) {
		const r = uu(un(n, e, t)),
			s = uu(un(n, e, i)),
			a = uu(un(t, i, n)),
			o = uu(un(t, i, e));
		return !!((r !== s && a !== o) || (r === 0 && cu(n, t, e)) || (s === 0 && cu(n, i, e)) || (a === 0 && cu(t, n, i)) || (o === 0 && cu(t, e, i)));
	}
	function cu(n, e, t) {
		return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
	}
	function uu(n) {
		return n > 0 ? 1 : n < 0 ? -1 : 0;
	}
	function RO(n, e) {
		let t = n;
		do {
			if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && bx(t, t.next, n, e)) return !0;
			t = t.next;
		} while (t !== n);
		return !1;
	}
	function Ul(n, e) {
		return un(n.prev, n, n.next) < 0 ? un(n, e, n.next) >= 0 && un(n, n.prev, e) >= 0 : un(n, e, n.prev) < 0 || un(n, n.next, e) < 0;
	}
	function PO(n, e) {
		let t = n,
			i = !1;
		const r = (n.x + e.x) / 2,
			s = (n.y + e.y) / 2;
		do t.y > s != t.next.y > s && t.next.y !== t.y && r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x && (i = !i), (t = t.next);
		while (t !== n);
		return i;
	}
	function Sx(n, e) {
		const t = new ip(n.i, n.x, n.y),
			i = new ip(e.i, e.x, e.y),
			r = n.next,
			s = e.prev;
		return (n.next = e), (e.prev = n), (t.next = r), (r.prev = t), (i.next = t), (t.prev = i), (s.next = i), (i.prev = s), i;
	}
	function y0(n, e, t, i) {
		const r = new ip(n, e, t);
		return i ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r)) : ((r.prev = r), (r.next = r)), r;
	}
	function kl(n) {
		(n.next.prev = n.prev), (n.prev.next = n.next), n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
	}
	function ip(n, e, t) {
		(this.i = n), (this.x = e), (this.y = t), (this.prev = null), (this.next = null), (this.z = 0), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
	}
	function DO(n, e, t, i) {
		let r = 0;
		for (let s = e, a = t - i; s < t; s += i) (r += (n[a] - n[s]) * (n[s + 1] + n[a + 1])), (a = s);
		return r;
	}
	class To {
		static area(e) {
			const t = e.length;
			let i = 0;
			for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
			return i * 0.5;
		}
		static isClockWise(e) {
			return To.area(e) < 0;
		}
		static triangulateShape(e, t) {
			const i = [],
				r = [],
				s = [];
			x0(e), b0(i, e);
			let a = e.length;
			t.forEach(x0);
			for (let l = 0; l < t.length; l++) r.push(a), (a += t[l].length), b0(i, t[l]);
			const o = gO.triangulate(i, r);
			for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
			return s;
		}
	}
	function x0(n) {
		const e = n.length;
		e > 2 && n[e - 1].equals(n[0]) && n.pop();
	}
	function b0(n, e) {
		for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
	}
	class Jp extends bt {
		constructor(e = new Iu([new Se(0.5, 0.5), new Se(-0.5, 0.5), new Se(-0.5, -0.5), new Se(0.5, -0.5)]), t = {}) {
			super(), (this.type = "ExtrudeGeometry"), (this.parameters = { shapes: e, options: t }), (e = Array.isArray(e) ? e : [e]);
			const i = this,
				r = [],
				s = [];
			for (let o = 0, l = e.length; o < l; o++) {
				const c = e[o];
				a(c);
			}
			this.setAttribute("position", new Tt(r, 3)), this.setAttribute("uv", new Tt(s, 2)), this.computeVertexNormals();
			function a(o) {
				const l = [],
					c = t.curveSegments !== void 0 ? t.curveSegments : 12,
					u = t.steps !== void 0 ? t.steps : 1,
					h = t.depth !== void 0 ? t.depth : 1;
				let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
					f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
					v = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
					_ = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
					p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
				const g = t.extrudePath,
					x = t.UVGenerator !== void 0 ? t.UVGenerator : OO;
				let b,
					T = !1,
					P,
					A,
					M,
					w;
				g && ((b = g.getSpacedPoints(u)), (T = !0), (d = !1), (P = g.computeFrenetFrames(u, !1)), (A = new D()), (M = new D()), (w = new D())), d || ((p = 0), (f = 0), (v = 0), (_ = 0));
				const y = o.extractPoints(c);
				let S = y.shape;
				const L = y.holes;
				if (!To.isClockWise(S)) {
					S = S.reverse();
					for (let F = 0, fe = L.length; F < fe; F++) {
						const pe = L[F];
						To.isClockWise(pe) && (L[F] = pe.reverse());
					}
				}
				const k = To.triangulateShape(S, L),
					B = S;
				for (let F = 0, fe = L.length; F < fe; F++) {
					const pe = L[F];
					S = S.concat(pe);
				}
				function W(F, fe, pe) {
					return fe || console.error("THREE.ExtrudeGeometry: vec does not exist"), F.clone().addScaledVector(fe, pe);
				}
				const H = S.length,
					z = k.length;
				function X(F, fe, pe) {
					let Ee, re, We;
					const Ce = F.x - fe.x,
						Ie = F.y - fe.y,
						U = pe.x - F.x,
						R = pe.y - F.y,
						ee = Ce * Ce + Ie * Ie,
						de = Ce * R - Ie * U;
					if (Math.abs(de) > Number.EPSILON) {
						const me = Math.sqrt(ee),
							oe = Math.sqrt(U * U + R * R),
							Xe = fe.x - Ie / me,
							Me = fe.y + Ce / me,
							Pe = pe.x - R / oe,
							Je = pe.y + U / oe,
							we = ((Pe - Xe) * R - (Je - Me) * U) / (Ce * R - Ie * U);
						(Ee = Xe + Ce * we - F.x), (re = Me + Ie * we - F.y);
						const Fe = Ee * Ee + re * re;
						if (Fe <= 2) return new Se(Ee, re);
						We = Math.sqrt(Fe / 2);
					} else {
						let me = !1;
						Ce > Number.EPSILON ? U > Number.EPSILON && (me = !0) : Ce < -Number.EPSILON ? U < -Number.EPSILON && (me = !0) : Math.sign(Ie) === Math.sign(R) && (me = !0), me ? ((Ee = -Ie), (re = Ce), (We = Math.sqrt(ee))) : ((Ee = Ce), (re = Ie), (We = Math.sqrt(ee / 2)));
					}
					return new Se(Ee / We, re / We);
				}
				const K = [];
				for (let F = 0, fe = B.length, pe = fe - 1, Ee = F + 1; F < fe; F++, pe++, Ee++) pe === fe && (pe = 0), Ee === fe && (Ee = 0), (K[F] = X(B[F], B[pe], B[Ee]));
				const G = [];
				let ue,
					ae = K.concat();
				for (let F = 0, fe = L.length; F < fe; F++) {
					const pe = L[F];
					ue = [];
					for (let Ee = 0, re = pe.length, We = re - 1, Ce = Ee + 1; Ee < re; Ee++, We++, Ce++) We === re && (We = 0), Ce === re && (Ce = 0), (ue[Ee] = X(pe[Ee], pe[We], pe[Ce]));
					G.push(ue), (ae = ae.concat(ue));
				}
				for (let F = 0; F < p; F++) {
					const fe = F / p,
						pe = f * Math.cos((fe * Math.PI) / 2),
						Ee = v * Math.sin((fe * Math.PI) / 2) + _;
					for (let re = 0, We = B.length; re < We; re++) {
						const Ce = W(B[re], K[re], Ee);
						V(Ce.x, Ce.y, -pe);
					}
					for (let re = 0, We = L.length; re < We; re++) {
						const Ce = L[re];
						ue = G[re];
						for (let Ie = 0, U = Ce.length; Ie < U; Ie++) {
							const R = W(Ce[Ie], ue[Ie], Ee);
							V(R.x, R.y, -pe);
						}
					}
				}
				const Ue = v + _;
				for (let F = 0; F < H; F++) {
					const fe = d ? W(S[F], ae[F], Ue) : S[F];
					T ? (M.copy(P.normals[0]).multiplyScalar(fe.x), A.copy(P.binormals[0]).multiplyScalar(fe.y), w.copy(b[0]).add(M).add(A), V(w.x, w.y, w.z)) : V(fe.x, fe.y, 0);
				}
				for (let F = 1; F <= u; F++)
					for (let fe = 0; fe < H; fe++) {
						const pe = d ? W(S[fe], ae[fe], Ue) : S[fe];
						T ? (M.copy(P.normals[F]).multiplyScalar(pe.x), A.copy(P.binormals[F]).multiplyScalar(pe.y), w.copy(b[F]).add(M).add(A), V(w.x, w.y, w.z)) : V(pe.x, pe.y, (h / u) * F);
					}
				for (let F = p - 1; F >= 0; F--) {
					const fe = F / p,
						pe = f * Math.cos((fe * Math.PI) / 2),
						Ee = v * Math.sin((fe * Math.PI) / 2) + _;
					for (let re = 0, We = B.length; re < We; re++) {
						const Ce = W(B[re], K[re], Ee);
						V(Ce.x, Ce.y, h + pe);
					}
					for (let re = 0, We = L.length; re < We; re++) {
						const Ce = L[re];
						ue = G[re];
						for (let Ie = 0, U = Ce.length; Ie < U; Ie++) {
							const R = W(Ce[Ie], ue[Ie], Ee);
							T ? V(R.x, R.y + b[u - 1].y, b[u - 1].x + pe) : V(R.x, R.y, h + pe);
						}
					}
				}
				Z(), ie();
				function Z() {
					const F = r.length / 3;
					if (d) {
						let fe = 0,
							pe = H * fe;
						for (let Ee = 0; Ee < z; Ee++) {
							const re = k[Ee];
							j(re[2] + pe, re[1] + pe, re[0] + pe);
						}
						(fe = u + p * 2), (pe = H * fe);
						for (let Ee = 0; Ee < z; Ee++) {
							const re = k[Ee];
							j(re[0] + pe, re[1] + pe, re[2] + pe);
						}
					} else {
						for (let fe = 0; fe < z; fe++) {
							const pe = k[fe];
							j(pe[2], pe[1], pe[0]);
						}
						for (let fe = 0; fe < z; fe++) {
							const pe = k[fe];
							j(pe[0] + H * u, pe[1] + H * u, pe[2] + H * u);
						}
					}
					i.addGroup(F, r.length / 3 - F, 0);
				}
				function ie() {
					const F = r.length / 3;
					let fe = 0;
					ge(B, fe), (fe += B.length);
					for (let pe = 0, Ee = L.length; pe < Ee; pe++) {
						const re = L[pe];
						ge(re, fe), (fe += re.length);
					}
					i.addGroup(F, r.length / 3 - F, 1);
				}
				function ge(F, fe) {
					let pe = F.length;
					for (; --pe >= 0; ) {
						const Ee = pe;
						let re = pe - 1;
						re < 0 && (re = F.length - 1);
						for (let We = 0, Ce = u + p * 2; We < Ce; We++) {
							const Ie = H * We,
								U = H * (We + 1),
								R = fe + Ee + Ie,
								ee = fe + re + Ie,
								de = fe + re + U,
								me = fe + Ee + U;
							he(R, ee, de, me);
						}
					}
				}
				function V(F, fe, pe) {
					l.push(F), l.push(fe), l.push(pe);
				}
				function j(F, fe, pe) {
					xe(F), xe(fe), xe(pe);
					const Ee = r.length / 3,
						re = x.generateTopUV(i, r, Ee - 3, Ee - 2, Ee - 1);
					He(re[0]), He(re[1]), He(re[2]);
				}
				function he(F, fe, pe, Ee) {
					xe(F), xe(fe), xe(Ee), xe(fe), xe(pe), xe(Ee);
					const re = r.length / 3,
						We = x.generateSideWallUV(i, r, re - 6, re - 3, re - 2, re - 1);
					He(We[0]), He(We[1]), He(We[3]), He(We[1]), He(We[2]), He(We[3]);
				}
				function xe(F) {
					r.push(l[F * 3 + 0]), r.push(l[F * 3 + 1]), r.push(l[F * 3 + 2]);
				}
				function He(F) {
					s.push(F.x), s.push(F.y);
				}
			}
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		toJSON() {
			const e = super.toJSON(),
				t = this.parameters.shapes,
				i = this.parameters.options;
			return IO(t, i, e);
		}
		static fromJSON(e, t) {
			const i = [];
			for (let s = 0, a = e.shapes.length; s < a; s++) {
				const o = t[e.shapes[s]];
				i.push(o);
			}
			const r = e.options.extrudePath;
			return r !== void 0 && (e.options.extrudePath = new ep[r.type]().fromJSON(r)), new Jp(i, e.options);
		}
	}
	const OO = {
		generateTopUV: function (n, e, t, i, r) {
			const s = e[t * 3],
				a = e[t * 3 + 1],
				o = e[i * 3],
				l = e[i * 3 + 1],
				c = e[r * 3],
				u = e[r * 3 + 1];
			return [new Se(s, a), new Se(o, l), new Se(c, u)];
		},
		generateSideWallUV: function (n, e, t, i, r, s) {
			const a = e[t * 3],
				o = e[t * 3 + 1],
				l = e[t * 3 + 2],
				c = e[i * 3],
				u = e[i * 3 + 1],
				h = e[i * 3 + 2],
				d = e[r * 3],
				f = e[r * 3 + 1],
				v = e[r * 3 + 2],
				_ = e[s * 3],
				p = e[s * 3 + 1],
				g = e[s * 3 + 2];
			return Math.abs(o - u) < Math.abs(a - c) ? [new Se(a, 1 - l), new Se(c, 1 - h), new Se(d, 1 - v), new Se(_, 1 - g)] : [new Se(o, 1 - l), new Se(u, 1 - h), new Se(f, 1 - v), new Se(p, 1 - g)];
		}
	};
	function IO(n, e, t) {
		if (((t.shapes = []), Array.isArray(n)))
			for (let i = 0, r = n.length; i < r; i++) {
				const s = n[i];
				t.shapes.push(s.uuid);
			}
		else t.shapes.push(n.uuid);
		return (t.options = Object.assign({}, e)), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
	}
	class yo extends Zp {
		constructor(e = 1, t = 0) {
			const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
				r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			super(i, r, e, t), (this.type = "OctahedronGeometry"), (this.parameters = { radius: e, detail: t });
		}
		static fromJSON(e) {
			return new yo(e.radius, e.detail);
		}
	}
	class Qp extends bt {
		constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, a = 0, o = Math.PI) {
			super(), (this.type = "SphereGeometry"), (this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: a, thetaLength: o }), (t = Math.max(3, Math.floor(t))), (i = Math.max(2, Math.floor(i)));
			const l = Math.min(a + o, Math.PI);
			let c = 0;
			const u = [],
				h = new D(),
				d = new D(),
				f = [],
				v = [],
				_ = [],
				p = [];
			for (let g = 0; g <= i; g++) {
				const x = [],
					b = g / i;
				let T = 0;
				g === 0 && a === 0 ? (T = 0.5 / t) : g === i && l === Math.PI && (T = -0.5 / t);
				for (let P = 0; P <= t; P++) {
					const A = P / t;
					(h.x = -e * Math.cos(r + A * s) * Math.sin(a + b * o)), (h.y = e * Math.cos(a + b * o)), (h.z = e * Math.sin(r + A * s) * Math.sin(a + b * o)), v.push(h.x, h.y, h.z), d.copy(h).normalize(), _.push(d.x, d.y, d.z), p.push(A + T, 1 - b), x.push(c++);
				}
				u.push(x);
			}
			for (let g = 0; g < i; g++)
				for (let x = 0; x < t; x++) {
					const b = u[g][x + 1],
						T = u[g][x],
						P = u[g + 1][x],
						A = u[g + 1][x + 1];
					(g !== 0 || a > 0) && f.push(b, T, A), (g !== i - 1 || l < Math.PI) && f.push(T, P, A);
				}
			this.setIndex(f), this.setAttribute("position", new Tt(v, 3)), this.setAttribute("normal", new Tt(_, 3)), this.setAttribute("uv", new Tt(p, 2));
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new Qp(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
		}
	}
	class zr extends bt {
		constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
			super(), (this.type = "TorusGeometry"), (this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }), (i = Math.floor(i)), (r = Math.floor(r));
			const a = [],
				o = [],
				l = [],
				c = [],
				u = new D(),
				h = new D(),
				d = new D();
			for (let f = 0; f <= i; f++)
				for (let v = 0; v <= r; v++) {
					const _ = (v / r) * s,
						p = (f / i) * Math.PI * 2;
					(h.x = (e + t * Math.cos(p)) * Math.cos(_)), (h.y = (e + t * Math.cos(p)) * Math.sin(_)), (h.z = t * Math.sin(p)), o.push(h.x, h.y, h.z), (u.x = e * Math.cos(_)), (u.y = e * Math.sin(_)), d.subVectors(h, u).normalize(), l.push(d.x, d.y, d.z), c.push(v / r), c.push(f / i);
				}
			for (let f = 1; f <= i; f++)
				for (let v = 1; v <= r; v++) {
					const _ = (r + 1) * f + v - 1,
						p = (r + 1) * (f - 1) + v - 1,
						g = (r + 1) * (f - 1) + v,
						x = (r + 1) * f + v;
					a.push(_, p, x), a.push(p, g, x);
				}
			this.setIndex(a), this.setAttribute("position", new Tt(o, 3)), this.setAttribute("normal", new Tt(l, 3)), this.setAttribute("uv", new Tt(c, 2));
		}
		copy(e) {
			return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
		}
		static fromJSON(e) {
			return new zr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
		}
	}
	class nr extends Er {
		constructor(e) {
			super(),
				(this.isMeshPhongMaterial = !0),
				(this.type = "MeshPhongMaterial"),
				(this.color = new rt(16777215)),
				(this.specular = new rt(1118481)),
				(this.shininess = 30),
				(this.map = null),
				(this.lightMap = null),
				(this.lightMapIntensity = 1),
				(this.aoMap = null),
				(this.aoMapIntensity = 1),
				(this.emissive = new rt(0)),
				(this.emissiveIntensity = 1),
				(this.emissiveMap = null),
				(this.bumpMap = null),
				(this.bumpScale = 1),
				(this.normalMap = null),
				(this.normalMapType = Ky),
				(this.normalScale = new Se(1, 1)),
				(this.displacementMap = null),
				(this.displacementScale = 1),
				(this.displacementBias = 0),
				(this.specularMap = null),
				(this.alphaMap = null),
				(this.envMap = null),
				(this.envMapRotation = new Un()),
				(this.combine = Up),
				(this.reflectivity = 1),
				(this.refractionRatio = 0.98),
				(this.wireframe = !1),
				(this.wireframeLinewidth = 1),
				(this.wireframeLinecap = "round"),
				(this.wireframeLinejoin = "round"),
				(this.flatShading = !1),
				(this.fog = !0),
				this.setValues(e);
		}
		copy(e) {
			return (
				super.copy(e),
				this.color.copy(e.color),
				this.specular.copy(e.specular),
				(this.shininess = e.shininess),
				(this.map = e.map),
				(this.lightMap = e.lightMap),
				(this.lightMapIntensity = e.lightMapIntensity),
				(this.aoMap = e.aoMap),
				(this.aoMapIntensity = e.aoMapIntensity),
				this.emissive.copy(e.emissive),
				(this.emissiveMap = e.emissiveMap),
				(this.emissiveIntensity = e.emissiveIntensity),
				(this.bumpMap = e.bumpMap),
				(this.bumpScale = e.bumpScale),
				(this.normalMap = e.normalMap),
				(this.normalMapType = e.normalMapType),
				this.normalScale.copy(e.normalScale),
				(this.displacementMap = e.displacementMap),
				(this.displacementScale = e.displacementScale),
				(this.displacementBias = e.displacementBias),
				(this.specularMap = e.specularMap),
				(this.alphaMap = e.alphaMap),
				(this.envMap = e.envMap),
				this.envMapRotation.copy(e.envMapRotation),
				(this.combine = e.combine),
				(this.reflectivity = e.reflectivity),
				(this.refractionRatio = e.refractionRatio),
				(this.wireframe = e.wireframe),
				(this.wireframeLinewidth = e.wireframeLinewidth),
				(this.wireframeLinecap = e.wireframeLinecap),
				(this.wireframeLinejoin = e.wireframeLinejoin),
				(this.flatShading = e.flatShading),
				(this.fog = e.fog),
				this
			);
		}
	}
	const Qu = {
		enabled: !1,
		files: {},
		add: function (n, e) {
			this.enabled !== !1 && (this.files[n] = e);
		},
		get: function (n) {
			if (this.enabled !== !1) return this.files[n];
		},
		remove: function (n) {
			delete this.files[n];
		},
		clear: function () {
			this.files = {};
		}
	};
	class FO {
		constructor(e, t, i) {
			const r = this;
			let s = !1,
				a = 0,
				o = 0,
				l;
			const c = [];
			(this.onStart = void 0),
				(this.onLoad = e),
				(this.onProgress = t),
				(this.onError = i),
				(this.itemStart = function (u) {
					o++, s === !1 && r.onStart !== void 0 && r.onStart(u, a, o), (s = !0);
				}),
				(this.itemEnd = function (u) {
					a++, r.onProgress !== void 0 && r.onProgress(u, a, o), a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad());
				}),
				(this.itemError = function (u) {
					r.onError !== void 0 && r.onError(u);
				}),
				(this.resolveURL = function (u) {
					return l ? l(u) : u;
				}),
				(this.setURLModifier = function (u) {
					return (l = u), this;
				}),
				(this.addHandler = function (u, h) {
					return c.push(u, h), this;
				}),
				(this.removeHandler = function (u) {
					const h = c.indexOf(u);
					return h !== -1 && c.splice(h, 2), this;
				}),
				(this.getHandler = function (u) {
					for (let h = 0, d = c.length; h < d; h += 2) {
						const f = c[h],
							v = c[h + 1];
						if ((f.global && (f.lastIndex = 0), f.test(u))) return v;
					}
					return null;
				});
		}
	}
	const Ex = new FO();
	class Ma {
		constructor(e) {
			(this.manager = e !== void 0 ? e : Ex), (this.crossOrigin = "anonymous"), (this.withCredentials = !1), (this.path = ""), (this.resourcePath = ""), (this.requestHeader = {});
		}
		load() {}
		loadAsync(e, t) {
			const i = this;
			return new Promise(function (r, s) {
				i.load(e, r, t, s);
			});
		}
		parse() {}
		setCrossOrigin(e) {
			return (this.crossOrigin = e), this;
		}
		setWithCredentials(e) {
			return (this.withCredentials = e), this;
		}
		setPath(e) {
			return (this.path = e), this;
		}
		setResourcePath(e) {
			return (this.resourcePath = e), this;
		}
		setRequestHeader(e) {
			return (this.requestHeader = e), this;
		}
	}
	Ma.DEFAULT_MATERIAL_NAME = "__DEFAULT";
	const kr = {};
	class NO extends Error {
		constructor(e, t) {
			super(e), (this.response = t);
		}
	}
	class em extends Ma {
		constructor(e) {
			super(e);
		}
		load(e, t, i, r) {
			e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
			const s = Qu.get(e);
			if (s !== void 0)
				return (
					this.manager.itemStart(e),
					setTimeout(() => {
						t && t(s), this.manager.itemEnd(e);
					}, 0),
					s
				);
			if (kr[e] !== void 0) {
				kr[e].push({ onLoad: t, onProgress: i, onError: r });
				return;
			}
			(kr[e] = []), kr[e].push({ onLoad: t, onProgress: i, onError: r });
			const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }),
				o = this.mimeType,
				l = this.responseType;
			fetch(a)
				.then((c) => {
					if (c.status === 200 || c.status === 0) {
						if ((c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)) return c;
						const u = kr[e],
							h = c.body.getReader(),
							d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
							f = d ? parseInt(d) : 0,
							v = f !== 0;
						let _ = 0;
						const p = new ReadableStream({
							start(g) {
								x();
								function x() {
									h.read().then(
										({ done: b, value: T }) => {
											if (b) g.close();
											else {
												_ += T.byteLength;
												const P = new ProgressEvent("progress", { lengthComputable: v, loaded: _, total: f });
												for (let A = 0, M = u.length; A < M; A++) {
													const w = u[A];
													w.onProgress && w.onProgress(P);
												}
												g.enqueue(T), x();
											}
										},
										(b) => {
											g.error(b);
										}
									);
								}
							}
						});
						return new Response(p);
					} else throw new NO(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
				})
				.then((c) => {
					switch (l) {
						case "arraybuffer":
							return c.arrayBuffer();
						case "blob":
							return c.blob();
						case "document":
							return c.text().then((u) => new DOMParser().parseFromString(u, o));
						case "json":
							return c.json();
						default:
							if (o === void 0) return c.text();
							{
								const h = /charset="?([^;"\s]*)"?/i.exec(o),
									d = h && h[1] ? h[1].toLowerCase() : void 0,
									f = new TextDecoder(d);
								return c.arrayBuffer().then((v) => f.decode(v));
							}
					}
				})
				.then((c) => {
					Qu.add(e, c);
					const u = kr[e];
					delete kr[e];
					for (let h = 0, d = u.length; h < d; h++) {
						const f = u[h];
						f.onLoad && f.onLoad(c);
					}
				})
				.catch((c) => {
					const u = kr[e];
					if (u === void 0) throw (this.manager.itemError(e), c);
					delete kr[e];
					for (let h = 0, d = u.length; h < d; h++) {
						const f = u[h];
						f.onError && f.onError(c);
					}
					this.manager.itemError(e);
				})
				.finally(() => {
					this.manager.itemEnd(e);
				}),
				this.manager.itemStart(e);
		}
		setResponseType(e) {
			return (this.responseType = e), this;
		}
		setMimeType(e) {
			return (this.mimeType = e), this;
		}
	}
	class UO extends Ma {
		constructor(e) {
			super(e);
		}
		load(e, t, i, r) {
			this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
			const s = this,
				a = Qu.get(e);
			if (a !== void 0)
				return (
					s.manager.itemStart(e),
					setTimeout(function () {
						t && t(a), s.manager.itemEnd(e);
					}, 0),
					a
				);
			const o = Il("img");
			function l() {
				u(), Qu.add(e, this), t && t(this), s.manager.itemEnd(e);
			}
			function c(h) {
				u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
			}
			function u() {
				o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
			}
			return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), (o.src = e), o;
		}
	}
	class wx extends Ma {
		constructor(e) {
			super(e);
		}
		load(e, t, i, r) {
			const s = new jn(),
				a = new UO(this.manager);
			return (
				a.setCrossOrigin(this.crossOrigin),
				a.setPath(this.path),
				a.load(
					e,
					function (o) {
						(s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
					},
					i,
					r
				),
				s
			);
		}
	}
	class Tx extends on {
		constructor(e, t = 1) {
			super(), (this.isLight = !0), (this.type = "Light"), (this.color = new rt(e)), (this.intensity = t);
		}
		dispose() {}
		copy(e, t) {
			return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
		}
		toJSON(e) {
			const t = super.toJSON(e);
			return (
				(t.object.color = this.color.getHex()),
				(t.object.intensity = this.intensity),
				this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
				this.distance !== void 0 && (t.object.distance = this.distance),
				this.angle !== void 0 && (t.object.angle = this.angle),
				this.decay !== void 0 && (t.object.decay = this.decay),
				this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
				this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
				this.target !== void 0 && (t.object.target = this.target.uuid),
				t
			);
		}
	}
	const Vd = new pt(),
		S0 = new D(),
		E0 = new D();
	class kO {
		constructor(e) {
			(this.camera = e), (this.intensity = 1), (this.bias = 0), (this.normalBias = 0), (this.radius = 1), (this.blurSamples = 8), (this.mapSize = new Se(512, 512)), (this.map = null), (this.mapPass = null), (this.matrix = new pt()), (this.autoUpdate = !0), (this.needsUpdate = !1), (this._frustum = new qp()), (this._frameExtents = new Se(1, 1)), (this._viewportCount = 1), (this._viewports = [new wn(0, 0, 1, 1)]);
		}
		getViewportCount() {
			return this._viewportCount;
		}
		getFrustum() {
			return this._frustum;
		}
		updateMatrices(e) {
			const t = this.camera,
				i = this.matrix;
			S0.setFromMatrixPosition(e.matrixWorld), t.position.copy(S0), E0.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(E0), t.updateMatrixWorld(), Vd.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Vd), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(Vd);
		}
		getViewport(e) {
			return this._viewports[e];
		}
		getFrameExtents() {
			return this._frameExtents;
		}
		dispose() {
			this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
		}
		copy(e) {
			return (this.camera = e.camera.clone()), (this.intensity = e.intensity), (this.bias = e.bias), (this.radius = e.radius), this.mapSize.copy(e.mapSize), this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		toJSON() {
			const e = {};
			return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), (e.camera = this.camera.toJSON(!1).object), delete e.camera.matrix, e;
		}
	}
	class BO extends kO {
		constructor() {
			super(new ec(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
		}
	}
	class eh extends Tx {
		constructor(e, t) {
			super(e, t), (this.isDirectionalLight = !0), (this.type = "DirectionalLight"), this.position.copy(on.DEFAULT_UP), this.updateMatrix(), (this.target = new on()), (this.shadow = new BO());
		}
		dispose() {
			this.shadow.dispose();
		}
		copy(e) {
			return super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
		}
	}
	class zO extends Tx {
		constructor(e, t) {
			super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
		}
	}
	class HO {
		static decodeText(e) {
			if ((console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")) return new TextDecoder().decode(e);
			let t = "";
			for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
			try {
				return decodeURIComponent(escape(t));
			} catch {
				return t;
			}
		}
		static extractUrlBase(e) {
			const t = e.lastIndexOf("/");
			return t === -1 ? "./" : e.slice(0, t + 1);
		}
		static resolveURL(e, t) {
			return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
		}
	}
	class GO {
		constructor(e = !0) {
			(this.autoStart = e), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
		}
		start() {
			(this.startTime = w0()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0);
		}
		stop() {
			this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
		}
		getElapsedTime() {
			return this.getDelta(), this.elapsedTime;
		}
		getDelta() {
			let e = 0;
			if (this.autoStart && !this.running) return this.start(), 0;
			if (this.running) {
				const t = w0();
				(e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
			}
			return e;
		}
	}
	function w0() {
		return (typeof performance > "u" ? Date : performance).now();
	}
	const T0 = new pt();
	class tm {
		constructor(e, t, i = 0, r = 1 / 0) {
			(this.ray = new _h(e, t)), (this.near = i), (this.far = r), (this.camera = null), (this.layers = new $p()), (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} });
		}
		set(e, t) {
			this.ray.set(e, t);
		}
		setFromCamera(e, t) {
			t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), (this.camera = t)) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), (this.camera = t)) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
		}
		setFromXRController(e) {
			return T0.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(T0), this;
		}
		intersectObject(e, t = !0, i = []) {
			return rp(e, this, i, t), i.sort(M0), i;
		}
		intersectObjects(e, t = !0, i = []) {
			for (let r = 0, s = e.length; r < s; r++) rp(e[r], this, i, t);
			return i.sort(M0), i;
		}
	}
	function M0(n, e) {
		return n.distance - e.distance;
	}
	function rp(n, e, t, i) {
		let r = !0;
		if ((n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1), r === !0 && i === !0)) {
			const s = n.children;
			for (let a = 0, o = s.length; a < o; a++) rp(s[a], e, t, !0);
		}
	}
	class VO extends Fl {
		constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
			(i = new rt(i)), (r = new rt(r));
			const s = t / 2,
				a = e / t,
				o = e / 2,
				l = [],
				c = [];
			for (let d = 0, f = 0, v = -o; d <= t; d++, v += a) {
				l.push(-o, 0, v, o, 0, v), l.push(v, 0, -o, v, 0, o);
				const _ = d === s ? i : r;
				_.toArray(c, f), (f += 3), _.toArray(c, f), (f += 3), _.toArray(c, f), (f += 3), _.toArray(c, f), (f += 3);
			}
			const u = new bt();
			u.setAttribute("position", new Tt(l, 3)), u.setAttribute("color", new Tt(c, 3));
			const h = new Fi({ vertexColors: !0, toneMapped: !1 });
			super(u, h), (this.type = "GridHelper");
		}
		dispose() {
			this.geometry.dispose(), this.material.dispose();
		}
	}
	const hu = new Tr();
	class WO extends Fl {
		constructor(e, t = 16776960) {
			const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
				r = new Float32Array(8 * 3),
				s = new bt();
			s.setIndex(new mn(i, 1)), s.setAttribute("position", new mn(r, 3)), super(s, new Fi({ color: t, toneMapped: !1 })), (this.object = e), (this.type = "BoxHelper"), (this.matrixAutoUpdate = !1), this.update();
		}
		update(e) {
			if ((e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && hu.setFromObject(this.object), hu.isEmpty())) return;
			const t = hu.min,
				i = hu.max,
				r = this.geometry.attributes.position,
				s = r.array;
			(s[0] = i.x), (s[1] = i.y), (s[2] = i.z), (s[3] = t.x), (s[4] = i.y), (s[5] = i.z), (s[6] = t.x), (s[7] = t.y), (s[8] = i.z), (s[9] = i.x), (s[10] = t.y), (s[11] = i.z), (s[12] = i.x), (s[13] = i.y), (s[14] = t.z), (s[15] = t.x), (s[16] = i.y), (s[17] = t.z), (s[18] = t.x), (s[19] = t.y), (s[20] = t.z), (s[21] = i.x), (s[22] = t.y), (s[23] = t.z), (r.needsUpdate = !0), this.geometry.computeBoundingSphere();
		}
		setFromObject(e) {
			return (this.object = e), this.update(), this;
		}
		copy(e, t) {
			return super.copy(e, t), (this.object = e.object), this;
		}
		dispose() {
			this.geometry.dispose(), this.material.dispose();
		}
	}
	class XO {
		constructor() {
			(this.type = "ShapePath"), (this.color = new rt()), (this.subPaths = []), (this.currentPath = null);
		}
		moveTo(e, t) {
			return (this.currentPath = new tp()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
		}
		lineTo(e, t) {
			return this.currentPath.lineTo(e, t), this;
		}
		quadraticCurveTo(e, t, i, r) {
			return this.currentPath.quadraticCurveTo(e, t, i, r), this;
		}
		bezierCurveTo(e, t, i, r, s, a) {
			return this.currentPath.bezierCurveTo(e, t, i, r, s, a), this;
		}
		splineThru(e) {
			return this.currentPath.splineThru(e), this;
		}
		toShapes(e) {
			function t(g) {
				const x = [];
				for (let b = 0, T = g.length; b < T; b++) {
					const P = g[b],
						A = new Iu();
					(A.curves = P.curves), x.push(A);
				}
				return x;
			}
			function i(g, x) {
				const b = x.length;
				let T = !1;
				for (let P = b - 1, A = 0; A < b; P = A++) {
					let M = x[P],
						w = x[A],
						y = w.x - M.x,
						S = w.y - M.y;
					if (Math.abs(S) > Number.EPSILON) {
						if ((S < 0 && ((M = x[A]), (y = -y), (w = x[P]), (S = -S)), g.y < M.y || g.y > w.y)) continue;
						if (g.y === M.y) {
							if (g.x === M.x) return !0;
						} else {
							const L = S * (g.x - M.x) - y * (g.y - M.y);
							if (L === 0) return !0;
							if (L < 0) continue;
							T = !T;
						}
					} else {
						if (g.y !== M.y) continue;
						if ((w.x <= g.x && g.x <= M.x) || (M.x <= g.x && g.x <= w.x)) return !0;
					}
				}
				return T;
			}
			const r = To.isClockWise,
				s = this.subPaths;
			if (s.length === 0) return [];
			let a, o, l;
			const c = [];
			if (s.length === 1) return (o = s[0]), (l = new Iu()), (l.curves = o.curves), c.push(l), c;
			let u = !r(s[0].getPoints());
			u = e ? !u : u;
			const h = [],
				d = [];
			let f = [],
				v = 0,
				_;
			(d[v] = void 0), (f[v] = []);
			for (let g = 0, x = s.length; g < x; g++) (o = s[g]), (_ = o.getPoints()), (a = r(_)), (a = e ? !a : a), a ? (!u && d[v] && v++, (d[v] = { s: new Iu(), p: _ }), (d[v].s.curves = o.curves), u && v++, (f[v] = [])) : f[v].push({ h: o, p: _[0] });
			if (!d[0]) return t(s);
			if (d.length > 1) {
				let g = !1,
					x = 0;
				for (let b = 0, T = d.length; b < T; b++) h[b] = [];
				for (let b = 0, T = d.length; b < T; b++) {
					const P = f[b];
					for (let A = 0; A < P.length; A++) {
						const M = P[A];
						let w = !0;
						for (let y = 0; y < d.length; y++) i(M.p, d[y].p) && (b !== y && x++, w ? ((w = !1), h[y].push(M)) : (g = !0));
						w && h[b].push(M);
					}
				}
				x > 0 && g === !1 && (f = h);
			}
			let p;
			for (let g = 0, x = d.length; g < x; g++) {
				(l = d[g].s), c.push(l), (p = f[g]);
				for (let b = 0, T = p.length; b < T; b++) l.holes.push(p[b].h);
			}
			return c;
		}
	}
	typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Np } }));
	typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : (window.__THREE__ = Np));
	const et = { IDLE: Symbol(), ROTATE: Symbol(), PAN: Symbol(), SCALE: Symbol(), FOV: Symbol(), FOCUS: Symbol(), ZROTATE: Symbol(), TOUCH_MULTI: Symbol(), ANIMATION_FOCUS: Symbol(), ANIMATION_ROTATE: Symbol() },
		Wt = { NONE: Symbol(), ONE_FINGER: Symbol(), ONE_FINGER_SWITCHED: Symbol(), TWO_FINGER: Symbol(), MULT_FINGER: Symbol(), CURSOR: Symbol() },
		xt = { x: 0, y: 0 },
		di = { camera: new pt(), gizmos: new pt() },
		Jt = { type: "change" },
		Yi = { type: "start" },
		Li = { type: "end" },
		$O = new tm(),
		_n = new D(),
		A0 = new pt(),
		C0 = new pt(),
		Xi = new D();
	class nm extends Ns {
		constructor(e, t, i = null) {
			super(),
				(this.camera = null),
				(this.domElement = t),
				(this.scene = i),
				(this.target = new D()),
				(this._currentTarget = new D()),
				(this.radiusFactor = 0.67),
				(this.mouseActions = []),
				(this._mouseOp = null),
				(this._v2_1 = new Se()),
				(this._v3_1 = new D()),
				(this._v3_2 = new D()),
				(this._m4_1 = new pt()),
				(this._m4_2 = new pt()),
				(this._quat = new En()),
				(this._translationMatrix = new pt()),
				(this._rotationMatrix = new pt()),
				(this._scaleMatrix = new pt()),
				(this._rotationAxis = new D()),
				(this._cameraMatrixState = new pt()),
				(this._cameraProjectionState = new pt()),
				(this._fovState = 1),
				(this._upState = new D()),
				(this._zoomState = 1),
				(this._nearPos = 0),
				(this._farPos = 0),
				(this._gizmoMatrixState = new pt()),
				(this._up0 = new D()),
				(this._zoom0 = 1),
				(this._fov0 = 0),
				(this._initialNear = 0),
				(this._nearPos0 = 0),
				(this._initialFar = 0),
				(this._farPos0 = 0),
				(this._cameraMatrixState0 = new pt()),
				(this._gizmoMatrixState0 = new pt()),
				(this._button = -1),
				(this._touchStart = []),
				(this._touchCurrent = []),
				(this._input = Wt.NONE),
				(this._switchSensibility = 32),
				(this._startFingerDistance = 0),
				(this._currentFingerDistance = 0),
				(this._startFingerRotation = 0),
				(this._currentFingerRotation = 0),
				(this._devPxRatio = 0),
				(this._downValid = !0),
				(this._nclicks = 0),
				(this._downEvents = []),
				(this._downStart = 0),
				(this._clickStart = 0),
				(this._maxDownTime = 250),
				(this._maxInterval = 300),
				(this._posThreshold = 24),
				(this._movementThreshold = 24),
				(this._currentCursorPosition = new D()),
				(this._startCursorPosition = new D()),
				(this._grid = null),
				(this._gridPosition = new D()),
				(this._gizmos = new Ot()),
				(this._curvePts = 128),
				(this._timeStart = -1),
				(this._animationId = -1),
				(this.focusAnimationTime = 500),
				(this._timePrev = 0),
				(this._timeCurrent = 0),
				(this._anglePrev = 0),
				(this._angleCurrent = 0),
				(this._cursorPosPrev = new D()),
				(this._cursorPosCurr = new D()),
				(this._wPrev = 0),
				(this._wCurr = 0),
				(this.adjustNearFar = !1),
				(this.scaleFactor = 1.1),
				(this.dampingFactor = 25),
				(this.wMax = 20),
				(this.enableAnimations = !0),
				(this.enableGrid = !1),
				(this.cursorZoom = !1),
				(this.minFov = 5),
				(this.maxFov = 90),
				(this.rotateSpeed = 1),
				(this.enabled = !0),
				(this.enablePan = !0),
				(this.enableRotate = !0),
				(this.enableZoom = !0),
				(this.enableGizmos = !0),
				(this.minDistance = 0),
				(this.maxDistance = 1 / 0),
				(this.minZoom = 0),
				(this.maxZoom = 1 / 0),
				(this._tbRadius = 1),
				(this._state = et.IDLE),
				this.setCamera(e),
				this.scene != null && this.scene.add(this._gizmos),
				(this.domElement.style.touchAction = "none"),
				(this._devPxRatio = window.devicePixelRatio),
				this.initializeMouseActions(),
				(this._onContextMenu = jO.bind(this)),
				(this._onWheel = QO.bind(this)),
				(this._onPointerUp = JO.bind(this)),
				(this._onPointerMove = ZO.bind(this)),
				(this._onPointerDown = KO.bind(this)),
				(this._onPointerCancel = YO.bind(this)),
				(this._onWindowResize = qO.bind(this)),
				this.domElement.addEventListener("contextmenu", this._onContextMenu),
				this.domElement.addEventListener("wheel", this._onWheel),
				this.domElement.addEventListener("pointerdown", this._onPointerDown),
				this.domElement.addEventListener("pointercancel", this._onPointerCancel),
				window.addEventListener("resize", this._onWindowResize);
		}
		onSinglePanStart(e, t) {
			if (this.enabled)
				switch ((this.dispatchEvent(Yi), this.setCenter(e.clientX, e.clientY), t)) {
					case "PAN":
						if (!this.enablePan) return;
						this._animationId != -1 && (cancelAnimationFrame(this._animationId), (this._animationId = -1), (this._timeStart = -1), this.activateGizmos(!1), this.dispatchEvent(Jt)), this.updateTbState(et.PAN, !0), this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement)), this.enableGrid && (this.drawGrid(), this.dispatchEvent(Jt));
						break;
					case "ROTATE":
						if (!this.enableRotate) return;
						this._animationId != -1 && (cancelAnimationFrame(this._animationId), (this._animationId = -1), (this._timeStart = -1)),
							this.updateTbState(et.ROTATE, !0),
							this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, xt.x, xt.y, this.domElement, this._tbRadius)),
							this.activateGizmos(!0),
							this.enableAnimations && ((this._timePrev = this._timeCurrent = performance.now()), (this._angleCurrent = this._anglePrev = 0), this._cursorPosPrev.copy(this._startCursorPosition), this._cursorPosCurr.copy(this._cursorPosPrev), (this._wCurr = 0), (this._wPrev = this._wCurr)),
							this.dispatchEvent(Jt);
						break;
					case "FOV":
						if (!this.camera.isPerspectiveCamera || !this.enableZoom) return;
						this._animationId != -1 && (cancelAnimationFrame(this._animationId), (this._animationId = -1), (this._timeStart = -1), this.activateGizmos(!1), this.dispatchEvent(Jt)), this.updateTbState(et.FOV, !0), this._startCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5), this._currentCursorPosition.copy(this._startCursorPosition);
						break;
					case "ZOOM":
						if (!this.enableZoom) return;
						this._animationId != -1 && (cancelAnimationFrame(this._animationId), (this._animationId = -1), (this._timeStart = -1), this.activateGizmos(!1), this.dispatchEvent(Jt)), this.updateTbState(et.SCALE, !0), this._startCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5), this._currentCursorPosition.copy(this._startCursorPosition);
						break;
				}
		}
		onSinglePanMove(e, t) {
			if (this.enabled) {
				const i = t != this._state;
				switch ((this.setCenter(e.clientX, e.clientY), t)) {
					case et.PAN:
						this.enablePan && (i ? (this.dispatchEvent(Li), this.dispatchEvent(Yi), this.updateTbState(t, !0), this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement)), this.enableGrid && this.drawGrid(), this.activateGizmos(!1)) : (this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement)), this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition))));
						break;
					case et.ROTATE:
						if (this.enableRotate)
							if (i) this.dispatchEvent(Li), this.dispatchEvent(Yi), this.updateTbState(t, !0), this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, xt.x, xt.y, this.domElement, this._tbRadius)), this.enableGrid && this.disposeGrid(), this.activateGizmos(!0);
							else {
								this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.camera, xt.x, xt.y, this.domElement, this._tbRadius));
								const r = this._startCursorPosition.distanceTo(this._currentCursorPosition),
									s = this._startCursorPosition.angleTo(this._currentCursorPosition),
									a = Math.max(r / this._tbRadius, s) * this.rotateSpeed;
								this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), a)),
									this.enableAnimations && ((this._timePrev = this._timeCurrent), (this._timeCurrent = performance.now()), (this._anglePrev = this._angleCurrent), (this._angleCurrent = a), this._cursorPosPrev.copy(this._cursorPosCurr), this._cursorPosCurr.copy(this._currentCursorPosition), (this._wPrev = this._wCurr), (this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent)));
							}
						break;
					case et.SCALE:
						if (this.enableZoom)
							if (i) this.dispatchEvent(Li), this.dispatchEvent(Yi), this.updateTbState(t, !0), this._startCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5), this._currentCursorPosition.copy(this._startCursorPosition), this.enableGrid && this.disposeGrid(), this.activateGizmos(!1);
							else {
								this._currentCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5);
								const s = this._currentCursorPosition.y - this._startCursorPosition.y;
								let a = 1;
								s < 0 ? (a = 1 / Math.pow(this.scaleFactor, -s * 8)) : s > 0 && (a = Math.pow(this.scaleFactor, s * 8)), this._v3_1.setFromMatrixPosition(this._gizmoMatrixState), this.applyTransformMatrix(this.scale(a, this._v3_1));
							}
						break;
					case et.FOV:
						if (this.enableZoom && this.camera.isPerspectiveCamera)
							if (i) this.dispatchEvent(Li), this.dispatchEvent(Yi), this.updateTbState(t, !0), this._startCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5), this._currentCursorPosition.copy(this._startCursorPosition), this.enableGrid && this.disposeGrid(), this.activateGizmos(!1);
							else {
								this._currentCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5);
								const s = this._currentCursorPosition.y - this._startCursorPosition.y;
								let a = 1;
								s < 0 ? (a = 1 / Math.pow(this.scaleFactor, -s * 8)) : s > 0 && (a = Math.pow(this.scaleFactor, s * 8)), this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
								const o = this._v3_1.distanceTo(this._gizmos.position);
								let l = o / a;
								l = an.clamp(l, this.minDistance, this.maxDistance);
								const c = o * Math.tan(an.DEG2RAD * this._fovState * 0.5);
								let u = an.RAD2DEG * (Math.atan(c / l) * 2);
								u = an.clamp(u, this.minFov, this.maxFov);
								const h = c / Math.tan(an.DEG2RAD * (u / 2));
								(a = o / h),
									this._v3_2.setFromMatrixPosition(this._gizmoMatrixState),
									this.setFov(u),
									this.applyTransformMatrix(this.scale(a, this._v3_2, !1)),
									_n
										.copy(this._gizmos.position)
										.sub(this.camera.position)
										.normalize()
										.multiplyScalar(h / o),
									this._m4_1.makeTranslation(_n.x, _n.y, _n.z);
							}
						break;
				}
				this.dispatchEvent(Jt);
			}
		}
		onSinglePanEnd() {
			if (this._state == et.ROTATE) {
				if (!this.enableRotate) return;
				if (this.enableAnimations)
					if (performance.now() - this._timeCurrent < 120) {
						const t = Math.abs((this._wPrev + this._wCurr) / 2),
							i = this;
						this._animationId = window.requestAnimationFrame(function (r) {
							i.updateTbState(et.ANIMATION_ROTATE, !0);
							const s = i.calculateRotationAxis(i._cursorPosPrev, i._cursorPosCurr);
							i.onRotationAnim(r, s, Math.min(t, i.wMax));
						});
					} else this.updateTbState(et.IDLE, !1), this.activateGizmos(!1), this.dispatchEvent(Jt);
				else this.updateTbState(et.IDLE, !1), this.activateGizmos(!1), this.dispatchEvent(Jt);
			} else (this._state == et.PAN || this._state == et.IDLE) && (this.updateTbState(et.IDLE, !1), this.enableGrid && this.disposeGrid(), this.activateGizmos(!1), this.dispatchEvent(Jt));
			this.dispatchEvent(Li);
		}
		onDoubleTap(e) {
			if (this.enabled && this.enablePan && this.scene != null) {
				this.dispatchEvent(Yi), this.setCenter(e.clientX, e.clientY);
				const t = this.unprojectOnObj(this.getCursorNDC(xt.x, xt.y, this.domElement), this.camera);
				if (t != null && this.enableAnimations) {
					const i = this;
					this._animationId != -1 && window.cancelAnimationFrame(this._animationId),
						(this._timeStart = -1),
						(this._animationId = window.requestAnimationFrame(function (r) {
							i.updateTbState(et.ANIMATION_FOCUS, !0), i.onFocusAnim(r, t, i._cameraMatrixState, i._gizmoMatrixState);
						}));
				} else t != null && !this.enableAnimations && (this.updateTbState(et.FOCUS, !0), this.focus(t, this.scaleFactor), this.updateTbState(et.IDLE, !1), this.dispatchEvent(Jt));
			}
			this.dispatchEvent(Li);
		}
		onDoublePanStart() {
			this.enabled && this.enablePan && (this.dispatchEvent(Yi), this.updateTbState(et.PAN, !0), this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2), this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement, !0)), this._currentCursorPosition.copy(this._startCursorPosition), this.activateGizmos(!1));
		}
		onDoublePanMove() {
			this.enabled &&
				this.enablePan &&
				(this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2),
				this._state != et.PAN && (this.updateTbState(et.PAN, !0), this._startCursorPosition.copy(this._currentCursorPosition)),
				this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement, !0)),
				this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, !0)),
				this.dispatchEvent(Jt));
		}
		onDoublePanEnd() {
			this.updateTbState(et.IDLE, !1), this.dispatchEvent(Li);
		}
		onRotateStart() {
			this.enabled && this.enableRotate && (this.dispatchEvent(Yi), this.updateTbState(et.ZROTATE, !0), (this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0])), (this._currentFingerRotation = this._startFingerRotation), this.camera.getWorldDirection(this._rotationAxis), !this.enablePan && !this.enableZoom && this.activateGizmos(!0));
		}
		onRotateMove() {
			if (this.enabled && this.enableRotate) {
				this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
				let e;
				this._state != et.ZROTATE && (this.updateTbState(et.ZROTATE, !0), (this._startFingerRotation = this._currentFingerRotation)),
					(this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0])),
					this.enablePan
						? (this._v3_2.setFromMatrixPosition(this._gizmoMatrixState),
						  (e = this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement)
								.applyQuaternion(this.camera.quaternion)
								.multiplyScalar(1 / this.camera.zoom)
								.add(this._v3_2)))
						: (e = new D().setFromMatrixPosition(this._gizmoMatrixState));
				const t = an.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);
				this.applyTransformMatrix(this.zRotate(e, t)), this.dispatchEvent(Jt);
			}
		}
		onRotateEnd() {
			this.updateTbState(et.IDLE, !1), this.activateGizmos(!1), this.dispatchEvent(Li);
		}
		onPinchStart() {
			this.enabled && this.enableZoom && (this.dispatchEvent(Yi), this.updateTbState(et.SCALE, !0), (this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1])), (this._currentFingerDistance = this._startFingerDistance), this.activateGizmos(!1));
		}
		onPinchMove() {
			if (this.enabled && this.enableZoom) {
				this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);
				const e = 12;
				this._state != et.SCALE && ((this._startFingerDistance = this._currentFingerDistance), this.updateTbState(et.SCALE, !0)), (this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), e * this._devPxRatio));
				const t = this._currentFingerDistance / this._startFingerDistance;
				let i;
				this.enablePan
					? this.camera.isOrthographicCamera
						? (i = this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement)
								.applyQuaternion(this.camera.quaternion)
								.multiplyScalar(1 / this.camera.zoom)
								.add(this._gizmos.position))
						: this.camera.isPerspectiveCamera && (i = this.unprojectOnTbPlane(this.camera, xt.x, xt.y, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position))
					: (i = this._gizmos.position),
					this.applyTransformMatrix(this.scale(t, i)),
					this.dispatchEvent(Jt);
			}
		}
		onPinchEnd() {
			this.updateTbState(et.IDLE, !1), this.dispatchEvent(Li);
		}
		onTriplePanStart() {
			if (this.enabled && this.enableZoom) {
				this.dispatchEvent(Yi), this.updateTbState(et.SCALE, !0);
				let e = 0,
					t = 0;
				const i = this._touchCurrent.length;
				for (let r = 0; r < i; r++) (e += this._touchCurrent[r].clientX), (t += this._touchCurrent[r].clientY);
				this.setCenter(e / i, t / i), this._startCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5), this._currentCursorPosition.copy(this._startCursorPosition);
			}
		}
		onTriplePanMove() {
			if (this.enabled && this.enableZoom) {
				let e = 0,
					t = 0;
				const i = this._touchCurrent.length;
				for (let d = 0; d < i; d++) (e += this._touchCurrent[d].clientX), (t += this._touchCurrent[d].clientY);
				this.setCenter(e / i, t / i);
				const r = 8;
				this._currentCursorPosition.setY(this.getCursorNDC(xt.x, xt.y, this.domElement).y * 0.5);
				const s = this._currentCursorPosition.y - this._startCursorPosition.y;
				let a = 1;
				s < 0 ? (a = 1 / Math.pow(this.scaleFactor, -s * r)) : s > 0 && (a = Math.pow(this.scaleFactor, s * r)), this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
				const o = this._v3_1.distanceTo(this._gizmos.position);
				let l = o / a;
				l = an.clamp(l, this.minDistance, this.maxDistance);
				const c = o * Math.tan(an.DEG2RAD * this._fovState * 0.5);
				let u = an.RAD2DEG * (Math.atan(c / l) * 2);
				u = an.clamp(u, this.minFov, this.maxFov);
				const h = c / Math.tan(an.DEG2RAD * (u / 2));
				(a = o / h),
					this._v3_2.setFromMatrixPosition(this._gizmoMatrixState),
					this.setFov(u),
					this.applyTransformMatrix(this.scale(a, this._v3_2, !1)),
					_n
						.copy(this._gizmos.position)
						.sub(this.camera.position)
						.normalize()
						.multiplyScalar(h / o),
					this._m4_1.makeTranslation(_n.x, _n.y, _n.z),
					this.dispatchEvent(Jt);
			}
		}
		onTriplePanEnd() {
			this.updateTbState(et.IDLE, !1), this.dispatchEvent(Li);
		}
		setCenter(e, t) {
			(xt.x = e), (xt.y = t);
		}
		initializeMouseActions() {
			this.setMouseAction("PAN", 0, "CTRL"), this.setMouseAction("PAN", 2), this.setMouseAction("ROTATE", 0), this.setMouseAction("ZOOM", "WHEEL"), this.setMouseAction("ZOOM", 1), this.setMouseAction("FOV", "WHEEL", "SHIFT"), this.setMouseAction("FOV", 1, "SHIFT");
		}
		compareMouseAction(e, t) {
			return e.operation == t.operation ? e.mouse == t.mouse && e.key == t.key : !1;
		}
		setMouseAction(e, t, i = null) {
			const r = ["PAN", "ROTATE", "ZOOM", "FOV"],
				s = [0, 1, 2, "WHEEL"],
				a = ["CTRL", "SHIFT", null];
			let o;
			if (!r.includes(e) || !s.includes(t) || !a.includes(i) || (t == "WHEEL" && e != "ZOOM" && e != "FOV")) return !1;
			switch (e) {
				case "PAN":
					o = et.PAN;
					break;
				case "ROTATE":
					o = et.ROTATE;
					break;
				case "ZOOM":
					o = et.SCALE;
					break;
				case "FOV":
					o = et.FOV;
					break;
			}
			const l = { operation: e, mouse: t, key: i, state: o };
			for (let c = 0; c < this.mouseActions.length; c++) if (this.mouseActions[c].mouse == l.mouse && this.mouseActions[c].key == l.key) return this.mouseActions.splice(c, 1, l), !0;
			return this.mouseActions.push(l), !0;
		}
		unsetMouseAction(e, t = null) {
			for (let i = 0; i < this.mouseActions.length; i++) if (this.mouseActions[i].mouse == e && this.mouseActions[i].key == t) return this.mouseActions.splice(i, 1), !0;
			return !1;
		}
		getOpFromAction(e, t) {
			let i;
			for (let r = 0; r < this.mouseActions.length; r++) if (((i = this.mouseActions[r]), i.mouse == e && i.key == t)) return i.operation;
			if (t != null) {
				for (let r = 0; r < this.mouseActions.length; r++) if (((i = this.mouseActions[r]), i.mouse == e && i.key == null)) return i.operation;
			}
			return null;
		}
		getOpStateFromAction(e, t) {
			let i;
			for (let r = 0; r < this.mouseActions.length; r++) if (((i = this.mouseActions[r]), i.mouse == e && i.key == t)) return i.state;
			if (t != null) {
				for (let r = 0; r < this.mouseActions.length; r++) if (((i = this.mouseActions[r]), i.mouse == e && i.key == null)) return i.state;
			}
			return null;
		}
		getAngle(e, t) {
			return (Math.atan2(t.clientY - e.clientY, t.clientX - e.clientX) * 180) / Math.PI;
		}
		updateTouchEvent(e) {
			for (let t = 0; t < this._touchCurrent.length; t++)
				if (this._touchCurrent[t].pointerId == e.pointerId) {
					this._touchCurrent.splice(t, 1, e);
					break;
				}
		}
		applyTransformMatrix(e) {
			if (
				(e.camera != null && (this._m4_1.copy(this._cameraMatrixState).premultiply(e.camera), this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale), this.camera.updateMatrix(), (this._state == et.ROTATE || this._state == et.ZROTATE || this._state == et.ANIMATION_ROTATE) && this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion)),
				e.gizmos != null && (this._m4_1.copy(this._gizmoMatrixState).premultiply(e.gizmos), this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale), this._gizmos.updateMatrix()),
				this._state == et.SCALE || this._state == et.FOCUS || this._state == et.ANIMATION_FOCUS)
			)
				if (((this._tbRadius = this.calculateTbRadius(this.camera)), this.adjustNearFar)) {
					const t = this.camera.position.distanceTo(this._gizmos.position),
						i = new Tr();
					i.setFromObject(this._gizmos);
					const r = new $o();
					i.getBoundingSphere(r);
					const s = Math.max(this._nearPos0, r.radius + r.center.length()),
						a = t - this._initialNear,
						o = Math.min(s, a);
					this.camera.near = t - o;
					const l = Math.min(this._farPos0, -r.radius + r.center.length()),
						c = t - this._initialFar,
						u = Math.min(l, c);
					(this.camera.far = t - u), this.camera.updateProjectionMatrix();
				} else {
					let t = !1;
					this.camera.near != this._initialNear && ((this.camera.near = this._initialNear), (t = !0)), this.camera.far != this._initialFar && ((this.camera.far = this._initialFar), (t = !0)), t && this.camera.updateProjectionMatrix();
				}
		}
		calculateAngularSpeed(e, t, i, r) {
			const s = t - e,
				a = (r - i) / 1e3;
			return a == 0 ? 0 : s / a;
		}
		calculatePointersDistance(e, t) {
			return Math.sqrt(Math.pow(t.clientX - e.clientX, 2) + Math.pow(t.clientY - e.clientY, 2));
		}
		calculateRotationAxis(e, t) {
			return this._rotationMatrix.extractRotation(this._cameraMatrixState), this._quat.setFromRotationMatrix(this._rotationMatrix), this._rotationAxis.crossVectors(e, t).applyQuaternion(this._quat), this._rotationAxis.normalize().clone();
		}
		calculateTbRadius(e) {
			const t = e.position.distanceTo(this._gizmos.position);
			if (e.type == "PerspectiveCamera") {
				const i = an.DEG2RAD * e.fov * 0.5,
					r = Math.atan(e.aspect * Math.tan(i));
				return Math.tan(Math.min(i, r)) * t * this.radiusFactor;
			} else if (e.type == "OrthographicCamera") return Math.min(e.top, e.right) * this.radiusFactor;
		}
		focus(e, t, i = 1) {
			_n.copy(e).sub(this._gizmos.position).multiplyScalar(i),
				this._translationMatrix.makeTranslation(_n.x, _n.y, _n.z),
				A0.copy(this._gizmoMatrixState),
				this._gizmoMatrixState.premultiply(this._translationMatrix),
				this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale),
				C0.copy(this._cameraMatrixState),
				this._cameraMatrixState.premultiply(this._translationMatrix),
				this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale),
				this.enableZoom && this.applyTransformMatrix(this.scale(t, this._gizmos.position)),
				this._gizmoMatrixState.copy(A0),
				this._cameraMatrixState.copy(C0);
		}
		drawGrid() {
			if (this.scene != null) {
				let i, r, s, a;
				if (this.camera.isOrthographicCamera) {
					const o = this.camera.right - this.camera.left,
						l = this.camera.bottom - this.camera.top;
					(s = Math.max(o, l)), (a = s / 20), (i = (s / this.camera.zoom) * 3), (r = (i / a) * this.camera.zoom);
				} else if (this.camera.isPerspectiveCamera) {
					const o = this.camera.position.distanceTo(this._gizmos.position),
						l = an.DEG2RAD * this.camera.fov * 0.5,
						c = Math.atan(this.camera.aspect * Math.tan(l));
					(s = Math.tan(Math.max(l, c)) * o * 2), (a = s / 20), (i = s * 3), (r = i / a);
				}
				this._grid == null && ((this._grid = new VO(i, r, 8947848, 8947848)), this._grid.position.copy(this._gizmos.position), this._gridPosition.copy(this._grid.position), this._grid.quaternion.copy(this.camera.quaternion), this._grid.rotateX(Math.PI * 0.5), this.scene.add(this._grid));
			}
		}
		dispose() {
			this._animationId != -1 && window.cancelAnimationFrame(this._animationId),
				this.domElement.removeEventListener("pointerdown", this._onPointerDown),
				this.domElement.removeEventListener("pointercancel", this._onPointerCancel),
				this.domElement.removeEventListener("wheel", this._onWheel),
				this.domElement.removeEventListener("contextmenu", this._onContextMenu),
				window.removeEventListener("pointermove", this._onPointerMove),
				window.removeEventListener("pointerup", this._onPointerUp),
				window.removeEventListener("resize", this._onWindowResize),
				this.scene !== null && this.scene.remove(this._gizmos),
				this.disposeGrid();
		}
		disposeGrid() {
			this._grid != null && this.scene != null && (this.scene.remove(this._grid), (this._grid = null));
		}
		easeOutCubic(e) {
			return 1 - Math.pow(1 - e, 3);
		}
		activateGizmos(e) {
			const t = this._gizmos.children[0],
				i = this._gizmos.children[1],
				r = this._gizmos.children[2];
			e ? (t.material.setValues({ opacity: 1 }), i.material.setValues({ opacity: 1 }), r.material.setValues({ opacity: 1 })) : (t.material.setValues({ opacity: 0.6 }), i.material.setValues({ opacity: 0.6 }), r.material.setValues({ opacity: 0.6 }));
		}
		getCursorNDC(e, t, i) {
			const r = i.getBoundingClientRect();
			return this._v2_1.setX(((e - r.left) / r.width) * 2 - 1), this._v2_1.setY(((r.bottom - t) / r.height) * 2 - 1), this._v2_1.clone();
		}
		getCursorPosition(e, t, i) {
			return this._v2_1.copy(this.getCursorNDC(e, t, i)), (this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5), (this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5), this._v2_1.clone();
		}
		setCamera(e) {
			e.lookAt(this.target),
				e.updateMatrix(),
				e.type == "PerspectiveCamera" && ((this._fov0 = e.fov), (this._fovState = e.fov)),
				this._cameraMatrixState0.copy(e.matrix),
				this._cameraMatrixState.copy(this._cameraMatrixState0),
				this._cameraProjectionState.copy(e.projectionMatrix),
				(this._zoom0 = e.zoom),
				(this._zoomState = this._zoom0),
				(this._initialNear = e.near),
				(this._nearPos0 = e.position.distanceTo(this.target) - e.near),
				(this._nearPos = this._initialNear),
				(this._initialFar = e.far),
				(this._farPos0 = e.position.distanceTo(this.target) - e.far),
				(this._farPos = this._initialFar),
				this._up0.copy(e.up),
				this._upState.copy(e.up),
				(this.camera = e),
				this.camera.updateProjectionMatrix(),
				(this._tbRadius = this.calculateTbRadius(e)),
				this.makeGizmos(this.target, this._tbRadius);
		}
		setGizmosVisible(e) {
			(this._gizmos.visible = e), this.dispatchEvent(Jt);
		}
		setTbRadius(e) {
			(this.radiusFactor = e), (this._tbRadius = this.calculateTbRadius(this.camera));
			const i = new Ms(0, 0, this._tbRadius, this._tbRadius).getPoints(this._curvePts),
				r = new bt().setFromPoints(i);
			for (const s in this._gizmos.children) this._gizmos.children[s].geometry = r;
			this.dispatchEvent(Jt);
		}
		makeGizmos(e, t) {
			const r = new Ms(0, 0, t, t).getPoints(this._curvePts),
				s = new bt().setFromPoints(r),
				a = new Fi({ color: 16744576, fog: !1, transparent: !0, opacity: 0.6 }),
				o = new Fi({ color: 8454016, fog: !1, transparent: !0, opacity: 0.6 }),
				l = new Fi({ color: 8421631, fog: !1, transparent: !0, opacity: 0.6 }),
				c = new Sn(s, a),
				u = new Sn(s, o),
				h = new Sn(s, l),
				d = Math.PI * 0.5;
			if (((c.rotation.x = d), (u.rotation.y = d), this._gizmoMatrixState0.identity().setPosition(e), this._gizmoMatrixState.copy(this._gizmoMatrixState0), this.camera.zoom !== 1)) {
				const f = 1 / this.camera.zoom;
				this._scaleMatrix.makeScale(f, f, f), this._translationMatrix.makeTranslation(-e.x, -e.y, -e.z), this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix), this._translationMatrix.makeTranslation(e.x, e.y, e.z), this._gizmoMatrixState.premultiply(this._translationMatrix);
			}
			this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale),
				this._gizmos.traverse(function (f) {
					f.isLine && (f.geometry.dispose(), f.material.dispose());
				}),
				this._gizmos.clear(),
				this._gizmos.add(c),
				this._gizmos.add(u),
				this._gizmos.add(h);
		}
		onFocusAnim(e, t, i, r) {
			if ((this._timeStart == -1 && (this._timeStart = e), this._state == et.ANIMATION_FOCUS)) {
				const a = (e - this._timeStart) / this.focusAnimationTime;
				if ((this._gizmoMatrixState.copy(r), a >= 1)) this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale), this.focus(t, this.scaleFactor), (this._timeStart = -1), this.updateTbState(et.IDLE, !1), this.activateGizmos(!1), this.dispatchEvent(Jt);
				else {
					const o = this.easeOutCubic(a),
						l = 1 - o + this.scaleFactor * o;
					this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale), this.focus(t, l, o), this.dispatchEvent(Jt);
					const c = this;
					this._animationId = window.requestAnimationFrame(function (u) {
						c.onFocusAnim(u, t, i, r.clone());
					});
				}
			} else (this._animationId = -1), (this._timeStart = -1);
		}
		onRotationAnim(e, t, i) {
			if ((this._timeStart == -1 && ((this._anglePrev = 0), (this._angleCurrent = 0), (this._timeStart = e)), this._state == et.ANIMATION_ROTATE)) {
				const r = (e - this._timeStart) / 1e3;
				if (i + -this.dampingFactor * r > 0) {
					(this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(r, 2) + i * r + 0), this.applyTransformMatrix(this.rotate(t, this._angleCurrent)), this.dispatchEvent(Jt);
					const a = this;
					this._animationId = window.requestAnimationFrame(function (o) {
						a.onRotationAnim(o, t, i);
					});
				} else (this._animationId = -1), (this._timeStart = -1), this.updateTbState(et.IDLE, !1), this.activateGizmos(!1), this.dispatchEvent(Jt);
			} else (this._animationId = -1), (this._timeStart = -1), this._state != et.ROTATE && (this.activateGizmos(!1), this.dispatchEvent(Jt));
		}
		pan(e, t, i = !1) {
			const r = e.clone().sub(t);
			if (this.camera.isOrthographicCamera) r.multiplyScalar(1 / this.camera.zoom);
			else if (this.camera.isPerspectiveCamera && i) {
				this._v3_1.setFromMatrixPosition(this._cameraMatrixState0), this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0);
				const s = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);
				r.multiplyScalar(1 / s);
			}
			return this._v3_1.set(r.x, r.y, 0).applyQuaternion(this.camera.quaternion), this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z), this.setTransformationMatrices(this._m4_1, this._m4_1), di;
		}
		reset() {
			(this.camera.zoom = this._zoom0),
				this.camera.isPerspectiveCamera && (this.camera.fov = this._fov0),
				(this.camera.near = this._nearPos),
				(this.camera.far = this._farPos),
				this._cameraMatrixState.copy(this._cameraMatrixState0),
				this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale),
				this.camera.up.copy(this._up0),
				this.camera.updateMatrix(),
				this.camera.updateProjectionMatrix(),
				this._gizmoMatrixState.copy(this._gizmoMatrixState0),
				this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale),
				this._gizmos.updateMatrix(),
				(this._tbRadius = this.calculateTbRadius(this.camera)),
				this.makeGizmos(this._gizmos.position, this._tbRadius),
				this.camera.lookAt(this._gizmos.position),
				this.updateTbState(et.IDLE, !1),
				this.dispatchEvent(Jt);
		}
		rotate(e, t) {
			const i = this._gizmos.position;
			return this._translationMatrix.makeTranslation(-i.x, -i.y, -i.z), this._rotationMatrix.makeRotationAxis(e, -t), this._m4_1.makeTranslation(i.x, i.y, i.z), this._m4_1.multiply(this._rotationMatrix), this._m4_1.multiply(this._translationMatrix), this.setTransformationMatrices(this._m4_1), di;
		}
		copyState() {
			let e;
			this.camera.isOrthographicCamera
				? (e = JSON.stringify({ arcballState: { cameraFar: this.camera.far, cameraMatrix: this.camera.matrix, cameraNear: this.camera.near, cameraUp: this.camera.up, cameraZoom: this.camera.zoom, gizmoMatrix: this._gizmos.matrix } }))
				: this.camera.isPerspectiveCamera && (e = JSON.stringify({ arcballState: { cameraFar: this.camera.far, cameraFov: this.camera.fov, cameraMatrix: this.camera.matrix, cameraNear: this.camera.near, cameraUp: this.camera.up, cameraZoom: this.camera.zoom, gizmoMatrix: this._gizmos.matrix } })),
				navigator.clipboard.writeText(e);
		}
		pasteState() {
			const e = this;
			navigator.clipboard.readText().then(function (i) {
				e.setStateFromJSON(i);
			});
		}
		saveState() {
			this._cameraMatrixState0.copy(this.camera.matrix), this._gizmoMatrixState0.copy(this._gizmos.matrix), (this._nearPos = this.camera.near), (this._farPos = this.camera.far), (this._zoom0 = this.camera.zoom), this._up0.copy(this.camera.up), this.camera.isPerspectiveCamera && (this._fov0 = this.camera.fov);
		}
		scale(e, t, i = !0) {
			Xi.copy(t);
			let r = 1 / e;
			if (this.camera.isOrthographicCamera) {
				(this.camera.zoom = this._zoomState),
					(this.camera.zoom *= e),
					this.camera.zoom > this.maxZoom ? ((this.camera.zoom = this.maxZoom), (r = this._zoomState / this.maxZoom)) : this.camera.zoom < this.minZoom && ((this.camera.zoom = this.minZoom), (r = this._zoomState / this.minZoom)),
					this.camera.updateProjectionMatrix(),
					this._v3_1.setFromMatrixPosition(this._gizmoMatrixState),
					this._scaleMatrix.makeScale(r, r, r),
					this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z),
					this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix),
					this._m4_2.multiply(this._translationMatrix),
					Xi.sub(this._v3_1);
				const s = Xi.clone().multiplyScalar(r);
				return Xi.sub(s), this._m4_1.makeTranslation(Xi.x, Xi.y, Xi.z), this._m4_2.premultiply(this._m4_1), this.setTransformationMatrices(this._m4_1, this._m4_2), di;
			} else if (this.camera.isPerspectiveCamera) {
				this._v3_1.setFromMatrixPosition(this._cameraMatrixState), this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);
				let s = this._v3_1.distanceTo(Xi),
					a = s - s * r;
				const o = s - a;
				if ((o < this.minDistance ? ((r = this.minDistance / s), (a = s - s * r)) : o > this.maxDistance && ((r = this.maxDistance / s), (a = s - s * r)), _n.copy(Xi).sub(this._v3_1).normalize().multiplyScalar(a), this._m4_1.makeTranslation(_n.x, _n.y, _n.z), i)) {
					const l = this._v3_2;
					(s = l.distanceTo(Xi)), (a = s - s * r), _n.copy(Xi).sub(this._v3_2).normalize().multiplyScalar(a), this._translationMatrix.makeTranslation(l.x, l.y, l.z), this._scaleMatrix.makeScale(r, r, r), this._m4_2.makeTranslation(_n.x, _n.y, _n.z).multiply(this._translationMatrix), this._m4_2.multiply(this._scaleMatrix), this._translationMatrix.makeTranslation(-l.x, -l.y, -l.z), this._m4_2.multiply(this._translationMatrix), this.setTransformationMatrices(this._m4_1, this._m4_2);
				} else this.setTransformationMatrices(this._m4_1);
				return di;
			}
		}
		setFov(e) {
			this.camera.isPerspectiveCamera && ((this.camera.fov = an.clamp(e, this.minFov, this.maxFov)), this.camera.updateProjectionMatrix());
		}
		setTransformationMatrices(e = null, t = null) {
			e != null ? (di.camera != null ? di.camera.copy(e) : (di.camera = e.clone())) : (di.camera = null), t != null ? (di.gizmos != null ? di.gizmos.copy(t) : (di.gizmos = t.clone())) : (di.gizmos = null);
		}
		zRotate(e, t) {
			return (
				this._rotationMatrix.makeRotationAxis(this._rotationAxis, t),
				this._translationMatrix.makeTranslation(-e.x, -e.y, -e.z),
				this._m4_1.makeTranslation(e.x, e.y, e.z),
				this._m4_1.multiply(this._rotationMatrix),
				this._m4_1.multiply(this._translationMatrix),
				this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(e),
				this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, t),
				this._v3_2.sub(this._v3_1),
				this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z),
				this.setTransformationMatrices(this._m4_1, this._m4_2),
				di
			);
		}
		getRaycaster() {
			return $O;
		}
		unprojectOnObj(e, t) {
			const i = this.getRaycaster();
			(i.near = t.near), (i.far = t.far), i.setFromCamera(e, t);
			const r = i.intersectObjects(this.scene.children, !0);
			for (let s = 0; s < r.length; s++) if (r[s].object.uuid != this._gizmos.uuid && r[s].face != null) return r[s].point.clone();
			return null;
		}
		unprojectOnTbSurface(e, t, i, r, s) {
			if (e.type == "OrthographicCamera") {
				this._v2_1.copy(this.getCursorPosition(t, i, r)), this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);
				const a = Math.pow(this._v2_1.x, 2),
					o = Math.pow(this._v2_1.y, 2),
					l = Math.pow(this._tbRadius, 2);
				return a + o <= l * 0.5 ? this._v3_1.setZ(Math.sqrt(l - (a + o))) : this._v3_1.setZ((l * 0.5) / Math.sqrt(a + o)), this._v3_1;
			} else if (e.type == "PerspectiveCamera") {
				this._v2_1.copy(this.getCursorNDC(t, i, r)), this._v3_1.set(this._v2_1.x, this._v2_1.y, -1), this._v3_1.applyMatrix4(e.projectionMatrixInverse);
				const a = this._v3_1.clone().normalize(),
					o = e.position.distanceTo(this._gizmos.position),
					l = Math.pow(s, 2),
					c = this._v3_1.z,
					u = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));
				if (u == 0) return a.set(this._v3_1.x, this._v3_1.y, s), a;
				const h = c / u,
					d = o;
				let f = Math.pow(h, 2) + 1,
					v = 2 * h * d,
					_ = Math.pow(d, 2) - l,
					p = Math.pow(v, 2) - 4 * f * _;
				if (p >= 0 && (this._v2_1.setX((-v - Math.sqrt(p)) / (2 * f)), this._v2_1.setY(h * this._v2_1.x + d), an.RAD2DEG * this._v2_1.angle() >= 45)) {
					const b = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(o - this._v2_1.y, 2));
					return a.multiplyScalar(b), (a.z += o), a;
				}
				(f = h), (v = d), (_ = -l * 0.5), (p = Math.pow(v, 2) - 4 * f * _), this._v2_1.setX((-v - Math.sqrt(p)) / (2 * f)), this._v2_1.setY(h * this._v2_1.x + d);
				const g = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(o - this._v2_1.y, 2));
				return a.multiplyScalar(g), (a.z += o), a;
			}
		}
		unprojectOnTbPlane(e, t, i, r, s = !1) {
			if (e.type == "OrthographicCamera") return this._v2_1.copy(this.getCursorPosition(t, i, r)), this._v3_1.set(this._v2_1.x, this._v2_1.y, 0), this._v3_1.clone();
			if (e.type == "PerspectiveCamera") {
				this._v2_1.copy(this.getCursorNDC(t, i, r)), this._v3_1.set(this._v2_1.x, this._v2_1.y, -1), this._v3_1.applyMatrix4(e.projectionMatrixInverse);
				const a = this._v3_1.clone().normalize(),
					o = this._v3_1.z,
					l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));
				let c;
				if ((s ? (c = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0))) : (c = e.position.distanceTo(this._gizmos.position)), l == 0)) return a.set(0, 0, 0), a;
				const u = o / l,
					h = c,
					d = -h / u,
					f = Math.sqrt(Math.pow(h, 2) + Math.pow(d, 2));
				return a.multiplyScalar(f), (a.z = 0), a;
			}
		}
		updateMatrixState() {
			this._cameraMatrixState.copy(this.camera.matrix), this._gizmoMatrixState.copy(this._gizmos.matrix), this.camera.isOrthographicCamera ? (this._cameraProjectionState.copy(this.camera.projectionMatrix), this.camera.updateProjectionMatrix(), (this._zoomState = this.camera.zoom)) : this.camera.isPerspectiveCamera && (this._fovState = this.camera.fov);
		}
		updateTbState(e, t) {
			(this._state = e), t && this.updateMatrixState();
		}
		update() {
			if ((this.target.equals(this._currentTarget) === !1 && (this._gizmos.position.copy(this.target), (this._tbRadius = this.calculateTbRadius(this.camera)), this.makeGizmos(this.target, this._tbRadius), this._currentTarget.copy(this.target)), this.camera.isOrthographicCamera)) {
				if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {
					const t = an.clamp(this.camera.zoom, this.minZoom, this.maxZoom);
					this.applyTransformMatrix(this.scale(t / this.camera.zoom, this._gizmos.position, !0));
				}
			} else if (this.camera.isPerspectiveCamera) {
				const t = this.camera.position.distanceTo(this._gizmos.position);
				if (t > this.maxDistance + 1e-6 || t < this.minDistance - 1e-6) {
					const r = an.clamp(t, this.minDistance, this.maxDistance);
					this.applyTransformMatrix(this.scale(r / t, this._gizmos.position)), this.updateMatrixState();
				}
				(this.camera.fov < this.minFov || this.camera.fov > this.maxFov) && ((this.camera.fov = an.clamp(this.camera.fov, this.minFov, this.maxFov)), this.camera.updateProjectionMatrix());
				const i = this._tbRadius;
				if (((this._tbRadius = this.calculateTbRadius(this.camera)), i < this._tbRadius - 1e-6 || i > this._tbRadius + 1e-6)) {
					const r = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3,
						s = this._tbRadius / r,
						o = new Ms(0, 0, s, s).getPoints(this._curvePts),
						l = new bt().setFromPoints(o);
					for (const c in this._gizmos.children) this._gizmos.children[c].geometry = l;
				}
			}
			this.camera.lookAt(this._gizmos.position);
		}
		setStateFromJSON(e) {
			const t = JSON.parse(e);
			if (t.arcballState != null) {
				this._cameraMatrixState.fromArray(t.arcballState.cameraMatrix.elements),
					this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale),
					this.camera.up.copy(t.arcballState.cameraUp),
					(this.camera.near = t.arcballState.cameraNear),
					(this.camera.far = t.arcballState.cameraFar),
					(this.camera.zoom = t.arcballState.cameraZoom),
					this.camera.isPerspectiveCamera && (this.camera.fov = t.arcballState.cameraFov),
					this._gizmoMatrixState.fromArray(t.arcballState.gizmoMatrix.elements),
					this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale),
					this.camera.updateMatrix(),
					this.camera.updateProjectionMatrix(),
					this._gizmos.updateMatrix(),
					(this._tbRadius = this.calculateTbRadius(this.camera));
				const i = new pt().copy(this._gizmoMatrixState0);
				this.makeGizmos(this._gizmos.position, this._tbRadius), this._gizmoMatrixState0.copy(i), this.camera.lookAt(this._gizmos.position), this.updateTbState(et.IDLE, !1), this.dispatchEvent(Jt);
			}
		}
	}
	function qO() {
		const n = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;
		this._tbRadius = this.calculateTbRadius(this.camera);
		const e = this._tbRadius / n,
			i = new Ms(0, 0, e, e).getPoints(this._curvePts),
			r = new bt().setFromPoints(i);
		for (const s in this._gizmos.children) this._gizmos.children[s].geometry = r;
		this.dispatchEvent(Jt);
	}
	function jO(n) {
		if (this.enabled) {
			for (let e = 0; e < this.mouseActions.length; e++)
				if (this.mouseActions[e].mouse == 2) {
					n.preventDefault();
					break;
				}
		}
	}
	function YO() {
		this._touchStart.splice(0, this._touchStart.length), this._touchCurrent.splice(0, this._touchCurrent.length), (this._input = Wt.NONE);
	}
	function KO(n) {
		if ((n.button == 0 && n.isPrimary ? ((this._downValid = !0), this._downEvents.push(n), (this._downStart = performance.now())) : (this._downValid = !1), n.pointerType == "touch" && this._input != Wt.CURSOR))
			switch ((this._touchStart.push(n), this._touchCurrent.push(n), this._input)) {
				case Wt.NONE:
					(this._input = Wt.ONE_FINGER), this.onSinglePanStart(n, "ROTATE"), window.addEventListener("pointermove", this._onPointerMove), window.addEventListener("pointerup", this._onPointerUp);
					break;
				case Wt.ONE_FINGER:
				case Wt.ONE_FINGER_SWITCHED:
					(this._input = Wt.TWO_FINGER), this.onRotateStart(), this.onPinchStart(), this.onDoublePanStart();
					break;
				case Wt.TWO_FINGER:
					(this._input = Wt.MULT_FINGER), this.onTriplePanStart(n);
					break;
			}
		else if (n.pointerType != "touch" && this._input == Wt.NONE) {
			let e = null;
			n.ctrlKey || n.metaKey ? (e = "CTRL") : n.shiftKey && (e = "SHIFT"), (this._mouseOp = this.getOpFromAction(n.button, e)), this._mouseOp != null && (window.addEventListener("pointermove", this._onPointerMove), window.addEventListener("pointerup", this._onPointerUp), (this._input = Wt.CURSOR), (this._button = n.button), this.onSinglePanStart(n, this._mouseOp));
		}
	}
	function ZO(n) {
		if (n.pointerType == "touch" && this._input != Wt.CURSOR)
			switch (this._input) {
				case Wt.ONE_FINGER:
					this.updateTouchEvent(n), this.onSinglePanMove(n, et.ROTATE);
					break;
				case Wt.ONE_FINGER_SWITCHED:
					if (this.calculatePointersDistance(this._touchCurrent[0], n) * this._devPxRatio >= this._switchSensibility) {
						(this._input = Wt.ONE_FINGER), this.updateTouchEvent(n), this.onSinglePanStart(n, "ROTATE");
						break;
					}
					break;
				case Wt.TWO_FINGER:
					this.updateTouchEvent(n), this.onRotateMove(), this.onPinchMove(), this.onDoublePanMove();
					break;
				case Wt.MULT_FINGER:
					this.updateTouchEvent(n), this.onTriplePanMove(n);
					break;
			}
		else if (n.pointerType != "touch" && this._input == Wt.CURSOR) {
			let e = null;
			n.ctrlKey || n.metaKey ? (e = "CTRL") : n.shiftKey && (e = "SHIFT");
			const t = this.getOpStateFromAction(this._button, e);
			t != null && this.onSinglePanMove(n, t);
		}
		this._downValid && this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], n) * this._devPxRatio > this._movementThreshold && (this._downValid = !1);
	}
	function JO(n) {
		if (n.pointerType == "touch" && this._input != Wt.CURSOR) {
			const e = this._touchCurrent.length;
			for (let t = 0; t < e; t++)
				if (this._touchCurrent[t].pointerId == n.pointerId) {
					this._touchCurrent.splice(t, 1), this._touchStart.splice(t, 1);
					break;
				}
			switch (this._input) {
				case Wt.ONE_FINGER:
				case Wt.ONE_FINGER_SWITCHED:
					window.removeEventListener("pointermove", this._onPointerMove), window.removeEventListener("pointerup", this._onPointerUp), (this._input = Wt.NONE), this.onSinglePanEnd();
					break;
				case Wt.TWO_FINGER:
					this.onDoublePanEnd(n), this.onPinchEnd(n), this.onRotateEnd(n), (this._input = Wt.ONE_FINGER_SWITCHED);
					break;
				case Wt.MULT_FINGER:
					this._touchCurrent.length == 0 && (window.removeEventListener("pointermove", this._onPointerMove), window.removeEventListener("pointerup", this._onPointerUp), (this._input = Wt.NONE), this.onTriplePanEnd());
					break;
			}
		} else n.pointerType != "touch" && this._input == Wt.CURSOR && (window.removeEventListener("pointermove", this._onPointerMove), window.removeEventListener("pointerup", this._onPointerUp), (this._input = Wt.NONE), this.onSinglePanEnd(), (this._button = -1));
		if (n.isPrimary)
			if (this._downValid)
				if (n.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp <= this._maxDownTime)
					if (this._nclicks == 0) (this._nclicks = 1), (this._clickStart = performance.now());
					else {
						const t = n.timeStamp - this._clickStart,
							i = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;
						t <= this._maxInterval && i <= this._posThreshold ? ((this._nclicks = 0), this._downEvents.splice(0, this._downEvents.length), this.onDoubleTap(n)) : ((this._nclicks = 1), this._downEvents.shift(), (this._clickStart = performance.now()));
					}
				else (this._downValid = !1), (this._nclicks = 0), this._downEvents.splice(0, this._downEvents.length);
			else (this._nclicks = 0), this._downEvents.splice(0, this._downEvents.length);
	}
	function QO(n) {
		if (this.enabled && this.enableZoom) {
			let e = null;
			n.ctrlKey || n.metaKey ? (e = "CTRL") : n.shiftKey && (e = "SHIFT");
			const t = this.getOpFromAction("WHEEL", e);
			if (t != null) {
				n.preventDefault(), this.dispatchEvent(Yi);
				const i = 125;
				let r = n.deltaY / i,
					s = 1;
				switch ((r > 0 ? (s = 1 / this.scaleFactor) : r < 0 && (s = this.scaleFactor), t)) {
					case "ZOOM":
						if ((this.updateTbState(et.SCALE, !0), r > 0 ? (s = 1 / Math.pow(this.scaleFactor, r)) : r < 0 && (s = Math.pow(this.scaleFactor, -r)), this.cursorZoom && this.enablePan)) {
							let a;
							this.camera.isOrthographicCamera
								? (a = this.unprojectOnTbPlane(this.camera, n.clientX, n.clientY, this.domElement)
										.applyQuaternion(this.camera.quaternion)
										.multiplyScalar(1 / this.camera.zoom)
										.add(this._gizmos.position))
								: this.camera.isPerspectiveCamera && (a = this.unprojectOnTbPlane(this.camera, n.clientX, n.clientY, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position)),
								this.applyTransformMatrix(this.scale(s, a));
						} else this.applyTransformMatrix(this.scale(s, this._gizmos.position));
						this._grid != null && (this.disposeGrid(), this.drawGrid()), this.updateTbState(et.IDLE, !1), this.dispatchEvent(Jt), this.dispatchEvent(Li);
						break;
					case "FOV":
						if (this.camera.isPerspectiveCamera) {
							this.updateTbState(et.FOV, !0), n.deltaX != 0 && ((r = n.deltaX / i), (s = 1), r > 0 ? (s = 1 / Math.pow(this.scaleFactor, r)) : r < 0 && (s = Math.pow(this.scaleFactor, -r))), this._v3_1.setFromMatrixPosition(this._cameraMatrixState);
							const a = this._v3_1.distanceTo(this._gizmos.position);
							let o = a / s;
							o = an.clamp(o, this.minDistance, this.maxDistance);
							const l = a * Math.tan(an.DEG2RAD * this.camera.fov * 0.5);
							let c = an.RAD2DEG * (Math.atan(l / o) * 2);
							c > this.maxFov ? (c = this.maxFov) : c < this.minFov && (c = this.minFov);
							const u = l / Math.tan(an.DEG2RAD * (c / 2));
							(s = a / u), this.setFov(c), this.applyTransformMatrix(this.scale(s, this._gizmos.position, !1));
						}
						this._grid != null && (this.disposeGrid(), this.drawGrid()), this.updateTbState(et.IDLE, !1), this.dispatchEvent(Jt), this.dispatchEvent(Li);
						break;
				}
			}
		}
	}
	class eI extends on {
		constructor(e, t) {
			super(), (this.isViewHelper = !0), (this.animating = !1), (this.center = new D());
			const i = new rt("#ff4466"),
				r = new rt("#88ff44"),
				s = new rt("#4488ff"),
				a = new rt("#000000"),
				o = {},
				l = [],
				c = new tm(),
				u = new Se(),
				h = new on(),
				d = new ec(-2, 2, 2, -2, 0, 4);
			d.position.set(0, 0, 2);
			const f = new xn(0.04, 0.04, 0.8, 5).rotateZ(-Math.PI / 2).translate(0.4, 0, 0),
				v = new Re(f, ue(i)),
				_ = new Re(f, ue(r)),
				p = new Re(f, ue(s));
			(_.rotation.z = Math.PI / 2), (p.rotation.y = -Math.PI / 2), this.add(v), this.add(p), this.add(_);
			const g = ae(i),
				x = ae(r),
				b = ae(s),
				T = ae(a),
				P = new ao(g),
				A = new ao(x),
				M = new ao(b),
				w = new ao(T),
				y = new ao(T),
				S = new ao(T);
			(P.position.x = 1),
				(A.position.y = 1),
				(M.position.z = 1),
				(w.position.x = -1),
				(y.position.y = -1),
				(S.position.z = -1),
				(w.material.opacity = 0.2),
				(y.material.opacity = 0.2),
				(S.material.opacity = 0.2),
				(P.userData.type = "posX"),
				(A.userData.type = "posY"),
				(M.userData.type = "posZ"),
				(w.userData.type = "negX"),
				(y.userData.type = "negY"),
				(S.userData.type = "negZ"),
				this.add(P),
				this.add(A),
				this.add(M),
				this.add(w),
				this.add(y),
				this.add(S),
				l.push(P),
				l.push(A),
				l.push(M),
				l.push(w),
				l.push(y),
				l.push(S);
			const L = new D(),
				N = 128,
				k = 2 * Math.PI;
			this.render = function (Z) {
				this.quaternion.copy(e.quaternion).invert(), this.updateMatrixWorld(), L.set(0, 0, 1), L.applyQuaternion(e.quaternion);
				const ie = t.offsetWidth - N;
				Z.clearDepth(), Z.getViewport(X), Z.setViewport(ie, 0, N, N), Z.render(this, d), Z.setViewport(X.x, X.y, X.z, X.w);
			};
			const B = new D(),
				W = new En(),
				H = new En(),
				z = new En(),
				X = new wn();
			let K = 0;
			(this.handleClick = function (Z) {
				if (this.animating === !0) return !1;
				const ie = t.getBoundingClientRect(),
					ge = ie.left + (t.offsetWidth - N),
					V = ie.top + (t.offsetHeight - N);
				(u.x = ((Z.clientX - ge) / (ie.right - ge)) * 2 - 1), (u.y = -((Z.clientY - V) / (ie.bottom - V)) * 2 + 1), c.setFromCamera(u, d);
				const j = c.intersectObjects(l);
				if (j.length > 0) {
					const xe = j[0].object;
					return G(xe, this.center), (this.animating = !0), !0;
				} else return !1;
			}),
				(this.setLabels = function (Z, ie, ge) {
					(o.labelX = Z), (o.labelY = ie), (o.labelZ = ge), Ue();
				}),
				(this.setLabelStyle = function (Z, ie, ge) {
					(o.font = Z), (o.color = ie), (o.radius = ge), Ue();
				}),
				(this.update = function (Z) {
					const ie = Z * k;
					H.rotateTowards(z, ie), e.position.set(0, 0, 1).applyQuaternion(H).multiplyScalar(K).add(this.center), e.quaternion.rotateTowards(W, ie), H.angleTo(z) === 0 && (this.animating = !1);
				}),
				(this.dispose = function () {
					f.dispose(), v.material.dispose(), _.material.dispose(), p.material.dispose(), P.material.map.dispose(), A.material.map.dispose(), M.material.map.dispose(), w.material.map.dispose(), y.material.map.dispose(), S.material.map.dispose(), P.material.dispose(), A.material.dispose(), M.material.dispose(), w.material.dispose(), y.material.dispose(), S.material.dispose();
				});
			function G(Z, ie) {
				switch (Z.userData.type) {
					case "posX":
						B.set(1, 0, 0), W.setFromEuler(new Un(0, Math.PI * 0.5, 0));
						break;
					case "posY":
						B.set(0, 1, 0), W.setFromEuler(new Un(-Math.PI * 0.5, 0, 0));
						break;
					case "posZ":
						B.set(0, 0, 1), W.setFromEuler(new Un());
						break;
					case "negX":
						B.set(-1, 0, 0), W.setFromEuler(new Un(0, -Math.PI * 0.5, 0));
						break;
					case "negY":
						B.set(0, -1, 0), W.setFromEuler(new Un(Math.PI * 0.5, 0, 0));
						break;
					case "negZ":
						B.set(0, 0, -1), W.setFromEuler(new Un(0, Math.PI, 0));
						break;
					default:
						console.error("ViewHelper: Invalid axis.");
				}
				(K = e.position.distanceTo(ie)), B.multiplyScalar(K).add(ie), h.position.copy(ie), h.lookAt(e.position), H.copy(h.quaternion), h.lookAt(B), z.copy(h.quaternion);
			}
			function ue(Z) {
				return new Kt({ color: Z, toneMapped: !1 });
			}
			function ae(Z, ie) {
				const { font: ge = "24px Arial", color: V = "#000000", radius: j = 14 } = o,
					he = document.createElement("canvas");
				(he.width = 64), (he.height = 64);
				const xe = he.getContext("2d");
				xe.beginPath(), xe.arc(32, 32, j, 0, 2 * Math.PI), xe.closePath(), (xe.fillStyle = Z.getStyle()), xe.fill(), ie && ((xe.font = ge), (xe.textAlign = "center"), (xe.fillStyle = V), xe.fillText(ie, 32, 41));
				const He = new iO(he);
				return (He.colorSpace = ni), new fx({ map: He, toneMapped: !1 });
			}
			function Ue() {
				P.material.map.dispose(), A.material.map.dispose(), M.material.map.dispose(), P.material.dispose(), A.material.dispose(), M.material.dispose(), (P.material = ae(i, o.labelX)), (A.material = ae(r, o.labelY)), (M.material = ae(s, o.labelZ));
			}
		}
	}
	function tI(n, e) {
		return (e.controls = n), (n.rotateSpeed = 1), (n.enableRotate = !0), (n.enableZoom = !0), (n.enablePan = !0), (n.zoomSpeed = 1), (n.panSpeed = 1), (n.cursorZoom = !0), (n.enableGrid = !0), n.activateGizmos(!1), n.setGizmosVisible(!1), ft.updateProjectionMatrix(), n.update(), { controls: n, viewHelper: e };
	}
	const Qs = new tm(),
		qn = new D(),
		fs = new D(),
		sn = new En(),
		L0 = { X: new D(1, 0, 0), Y: new D(0, 1, 0), Z: new D(0, 0, 1) },
		Wd = { type: "change" },
		R0 = { type: "mouseDown", mode: null },
		P0 = { type: "mouseUp", mode: null },
		D0 = { type: "objectChange" };
	class nI extends on {
		constructor(e, t) {
			super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), (t = document)), (this.isTransformControls = !0), (this.visible = !1), (this.domElement = t), (this.domElement.style.touchAction = "none");
			const i = new lI();
			(this._gizmo = i), this.add(i);
			const r = new cI();
			(this._plane = r), this.add(r);
			const s = this;
			function a(x, b) {
				let T = b;
				Object.defineProperty(s, x, {
					get: function () {
						return T !== void 0 ? T : b;
					},
					set: function (P) {
						T !== P && ((T = P), (r[x] = P), (i[x] = P), s.dispatchEvent({ type: x + "-changed", value: P }), s.dispatchEvent(Wd));
					}
				}),
					(s[x] = b),
					(r[x] = b),
					(i[x] = b);
			}
			a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
			const o = new D(),
				l = new D(),
				c = new En(),
				u = new En(),
				h = new D(),
				d = new En(),
				f = new D(),
				v = new D(),
				_ = new D(),
				p = 0,
				g = new D();
			a("worldPosition", o),
				a("worldPositionStart", l),
				a("worldQuaternion", c),
				a("worldQuaternionStart", u),
				a("cameraPosition", h),
				a("cameraQuaternion", d),
				a("pointStart", f),
				a("pointEnd", v),
				a("rotationAxis", _),
				a("rotationAngle", p),
				a("eye", g),
				(this._offset = new D()),
				(this._startNorm = new D()),
				(this._endNorm = new D()),
				(this._cameraScale = new D()),
				(this._parentPosition = new D()),
				(this._parentQuaternion = new En()),
				(this._parentQuaternionInv = new En()),
				(this._parentScale = new D()),
				(this._worldScaleStart = new D()),
				(this._worldQuaternionInv = new En()),
				(this._worldScale = new D()),
				(this._positionStart = new D()),
				(this._quaternionStart = new En()),
				(this._scaleStart = new D()),
				(this._getPointer = iI.bind(this)),
				(this._onPointerDown = sI.bind(this)),
				(this._onPointerHover = rI.bind(this)),
				(this._onPointerMove = aI.bind(this)),
				(this._onPointerUp = oI.bind(this)),
				this.domElement.addEventListener("pointerdown", this._onPointerDown),
				this.domElement.addEventListener("pointermove", this._onPointerHover),
				this.domElement.addEventListener("pointerup", this._onPointerUp);
		}
		updateMatrixWorld(e) {
			this.object !== void 0 &&
				(this.object.updateMatrixWorld(),
				this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale),
				this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale),
				this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
				this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
				this.camera.updateMatrixWorld(),
				this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale),
				this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),
				super.updateMatrixWorld(e);
		}
		pointerHover(e) {
			if (this.object === void 0 || this.dragging === !0) return;
			e !== null && Qs.setFromCamera(e, this.camera);
			const t = Xd(this._gizmo.picker[this.mode], Qs);
			t ? (this.axis = t.object.name) : (this.axis = null);
		}
		pointerDown(e) {
			if (!(this.object === void 0 || this.dragging === !0 || (e != null && e.button !== 0)) && this.axis !== null) {
				e !== null && Qs.setFromCamera(e, this.camera);
				const t = Xd(this._plane, Qs, !0);
				t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), (this.dragging = !0), (R0.mode = this.mode), this.dispatchEvent(R0);
			}
		}
		pointerMove(e) {
			const t = this.axis,
				i = this.mode,
				r = this.object;
			let s = this.space;
			if ((i === "scale" ? (s = "local") : (t === "E" || t === "XYZE" || t === "XYZ") && (s = "world"), r === void 0 || t === null || this.dragging === !1 || (e !== null && e.button !== -1))) return;
			e !== null && Qs.setFromCamera(e, this.camera);
			const a = Xd(this._plane, Qs, !0);
			if (a) {
				if ((this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate"))
					this._offset.copy(this.pointEnd).sub(this.pointStart),
						s === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv),
						t.indexOf("X") === -1 && (this._offset.x = 0),
						t.indexOf("Y") === -1 && (this._offset.y = 0),
						t.indexOf("Z") === -1 && (this._offset.z = 0),
						s === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),
						r.position.copy(this._offset).add(this._positionStart),
						this.translationSnap &&
							(s === "local" &&
								(r.position.applyQuaternion(sn.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)),
							s === "world" &&
								(r.parent && r.position.add(qn.setFromMatrixPosition(r.parent.matrixWorld)),
								t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap),
								t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap),
								t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap),
								r.parent && r.position.sub(qn.setFromMatrixPosition(r.parent.matrixWorld))));
				else if (i === "scale") {
					if (t.search("XYZ") !== -1) {
						let o = this.pointEnd.length() / this.pointStart.length();
						this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), fs.set(o, o, o);
					} else qn.copy(this.pointStart), fs.copy(this.pointEnd), qn.applyQuaternion(this._worldQuaternionInv), fs.applyQuaternion(this._worldQuaternionInv), fs.divide(qn), t.search("X") === -1 && (fs.x = 1), t.search("Y") === -1 && (fs.y = 1), t.search("Z") === -1 && (fs.z = 1);
					r.scale.copy(this._scaleStart).multiply(fs), this.scaleSnap && (t.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
				} else if (i === "rotate") {
					this._offset.copy(this.pointEnd).sub(this.pointStart);
					const o = 20 / this.worldPosition.distanceTo(qn.setFromMatrixPosition(this.camera.matrixWorld));
					let l = !1;
					t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), (this.rotationAngle = this._offset.dot(qn.copy(this.rotationAxis).cross(this.eye)) * o)) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(L0[t]), qn.copy(L0[t]), s === "local" && qn.applyQuaternion(this.worldQuaternion), qn.cross(this.eye), qn.length() === 0 ? (l = !0) : (this.rotationAngle = this._offset.dot(qn.normalize()) * o)),
						(t === "E" || l) && (this.rotationAxis.copy(this.eye), (this.rotationAngle = this.pointEnd.angleTo(this.pointStart)), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), (this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1)),
						this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap),
						s === "local" && t !== "E" && t !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(sn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(sn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
				}
				this.dispatchEvent(Wd), this.dispatchEvent(D0);
			}
		}
		pointerUp(e) {
			(e !== null && e.button !== 0) || (this.dragging && this.axis !== null && ((P0.mode = this.mode), this.dispatchEvent(P0)), (this.dragging = !1), (this.axis = null));
		}
		dispose() {
			this.domElement.removeEventListener("pointerdown", this._onPointerDown),
				this.domElement.removeEventListener("pointermove", this._onPointerHover),
				this.domElement.removeEventListener("pointermove", this._onPointerMove),
				this.domElement.removeEventListener("pointerup", this._onPointerUp),
				this.traverse(function (e) {
					e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
				});
		}
		attach(e) {
			return (this.object = e), (this.visible = !0), this;
		}
		detach() {
			return (this.object = void 0), (this.visible = !1), (this.axis = null), this;
		}
		reset() {
			this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Wd), this.dispatchEvent(D0), this.pointStart.copy(this.pointEnd));
		}
		getRaycaster() {
			return Qs;
		}
		getMode() {
			return this.mode;
		}
		setMode(e) {
			this.mode = e;
		}
		setTranslationSnap(e) {
			this.translationSnap = e;
		}
		setRotationSnap(e) {
			this.rotationSnap = e;
		}
		setScaleSnap(e) {
			this.scaleSnap = e;
		}
		setSize(e) {
			this.size = e;
		}
		setSpace(e) {
			this.space = e;
		}
	}
	function iI(n) {
		if (this.domElement.ownerDocument.pointerLockElement) return { x: 0, y: 0, button: n.button };
		{
			const e = this.domElement.getBoundingClientRect();
			return { x: ((n.clientX - e.left) / e.width) * 2 - 1, y: (-(n.clientY - e.top) / e.height) * 2 + 1, button: n.button };
		}
	}
	function rI(n) {
		if (this.enabled)
			switch (n.pointerType) {
				case "mouse":
				case "pen":
					this.pointerHover(this._getPointer(n));
					break;
			}
	}
	function sI(n) {
		this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(n.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(n)), this.pointerDown(this._getPointer(n)));
	}
	function aI(n) {
		this.enabled && this.pointerMove(this._getPointer(n));
	}
	function oI(n) {
		this.enabled && (this.domElement.releasePointerCapture(n.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(n)));
	}
	function Xd(n, e, t) {
		const i = e.intersectObject(n, !0);
		for (let r = 0; r < i.length; r++) if (i[r].object.visible || t) return i[r];
		return !1;
	}
	const du = new Un(),
		Yt = new D(0, 1, 0),
		O0 = new D(0, 0, 0),
		I0 = new pt(),
		fu = new En(),
		Fu = new En(),
		dr = new D(),
		F0 = new pt(),
		Sl = new D(1, 0, 0),
		sa = new D(0, 1, 0),
		El = new D(0, 0, 1),
		pu = new D(),
		ml = new D(),
		gl = new D();
	class lI extends on {
		constructor() {
			super(), (this.isTransformControlsGizmo = !0), (this.type = "TransformControlsGizmo");
			const e = new Kt({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }),
				t = new Fi({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }),
				i = e.clone();
			i.opacity = 0.15;
			const r = t.clone();
			r.opacity = 0.5;
			const s = e.clone();
			s.color.setHex(16711680);
			const a = e.clone();
			a.color.setHex(65280);
			const o = e.clone();
			o.color.setHex(255);
			const l = e.clone();
			l.color.setHex(16711680), (l.opacity = 0.5);
			const c = e.clone();
			c.color.setHex(65280), (c.opacity = 0.5);
			const u = e.clone();
			u.color.setHex(255), (u.opacity = 0.5);
			const h = e.clone();
			h.opacity = 0.25;
			const d = e.clone();
			d.color.setHex(16776960), (d.opacity = 0.25), e.clone().color.setHex(16776960);
			const v = e.clone();
			v.color.setHex(7895160);
			const _ = new xn(0, 0.04, 0.1, 12);
			_.translate(0, 0.05, 0);
			const p = new yn(0.08, 0.08, 0.08);
			p.translate(0, 0.04, 0);
			const g = new bt();
			g.setAttribute("position", new Tt([0, 0, 0, 1, 0, 0], 3));
			const x = new xn(0.0075, 0.0075, 0.5, 3);
			x.translate(0, 0.25, 0);
			function b(W, H) {
				const z = new zr(W, 0.0075, 3, 64, H * Math.PI * 2);
				return z.rotateY(Math.PI / 2), z.rotateX(Math.PI / 2), z;
			}
			function T() {
				const W = new bt();
				return W.setAttribute("position", new Tt([0, 0, 0, 1, 1, 1], 3)), W;
			}
			const P = {
					X: [
						[new Re(_, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
						[new Re(_, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
						[new Re(x, s), [0, 0, 0], [0, 0, -Math.PI / 2]]
					],
					Y: [[new Re(_, a), [0, 0.5, 0]], [new Re(_, a), [0, -0.5, 0], [Math.PI, 0, 0]], [new Re(x, a)]],
					Z: [
						[new Re(_, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
						[new Re(_, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
						[new Re(x, o), null, [Math.PI / 2, 0, 0]]
					],
					XYZ: [[new Re(new yo(0.1, 0), h.clone()), [0, 0, 0]]],
					XY: [[new Re(new yn(0.15, 0.15, 0.01), u.clone()), [0.15, 0.15, 0]]],
					YZ: [[new Re(new yn(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
					XZ: [[new Re(new yn(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]
				},
				A = {
					X: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
					],
					Y: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
					],
					Z: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
					],
					XYZ: [[new Re(new yo(0.2, 0), i)]],
					XY: [[new Re(new yn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]],
					YZ: [[new Re(new yn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
					XZ: [[new Re(new yn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]
				},
				M = { START: [[new Re(new yo(0.01, 2), r), null, null, null, "helper"]], END: [[new Re(new yo(0.01, 2), r), null, null, null, "helper"]], DELTA: [[new Sn(T(), r), null, null, null, "helper"]], X: [[new Sn(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Sn(g, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Sn(g, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] },
				w = { XYZE: [[new Re(b(0.5, 1), v), null, [0, Math.PI / 2, 0]]], X: [[new Re(b(0.5, 0.5), s)]], Y: [[new Re(b(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]], Z: [[new Re(b(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]], E: [[new Re(b(0.75, 1), d), null, [0, Math.PI / 2, 0]]] },
				y = { AXIS: [[new Sn(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] },
				S = { XYZE: [[new Re(new Qp(0.25, 10, 8), i)]], X: [[new Re(new zr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new Re(new zr(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new Re(new zr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new Re(new zr(0.75, 0.1, 2, 24), i)]] },
				L = {
					X: [
						[new Re(p, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
						[new Re(x, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
						[new Re(p, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
					],
					Y: [[new Re(p, a), [0, 0.5, 0]], [new Re(x, a)], [new Re(p, a), [0, -0.5, 0], [0, 0, Math.PI]]],
					Z: [
						[new Re(p, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
						[new Re(x, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
						[new Re(p, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
					],
					XY: [[new Re(new yn(0.15, 0.15, 0.01), u), [0.15, 0.15, 0]]],
					YZ: [[new Re(new yn(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
					XZ: [[new Re(new yn(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]],
					XYZ: [[new Re(new yn(0.1, 0.1, 0.1), h.clone())]]
				},
				N = {
					X: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
					],
					Y: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
					],
					Z: [
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
						[new Re(new xn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
					],
					XY: [[new Re(new yn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]],
					YZ: [[new Re(new yn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
					XZ: [[new Re(new yn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]],
					XYZ: [[new Re(new yn(0.2, 0.2, 0.2), i), [0, 0, 0]]]
				},
				k = { X: [[new Sn(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Sn(g, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Sn(g, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
			function B(W) {
				const H = new on();
				for (const z in W)
					for (let X = W[z].length; X--; ) {
						const K = W[z][X][0].clone(),
							G = W[z][X][1],
							ue = W[z][X][2],
							ae = W[z][X][3],
							Ue = W[z][X][4];
						(K.name = z), (K.tag = Ue), G && K.position.set(G[0], G[1], G[2]), ue && K.rotation.set(ue[0], ue[1], ue[2]), ae && K.scale.set(ae[0], ae[1], ae[2]), K.updateMatrix();
						const Z = K.geometry.clone();
						Z.applyMatrix4(K.matrix), (K.geometry = Z), (K.renderOrder = 1 / 0), K.position.set(0, 0, 0), K.rotation.set(0, 0, 0), K.scale.set(1, 1, 1), H.add(K);
					}
				return H;
			}
			(this.gizmo = {}),
				(this.picker = {}),
				(this.helper = {}),
				this.add((this.gizmo.translate = B(P))),
				this.add((this.gizmo.rotate = B(w))),
				this.add((this.gizmo.scale = B(L))),
				this.add((this.picker.translate = B(A))),
				this.add((this.picker.rotate = B(S))),
				this.add((this.picker.scale = B(N))),
				this.add((this.helper.translate = B(M))),
				this.add((this.helper.rotate = B(y))),
				this.add((this.helper.scale = B(k))),
				(this.picker.translate.visible = !1),
				(this.picker.rotate.visible = !1),
				(this.picker.scale.visible = !1);
		}
		updateMatrixWorld(e) {
			const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Fu;
			(this.gizmo.translate.visible = this.mode === "translate"), (this.gizmo.rotate.visible = this.mode === "rotate"), (this.gizmo.scale.visible = this.mode === "scale"), (this.helper.translate.visible = this.mode === "translate"), (this.helper.rotate.visible = this.mode === "rotate"), (this.helper.scale.visible = this.mode === "scale");
			let r = [];
			(r = r.concat(this.picker[this.mode].children)), (r = r.concat(this.gizmo[this.mode].children)), (r = r.concat(this.helper[this.mode].children));
			for (let s = 0; s < r.length; s++) {
				const a = r[s];
				(a.visible = !0), a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
				let o;
				if ((this.camera.isOrthographicCamera ? (o = (this.camera.top - this.camera.bottom) / this.camera.zoom) : (o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min((1.9 * Math.tan((Math.PI * this.camera.fov) / 360)) / this.camera.zoom, 7)), a.scale.set(1, 1, 1).multiplyScalar((o * this.size) / 4), a.tag === "helper")) {
					(a.visible = !1),
						a.name === "AXIS"
							? ((a.visible = !!this.axis),
							  this.axis === "X" && (sn.setFromEuler(du.set(0, 0, 0)), a.quaternion.copy(i).multiply(sn), Math.abs(Yt.copy(Sl).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)),
							  this.axis === "Y" && (sn.setFromEuler(du.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(sn), Math.abs(Yt.copy(sa).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)),
							  this.axis === "Z" && (sn.setFromEuler(du.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(sn), Math.abs(Yt.copy(El).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)),
							  this.axis === "XYZE" && (sn.setFromEuler(du.set(0, Math.PI / 2, 0)), Yt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(I0.lookAt(O0, Yt, sa)), a.quaternion.multiply(sn), (a.visible = this.dragging)),
							  this.axis === "E" && (a.visible = !1))
							: a.name === "START"
							? (a.position.copy(this.worldPositionStart), (a.visible = this.dragging))
							: a.name === "END"
							? (a.position.copy(this.worldPosition), (a.visible = this.dragging))
							: a.name === "DELTA"
							? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), qn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), qn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(qn), (a.visible = this.dragging))
							: (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
					continue;
				}
				a.quaternion.copy(i),
					this.mode === "translate" || this.mode === "scale"
						? (a.name === "X" && Math.abs(Yt.copy(Sl).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
						  a.name === "Y" && Math.abs(Yt.copy(sa).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
						  a.name === "Z" && Math.abs(Yt.copy(El).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
						  a.name === "XY" && Math.abs(Yt.copy(El).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
						  a.name === "YZ" && Math.abs(Yt.copy(Sl).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
						  a.name === "XZ" && Math.abs(Yt.copy(sa).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)))
						: this.mode === "rotate" &&
						  (fu.copy(i),
						  Yt.copy(this.eye).applyQuaternion(sn.copy(i).invert()),
						  a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(I0.lookAt(this.eye, O0, sa)),
						  a.name === "X" && (sn.setFromAxisAngle(Sl, Math.atan2(-Yt.y, Yt.z)), sn.multiplyQuaternions(fu, sn), a.quaternion.copy(sn)),
						  a.name === "Y" && (sn.setFromAxisAngle(sa, Math.atan2(Yt.x, Yt.z)), sn.multiplyQuaternions(fu, sn), a.quaternion.copy(sn)),
						  a.name === "Z" && (sn.setFromAxisAngle(El, Math.atan2(Yt.y, Yt.x)), sn.multiplyQuaternions(fu, sn), a.quaternion.copy(sn))),
					(a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX)),
					(a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY)),
					(a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ)),
					(a.visible = a.visible && (a.name.indexOf("E") === -1 || (this.showX && this.showY && this.showZ))),
					(a.material._color = a.material._color || a.material.color.clone()),
					(a.material._opacity = a.material._opacity || a.material.opacity),
					a.material.color.copy(a.material._color),
					(a.material.opacity = a.material._opacity),
					this.enabled &&
						this.axis &&
						(a.name === this.axis ||
							this.axis.split("").some(function (l) {
								return a.name === l;
							})) &&
						(a.material.color.setHex(16776960), (a.material.opacity = 1));
			}
			super.updateMatrixWorld(e);
		}
	}
	class cI extends Re {
		constructor() {
			super(new Ql(1e5, 1e5, 2, 2), new Kt({ visible: !1, wireframe: !0, side: An, transparent: !0, opacity: 0.1, toneMapped: !1 })), (this.isTransformControlsPlane = !0), (this.type = "TransformControlsPlane");
		}
		updateMatrixWorld(e) {
			let t = this.space;
			switch ((this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), pu.copy(Sl).applyQuaternion(t === "local" ? this.worldQuaternion : Fu), ml.copy(sa).applyQuaternion(t === "local" ? this.worldQuaternion : Fu), gl.copy(El).applyQuaternion(t === "local" ? this.worldQuaternion : Fu), Yt.copy(ml), this.mode)) {
				case "translate":
				case "scale":
					switch (this.axis) {
						case "X":
							Yt.copy(this.eye).cross(pu), dr.copy(pu).cross(Yt);
							break;
						case "Y":
							Yt.copy(this.eye).cross(ml), dr.copy(ml).cross(Yt);
							break;
						case "Z":
							Yt.copy(this.eye).cross(gl), dr.copy(gl).cross(Yt);
							break;
						case "XY":
							dr.copy(gl);
							break;
						case "YZ":
							dr.copy(pu);
							break;
						case "XZ":
							Yt.copy(gl), dr.copy(ml);
							break;
						case "XYZ":
						case "E":
							dr.set(0, 0, 0);
							break;
					}
					break;
				case "rotate":
				default:
					dr.set(0, 0, 0);
			}
			dr.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (F0.lookAt(qn.set(0, 0, 0), dr, Yt), this.quaternion.setFromRotationMatrix(F0)), super.updateMatrixWorld(e);
		}
	}
	const Mx = (n, e, t, i, r) => {
			addEventListener("keydown", function (s) {
				switch (s.key) {
					case "r":
						r || (t.activateGizmos(!0), t.setGizmosVisible(!0), (t.enableRotate = !0), console.log("rotate (r) pressed - controls.enableRotate = true"), (t.enableZoom = !0), (t.enablePan = !1), (t.cursorZoom = !1)), t.target.set(e.position.x, e.position.y, e.position.z), n.lookAt(t.target), n.updateProjectionMatrix(), t.update();
						break;
					case "p":
						(e.visible = !1),
							r || (console.log("pan (p) pressed - enabling TransformControls"), (r = new nI(n, ti.domElement)), r.attach(e), Bt.add(r), (t.enableRotate = !1), (r.name = "TransformControls")),
							r.addEventListener("dragging-changed", function (a) {
								t.enabled = !a.value;
							});
						break;
				}
			}),
				addEventListener("keyup", function (s) {
					switch (s.key) {
						case "r":
							r || (t.activateGizmos(!1), t.setGizmosVisible(!1), (t.enableRotate = !0), console.log("rotate (r) released - controls.enableRotate = false"), (t.enableZoom = !0), (t.enablePan = !0), (t.cursorZoom = !0)), n.updateProjectionMatrix(), t.update();
							break;
						case "p":
							console.log("pan (p) released - disabling TransformControls"), (e.visible = !0), r && (r.detach(e), Bt.remove(r), r.dispose(), (r = null)), (t.enableRotate = !0);
							break;
					}
				});
		},
		uI = () => {
			const n = new eI(ft, ti.domElement);
			(n.controls = Ct), (n.controls.center = Ct.target), hI(n), dI(n), n.update();
			const e = document.createElement("div");
			return (e.id = "viewHelper"), (e.style.position = "absolute"), (e.style.right = "10px"), (e.style.bottom = "10px"), (e.style.height = "128px"), (e.style.width = "128px"), n.setLabels("X", "Y", "Z"), document.body.appendChild(e), e.addEventListener("pointerup", (t) => n.handleClick(t)), n;
		};
	function hI(n) {
		const [e, t, i, r, s, a] = n.children.slice(3, 9);
		(r.material = e.material.clone()), (s.material = t.material.clone()), (a.material = i.material.clone()), (r.material.opacity = 0.3), (s.material.opacity = 0.3), (a.material.opacity = 0.3), (r.material.transparent = !0), (s.material.transparent = !0), (a.material.transparent = !0);
	}
	function dI(n) {
		const [e, t, i, r, s, a] = n.children.slice(3, 9),
			o = new D(0, 0, 0);
		$d(o, r.position, r.material.color, n), $d(o, s.position, s.material.color, n), $d(o, a.position, a.material.color, n);
	}
	function $d(n, e, t, i) {
		const r = e.clone().multiplyScalar(0.75),
			s = new bt().setFromPoints([n, r]),
			a = new Fi({ color: t, transparent: !0, opacity: 0.3 }),
			o = new Sn(s, a);
		i.add(o);
	}
	const fI = 0,
		Ri = { frustumSize: 1e3, lightIntensity: 0.6, ambientIntensity: 0.1, directionalLightPosition: { x: 800, y: 500, z: 2e3 }, sceneBackground: fI };
	function pI() {
		const n = () => {
			const { frustumSize: e } = Ri,
				t = window.innerWidth / window.innerHeight;
			ft instanceof ec ? ((ft.left = (-e * t) / 2), (ft.right = (e * t) / 2), (ft.top = e / 2), (ft.bottom = -e / 2)) : ft instanceof fi && (ft.aspect = t), ft.updateProjectionMatrix(), ti.setSize(window.innerWidth, window.innerHeight);
		};
		window.addEventListener("resize", n, !1);
	}
	function qd(n, e, t, i, r, s) {
		const a = new nr({ color: i, emissive: i }),
			o = new xn(0.05, 0.05, t - r, 6),
			l = new Re(o, a);
		l.position.copy(e.clone().addScaledVector(n, (t - r) / 2)), l.quaternion.setFromUnitVectors(new D(0, 1, 0), n.clone().normalize());
		const c = new Kp(s, r, 6),
			u = new Re(c, a);
		u.position.copy(e.clone().addScaledVector(n, t - r / 2)), u.quaternion.setFromUnitVectors(new D(0, 1, 0), n.clone().normalize());
		const h = new Ot();
		return h.add(l), h.add(u), (a.transparent = !0), (a.opacity = 0.5), h;
	}
	const Ai = JSON.parse(localStorage.getItem("WorldOriginSettings"));
	let ft,
		Bt,
		Ct,
		le = {
			worldXCenter: Ai && Ai.worldXCenter !== null ? Ai.worldXCenter : 0,
			worldYCenter: Ai && Ai.worldYCenter !== null ? Ai.worldYCenter : 0,
			worldZCenter: Ai && Ai.worldZCenter !== null ? Ai.worldZCenter : 0,
			cameraDistance: Ai && Ai.cameraDistance !== null ? Ai.cameraDistance : 1e3,
			usePerspectiveCam: !1,
			upDirection: "Z",
			rotationAngle: 0,
			holeDisplay: "mesh-cross",
			holeNameDisplay: !0,
			holeLengthDisplay: !1,
			holeDiameterDisplay: !1,
			wireframeSolidTransparentTexture: "solid",
			debugComments: !0
		},
		ti,
		N0,
		Ax,
		Mo,
		Ao;
	function mI() {
		Bt.background = new rt(Ri.sceneBackground);
		const n = new Ot();
		n.name = "Lighting";
		const e = new zO(16777215, Ri.ambientIntensity),
			t = new eh(16777215, Ri.lightIntensity),
			i = new eh(16777215, Ri.lightIntensity);
		t.position.set(Ri.directionalLightPosition.x, Ri.directionalLightPosition.y, Ri.directionalLightPosition.z),
			i.position.set(-2 * Ri.directionalLightPosition.x, Ri.directionalLightPosition.y, Ri.directionalLightPosition.z),
			(e.name = "Ambient 1"),
			(t.name = "Directional 1"),
			(i.name = "Directional 2"),
			(e.userData = { entityType: "light", lightType: "ambient" }),
			(t.userData = { entityType: "light", lightType: "directional" }),
			(i.userData = { entityType: "light", lightType: "directional" }),
			n.add(e),
			n.add(t),
			n.add(i),
			Bt.add(n);
	}
	function gI(n) {
		const { frustumSize: e } = Ri;
		return (Mo = new fi(35, window.innerWidth / window.innerHeight, 0.001, 1e4)), (Ao = new ec((-e * n) / 2, (e * n) / 2, e / 2, -e / 2, -1e4, 1e4)), new D(0, 0, le.cameraDistance), (ft = le.usePerspectiveCam ? Mo : Ao), { cameraPerspective: Mo, cameraOrthographic: Ao };
	}
	function vI(n, e, t) {
		const i = ft.position.clone();
		console.log("Position: ", i), Ct.target.clone();
		const r = ft.up.clone(),
			s = window.innerWidth / window.innerHeight;
		(Mo.aspect = s),
			Mo.updateProjectionMatrix(),
			(Ao.aspect = s),
			Ao.updateProjectionMatrix(),
			(ft = le.usePerspectiveCam ? Mo : Ao),
			Ct.dispose(),
			(Ct = new nm(ft, ti.domElement, Bt)),
			(viewHelper.controls = Ct),
			(Ct.rotateSpeed = 1),
			(Ct.enableRotate = !0),
			(Ct.enableZoom = !0),
			(Ct.enablePan = !0),
			(Ct.zoomSpeed = 1),
			(Ct.panSpeed = 1),
			(Ct.cursorZoom = !0),
			(Ct.enableGrid = !0),
			Ct.activateGizmos(!1),
			Ct.setGizmosVisible(!1),
			ft.position.copy(i),
			Ct.target.copy(new D(n, e, t)),
			ft.up.copy(r),
			ft.lookAt(new D(n, e, t)),
			Ct.update(),
			ft.updateProjectionMatrix(),
			(ft.userData = { entityType: "camera", isPerspective: le.usePerspectiveCam, isOrthographic: !le.usePerspectiveCam, up: ft.up, cameraLookAt: new D(n, e, t), controlsTarget: new D(n, e, t) }),
			console.log("Camera updated:", ft),
			console.log("Controls updated:", Ct),
			console.log("Camera User Data: ", ft.userData),
			Mx(ft, cn, Ct, viewHelper, Ax);
	}
	let cn = new Ot();
	function _I(n) {
		console.log("createScene(points)", n), (Bt = new tO());
		const e = document.querySelector("#canvas");
		let t = e.offsetWidth / e.offsetHeight;
		(N0 = new GO()),
			(n === null || n.length === 0) && cn.position.set(0, 0, 0),
			cn.add(qd(new D(1, 0, 0), new D(0, 0, 0), 10, 16711680, 5, 2)),
			(cn.children[0].name = "+X Arrow"),
			cn.add(qd(new D(0, 1, 0), new D(0, 0, 0), 10, 65280, 5, 2)),
			(cn.children[1].name = "+Y Arrow"),
			cn.add(qd(new D(0, 0, 1), new D(0, 0, 0), 10, 255, 5, 2)),
			(cn.children[2].name = "+Z Arrow"),
			(cn.name = "Object Center"),
			(cn.material = new Kt({ color: 0, visible: !0, transparent: !0, opacity: 0.5 })),
			Bt.add(cn),
			gI(t),
			(ti = new eO({ antialias: !0, depth: !0, precision: "highp", powerPreference: "high-performance", stencil: !1 })),
			ti.setSize(e.offsetWidth, e.offsetHeight),
			ti.setPixelRatio(window.devicePixelRatio),
			(ti.autoClear = !1),
			e.appendChild(ti.domElement),
			(Ct = new nm(ft, ti.domElement, Bt)),
			mI();
		let i = new D(0, 0, 0);
		ft.position.set(0, 0, parseFloat(le.cameraDistance)), ft.lookAt(0, 0, 0), ft.up.set(0, 1, 0), Ct.target.set(i.x, i.y, i.z), ft.position.copy(i), Ct.target.copy(cn.position), Ct.update();
		let r = uI();
		tI(Ct, r), Mx(ft, cn, Ct, r, Ax), s();
		function s() {
			requestAnimationFrame(s), ti.clear();
			const a = N0.getDelta();
			r.animating && r.update(a), ti.render(Bt, ft), r.render(ti);
		}
		return le.debugComments && console.log("Initialized canvas:", { scene: Bt, camera: ft, renderer: ti }), { scene: Bt, camera: ft, renderer: ti };
	}
	pI();
	function Rl(n) {
		let e = 0,
			t = 0,
			i = 0;
		n.forEach((s) => {
			(e += s.startXLocation), (t += s.startYLocation), (i += s.startZLocation);
		});
		const r = { x: parseFloat((e / n.length).toFixed(3)), y: parseFloat((t / n.length).toFixed(3)), z: parseFloat((i / n.length).toFixed(3)) };
		return console.log("Centroid in getCentroid: ", r), r;
	}
	function U0(n) {
		let e = 0,
			t = 0,
			i = 0;
		n.forEach((s) => {
			(e += s.pointX), (t += s.pointY), (i += s.pointZ);
		});
		const r = { x: parseFloat((e / n.length).toFixed(3)), y: parseFloat((t / n.length).toFixed(3)), z: parseFloat((i / n.length).toFixed(3)) };
		return console.log("Centroid in getPointCloudCentroid: ", r), r;
	}
	function yI() {
		const n = "0123456789ABCDEF";
		let e = "#";
		for (let h = 0; h < 6; h++) e += n[Math.floor(Math.random() * 16)];
		const t = e.substring(1),
			i = parseInt(t, 16),
			r = (i >> 16) & 255,
			s = (i >> 8) & 255,
			a = i & 255,
			o = Math.min(255, r + 0.2 * (255 - r)),
			l = Math.min(255, s + 0.2 * (255 - s)),
			c = Math.min(255, a + 0.2 * (255 - a));
		return "#" + Math.round(o).toString(16).padStart(2, "0") + Math.round(l).toString(16).padStart(2, "0") + Math.round(c).toString(16).padStart(2, "0");
	}
	function Dn(n, e, t, i, r, s) {
		(!(t instanceof D) || !(i instanceof D)) && console.warn("startVector must be an instance of Vector3: ", t, " and endVector must be an instance of Vector3: ", i), (r = r || 500), (r = r / 1e3);
		let a;
		e === "basic" ? (a = new Kt({ color: n })) : e === "phong" ? (a = new nr({ color: n, flatShading: !0 })) : e === "phong-invisible" ? (a = new nr({ color: n, transparent: !0, opacity: 0 })) : (a = new nr({ color: n }));
		const o = t.distanceTo(i),
			l = i.clone().sub(t).normalize(),
			c = t.clone().add(i).multiplyScalar(0.5),
			u = new xn(r / 2, r / 2, o, s),
			h = new Re(u, a);
		return h.position.copy(c), h.quaternion.setFromUnitVectors(new D(0, 1, 0), l), (h.name = "cylinder"), h;
	}
	function jd(n, e, t, i, r, s, a, o) {
		(i = i || 500), (i = i / 1e3), (r = r || 100), (r = r / 1e3), (s = s || 4), (a = a || 32);
		let l;
		l = new Kt({ color: n });
		const c = new zr(i / 2, r / 2, s, a, o),
			u = new Re(c, l);
		return u.position.copy(t), (u.name = "circle-torus"), u;
	}
	function k0(n, e, t, i, r, s, a, o, l, c, u, h, d, f) {
		e = null;
		const v = ["lime", "white", "orange", "grey", "red"],
			_ = new Ot();
		_.add(jd(e || v[0], t, a, c, u, h, d, f)),
			_.add(Dn(e || v[1], t, a, o, u, h)),
			_.add(jd(e || v[2], t, o, c / 2, u, h, d, f)),
			_.add(Dn(e || v[3], t, o, l, u, h)),
			_.add(jd(e || v[4], t, l, c / 2, u, h, d, f)),
			(_.name = s),
			(_.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-circle" });
		let p = n.children.find((g) => g.isGroup && g.name === r);
		p || ((p = new Ot()), (p.name = r), n.add(p)), p.add(_);
	}
	function xI(n, e, t, i, r, s, a, o) {
		const c = { topLeft: new D(s.x - 0.5, s.y + 0.5, s.z), topRight: new D(s.x + 0.5, s.y + 0.5, s.z), bottomLeft: new D(s.x - 0.5, s.y - 0.5, s.z), bottomRight: new D(s.x + 0.5, s.y - 0.5, s.z) },
			u = new Ot();
		u.add(Dn(color, t, c.topLeft, c.bottomRight, a, o)), u.add(Dn(color, t, c.bottomLeft, c.topRight, a, o)), (u.name = name), (u.userData = { uuid: i, blastName: r, entityType: "hole", pointID: name, collarXYZ: s, displayType: "mesh-dummy" });
		let h = n.children.find((d) => d.isGroup && d.name === r);
		h || ((h = new Ot()), (h.name = r), n.add(h)), h.add(hole);
	}
	function bI(n, e, t, i, r, s, a, o, l, c, u, h) {
		const f = c / 1e3 / 2,
			v = 100,
			_ = { topLeft: new D(a.x - f, a.y + f, a.z), topRight: new D(a.x + f, a.y + f, a.z), bottomLeft: new D(a.x - f, a.y - f, a.z), bottomRight: new D(a.x + f, a.y - f, a.z) },
			p = new Ot();
		p.add(Dn(e, t, _.topLeft, _.bottomRight, v, h)), p.add(Dn(e, t, _.bottomLeft, _.topRight, v, h)), p.add(Dn(e, t, a, o, v, h)), (e = "red"), p.add(Dn(e, t, o, l, v, h)), (p.name = s), (p.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-cross" });
		let g = n.children.find((x) => x.isGroup && x.name === r);
		g || ((g = new Ot()), (g.name = r), n.add(g)), g.add(p);
	}
	function SI(n, e, t, i, r, s, a, o, l, c, u, h) {
		(c = c || 500), (t = t || "phong");
		const d = new Ot();
		(d.name = s),
			d.position.set(0, 0, 0),
			u > 0 && (d.add(Dn(e, t, a, o, c, h)), (d.children[0].name = a.distanceTo(o).toFixed(3) + "m (bench)"), (e = "red"), d.add(Dn(e, t, o, l, c, h)), (d.children[1].name = o.distanceTo(l).toFixed(3) + "m (subdrill)")),
			u <= 0 && (d.add(Dn(e, t, a, l, c, h)), (d.children[0].name = a.distanceTo(l).toFixed(3) + "m (bench)"), (e = "blue"), d.add(Dn(e, "phong-invisible", o, l, c, h)), (d.children[1].name = u.toFixed(3) + "m (subdrill)")),
			(d.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-cylinder" });
		let f = n.children.find((v) => v.isGroup && v.name === r);
		f || ((f = new Ot()), (f.name = r), n.add(f)), f.add(d);
	}
	function Co(n, e, t, i, r, s, a, o, l) {
		(i = i || 500), (i = i / 1e3), (r = r || 100), (r = r / 1e3), (s = s || 4), (a = a || 4);
		let c;
		c = new Kt({ color: n });
		const u = new zr(i / 2, r / 2, s, a, o),
			h = new Re(u, c);
		if (l) {
			const d = new pt();
			d.makeRotationZ(Math.PI / 4), h.applyMatrix4(d), (h.name = "square-torus");
		} else h.name = "diamond-torus";
		return h.position.copy(t), h;
	}
	function EI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v) {
		e = null;
		const _ = ["lime", "white", "orange", "grey", "red"],
			p = new Ot();
		p.add(Co(e || _[0], t, a, c, u, h, d, f, v)),
			p.add(Dn(e || _[1], t, a, o, u, h)),
			p.add(Co(e || _[2], t, o, c / 2, u, h, d, f, v)),
			p.add(Dn(e || _[3], t, o, l, u, h)),
			p.add(Co(e || _[4], t, l, c / 2, u, h, d, f, v)),
			(p.name = s),
			(p.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-diamond" });
		let g = n.children.find((x) => x.isGroup && x.name === r);
		g || ((g = new Ot()), (g.name = r), n.add(g)), g.add(p);
	}
	function wI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v) {
		e = null;
		const _ = ["lime", "white", "orange", "grey", "red"],
			p = new Ot();
		p.add(Co(e || _[0], t, a, c, u, h, d, f, v)),
			p.add(Dn(e || _[1], t, a, o, u, h)),
			p.add(Co(e || _[2], t, o, c / 2, u, h, d, f, v)),
			p.add(Dn(e || _[3], t, o, l, u, h)),
			p.add(Co(e || _[4], t, l, c / 2, u, h, d, f, v)),
			(p.name = s),
			(p.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-square" });
		let g = n.children.find((x) => x.isGroup && x.name === r);
		g || ((g = new Ot()), (g.name = r), n.add(g)), g.add(p);
	}
	function TI(n, e, t, i, r, s, a, o, l, c, u, h) {
		t = t || "basic";
		const d = new Ot();
		d.add(Dn(e, t, a, o, 500, h)),
			(d.children[0].material.wireframe = !0),
			(e = yI()),
			o.distanceTo(l) > 0 && ((e = "red"), d.add(Dn(e, t, o, l, 500, h)), (d.children[1].material.wireframe = !0)),
			(d.name = s),
			(d.userData = { uuid: i, blastName: r, entityType: "hole", pointID: s, collarXYZ: a, intervalXYZ: o, toeXYZ: l, diameter: c, holeLength: a.distanceTo(l).toFixed(3), subdrill: o.distanceTo(l).toFixed(3), benchLength: a.distanceTo(o).toFixed(3), holeType: "unknown", displayType: "mesh-cube" });
		let f = n.children.find((v) => v.isGroup && v.name === r);
		f || ((f = new Ot()), (f.name = r), n.add(f)), f.add(d);
	}
	class Ar extends bt {
		constructor() {
			super(),
				(this.isMeshLine = !0),
				(this.type = "MeshLine"),
				(this.positions = []),
				(this.previous = []),
				(this.next = []),
				(this.side = []),
				(this.width = []),
				(this.indices_array = []),
				(this.uvs = []),
				(this.counters = []),
				(this._points = []),
				(this._geom = null),
				(this.widthCallback = null),
				(this.matrixWorld = new pt()),
				Object.defineProperties(this, {
					geometry: {
						enumerable: !0,
						get: function () {
							return this;
						}
					},
					geom: {
						enumerable: !0,
						get: function () {
							return this._geom;
						},
						set: function (e) {
							this.setGeometry(e, this.widthCallback);
						}
					},
					points: {
						enumerable: !0,
						get: function () {
							return this._points;
						},
						set: function (e) {
							this.setPoints(e, this.widthCallback);
						}
					}
				});
		}
	}
	Ar.prototype.setMatrixWorld = function (n) {
		this.matrixWorld = n;
	};
	Ar.prototype.setGeometry = function (n, e) {
		(this._geometry = n), this.setPoints(n.getAttribute("position").array, e);
	};
	Ar.prototype.setPoints = function (n, e) {
		if (!(n instanceof Float32Array) && !(n instanceof Array)) {
			console.error("ERROR: The BufferArray of points is not instancied correctly.");
			return;
		}
		if (((this._points = n), (this.widthCallback = e), (this.positions = []), (this.counters = []), n.length && n[0] instanceof D))
			for (var t = 0; t < n.length; t++) {
				var i = n[t],
					r = t / n.length;
				this.positions.push(i.x, i.y, i.z), this.positions.push(i.x, i.y, i.z), this.counters.push(r), this.counters.push(r);
			}
		else
			for (var t = 0; t < n.length; t += 3) {
				var r = t / n.length;
				this.positions.push(n[t], n[t + 1], n[t + 2]), this.positions.push(n[t], n[t + 1], n[t + 2]), this.counters.push(r), this.counters.push(r);
			}
		this.process();
	};
	function MI(n, e) {
		var t = new pt(),
			i = new Ray(),
			r = new Sphere(),
			s = new D(),
			a = this.geometry;
		if ((a.boundingSphere || a.computeBoundingSphere(), r.copy(a.boundingSphere), r.applyMatrix4(this.matrixWorld), n.ray.intersectSphere(r, s) !== !1)) {
			t.copy(this.matrixWorld).invert(), i.copy(n.ray).applyMatrix4(t);
			var o = new D(),
				l = new D(),
				c = new D(),
				u = this instanceof Fl ? 2 : 1,
				h = a.index,
				d = a.attributes;
			if (h !== null)
				for (var f = h.array, v = d.position.array, _ = d.width.array, p = 0, g = f.length - 1; p < g; p += u) {
					var x = f[p],
						b = f[p + 1];
					o.fromArray(v, x * 3), l.fromArray(v, b * 3);
					var T = _[Math.floor(p / 3)] !== void 0 ? _[Math.floor(p / 3)] : 1,
						P = n.params.Line.threshold + (this.material.lineWidth * T) / 2,
						A = P * P,
						M = i.distanceSqToSegment(o, l, s, c);
					if (!(M > A)) {
						s.applyMatrix4(this.matrixWorld);
						var w = n.ray.origin.distanceTo(s);
						w < n.near || w > n.far || (e.push({ distance: w, point: c.clone().applyMatrix4(this.matrixWorld), index: p, face: null, faceIndex: null, object: this }), (p = g));
					}
				}
		}
	}
	Ar.prototype.raycast = MI;
	Ar.prototype.compareV3 = function (n, e) {
		var t = n * 6,
			i = e * 6;
		return this.positions[t] === this.positions[i] && this.positions[t + 1] === this.positions[i + 1] && this.positions[t + 2] === this.positions[i + 2];
	};
	Ar.prototype.copyV3 = function (n) {
		var e = n * 6;
		return [this.positions[e], this.positions[e + 1], this.positions[e + 2]];
	};
	Ar.prototype.process = function () {
		var n = this.positions.length / 6;
		(this.previous = []), (this.next = []), (this.side = []), (this.width = []), (this.indices_array = []), (this.uvs = []);
		var e, t;
		this.compareV3(0, n - 1) ? (t = this.copyV3(n - 2)) : (t = this.copyV3(0)), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]);
		for (var i = 0; i < n; i++) {
			if ((this.side.push(1), this.side.push(-1), this.widthCallback ? (e = this.widthCallback(i / (n - 1))) : (e = 1), this.width.push(e), this.width.push(e), this.uvs.push(i / (n - 1), 0), this.uvs.push(i / (n - 1), 1), i < n - 1)) {
				(t = this.copyV3(i)), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]);
				var r = i * 2;
				this.indices_array.push(r, r + 1, r + 2), this.indices_array.push(r + 2, r + 1, r + 3);
			}
			i > 0 && ((t = this.copyV3(i)), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2]));
		}
		this.compareV3(n - 1, 0) ? (t = this.copyV3(1)) : (t = this.copyV3(n - 1)),
			this.next.push(t[0], t[1], t[2]),
			this.next.push(t[0], t[1], t[2]),
			!this._attributes || this._attributes.position.count !== this.positions.length
				? (this._attributes = { position: new mn(new Float32Array(this.positions), 3), previous: new mn(new Float32Array(this.previous), 3), next: new mn(new Float32Array(this.next), 3), side: new mn(new Float32Array(this.side), 1), width: new mn(new Float32Array(this.width), 1), uv: new mn(new Float32Array(this.uvs), 2), index: new mn(new Uint16Array(this.indices_array), 1), counters: new mn(new Float32Array(this.counters), 1) })
				: (this._attributes.position.copyArray(new Float32Array(this.positions)),
				  (this._attributes.position.needsUpdate = !0),
				  this._attributes.previous.copyArray(new Float32Array(this.previous)),
				  (this._attributes.previous.needsUpdate = !0),
				  this._attributes.next.copyArray(new Float32Array(this.next)),
				  (this._attributes.next.needsUpdate = !0),
				  this._attributes.side.copyArray(new Float32Array(this.side)),
				  (this._attributes.side.needsUpdate = !0),
				  this._attributes.width.copyArray(new Float32Array(this.width)),
				  (this._attributes.width.needsUpdate = !0),
				  this._attributes.uv.copyArray(new Float32Array(this.uvs)),
				  (this._attributes.uv.needsUpdate = !0),
				  this._attributes.index.copyArray(new Uint16Array(this.indices_array)),
				  (this._attributes.index.needsUpdate = !0)),
			this.setAttribute("position", this._attributes.position),
			this.setAttribute("previous", this._attributes.previous),
			this.setAttribute("next", this._attributes.next),
			this.setAttribute("side", this._attributes.side),
			this.setAttribute("width", this._attributes.width),
			this.setAttribute("uv", this._attributes.uv),
			this.setAttribute("counters", this._attributes.counters),
			this.setIndex(this._attributes.index),
			this.computeBoundingSphere(),
			this.computeBoundingBox();
	};
	function Yd(n, e, t, i, r) {
		var s;
		if (((n = n.subarray || n.slice ? n : n.buffer), (t = t.subarray || t.slice ? t : t.buffer), (n = e ? (n.subarray ? n.subarray(e, r && e + r) : n.slice(e, r && e + r)) : n), t.set)) t.set(n, i);
		else for (s = 0; s < n.length; s++) t[s + i] = n[s];
		return t;
	}
	Ar.prototype.advance = function (n) {
		var e = this._attributes.position.array,
			t = this._attributes.previous.array,
			i = this._attributes.next.array,
			r = e.length;
		Yd(e, 0, t, 0, r), Yd(e, 6, e, 0, r - 6), (e[r - 6] = n.x), (e[r - 5] = n.y), (e[r - 4] = n.z), (e[r - 3] = n.x), (e[r - 2] = n.y), (e[r - 1] = n.z), Yd(e, 6, i, 0, r - 6), (i[r - 6] = n.x), (i[r - 5] = n.y), (i[r - 4] = n.z), (i[r - 3] = n.x), (i[r - 2] = n.y), (i[r - 1] = n.z), (this._attributes.position.needsUpdate = !0), (this._attributes.previous.needsUpdate = !0), (this._attributes.next.needsUpdate = !0);
	};
	st.meshline_vert = [
		"",
		st.logdepthbuf_pars_vertex,
		st.fog_pars_vertex,
		"",
		"attribute vec3 previous;",
		"attribute vec3 next;",
		"attribute float side;",
		"attribute float width;",
		"attribute float counters;",
		"",
		"uniform vec2 resolution;",
		"uniform float lineWidth;",
		"uniform vec3 color;",
		"uniform float opacity;",
		"uniform float sizeAttenuation;",
		"",
		"varying vec2 vUV;",
		"varying vec4 vColor;",
		"varying float vCounters;",
		"",
		"vec2 fix( vec4 i, float aspect ) {",
		"",
		"    vec2 res = i.xy / i.w;",
		"    res.x *= aspect;",
		"	 vCounters = counters;",
		"    return res;",
		"",
		"}",
		"",
		"void main() {",
		"",
		"    float aspect = resolution.x / resolution.y;",
		"",
		"    vColor = vec4( color, opacity );",
		"    vUV = uv;",
		"",
		"    mat4 m = projectionMatrix * modelViewMatrix;",
		"    vec4 finalPosition = m * vec4( position, 1.0 );",
		"    vec4 prevPos = m * vec4( previous, 1.0 );",
		"    vec4 nextPos = m * vec4( next, 1.0 );",
		"",
		"    vec2 currentP = fix( finalPosition, aspect );",
		"    vec2 prevP = fix( prevPos, aspect );",
		"    vec2 nextP = fix( nextPos, aspect );",
		"",
		"    float w = lineWidth * width;",
		"",
		"    vec2 dir;",
		"    if( nextP == currentP ) dir = normalize( currentP - prevP );",
		"    else if( prevP == currentP ) dir = normalize( nextP - currentP );",
		"    else {",
		"        vec2 dir1 = normalize( currentP - prevP );",
		"        vec2 dir2 = normalize( nextP - currentP );",
		"        dir = normalize( dir1 + dir2 );",
		"",
		"        vec2 perp = vec2( -dir1.y, dir1.x );",
		"        vec2 miter = vec2( -dir.y, dir.x );",
		"        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );",
		"",
		"    }",
		"",
		"    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;",
		"    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );",
		"    normal.xy *= .5 * w;",
		"    normal *= projectionMatrix;",
		"    if( sizeAttenuation == 0. ) {",
		"        normal.xy *= finalPosition.w;",
		"        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;",
		"    }",
		"",
		"    finalPosition.xy += normal.xy * side;",
		"",
		"    gl_Position = finalPosition;",
		"",
		st.logdepthbuf_vertex,
		st.fog_vertex && "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
		st.fog_vertex,
		"}"
	].join(`
`);
	st.meshline_frag = [
		"",
		st.fog_pars_fragment,
		st.logdepthbuf_pars_fragment,
		"",
		"uniform sampler2D map;",
		"uniform sampler2D alphaMap;",
		"uniform float useMap;",
		"uniform float useAlphaMap;",
		"uniform float useDash;",
		"uniform float dashArray;",
		"uniform float dashOffset;",
		"uniform float dashRatio;",
		"uniform float visibility;",
		"uniform float alphaTest;",
		"uniform vec2 repeat;",
		"",
		"varying vec2 vUV;",
		"varying vec4 vColor;",
		"varying float vCounters;",
		"",
		"void main() {",
		"",
		st.logdepthbuf_fragment,
		"",
		"    vec4 c = vColor;",
		"    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );",
		"    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;",
		"    if( c.a < alphaTest ) discard;",
		"    if( useDash == 1. ){",
		"        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));",
		"    }",
		"    gl_FragColor = c;",
		"    gl_FragColor.a *= step(vCounters, visibility);",
		"",
		st.fog_fragment,
		"}"
	].join(`
`);
	class im extends wr {
		constructor(e) {
			super({
				uniforms: Object.assign({}, Be.fog, { lineWidth: { value: 1 }, map: { value: null }, useMap: { value: 0 }, alphaMap: { value: null }, useAlphaMap: { value: 0 }, color: { value: new rt(16777215) }, opacity: { value: 1 }, resolution: { value: new Se(1, 1) }, sizeAttenuation: { value: 1 }, dashArray: { value: 0 }, dashOffset: { value: 0 }, dashRatio: { value: 0.5 }, useDash: { value: 0 }, visibility: { value: 1 }, alphaTest: { value: 0 }, repeat: { value: new Se(1, 1) } }),
				vertexShader: st.meshline_vert,
				fragmentShader: st.meshline_frag
			}),
				(this.isMeshLineMaterial = !0),
				(this.type = "MeshLineMaterial"),
				Object.defineProperties(this, {
					lineWidth: {
						enumerable: !0,
						get: function () {
							return this.uniforms.lineWidth.value;
						},
						set: function (t) {
							this.uniforms.lineWidth.value = t;
						}
					},
					map: {
						enumerable: !0,
						get: function () {
							return this.uniforms.map.value;
						},
						set: function (t) {
							this.uniforms.map.value = t;
						}
					},
					useMap: {
						enumerable: !0,
						get: function () {
							return this.uniforms.useMap.value;
						},
						set: function (t) {
							this.uniforms.useMap.value = t;
						}
					},
					alphaMap: {
						enumerable: !0,
						get: function () {
							return this.uniforms.alphaMap.value;
						},
						set: function (t) {
							this.uniforms.alphaMap.value = t;
						}
					},
					useAlphaMap: {
						enumerable: !0,
						get: function () {
							return this.uniforms.useAlphaMap.value;
						},
						set: function (t) {
							this.uniforms.useAlphaMap.value = t;
						}
					},
					color: {
						enumerable: !0,
						get: function () {
							return this.uniforms.color.value;
						},
						set: function (t) {
							this.uniforms.color.value = t;
						}
					},
					opacity: {
						enumerable: !0,
						get: function () {
							return this.uniforms.opacity.value;
						},
						set: function (t) {
							this.uniforms.opacity.value = t;
						}
					},
					resolution: {
						enumerable: !0,
						get: function () {
							return this.uniforms.resolution.value;
						},
						set: function (t) {
							this.uniforms.resolution.value.copy(t);
						}
					},
					sizeAttenuation: {
						enumerable: !0,
						get: function () {
							return this.uniforms.sizeAttenuation.value;
						},
						set: function (t) {
							this.uniforms.sizeAttenuation.value = t;
						}
					},
					dashArray: {
						enumerable: !0,
						get: function () {
							return this.uniforms.dashArray.value;
						},
						set: function (t) {
							(this.uniforms.dashArray.value = t), (this.useDash = t !== 0 ? 1 : 0);
						}
					},
					dashOffset: {
						enumerable: !0,
						get: function () {
							return this.uniforms.dashOffset.value;
						},
						set: function (t) {
							this.uniforms.dashOffset.value = t;
						}
					},
					dashRatio: {
						enumerable: !0,
						get: function () {
							return this.uniforms.dashRatio.value;
						},
						set: function (t) {
							this.uniforms.dashRatio.value = t;
						}
					},
					useDash: {
						enumerable: !0,
						get: function () {
							return this.uniforms.useDash.value;
						},
						set: function (t) {
							this.uniforms.useDash.value = t;
						}
					},
					visibility: {
						enumerable: !0,
						get: function () {
							return this.uniforms.visibility.value;
						},
						set: function (t) {
							this.uniforms.visibility.value = t;
						}
					},
					alphaTest: {
						enumerable: !0,
						get: function () {
							return this.uniforms.alphaTest.value;
						},
						set: function (t) {
							this.uniforms.alphaTest.value = t;
						}
					},
					repeat: {
						enumerable: !0,
						get: function () {
							return this.uniforms.repeat.value;
						},
						set: function (t) {
							this.uniforms.repeat.value.copy(t);
						}
					}
				}),
				this.setValues(e);
		}
	}
	im.prototype.copy = function (n) {
		return (
			wr.prototype.copy.call(this, n),
			(this.lineWidth = n.lineWidth),
			(this.map = n.map),
			(this.useMap = n.useMap),
			(this.alphaMap = n.alphaMap),
			(this.useAlphaMap = n.useAlphaMap),
			this.color.copy(n.color),
			(this.opacity = n.opacity),
			this.resolution.copy(n.resolution),
			(this.sizeAttenuation = n.sizeAttenuation),
			this.dashArray.copy(n.dashArray),
			this.dashOffset.copy(n.dashOffset),
			this.dashRatio.copy(n.dashRatio),
			(this.useDash = n.useDash),
			(this.visibility = n.visibility),
			(this.alphaTest = n.alphaTest),
			this.repeat.copy(n.repeat),
			this
		);
	};
	function Oi(n, e, t, i, r, s, a, o, l) {
		const c = new im({ map: null, useMap: !1, color: new rt(t), opacity: o, resolution: new Se(window.innerWidth, window.innerHeight), lineWidth: i, dashArray: r, dashOffset: s, dashRatio: a, opacity: o, sizeAttenuation: l });
		(n = new D(n.x, n.y, n.z)), (e = new D(e.x, e.y, e.z));
		const u = [n, e],
			h = new Ar(),
			d = new bt().setFromPoints(u);
		h.setGeometry(d);
		const f = new Re(h, c);
		return (f.name = "line"), f;
	}
	function AI(n, e, t, i, r, s, a, o, l, c, u) {
		const d = t / 1e3 / 2;
		c = c;
		const f = new pt();
		f.makeRotationZ(Math.PI / (c * 2));
		{
			const v = new xa(d, c),
				_ = new Kt({ color: new rt(n), opacity: o, transparent: o < 1, side: An }),
				p = new Re(v, _);
			return p.applyMatrix4(f), p.position.set(e.x, e.y, e.z), (p.name = "filled-anyShape"), p;
		}
	}
	function CI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v) {
		l = l || 500;
		const p = l / 1e3 / 2,
			g = { topLeft: { x: s.x - p, y: s.y + p, z: s.z }, topRight: { x: s.x + p, y: s.y + p, z: s.z }, bottomLeft: { x: s.x - p, y: s.y - p, z: s.z }, bottomRight: { x: s.x + p, y: s.y - p, z: s.z } },
			x = new Ot();
		x.add(Oi(g.topLeft, g.bottomRight, e, c, u, h, d, f, v)), x.add(Oi(g.bottomLeft, g.topRight, e, c, u, h, d, f, v)), x.add(Oi(s, a, e, c, u, h, d, f, v)), (e = "red"), x.add(Oi(a, o, e, c, u, h, d, f, v)), (x.name = r), (x.userData = { entityType: "hole", pointID: r, collarXYZ: s, intervalXYZ: a, toeXYZ: o, diameter: l, subdrill: a.distanceTo(o), benchLength: s.distanceTo(a), holeType: "unknown", displayType: "line-cross" });
		let b = n.children.find((T) => T.isGroup && T.name === i);
		b || ((b = new Ot()), (b.name = i), n.add(b)), b.add(x);
	}
	function LI(n, e, t, i, r, s, a, o, l, c) {
		const h = t / 1e3 / 2,
			d = 32;
		if (c) {
			const f = new xa(h, d),
				v = new Kt({ color: new rt(n), opacity: o, transparent: o < 1, side: An }),
				_ = new Re(f, v);
			return _.position.set(e.x, e.y, e.z), (_.name = "filled-circle-part"), _;
		} else {
			const f = new im({ color: new rt(n), opacity: o, resolution: new Se(window.innerWidth, window.innerHeight), lineWidth: i, dashArray: r, dashOffset: s, dashRatio: a, sizeAttenuation: l }),
				v = new bt(),
				_ = [];
			for (let x = 0; x <= d; x++) {
				const b = (x / d) * Math.PI * 2,
					T = h * Math.cos(b),
					P = h * Math.sin(b);
				_.push(T + e.x, P + e.y, e.z);
			}
			v.setAttribute("position", new Tt(_, 3));
			const p = new Ar();
			p.setGeometry(v);
			const g = new Re(p.geometry, f);
			return (g.name = "outline-circle-part"), g;
		}
	}
	function B0(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v, _) {
		(l = l || 500), (s = s instanceof D ? s : new D(s.x, s.y, s.z)), (a = a instanceof D ? a : new D(a.x, a.y, a.z)), (o = o instanceof D ? o : new D(o.x, o.y, o.z));
		const p = new Ot();
		p.add(LI(e, s, l, c, u, h, d, f, v, _)), p.add(Oi(s, a, e, c, u, h, d, f, v)), (e = "red"), p.add(Oi(a, o, e, c, u, h, d, f, v)), (p.name = r), (p.name = r), (p.userData = { uuid: t, blastName: i, entityType: "hole", pointID: r, collarXYZ: s, intervalXYZ: a, toeXYZ: o, diameter: l, holeLength: s.distanceTo(o).toFixed(3), subdrill: a.distanceTo(o).toFixed(3), benchLength: s.distanceTo(a).toFixed(3), holeType: "unknown", displayType: "line-circle" });
		let g = n.children.find((x) => x.isGroup && x.name === i);
		g || ((g = new Ot()), (g.name = i), n.add(g)), g.add(p);
	}
	function Cx(n, e, t, i, r, s, a, o, l, c, u) {
		const d = t / 1e3 / 2,
			f = 4,
			v = new pt();
		v.makeRotationZ(Math.PI / 4);
		{
			const _ = new xa(d, f),
				p = new Kt({ color: new rt(n), opacity: o, transparent: o < 1, side: An }),
				g = new Re(_, p);
			return c && g.applyMatrix4(v), g.position.set(e.x, e.y, e.z), (g.name = "filled-square"), g;
		}
	}
	function RI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v, _) {
		l = l || 500;
		const p = new Ot();
		p.add(Cx(e, s, l, c, u, h, d, f, v, !1)), p.add(Oi(s, a, e, c, u, h, d, f, v)), (e = "red"), p.add(Oi(a, o, e, c, u, h, d, f, v)), (p.name = r), (p.name = r), (p.userData = { uuid: t, blastName: i, entityType: "hole", pointID: r, collarXYZ: s, intervalXYZ: a, toeXYZ: o, diameter: l, holeLength: s.distanceTo(o).toFixed(3), subdrill: a.distanceTo(o).toFixed(3), benchLength: s.distanceTo(a).toFixed(3), holeType: "unknown", displayType: "line-diamond" });
		let g = n.children.find((x) => x.isGroup && x.name === i);
		g || ((g = new Ot()), (g.name = i), n.add(g)), g.add(p);
	}
	function PI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v, _) {
		l = l || 500;
		const p = new Ot();
		p.add(Cx(e, s, l, c, u, h, d, f, v, !0)), p.add(Oi(s, a, e, c, u, h, d, f, v)), (e = "red"), p.add(Oi(a, o, e, c, u, h, d, f, v)), (p.name = r), (p.name = r), (p.userData = { uuid: t, blastName: i, entityType: "hole", pointID: r, collarXYZ: s, intervalXYZ: a, toeXYZ: o, diameter: l, holeLength: s.distanceTo(o).toFixed(3), subdrill: a.distanceTo(o).toFixed(3), benchLength: s.distanceTo(a).toFixed(3), holeType: "unknown", displayType: "line-square" });
		let g = n.children.find((x) => x.isGroup && x.name === i);
		g || ((g = new Ot()), (g.name = i), n.add(g)), g.add(p);
	}
	function DI(n, e, t, i, r, s, a, o, l, c, u, h, d, f, v, _) {
		l = l || 500;
		const p = new Ot();
		p.add(AI(e, s, l, c, u, h, d, f, v, 3)), p.add(Oi(s, a, e, c, u, h, d, f, v)), (e = "red"), p.add(Oi(a, o, e, c, u, h, d, f, v)), (p.name = r), (p.name = r), (p.userData = { uuid: t, blastName: i, entityType: "hole", pointID: r, collarXYZ: s, intervalXYZ: a, toeXYZ: o, diameter: l, holeLength: s.distanceTo(o).toFixed(3), subdrill: a.distanceTo(o).toFixed(3), benchLength: s.distanceTo(a).toFixed(3), holeType: "unknown", displayType: "line-triangle" });
		let g = n.children.find((x) => x.isGroup && x.name === i);
		g || ((g = new Ot()), (g.name = i), n.add(g)), g.add(p);
	}
	class sp extends Jp {
		constructor(e, t = {}) {
			const i = t.font;
			if (i === void 0) super();
			else {
				const r = i.generateShapes(e, t.size);
				t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"), (t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(r, t);
			}
			this.type = "TextGeometry";
		}
	}
	function Nu(n, e, t, i, r, s, a, o) {
		a = a || "None";
		const l = new sp(a, { font: t, size: 1, depth: 0.05, curveSegments: 12, bevelEnabled: !1, bevelSegments: 2, bevelSize: 0, bevelThickness: 0 });
		l.computeBoundingBox();
		const c = l.boundingBox,
			u = c.max.x - c.min.x,
			h = c.max.y - c.min.y,
			d = new nr({ color: e }),
			f = new Re(l, d);
		f.position.set(parseFloat(i.x), parseFloat(i.y), parseFloat(i.z)), (f.name = a + "- text"), (f.userData = { uuid: r, blastName: s, entityType: o, vector: i, value: a, textWidth: u, textHeight: h, font: t, colour: e });
		let v = n.children.find((_) => _.isGroup && _.name === s + " {text}");
		v || ((v = new Ot()), (v.name = s + " {text}"), n.add(v)), v.add(f);
	}
	let OI = class {
		constructor(e) {
			(this.isFont = !0), (this.type = "Font"), (this.data = e);
		}
		generateShapes(e, t = 100) {
			const i = [],
				r = II(e, t, this.data);
			for (let s = 0, a = r.length; s < a; s++) i.push(...r[s].toShapes());
			return i;
		}
	};
	function II(n, e, t) {
		const i = Array.from(n),
			r = e / t.resolution,
			s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * r,
			a = [];
		let o = 0,
			l = 0;
		for (let c = 0; c < i.length; c++) {
			const u = i[c];
			if (
				u ===
				`
`
			)
				(o = 0), (l -= s);
			else {
				const h = FI(u, r, o, l, t);
				(o += h.offsetX), a.push(h.path);
			}
		}
		return a;
	}
	function FI(n, e, t, i, r) {
		const s = r.glyphs[n] || r.glyphs["?"];
		if (!s) {
			console.error('THREE.Font: character "' + n + '" does not exists in font family ' + r.familyName + ".");
			return;
		}
		const a = new XO();
		let o, l, c, u, h, d, f, v;
		if (s.o) {
			const _ = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
			for (let p = 0, g = _.length; p < g; )
				switch (_[p++]) {
					case "m":
						(o = _[p++] * e + t), (l = _[p++] * e + i), a.moveTo(o, l);
						break;
					case "l":
						(o = _[p++] * e + t), (l = _[p++] * e + i), a.lineTo(o, l);
						break;
					case "q":
						(c = _[p++] * e + t), (u = _[p++] * e + i), (h = _[p++] * e + t), (d = _[p++] * e + i), a.quadraticCurveTo(h, d, c, u);
						break;
					case "b":
						(c = _[p++] * e + t), (u = _[p++] * e + i), (h = _[p++] * e + t), (d = _[p++] * e + i), (f = _[p++] * e + t), (v = _[p++] * e + i), a.bezierCurveTo(h, d, f, v, c, u);
						break;
				}
		}
		return { offsetX: s.ha * e, path: a };
	}
	/*! https://mths.be/codepointat v0.2.0 by @mathias */ String.prototype.codePointAt ||
		(function () {
			var n = (function () {
					try {
						var t = {},
							i = Object.defineProperty,
							r = i(t, t, t) && i;
					} catch {}
					return r;
				})(),
				e = function (t) {
					if (this == null) throw TypeError();
					var i = String(this),
						r = i.length,
						s = t ? Number(t) : 0;
					if ((s != s && (s = 0), !(s < 0 || s >= r))) {
						var a = i.charCodeAt(s),
							o;
						return a >= 55296 && a <= 56319 && r > s + 1 && ((o = i.charCodeAt(s + 1)), o >= 56320 && o <= 57343) ? (a - 55296) * 1024 + o - 56320 + 65536 : a;
					}
				};
			n ? n(String.prototype, "codePointAt", { value: e, configurable: !0, writable: !0 }) : (String.prototype.codePointAt = e);
		})();
	var rm = 0,
		Lx = -3;
	function Bl() {
		(this.table = new Uint16Array(16)), (this.trans = new Uint16Array(288));
	}
	function NI(n, e) {
		(this.source = n), (this.sourceIndex = 0), (this.tag = 0), (this.bitcount = 0), (this.dest = e), (this.destLen = 0), (this.ltree = new Bl()), (this.dtree = new Bl());
	}
	var Rx = new Bl(),
		Px = new Bl(),
		sm = new Uint8Array(30),
		am = new Uint16Array(30),
		Dx = new Uint8Array(30),
		Ox = new Uint16Array(30),
		UI = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
		z0 = new Bl(),
		fr = new Uint8Array(320);
	function Ix(n, e, t, i) {
		var r, s;
		for (r = 0; r < t; ++r) n[r] = 0;
		for (r = 0; r < 30 - t; ++r) n[r + t] = (r / t) | 0;
		for (s = i, r = 0; r < 30; ++r) (e[r] = s), (s += 1 << n[r]);
	}
	function kI(n, e) {
		var t;
		for (t = 0; t < 7; ++t) n.table[t] = 0;
		for (n.table[7] = 24, n.table[8] = 152, n.table[9] = 112, t = 0; t < 24; ++t) n.trans[t] = 256 + t;
		for (t = 0; t < 144; ++t) n.trans[24 + t] = t;
		for (t = 0; t < 8; ++t) n.trans[168 + t] = 280 + t;
		for (t = 0; t < 112; ++t) n.trans[176 + t] = 144 + t;
		for (t = 0; t < 5; ++t) e.table[t] = 0;
		for (e.table[5] = 32, t = 0; t < 32; ++t) e.trans[t] = t;
	}
	var H0 = new Uint16Array(16);
	function Kd(n, e, t, i) {
		var r, s;
		for (r = 0; r < 16; ++r) n.table[r] = 0;
		for (r = 0; r < i; ++r) n.table[e[t + r]]++;
		for (n.table[0] = 0, s = 0, r = 0; r < 16; ++r) (H0[r] = s), (s += n.table[r]);
		for (r = 0; r < i; ++r) e[t + r] && (n.trans[H0[e[t + r]]++] = r);
	}
	function BI(n) {
		n.bitcount-- || ((n.tag = n.source[n.sourceIndex++]), (n.bitcount = 7));
		var e = n.tag & 1;
		return (n.tag >>>= 1), e;
	}
	function mr(n, e, t) {
		if (!e) return t;
		for (; n.bitcount < 24; ) (n.tag |= n.source[n.sourceIndex++] << n.bitcount), (n.bitcount += 8);
		var i = n.tag & (65535 >>> (16 - e));
		return (n.tag >>>= e), (n.bitcount -= e), i + t;
	}
	function ap(n, e) {
		for (; n.bitcount < 24; ) (n.tag |= n.source[n.sourceIndex++] << n.bitcount), (n.bitcount += 8);
		var t = 0,
			i = 0,
			r = 0,
			s = n.tag;
		do (i = 2 * i + (s & 1)), (s >>>= 1), ++r, (t += e.table[r]), (i -= e.table[r]);
		while (i >= 0);
		return (n.tag = s), (n.bitcount -= r), e.trans[t + i];
	}
	function zI(n, e, t) {
		var i, r, s, a, o, l;
		for (i = mr(n, 5, 257), r = mr(n, 5, 1), s = mr(n, 4, 4), a = 0; a < 19; ++a) fr[a] = 0;
		for (a = 0; a < s; ++a) {
			var c = mr(n, 3, 0);
			fr[UI[a]] = c;
		}
		for (Kd(z0, fr, 0, 19), o = 0; o < i + r; ) {
			var u = ap(n, z0);
			switch (u) {
				case 16:
					var h = fr[o - 1];
					for (l = mr(n, 2, 3); l; --l) fr[o++] = h;
					break;
				case 17:
					for (l = mr(n, 3, 3); l; --l) fr[o++] = 0;
					break;
				case 18:
					for (l = mr(n, 7, 11); l; --l) fr[o++] = 0;
					break;
				default:
					fr[o++] = u;
					break;
			}
		}
		Kd(e, fr, 0, i), Kd(t, fr, i, r);
	}
	function G0(n, e, t) {
		for (;;) {
			var i = ap(n, e);
			if (i === 256) return rm;
			if (i < 256) n.dest[n.destLen++] = i;
			else {
				var r, s, a, o;
				for (i -= 257, r = mr(n, sm[i], am[i]), s = ap(n, t), a = n.destLen - mr(n, Dx[s], Ox[s]), o = a; o < a + r; ++o) n.dest[n.destLen++] = n.dest[o];
			}
		}
	}
	function HI(n) {
		for (var e, t, i; n.bitcount > 8; ) n.sourceIndex--, (n.bitcount -= 8);
		if (((e = n.source[n.sourceIndex + 1]), (e = 256 * e + n.source[n.sourceIndex]), (t = n.source[n.sourceIndex + 3]), (t = 256 * t + n.source[n.sourceIndex + 2]), e !== (~t & 65535))) return Lx;
		for (n.sourceIndex += 4, i = e; i; --i) n.dest[n.destLen++] = n.source[n.sourceIndex++];
		return (n.bitcount = 0), rm;
	}
	function GI(n, e) {
		var t = new NI(n, e),
			i,
			r,
			s;
		do {
			switch (((i = BI(t)), (r = mr(t, 2, 0)), r)) {
				case 0:
					s = HI(t);
					break;
				case 1:
					s = G0(t, Rx, Px);
					break;
				case 2:
					zI(t, t.ltree, t.dtree), (s = G0(t, t.ltree, t.dtree));
					break;
				default:
					s = Lx;
			}
			if (s !== rm) throw new Error("Data error");
		} while (!i);
		return t.destLen < t.dest.length ? (typeof t.dest.slice == "function" ? t.dest.slice(0, t.destLen) : t.dest.subarray(0, t.destLen)) : t.dest;
	}
	kI(Rx, Px);
	Ix(sm, am, 4, 3);
	Ix(Dx, Ox, 2, 1);
	sm[28] = 0;
	am[28] = 258;
	var VI = GI;
	function oo(n, e, t, i, r) {
		return Math.pow(1 - r, 3) * n + 3 * Math.pow(1 - r, 2) * r * e + 3 * (1 - r) * Math.pow(r, 2) * t + Math.pow(r, 3) * i;
	}
	function Qr() {
		(this.x1 = Number.NaN), (this.y1 = Number.NaN), (this.x2 = Number.NaN), (this.y2 = Number.NaN);
	}
	Qr.prototype.isEmpty = function () {
		return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
	};
	Qr.prototype.addPoint = function (n, e) {
		typeof n == "number" && ((isNaN(this.x1) || isNaN(this.x2)) && ((this.x1 = n), (this.x2 = n)), n < this.x1 && (this.x1 = n), n > this.x2 && (this.x2 = n)), typeof e == "number" && ((isNaN(this.y1) || isNaN(this.y2)) && ((this.y1 = e), (this.y2 = e)), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));
	};
	Qr.prototype.addX = function (n) {
		this.addPoint(n, null);
	};
	Qr.prototype.addY = function (n) {
		this.addPoint(null, n);
	};
	Qr.prototype.addBezier = function (n, e, t, i, r, s, a, o) {
		var l = [n, e],
			c = [t, i],
			u = [r, s],
			h = [a, o];
		this.addPoint(n, e), this.addPoint(a, o);
		for (var d = 0; d <= 1; d++) {
			var f = 6 * l[d] - 12 * c[d] + 6 * u[d],
				v = -3 * l[d] + 9 * c[d] - 9 * u[d] + 3 * h[d],
				_ = 3 * c[d] - 3 * l[d];
			if (v === 0) {
				if (f === 0) continue;
				var p = -_ / f;
				0 < p && p < 1 && (d === 0 && this.addX(oo(l[d], c[d], u[d], h[d], p)), d === 1 && this.addY(oo(l[d], c[d], u[d], h[d], p)));
				continue;
			}
			var g = Math.pow(f, 2) - 4 * _ * v;
			if (!(g < 0)) {
				var x = (-f + Math.sqrt(g)) / (2 * v);
				0 < x && x < 1 && (d === 0 && this.addX(oo(l[d], c[d], u[d], h[d], x)), d === 1 && this.addY(oo(l[d], c[d], u[d], h[d], x)));
				var b = (-f - Math.sqrt(g)) / (2 * v);
				0 < b && b < 1 && (d === 0 && this.addX(oo(l[d], c[d], u[d], h[d], b)), d === 1 && this.addY(oo(l[d], c[d], u[d], h[d], b)));
			}
		}
	};
	Qr.prototype.addQuad = function (n, e, t, i, r, s) {
		var a = n + 0.6666666666666666 * (t - n),
			o = e + (2 / 3) * (i - e),
			l = a + (1 / 3) * (r - n),
			c = o + (1 / 3) * (s - e);
		this.addBezier(n, e, a, o, l, c, r, s);
	};
	function Tn() {
		(this.commands = []), (this.fill = "black"), (this.stroke = null), (this.strokeWidth = 1);
	}
	Tn.prototype.moveTo = function (n, e) {
		this.commands.push({ type: "M", x: n, y: e });
	};
	Tn.prototype.lineTo = function (n, e) {
		this.commands.push({ type: "L", x: n, y: e });
	};
	Tn.prototype.curveTo = Tn.prototype.bezierCurveTo = function (n, e, t, i, r, s) {
		this.commands.push({ type: "C", x1: n, y1: e, x2: t, y2: i, x: r, y: s });
	};
	Tn.prototype.quadTo = Tn.prototype.quadraticCurveTo = function (n, e, t, i) {
		this.commands.push({ type: "Q", x1: n, y1: e, x: t, y: i });
	};
	Tn.prototype.close = Tn.prototype.closePath = function () {
		this.commands.push({ type: "Z" });
	};
	Tn.prototype.extend = function (n) {
		if (n.commands) n = n.commands;
		else if (n instanceof Qr) {
			var e = n;
			this.moveTo(e.x1, e.y1), this.lineTo(e.x2, e.y1), this.lineTo(e.x2, e.y2), this.lineTo(e.x1, e.y2), this.close();
			return;
		}
		Array.prototype.push.apply(this.commands, n);
	};
	Tn.prototype.getBoundingBox = function () {
		for (var n = new Qr(), e = 0, t = 0, i = 0, r = 0, s = 0; s < this.commands.length; s++) {
			var a = this.commands[s];
			switch (a.type) {
				case "M":
					n.addPoint(a.x, a.y), (e = i = a.x), (t = r = a.y);
					break;
				case "L":
					n.addPoint(a.x, a.y), (i = a.x), (r = a.y);
					break;
				case "Q":
					n.addQuad(i, r, a.x1, a.y1, a.x, a.y), (i = a.x), (r = a.y);
					break;
				case "C":
					n.addBezier(i, r, a.x1, a.y1, a.x2, a.y2, a.x, a.y), (i = a.x), (r = a.y);
					break;
				case "Z":
					(i = e), (r = t);
					break;
				default:
					throw new Error("Unexpected path command " + a.type);
			}
		}
		return n.isEmpty() && n.addPoint(0, 0), n;
	};
	Tn.prototype.draw = function (n) {
		n.beginPath();
		for (var e = 0; e < this.commands.length; e += 1) {
			var t = this.commands[e];
			t.type === "M" ? n.moveTo(t.x, t.y) : t.type === "L" ? n.lineTo(t.x, t.y) : t.type === "C" ? n.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y) : t.type === "Q" ? n.quadraticCurveTo(t.x1, t.y1, t.x, t.y) : t.type === "Z" && n.closePath();
		}
		this.fill && ((n.fillStyle = this.fill), n.fill()), this.stroke && ((n.strokeStyle = this.stroke), (n.lineWidth = this.strokeWidth), n.stroke());
	};
	Tn.prototype.toPathData = function (n) {
		n = n !== void 0 ? n : 2;
		function e(a) {
			return Math.round(a) === a ? "" + Math.round(a) : a.toFixed(n);
		}
		function t() {
			for (var a = arguments, o = "", l = 0; l < arguments.length; l += 1) {
				var c = a[l];
				c >= 0 && l > 0 && (o += " "), (o += e(c));
			}
			return o;
		}
		for (var i = "", r = 0; r < this.commands.length; r += 1) {
			var s = this.commands[r];
			s.type === "M" ? (i += "M" + t(s.x, s.y)) : s.type === "L" ? (i += "L" + t(s.x, s.y)) : s.type === "C" ? (i += "C" + t(s.x1, s.y1, s.x2, s.y2, s.x, s.y)) : s.type === "Q" ? (i += "Q" + t(s.x1, s.y1, s.x, s.y)) : s.type === "Z" && (i += "Z");
		}
		return i;
	};
	Tn.prototype.toSVG = function (n) {
		var e = '<path d="';
		return (e += this.toPathData(n)), (e += '"'), this.fill && this.fill !== "black" && (this.fill === null ? (e += ' fill="none"') : (e += ' fill="' + this.fill + '"')), this.stroke && (e += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), (e += "/>"), e;
	};
	Tn.prototype.toDOMElement = function (n) {
		var e = this.toPathData(n),
			t = document.createElementNS("http://www.w3.org/2000/svg", "path");
		return t.setAttribute("d", e), t;
	};
	function Fx(n) {
		throw new Error(n);
	}
	function V0(n, e) {
		n || Fx(e);
	}
	var tt = { fail: Fx, argument: V0, assert: V0 },
		W0 = 32768,
		X0 = 2147483648,
		Ho = {},
		ze = {},
		mt = {};
	function or(n) {
		return function () {
			return n;
		};
	}
	ze.BYTE = function (n) {
		return tt.argument(n >= 0 && n <= 255, "Byte value should be between 0 and 255."), [n];
	};
	mt.BYTE = or(1);
	ze.CHAR = function (n) {
		return [n.charCodeAt(0)];
	};
	mt.CHAR = or(1);
	ze.CHARARRAY = function (n) {
		typeof n > "u" && ((n = ""), console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name."));
		for (var e = [], t = 0; t < n.length; t += 1) e[t] = n.charCodeAt(t);
		return e;
	};
	mt.CHARARRAY = function (n) {
		return typeof n > "u" ? 0 : n.length;
	};
	ze.USHORT = function (n) {
		return [(n >> 8) & 255, n & 255];
	};
	mt.USHORT = or(2);
	ze.SHORT = function (n) {
		return n >= W0 && (n = -(2 * W0 - n)), [(n >> 8) & 255, n & 255];
	};
	mt.SHORT = or(2);
	ze.UINT24 = function (n) {
		return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
	};
	mt.UINT24 = or(3);
	ze.ULONG = function (n) {
		return [(n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, n & 255];
	};
	mt.ULONG = or(4);
	ze.LONG = function (n) {
		return n >= X0 && (n = -(2 * X0 - n)), [(n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, n & 255];
	};
	mt.LONG = or(4);
	ze.FIXED = ze.ULONG;
	mt.FIXED = mt.ULONG;
	ze.FWORD = ze.SHORT;
	mt.FWORD = mt.SHORT;
	ze.UFWORD = ze.USHORT;
	mt.UFWORD = mt.USHORT;
	ze.LONGDATETIME = function (n) {
		return [0, 0, 0, 0, (n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, n & 255];
	};
	mt.LONGDATETIME = or(8);
	ze.TAG = function (n) {
		return tt.argument(n.length === 4, "Tag should be exactly 4 ASCII characters."), [n.charCodeAt(0), n.charCodeAt(1), n.charCodeAt(2), n.charCodeAt(3)];
	};
	mt.TAG = or(4);
	ze.Card8 = ze.BYTE;
	mt.Card8 = mt.BYTE;
	ze.Card16 = ze.USHORT;
	mt.Card16 = mt.USHORT;
	ze.OffSize = ze.BYTE;
	mt.OffSize = mt.BYTE;
	ze.SID = ze.USHORT;
	mt.SID = mt.USHORT;
	ze.NUMBER = function (n) {
		return n >= -107 && n <= 107 ? [n + 139] : n >= 108 && n <= 1131 ? ((n = n - 108), [(n >> 8) + 247, n & 255]) : n >= -1131 && n <= -108 ? ((n = -n - 108), [(n >> 8) + 251, n & 255]) : n >= -32768 && n <= 32767 ? ze.NUMBER16(n) : ze.NUMBER32(n);
	};
	mt.NUMBER = function (n) {
		return ze.NUMBER(n).length;
	};
	ze.NUMBER16 = function (n) {
		return [28, (n >> 8) & 255, n & 255];
	};
	mt.NUMBER16 = or(3);
	ze.NUMBER32 = function (n) {
		return [29, (n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, n & 255];
	};
	mt.NUMBER32 = or(5);
	ze.REAL = function (n) {
		var e = n.toString(),
			t = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(e);
		if (t) {
			var i = parseFloat("1e" + ((t[2] ? +t[2] : 0) + t[1].length));
			e = (Math.round(n * i) / i).toString();
		}
		for (var r = "", s = 0, a = e.length; s < a; s += 1) {
			var o = e[s];
			o === "e" ? (r += e[++s] === "-" ? "c" : "b") : o === "." ? (r += "a") : o === "-" ? (r += "e") : (r += o);
		}
		r += r.length & 1 ? "f" : "ff";
		for (var l = [30], c = 0, u = r.length; c < u; c += 2) l.push(parseInt(r.substr(c, 2), 16));
		return l;
	};
	mt.REAL = function (n) {
		return ze.REAL(n).length;
	};
	ze.NAME = ze.CHARARRAY;
	mt.NAME = mt.CHARARRAY;
	ze.STRING = ze.CHARARRAY;
	mt.STRING = mt.CHARARRAY;
	Ho.UTF8 = function (n, e, t) {
		for (var i = [], r = t, s = 0; s < r; s++, e += 1) i[s] = n.getUint8(e);
		return String.fromCharCode.apply(null, i);
	};
	Ho.UTF16 = function (n, e, t) {
		for (var i = [], r = t / 2, s = 0; s < r; s++, e += 2) i[s] = n.getUint16(e);
		return String.fromCharCode.apply(null, i);
	};
	ze.UTF16 = function (n) {
		for (var e = [], t = 0; t < n.length; t += 1) {
			var i = n.charCodeAt(t);
			(e[e.length] = (i >> 8) & 255), (e[e.length] = i & 255);
		}
		return e;
	};
	mt.UTF16 = function (n) {
		return n.length * 2;
	};
	var op = {
		"x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
		"x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",
		"x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ",
		"x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­",
		"x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
		"x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
		"x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
		macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
		"x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
		"x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"
	};
	Ho.MACSTRING = function (n, e, t, i) {
		var r = op[i];
		if (r !== void 0) {
			for (var s = "", a = 0; a < t; a++) {
				var o = n.getUint8(e + a);
				o <= 127 ? (s += String.fromCharCode(o)) : (s += r[o & 127]);
			}
			return s;
		}
	};
	var mu = typeof WeakMap == "function" && new WeakMap(),
		gu,
		WI = function (n) {
			if (!gu) {
				gu = {};
				for (var e in op) gu[e] = new String(e);
			}
			var t = gu[n];
			if (t !== void 0) {
				if (mu) {
					var i = mu.get(t);
					if (i !== void 0) return i;
				}
				var r = op[n];
				if (r !== void 0) {
					for (var s = {}, a = 0; a < r.length; a++) s[r.charCodeAt(a)] = a + 128;
					return mu && mu.set(t, s), s;
				}
			}
		};
	ze.MACSTRING = function (n, e) {
		var t = WI(e);
		if (t !== void 0) {
			for (var i = [], r = 0; r < n.length; r++) {
				var s = n.charCodeAt(r);
				if (s >= 128 && ((s = t[s]), s === void 0)) return;
				i[r] = s;
			}
			return i;
		}
	};
	mt.MACSTRING = function (n, e) {
		var t = ze.MACSTRING(n, e);
		return t !== void 0 ? t.length : 0;
	};
	function lp(n) {
		return n >= -128 && n <= 127;
	}
	function XI(n, e, t) {
		for (var i = 0, r = n.length; e < r && i < 64 && n[e] === 0; ) ++e, ++i;
		return t.push(128 | (i - 1)), e;
	}
	function $I(n, e, t) {
		for (var i = 0, r = n.length, s = e; s < r && i < 64; ) {
			var a = n[s];
			if (!lp(a) || (a === 0 && s + 1 < r && n[s + 1] === 0)) break;
			++s, ++i;
		}
		t.push(i - 1);
		for (var o = e; o < s; ++o) t.push((n[o] + 256) & 255);
		return s;
	}
	function qI(n, e, t) {
		for (var i = 0, r = n.length, s = e; s < r && i < 64; ) {
			var a = n[s];
			if (a === 0 || (lp(a) && s + 1 < r && lp(n[s + 1]))) break;
			++s, ++i;
		}
		t.push(64 | (i - 1));
		for (var o = e; o < s; ++o) {
			var l = n[o];
			t.push(((l + 65536) >> 8) & 255, (l + 256) & 255);
		}
		return s;
	}
	ze.VARDELTAS = function (n) {
		for (var e = 0, t = []; e < n.length; ) {
			var i = n[e];
			i === 0 ? (e = XI(n, e, t)) : i >= -128 && i <= 127 ? (e = $I(n, e, t)) : (e = qI(n, e, t));
		}
		return t;
	};
	ze.INDEX = function (n) {
		for (var e = 1, t = [e], i = [], r = 0; r < n.length; r += 1) {
			var s = ze.OBJECT(n[r]);
			Array.prototype.push.apply(i, s), (e += s.length), t.push(e);
		}
		if (i.length === 0) return [0, 0];
		for (var a = [], o = (1 + Math.floor(Math.log(e) / Math.log(2)) / 8) | 0, l = [void 0, ze.BYTE, ze.USHORT, ze.UINT24, ze.ULONG][o], c = 0; c < t.length; c += 1) {
			var u = l(t[c]);
			Array.prototype.push.apply(a, u);
		}
		return Array.prototype.concat(ze.Card16(n.length), ze.OffSize(o), a, i);
	};
	mt.INDEX = function (n) {
		return ze.INDEX(n).length;
	};
	ze.DICT = function (n) {
		for (var e = [], t = Object.keys(n), i = t.length, r = 0; r < i; r += 1) {
			var s = parseInt(t[r], 0),
				a = n[s];
			(e = e.concat(ze.OPERAND(a.value, a.type))), (e = e.concat(ze.OPERATOR(s)));
		}
		return e;
	};
	mt.DICT = function (n) {
		return ze.DICT(n).length;
	};
	ze.OPERATOR = function (n) {
		return n < 1200 ? [n] : [12, n - 1200];
	};
	ze.OPERAND = function (n, e) {
		var t = [];
		if (Array.isArray(e)) for (var i = 0; i < e.length; i += 1) tt.argument(n.length === e.length, "Not enough arguments given for type" + e), (t = t.concat(ze.OPERAND(n[i], e[i])));
		else if (e === "SID") t = t.concat(ze.NUMBER(n));
		else if (e === "offset") t = t.concat(ze.NUMBER32(n));
		else if (e === "number") t = t.concat(ze.NUMBER(n));
		else if (e === "real") t = t.concat(ze.REAL(n));
		else throw new Error("Unknown operand type " + e);
		return t;
	};
	ze.OP = ze.BYTE;
	mt.OP = mt.BYTE;
	var vu = typeof WeakMap == "function" && new WeakMap();
	ze.CHARSTRING = function (n) {
		if (vu) {
			var e = vu.get(n);
			if (e !== void 0) return e;
		}
		for (var t = [], i = n.length, r = 0; r < i; r += 1) {
			var s = n[r];
			t = t.concat(ze[s.type](s.value));
		}
		return vu && vu.set(n, t), t;
	};
	mt.CHARSTRING = function (n) {
		return ze.CHARSTRING(n).length;
	};
	ze.OBJECT = function (n) {
		var e = ze[n.type];
		return tt.argument(e !== void 0, "No encoding function for type " + n.type), e(n.value);
	};
	mt.OBJECT = function (n) {
		var e = mt[n.type];
		return tt.argument(e !== void 0, "No sizeOf function for type " + n.type), e(n.value);
	};
	ze.TABLE = function (n) {
		for (var e = [], t = n.fields.length, i = [], r = [], s = 0; s < t; s += 1) {
			var a = n.fields[s],
				o = ze[a.type];
			tt.argument(o !== void 0, "No encoding function for field type " + a.type + " (" + a.name + ")");
			var l = n[a.name];
			l === void 0 && (l = a.value);
			var c = o(l);
			a.type === "TABLE" ? (r.push(e.length), (e = e.concat([0, 0])), i.push(c)) : (e = e.concat(c));
		}
		for (var u = 0; u < i.length; u += 1) {
			var h = r[u],
				d = e.length;
			tt.argument(d < 65536, "Table " + n.tableName + " too big."), (e[h] = d >> 8), (e[h + 1] = d & 255), (e = e.concat(i[u]));
		}
		return e;
	};
	mt.TABLE = function (n) {
		for (var e = 0, t = n.fields.length, i = 0; i < t; i += 1) {
			var r = n.fields[i],
				s = mt[r.type];
			tt.argument(s !== void 0, "No sizeOf function for field type " + r.type + " (" + r.name + ")");
			var a = n[r.name];
			a === void 0 && (a = r.value), (e += s(a)), r.type === "TABLE" && (e += 2);
		}
		return e;
	};
	ze.RECORD = ze.TABLE;
	mt.RECORD = mt.TABLE;
	ze.LITERAL = function (n) {
		return n;
	};
	mt.LITERAL = function (n) {
		return n.length;
	};
	function On(n, e, t) {
		if (e.length && (e[0].name !== "coverageFormat" || e[0].value === 1))
			for (var i = 0; i < e.length; i += 1) {
				var r = e[i];
				this[r.name] = r.value;
			}
		if (((this.tableName = n), (this.fields = e), t))
			for (var s = Object.keys(t), a = 0; a < s.length; a += 1) {
				var o = s[a],
					l = t[o];
				this[o] !== void 0 && (this[o] = l);
			}
	}
	On.prototype.encode = function () {
		return ze.TABLE(this);
	};
	On.prototype.sizeOf = function () {
		return mt.TABLE(this);
	};
	function zl(n, e, t) {
		t === void 0 && (t = e.length);
		var i = new Array(e.length + 1);
		i[0] = { name: n + "Count", type: "USHORT", value: t };
		for (var r = 0; r < e.length; r++) i[r + 1] = { name: n + r, type: "USHORT", value: e[r] };
		return i;
	}
	function cp(n, e, t) {
		var i = e.length,
			r = new Array(i + 1);
		r[0] = { name: n + "Count", type: "USHORT", value: i };
		for (var s = 0; s < i; s++) r[s + 1] = { name: n + s, type: "TABLE", value: t(e[s], s) };
		return r;
	}
	function Hl(n, e, t) {
		var i = e.length,
			r = [];
		r[0] = { name: n + "Count", type: "USHORT", value: i };
		for (var s = 0; s < i; s++) r = r.concat(t(e[s], s));
		return r;
	}
	function th(n) {
		n.format === 1
			? On.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(zl("glyph", n.glyphs)))
			: n.format === 2
			? On.call(
					this,
					"coverageTable",
					[{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(
						Hl("rangeRecord", n.ranges, function (e) {
							return [
								{ name: "startGlyphID", type: "USHORT", value: e.start },
								{ name: "endGlyphID", type: "USHORT", value: e.end },
								{ name: "startCoverageIndex", type: "USHORT", value: e.index }
							];
						})
					)
			  )
			: tt.assert(!1, "Coverage format must be 1 or 2.");
	}
	th.prototype = Object.create(On.prototype);
	th.prototype.constructor = th;
	function nh(n) {
		On.call(
			this,
			"scriptListTable",
			Hl("scriptRecord", n, function (e, t) {
				var i = e.script,
					r = i.defaultLangSys;
				return (
					tt.assert(!!r, "Unable to write GSUB: script " + e.tag + " has no default language system."),
					[
						{ name: "scriptTag" + t, type: "TAG", value: e.tag },
						{
							name: "script" + t,
							type: "TABLE",
							value: new On(
								"scriptTable",
								[
									{
										name: "defaultLangSys",
										type: "TABLE",
										value: new On(
											"defaultLangSys",
											[
												{ name: "lookupOrder", type: "USHORT", value: 0 },
												{ name: "reqFeatureIndex", type: "USHORT", value: r.reqFeatureIndex }
											].concat(zl("featureIndex", r.featureIndexes))
										)
									}
								].concat(
									Hl("langSys", i.langSysRecords, function (s, a) {
										var o = s.langSys;
										return [
											{ name: "langSysTag" + a, type: "TAG", value: s.tag },
											{
												name: "langSys" + a,
												type: "TABLE",
												value: new On(
													"langSys",
													[
														{ name: "lookupOrder", type: "USHORT", value: 0 },
														{ name: "reqFeatureIndex", type: "USHORT", value: o.reqFeatureIndex }
													].concat(zl("featureIndex", o.featureIndexes))
												)
											}
										];
									})
								)
							)
						}
					]
				);
			})
		);
	}
	nh.prototype = Object.create(On.prototype);
	nh.prototype.constructor = nh;
	function ih(n) {
		On.call(
			this,
			"featureListTable",
			Hl("featureRecord", n, function (e, t) {
				var i = e.feature;
				return [
					{ name: "featureTag" + t, type: "TAG", value: e.tag },
					{ name: "feature" + t, type: "TABLE", value: new On("featureTable", [{ name: "featureParams", type: "USHORT", value: i.featureParams }].concat(zl("lookupListIndex", i.lookupListIndexes))) }
				];
			})
		);
	}
	ih.prototype = Object.create(On.prototype);
	ih.prototype.constructor = ih;
	function rh(n, e) {
		On.call(
			this,
			"lookupListTable",
			cp("lookup", n, function (t) {
				var i = e[t.lookupType];
				return (
					tt.assert(!!i, "Unable to write GSUB lookup type " + t.lookupType + " tables."),
					new On(
						"lookupTable",
						[
							{ name: "lookupType", type: "USHORT", value: t.lookupType },
							{ name: "lookupFlag", type: "USHORT", value: t.lookupFlag }
						].concat(cp("subtable", t.subtables, i))
					)
				);
			})
		);
	}
	rh.prototype = Object.create(On.prototype);
	rh.prototype.constructor = rh;
	var Ve = { Table: On, Record: On, Coverage: th, ScriptList: nh, FeatureList: ih, LookupList: rh, ushortList: zl, tableList: cp, recordList: Hl };
	function $0(n, e) {
		return n.getUint8(e);
	}
	function sh(n, e) {
		return n.getUint16(e, !1);
	}
	function jI(n, e) {
		return n.getInt16(e, !1);
	}
	function om(n, e) {
		return n.getUint32(e, !1);
	}
	function Nx(n, e) {
		var t = n.getInt16(e, !1),
			i = n.getUint16(e + 2, !1);
		return t + i / 65535;
	}
	function YI(n, e) {
		for (var t = "", i = e; i < e + 4; i += 1) t += String.fromCharCode(n.getInt8(i));
		return t;
	}
	function KI(n, e, t) {
		for (var i = 0, r = 0; r < t; r += 1) (i <<= 8), (i += n.getUint8(e + r));
		return i;
	}
	function ZI(n, e, t) {
		for (var i = [], r = e; r < t; r += 1) i.push(n.getUint8(r));
		return i;
	}
	function JI(n) {
		for (var e = "", t = 0; t < n.length; t += 1) e += String.fromCharCode(n[t]);
		return e;
	}
	var QI = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
	function ne(n, e) {
		(this.data = n), (this.offset = e), (this.relativeOffset = 0);
	}
	ne.prototype.parseByte = function () {
		var n = this.data.getUint8(this.offset + this.relativeOffset);
		return (this.relativeOffset += 1), n;
	};
	ne.prototype.parseChar = function () {
		var n = this.data.getInt8(this.offset + this.relativeOffset);
		return (this.relativeOffset += 1), n;
	};
	ne.prototype.parseCard8 = ne.prototype.parseByte;
	ne.prototype.parseUShort = function () {
		var n = this.data.getUint16(this.offset + this.relativeOffset);
		return (this.relativeOffset += 2), n;
	};
	ne.prototype.parseCard16 = ne.prototype.parseUShort;
	ne.prototype.parseSID = ne.prototype.parseUShort;
	ne.prototype.parseOffset16 = ne.prototype.parseUShort;
	ne.prototype.parseShort = function () {
		var n = this.data.getInt16(this.offset + this.relativeOffset);
		return (this.relativeOffset += 2), n;
	};
	ne.prototype.parseF2Dot14 = function () {
		var n = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
		return (this.relativeOffset += 2), n;
	};
	ne.prototype.parseULong = function () {
		var n = om(this.data, this.offset + this.relativeOffset);
		return (this.relativeOffset += 4), n;
	};
	ne.prototype.parseOffset32 = ne.prototype.parseULong;
	ne.prototype.parseFixed = function () {
		var n = Nx(this.data, this.offset + this.relativeOffset);
		return (this.relativeOffset += 4), n;
	};
	ne.prototype.parseString = function (n) {
		var e = this.data,
			t = this.offset + this.relativeOffset,
			i = "";
		this.relativeOffset += n;
		for (var r = 0; r < n; r++) i += String.fromCharCode(e.getUint8(t + r));
		return i;
	};
	ne.prototype.parseTag = function () {
		return this.parseString(4);
	};
	ne.prototype.parseLongDateTime = function () {
		var n = om(this.data, this.offset + this.relativeOffset + 4);
		return (n -= 2082844800), (this.relativeOffset += 8), n;
	};
	ne.prototype.parseVersion = function (n) {
		var e = sh(this.data, this.offset + this.relativeOffset),
			t = sh(this.data, this.offset + this.relativeOffset + 2);
		return (this.relativeOffset += 4), n === void 0 && (n = 4096), e + t / n / 10;
	};
	ne.prototype.skip = function (n, e) {
		e === void 0 && (e = 1), (this.relativeOffset += QI[n] * e);
	};
	ne.prototype.parseULongList = function (n) {
		n === void 0 && (n = this.parseULong());
		for (var e = new Array(n), t = this.data, i = this.offset + this.relativeOffset, r = 0; r < n; r++) (e[r] = t.getUint32(i)), (i += 4);
		return (this.relativeOffset += n * 4), e;
	};
	ne.prototype.parseOffset16List = ne.prototype.parseUShortList = function (n) {
		n === void 0 && (n = this.parseUShort());
		for (var e = new Array(n), t = this.data, i = this.offset + this.relativeOffset, r = 0; r < n; r++) (e[r] = t.getUint16(i)), (i += 2);
		return (this.relativeOffset += n * 2), e;
	};
	ne.prototype.parseShortList = function (n) {
		for (var e = new Array(n), t = this.data, i = this.offset + this.relativeOffset, r = 0; r < n; r++) (e[r] = t.getInt16(i)), (i += 2);
		return (this.relativeOffset += n * 2), e;
	};
	ne.prototype.parseByteList = function (n) {
		for (var e = new Array(n), t = this.data, i = this.offset + this.relativeOffset, r = 0; r < n; r++) e[r] = t.getUint8(i++);
		return (this.relativeOffset += n), e;
	};
	ne.prototype.parseList = function (n, e) {
		e || ((e = n), (n = this.parseUShort()));
		for (var t = new Array(n), i = 0; i < n; i++) t[i] = e.call(this);
		return t;
	};
	ne.prototype.parseList32 = function (n, e) {
		e || ((e = n), (n = this.parseULong()));
		for (var t = new Array(n), i = 0; i < n; i++) t[i] = e.call(this);
		return t;
	};
	ne.prototype.parseRecordList = function (n, e) {
		e || ((e = n), (n = this.parseUShort()));
		for (var t = new Array(n), i = Object.keys(e), r = 0; r < n; r++) {
			for (var s = {}, a = 0; a < i.length; a++) {
				var o = i[a],
					l = e[o];
				s[o] = l.call(this);
			}
			t[r] = s;
		}
		return t;
	};
	ne.prototype.parseRecordList32 = function (n, e) {
		e || ((e = n), (n = this.parseULong()));
		for (var t = new Array(n), i = Object.keys(e), r = 0; r < n; r++) {
			for (var s = {}, a = 0; a < i.length; a++) {
				var o = i[a],
					l = e[o];
				s[o] = l.call(this);
			}
			t[r] = s;
		}
		return t;
	};
	ne.prototype.parseStruct = function (n) {
		if (typeof n == "function") return n.call(this);
		for (var e = Object.keys(n), t = {}, i = 0; i < e.length; i++) {
			var r = e[i],
				s = n[r];
			t[r] = s.call(this);
		}
		return t;
	};
	ne.prototype.parseValueRecord = function (n) {
		if ((n === void 0 && (n = this.parseUShort()), n !== 0)) {
			var e = {};
			return n & 1 && (e.xPlacement = this.parseShort()), n & 2 && (e.yPlacement = this.parseShort()), n & 4 && (e.xAdvance = this.parseShort()), n & 8 && (e.yAdvance = this.parseShort()), n & 16 && ((e.xPlaDevice = void 0), this.parseShort()), n & 32 && ((e.yPlaDevice = void 0), this.parseShort()), n & 64 && ((e.xAdvDevice = void 0), this.parseShort()), n & 128 && ((e.yAdvDevice = void 0), this.parseShort()), e;
		}
	};
	ne.prototype.parseValueRecordList = function () {
		for (var n = this.parseUShort(), e = this.parseUShort(), t = new Array(e), i = 0; i < e; i++) t[i] = this.parseValueRecord(n);
		return t;
	};
	ne.prototype.parsePointer = function (n) {
		var e = this.parseOffset16();
		if (e > 0) return new ne(this.data, this.offset + e).parseStruct(n);
	};
	ne.prototype.parsePointer32 = function (n) {
		var e = this.parseOffset32();
		if (e > 0) return new ne(this.data, this.offset + e).parseStruct(n);
	};
	ne.prototype.parseListOfLists = function (n) {
		for (var e = this.parseOffset16List(), t = e.length, i = this.relativeOffset, r = new Array(t), s = 0; s < t; s++) {
			var a = e[s];
			if (a === 0) {
				r[s] = void 0;
				continue;
			}
			if (((this.relativeOffset = a), n)) {
				for (var o = this.parseOffset16List(), l = new Array(o.length), c = 0; c < o.length; c++) (this.relativeOffset = a + o[c]), (l[c] = n.call(this));
				r[s] = l;
			} else r[s] = this.parseUShortList();
		}
		return (this.relativeOffset = i), r;
	};
	ne.prototype.parseCoverage = function () {
		var n = this.offset + this.relativeOffset,
			e = this.parseUShort(),
			t = this.parseUShort();
		if (e === 1) return { format: 1, glyphs: this.parseUShortList(t) };
		if (e === 2) {
			for (var i = new Array(t), r = 0; r < t; r++) i[r] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
			return { format: 2, ranges: i };
		}
		throw new Error("0x" + n.toString(16) + ": Coverage format must be 1 or 2.");
	};
	ne.prototype.parseClassDef = function () {
		var n = this.offset + this.relativeOffset,
			e = this.parseUShort();
		if (e === 1) return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
		if (e === 2) return { format: 2, ranges: this.parseRecordList({ start: ne.uShort, end: ne.uShort, classId: ne.uShort }) };
		throw new Error("0x" + n.toString(16) + ": ClassDef format must be 1 or 2.");
	};
	ne.list = function (n, e) {
		return function () {
			return this.parseList(n, e);
		};
	};
	ne.list32 = function (n, e) {
		return function () {
			return this.parseList32(n, e);
		};
	};
	ne.recordList = function (n, e) {
		return function () {
			return this.parseRecordList(n, e);
		};
	};
	ne.recordList32 = function (n, e) {
		return function () {
			return this.parseRecordList32(n, e);
		};
	};
	ne.pointer = function (n) {
		return function () {
			return this.parsePointer(n);
		};
	};
	ne.pointer32 = function (n) {
		return function () {
			return this.parsePointer32(n);
		};
	};
	ne.tag = ne.prototype.parseTag;
	ne.byte = ne.prototype.parseByte;
	ne.uShort = ne.offset16 = ne.prototype.parseUShort;
	ne.uShortList = ne.prototype.parseUShortList;
	ne.uLong = ne.offset32 = ne.prototype.parseULong;
	ne.uLongList = ne.prototype.parseULongList;
	ne.struct = ne.prototype.parseStruct;
	ne.coverage = ne.prototype.parseCoverage;
	ne.classDef = ne.prototype.parseClassDef;
	var q0 = { reserved: ne.uShort, reqFeatureIndex: ne.uShort, featureIndexes: ne.uShortList };
	ne.prototype.parseScriptList = function () {
		return this.parsePointer(ne.recordList({ tag: ne.tag, script: ne.pointer({ defaultLangSys: ne.pointer(q0), langSysRecords: ne.recordList({ tag: ne.tag, langSys: ne.pointer(q0) }) }) })) || [];
	};
	ne.prototype.parseFeatureList = function () {
		return this.parsePointer(ne.recordList({ tag: ne.tag, feature: ne.pointer({ featureParams: ne.offset16, lookupListIndexes: ne.uShortList }) })) || [];
	};
	ne.prototype.parseLookupList = function (n) {
		return (
			this.parsePointer(
				ne.list(
					ne.pointer(function () {
						var e = this.parseUShort();
						tt.argument(1 <= e && e <= 9, "GPOS/GSUB lookup type " + e + " unknown.");
						var t = this.parseUShort(),
							i = t & 16;
						return { lookupType: e, lookupFlag: t, subtables: this.parseList(ne.pointer(n[e])), markFilteringSet: i ? this.parseUShort() : void 0 };
					})
				)
			) || []
		);
	};
	ne.prototype.parseFeatureVariationsList = function () {
		return (
			this.parsePointer32(function () {
				var n = this.parseUShort(),
					e = this.parseUShort();
				tt.argument(n === 1 && e < 1, "GPOS/GSUB feature variations table unknown.");
				var t = this.parseRecordList32({ conditionSetOffset: ne.offset32, featureTableSubstitutionOffset: ne.offset32 });
				return t;
			}) || []
		);
	};
	var Ze = { getByte: $0, getCard8: $0, getUShort: sh, getCard16: sh, getShort: jI, getULong: om, getFixed: Nx, getTag: YI, getOffset: KI, getBytes: ZI, bytesToString: JI, Parser: ne };
	function eF(n, e) {
		e.parseUShort(), (n.length = e.parseULong()), (n.language = e.parseULong());
		var t;
		(n.groupCount = t = e.parseULong()), (n.glyphIndexMap = {});
		for (var i = 0; i < t; i += 1) for (var r = e.parseULong(), s = e.parseULong(), a = e.parseULong(), o = r; o <= s; o += 1) (n.glyphIndexMap[o] = a), a++;
	}
	function tF(n, e, t, i, r) {
		(n.length = e.parseUShort()), (n.language = e.parseUShort());
		var s;
		(n.segCount = s = e.parseUShort() >> 1), e.skip("uShort", 3), (n.glyphIndexMap = {});
		for (var a = new Ze.Parser(t, i + r + 14), o = new Ze.Parser(t, i + r + 16 + s * 2), l = new Ze.Parser(t, i + r + 16 + s * 4), c = new Ze.Parser(t, i + r + 16 + s * 6), u = i + r + 16 + s * 8, h = 0; h < s - 1; h += 1)
			for (var d = void 0, f = a.parseUShort(), v = o.parseUShort(), _ = l.parseShort(), p = c.parseUShort(), g = v; g <= f; g += 1) p !== 0 ? ((u = c.offset + c.relativeOffset - 2), (u += p), (u += (g - v) * 2), (d = Ze.getUShort(t, u)), d !== 0 && (d = (d + _) & 65535)) : (d = (g + _) & 65535), (n.glyphIndexMap[g] = d);
	}
	function nF(n, e) {
		var t = {};
		(t.version = Ze.getUShort(n, e)), tt.argument(t.version === 0, "cmap table version should be 0."), (t.numTables = Ze.getUShort(n, e + 2));
		for (var i = -1, r = t.numTables - 1; r >= 0; r -= 1) {
			var s = Ze.getUShort(n, e + 4 + r * 8),
				a = Ze.getUShort(n, e + 4 + r * 8 + 2);
			if ((s === 3 && (a === 0 || a === 1 || a === 10)) || (s === 0 && (a === 0 || a === 1 || a === 2 || a === 3 || a === 4))) {
				i = Ze.getULong(n, e + 4 + r * 8 + 4);
				break;
			}
		}
		if (i === -1) throw new Error("No valid cmap sub-tables found.");
		var o = new Ze.Parser(n, e + i);
		if (((t.format = o.parseUShort()), t.format === 12)) eF(t, o);
		else if (t.format === 4) tF(t, o, n, e, i);
		else throw new Error("Only format 4 and 12 cmap tables are supported (found format " + t.format + ").");
		return t;
	}
	function iF(n, e, t) {
		n.segments.push({ end: e, start: e, delta: -(e - t), offset: 0, glyphIndex: t });
	}
	function rF(n) {
		n.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });
	}
	function sF(n) {
		var e = !0,
			t;
		for (t = n.length - 1; t > 0; t -= 1) {
			var i = n.get(t);
			if (i.unicode > 65535) {
				console.log("Adding CMAP format 12 (needed!)"), (e = !1);
				break;
			}
		}
		var r = [
			{ name: "version", type: "USHORT", value: 0 },
			{ name: "numTables", type: "USHORT", value: e ? 1 : 2 },
			{ name: "platformID", type: "USHORT", value: 3 },
			{ name: "encodingID", type: "USHORT", value: 1 },
			{ name: "offset", type: "ULONG", value: e ? 12 : 20 }
		];
		e ||
			(r = r.concat([
				{ name: "cmap12PlatformID", type: "USHORT", value: 3 },
				{ name: "cmap12EncodingID", type: "USHORT", value: 10 },
				{ name: "cmap12Offset", type: "ULONG", value: 0 }
			])),
			(r = r.concat([
				{ name: "format", type: "USHORT", value: 4 },
				{ name: "cmap4Length", type: "USHORT", value: 0 },
				{ name: "language", type: "USHORT", value: 0 },
				{ name: "segCountX2", type: "USHORT", value: 0 },
				{ name: "searchRange", type: "USHORT", value: 0 },
				{ name: "entrySelector", type: "USHORT", value: 0 },
				{ name: "rangeShift", type: "USHORT", value: 0 }
			]));
		var s = new Ve.Table("cmap", r);
		for (s.segments = [], t = 0; t < n.length; t += 1) {
			for (var a = n.get(t), o = 0; o < a.unicodes.length; o += 1) iF(s, a.unicodes[o], t);
			s.segments = s.segments.sort(function (x, b) {
				return x.start - b.start;
			});
		}
		rF(s);
		var l = s.segments.length,
			c = 0,
			u = [],
			h = [],
			d = [],
			f = [],
			v = [],
			_ = [];
		for (t = 0; t < l; t += 1) {
			var p = s.segments[t];
			p.end <= 65535 && p.start <= 65535 ? ((u = u.concat({ name: "end_" + t, type: "USHORT", value: p.end })), (h = h.concat({ name: "start_" + t, type: "USHORT", value: p.start })), (d = d.concat({ name: "idDelta_" + t, type: "SHORT", value: p.delta })), (f = f.concat({ name: "idRangeOffset_" + t, type: "USHORT", value: p.offset })), p.glyphId !== void 0 && (v = v.concat({ name: "glyph_" + t, type: "USHORT", value: p.glyphId }))) : (c += 1),
				!e && p.glyphIndex !== void 0 && ((_ = _.concat({ name: "cmap12Start_" + t, type: "ULONG", value: p.start })), (_ = _.concat({ name: "cmap12End_" + t, type: "ULONG", value: p.end })), (_ = _.concat({ name: "cmap12Glyph_" + t, type: "ULONG", value: p.glyphIndex })));
		}
		if (
			((s.segCountX2 = (l - c) * 2),
			(s.searchRange = Math.pow(2, Math.floor(Math.log(l - c) / Math.log(2))) * 2),
			(s.entrySelector = Math.log(s.searchRange / 2) / Math.log(2)),
			(s.rangeShift = s.segCountX2 - s.searchRange),
			(s.fields = s.fields.concat(u)),
			s.fields.push({ name: "reservedPad", type: "USHORT", value: 0 }),
			(s.fields = s.fields.concat(h)),
			(s.fields = s.fields.concat(d)),
			(s.fields = s.fields.concat(f)),
			(s.fields = s.fields.concat(v)),
			(s.cmap4Length = 14 + u.length * 2 + 2 + h.length * 2 + d.length * 2 + f.length * 2 + v.length * 2),
			!e)
		) {
			var g = 16 + _.length * 4;
			(s.cmap12Offset = 12 + 2 * 2 + 4 + s.cmap4Length),
				(s.fields = s.fields.concat([
					{ name: "cmap12Format", type: "USHORT", value: 12 },
					{ name: "cmap12Reserved", type: "USHORT", value: 0 },
					{ name: "cmap12Length", type: "ULONG", value: g },
					{ name: "cmap12Language", type: "ULONG", value: 0 },
					{ name: "cmap12nGroups", type: "ULONG", value: _.length / 3 }
				])),
				(s.fields = s.fields.concat(_));
		}
		return s;
	}
	var Ux = { parse: nF, make: sF },
		Uu = [
			".notdef",
			"space",
			"exclam",
			"quotedbl",
			"numbersign",
			"dollar",
			"percent",
			"ampersand",
			"quoteright",
			"parenleft",
			"parenright",
			"asterisk",
			"plus",
			"comma",
			"hyphen",
			"period",
			"slash",
			"zero",
			"one",
			"two",
			"three",
			"four",
			"five",
			"six",
			"seven",
			"eight",
			"nine",
			"colon",
			"semicolon",
			"less",
			"equal",
			"greater",
			"question",
			"at",
			"A",
			"B",
			"C",
			"D",
			"E",
			"F",
			"G",
			"H",
			"I",
			"J",
			"K",
			"L",
			"M",
			"N",
			"O",
			"P",
			"Q",
			"R",
			"S",
			"T",
			"U",
			"V",
			"W",
			"X",
			"Y",
			"Z",
			"bracketleft",
			"backslash",
			"bracketright",
			"asciicircum",
			"underscore",
			"quoteleft",
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"g",
			"h",
			"i",
			"j",
			"k",
			"l",
			"m",
			"n",
			"o",
			"p",
			"q",
			"r",
			"s",
			"t",
			"u",
			"v",
			"w",
			"x",
			"y",
			"z",
			"braceleft",
			"bar",
			"braceright",
			"asciitilde",
			"exclamdown",
			"cent",
			"sterling",
			"fraction",
			"yen",
			"florin",
			"section",
			"currency",
			"quotesingle",
			"quotedblleft",
			"guillemotleft",
			"guilsinglleft",
			"guilsinglright",
			"fi",
			"fl",
			"endash",
			"dagger",
			"daggerdbl",
			"periodcentered",
			"paragraph",
			"bullet",
			"quotesinglbase",
			"quotedblbase",
			"quotedblright",
			"guillemotright",
			"ellipsis",
			"perthousand",
			"questiondown",
			"grave",
			"acute",
			"circumflex",
			"tilde",
			"macron",
			"breve",
			"dotaccent",
			"dieresis",
			"ring",
			"cedilla",
			"hungarumlaut",
			"ogonek",
			"caron",
			"emdash",
			"AE",
			"ordfeminine",
			"Lslash",
			"Oslash",
			"OE",
			"ordmasculine",
			"ae",
			"dotlessi",
			"lslash",
			"oslash",
			"oe",
			"germandbls",
			"onesuperior",
			"logicalnot",
			"mu",
			"trademark",
			"Eth",
			"onehalf",
			"plusminus",
			"Thorn",
			"onequarter",
			"divide",
			"brokenbar",
			"degree",
			"thorn",
			"threequarters",
			"twosuperior",
			"registered",
			"minus",
			"eth",
			"multiply",
			"threesuperior",
			"copyright",
			"Aacute",
			"Acircumflex",
			"Adieresis",
			"Agrave",
			"Aring",
			"Atilde",
			"Ccedilla",
			"Eacute",
			"Ecircumflex",
			"Edieresis",
			"Egrave",
			"Iacute",
			"Icircumflex",
			"Idieresis",
			"Igrave",
			"Ntilde",
			"Oacute",
			"Ocircumflex",
			"Odieresis",
			"Ograve",
			"Otilde",
			"Scaron",
			"Uacute",
			"Ucircumflex",
			"Udieresis",
			"Ugrave",
			"Yacute",
			"Ydieresis",
			"Zcaron",
			"aacute",
			"acircumflex",
			"adieresis",
			"agrave",
			"aring",
			"atilde",
			"ccedilla",
			"eacute",
			"ecircumflex",
			"edieresis",
			"egrave",
			"iacute",
			"icircumflex",
			"idieresis",
			"igrave",
			"ntilde",
			"oacute",
			"ocircumflex",
			"odieresis",
			"ograve",
			"otilde",
			"scaron",
			"uacute",
			"ucircumflex",
			"udieresis",
			"ugrave",
			"yacute",
			"ydieresis",
			"zcaron",
			"exclamsmall",
			"Hungarumlautsmall",
			"dollaroldstyle",
			"dollarsuperior",
			"ampersandsmall",
			"Acutesmall",
			"parenleftsuperior",
			"parenrightsuperior",
			"266 ff",
			"onedotenleader",
			"zerooldstyle",
			"oneoldstyle",
			"twooldstyle",
			"threeoldstyle",
			"fouroldstyle",
			"fiveoldstyle",
			"sixoldstyle",
			"sevenoldstyle",
			"eightoldstyle",
			"nineoldstyle",
			"commasuperior",
			"threequartersemdash",
			"periodsuperior",
			"questionsmall",
			"asuperior",
			"bsuperior",
			"centsuperior",
			"dsuperior",
			"esuperior",
			"isuperior",
			"lsuperior",
			"msuperior",
			"nsuperior",
			"osuperior",
			"rsuperior",
			"ssuperior",
			"tsuperior",
			"ff",
			"ffi",
			"ffl",
			"parenleftinferior",
			"parenrightinferior",
			"Circumflexsmall",
			"hyphensuperior",
			"Gravesmall",
			"Asmall",
			"Bsmall",
			"Csmall",
			"Dsmall",
			"Esmall",
			"Fsmall",
			"Gsmall",
			"Hsmall",
			"Ismall",
			"Jsmall",
			"Ksmall",
			"Lsmall",
			"Msmall",
			"Nsmall",
			"Osmall",
			"Psmall",
			"Qsmall",
			"Rsmall",
			"Ssmall",
			"Tsmall",
			"Usmall",
			"Vsmall",
			"Wsmall",
			"Xsmall",
			"Ysmall",
			"Zsmall",
			"colonmonetary",
			"onefitted",
			"rupiah",
			"Tildesmall",
			"exclamdownsmall",
			"centoldstyle",
			"Lslashsmall",
			"Scaronsmall",
			"Zcaronsmall",
			"Dieresissmall",
			"Brevesmall",
			"Caronsmall",
			"Dotaccentsmall",
			"Macronsmall",
			"figuredash",
			"hypheninferior",
			"Ogoneksmall",
			"Ringsmall",
			"Cedillasmall",
			"questiondownsmall",
			"oneeighth",
			"threeeighths",
			"fiveeighths",
			"seveneighths",
			"onethird",
			"twothirds",
			"zerosuperior",
			"foursuperior",
			"fivesuperior",
			"sixsuperior",
			"sevensuperior",
			"eightsuperior",
			"ninesuperior",
			"zeroinferior",
			"oneinferior",
			"twoinferior",
			"threeinferior",
			"fourinferior",
			"fiveinferior",
			"sixinferior",
			"seveninferior",
			"eightinferior",
			"nineinferior",
			"centinferior",
			"dollarinferior",
			"periodinferior",
			"commainferior",
			"Agravesmall",
			"Aacutesmall",
			"Acircumflexsmall",
			"Atildesmall",
			"Adieresissmall",
			"Aringsmall",
			"AEsmall",
			"Ccedillasmall",
			"Egravesmall",
			"Eacutesmall",
			"Ecircumflexsmall",
			"Edieresissmall",
			"Igravesmall",
			"Iacutesmall",
			"Icircumflexsmall",
			"Idieresissmall",
			"Ethsmall",
			"Ntildesmall",
			"Ogravesmall",
			"Oacutesmall",
			"Ocircumflexsmall",
			"Otildesmall",
			"Odieresissmall",
			"OEsmall",
			"Oslashsmall",
			"Ugravesmall",
			"Uacutesmall",
			"Ucircumflexsmall",
			"Udieresissmall",
			"Yacutesmall",
			"Thornsmall",
			"Ydieresissmall",
			"001.000",
			"001.001",
			"001.002",
			"001.003",
			"Black",
			"Bold",
			"Book",
			"Light",
			"Medium",
			"Regular",
			"Roman",
			"Semibold"
		],
		aF = [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"space",
			"exclam",
			"quotedbl",
			"numbersign",
			"dollar",
			"percent",
			"ampersand",
			"quoteright",
			"parenleft",
			"parenright",
			"asterisk",
			"plus",
			"comma",
			"hyphen",
			"period",
			"slash",
			"zero",
			"one",
			"two",
			"three",
			"four",
			"five",
			"six",
			"seven",
			"eight",
			"nine",
			"colon",
			"semicolon",
			"less",
			"equal",
			"greater",
			"question",
			"at",
			"A",
			"B",
			"C",
			"D",
			"E",
			"F",
			"G",
			"H",
			"I",
			"J",
			"K",
			"L",
			"M",
			"N",
			"O",
			"P",
			"Q",
			"R",
			"S",
			"T",
			"U",
			"V",
			"W",
			"X",
			"Y",
			"Z",
			"bracketleft",
			"backslash",
			"bracketright",
			"asciicircum",
			"underscore",
			"quoteleft",
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"g",
			"h",
			"i",
			"j",
			"k",
			"l",
			"m",
			"n",
			"o",
			"p",
			"q",
			"r",
			"s",
			"t",
			"u",
			"v",
			"w",
			"x",
			"y",
			"z",
			"braceleft",
			"bar",
			"braceright",
			"asciitilde",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"exclamdown",
			"cent",
			"sterling",
			"fraction",
			"yen",
			"florin",
			"section",
			"currency",
			"quotesingle",
			"quotedblleft",
			"guillemotleft",
			"guilsinglleft",
			"guilsinglright",
			"fi",
			"fl",
			"",
			"endash",
			"dagger",
			"daggerdbl",
			"periodcentered",
			"",
			"paragraph",
			"bullet",
			"quotesinglbase",
			"quotedblbase",
			"quotedblright",
			"guillemotright",
			"ellipsis",
			"perthousand",
			"",
			"questiondown",
			"",
			"grave",
			"acute",
			"circumflex",
			"tilde",
			"macron",
			"breve",
			"dotaccent",
			"dieresis",
			"",
			"ring",
			"cedilla",
			"",
			"hungarumlaut",
			"ogonek",
			"caron",
			"emdash",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"AE",
			"",
			"ordfeminine",
			"",
			"",
			"",
			"",
			"Lslash",
			"Oslash",
			"OE",
			"ordmasculine",
			"",
			"",
			"",
			"",
			"",
			"ae",
			"",
			"",
			"",
			"dotlessi",
			"",
			"",
			"lslash",
			"oslash",
			"oe",
			"germandbls"
		],
		oF = [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"space",
			"exclamsmall",
			"Hungarumlautsmall",
			"",
			"dollaroldstyle",
			"dollarsuperior",
			"ampersandsmall",
			"Acutesmall",
			"parenleftsuperior",
			"parenrightsuperior",
			"twodotenleader",
			"onedotenleader",
			"comma",
			"hyphen",
			"period",
			"fraction",
			"zerooldstyle",
			"oneoldstyle",
			"twooldstyle",
			"threeoldstyle",
			"fouroldstyle",
			"fiveoldstyle",
			"sixoldstyle",
			"sevenoldstyle",
			"eightoldstyle",
			"nineoldstyle",
			"colon",
			"semicolon",
			"commasuperior",
			"threequartersemdash",
			"periodsuperior",
			"questionsmall",
			"",
			"asuperior",
			"bsuperior",
			"centsuperior",
			"dsuperior",
			"esuperior",
			"",
			"",
			"isuperior",
			"",
			"",
			"lsuperior",
			"msuperior",
			"nsuperior",
			"osuperior",
			"",
			"",
			"rsuperior",
			"ssuperior",
			"tsuperior",
			"",
			"ff",
			"fi",
			"fl",
			"ffi",
			"ffl",
			"parenleftinferior",
			"",
			"parenrightinferior",
			"Circumflexsmall",
			"hyphensuperior",
			"Gravesmall",
			"Asmall",
			"Bsmall",
			"Csmall",
			"Dsmall",
			"Esmall",
			"Fsmall",
			"Gsmall",
			"Hsmall",
			"Ismall",
			"Jsmall",
			"Ksmall",
			"Lsmall",
			"Msmall",
			"Nsmall",
			"Osmall",
			"Psmall",
			"Qsmall",
			"Rsmall",
			"Ssmall",
			"Tsmall",
			"Usmall",
			"Vsmall",
			"Wsmall",
			"Xsmall",
			"Ysmall",
			"Zsmall",
			"colonmonetary",
			"onefitted",
			"rupiah",
			"Tildesmall",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"exclamdownsmall",
			"centoldstyle",
			"Lslashsmall",
			"",
			"",
			"Scaronsmall",
			"Zcaronsmall",
			"Dieresissmall",
			"Brevesmall",
			"Caronsmall",
			"",
			"Dotaccentsmall",
			"",
			"",
			"Macronsmall",
			"",
			"",
			"figuredash",
			"hypheninferior",
			"",
			"",
			"Ogoneksmall",
			"Ringsmall",
			"Cedillasmall",
			"",
			"",
			"",
			"onequarter",
			"onehalf",
			"threequarters",
			"questiondownsmall",
			"oneeighth",
			"threeeighths",
			"fiveeighths",
			"seveneighths",
			"onethird",
			"twothirds",
			"",
			"",
			"zerosuperior",
			"onesuperior",
			"twosuperior",
			"threesuperior",
			"foursuperior",
			"fivesuperior",
			"sixsuperior",
			"sevensuperior",
			"eightsuperior",
			"ninesuperior",
			"zeroinferior",
			"oneinferior",
			"twoinferior",
			"threeinferior",
			"fourinferior",
			"fiveinferior",
			"sixinferior",
			"seveninferior",
			"eightinferior",
			"nineinferior",
			"centinferior",
			"dollarinferior",
			"periodinferior",
			"commainferior",
			"Agravesmall",
			"Aacutesmall",
			"Acircumflexsmall",
			"Atildesmall",
			"Adieresissmall",
			"Aringsmall",
			"AEsmall",
			"Ccedillasmall",
			"Egravesmall",
			"Eacutesmall",
			"Ecircumflexsmall",
			"Edieresissmall",
			"Igravesmall",
			"Iacutesmall",
			"Icircumflexsmall",
			"Idieresissmall",
			"Ethsmall",
			"Ntildesmall",
			"Ogravesmall",
			"Oacutesmall",
			"Ocircumflexsmall",
			"Otildesmall",
			"Odieresissmall",
			"OEsmall",
			"Oslashsmall",
			"Ugravesmall",
			"Uacutesmall",
			"Ucircumflexsmall",
			"Udieresissmall",
			"Yacutesmall",
			"Thornsmall",
			"Ydieresissmall"
		],
		la = [
			".notdef",
			".null",
			"nonmarkingreturn",
			"space",
			"exclam",
			"quotedbl",
			"numbersign",
			"dollar",
			"percent",
			"ampersand",
			"quotesingle",
			"parenleft",
			"parenright",
			"asterisk",
			"plus",
			"comma",
			"hyphen",
			"period",
			"slash",
			"zero",
			"one",
			"two",
			"three",
			"four",
			"five",
			"six",
			"seven",
			"eight",
			"nine",
			"colon",
			"semicolon",
			"less",
			"equal",
			"greater",
			"question",
			"at",
			"A",
			"B",
			"C",
			"D",
			"E",
			"F",
			"G",
			"H",
			"I",
			"J",
			"K",
			"L",
			"M",
			"N",
			"O",
			"P",
			"Q",
			"R",
			"S",
			"T",
			"U",
			"V",
			"W",
			"X",
			"Y",
			"Z",
			"bracketleft",
			"backslash",
			"bracketright",
			"asciicircum",
			"underscore",
			"grave",
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"g",
			"h",
			"i",
			"j",
			"k",
			"l",
			"m",
			"n",
			"o",
			"p",
			"q",
			"r",
			"s",
			"t",
			"u",
			"v",
			"w",
			"x",
			"y",
			"z",
			"braceleft",
			"bar",
			"braceright",
			"asciitilde",
			"Adieresis",
			"Aring",
			"Ccedilla",
			"Eacute",
			"Ntilde",
			"Odieresis",
			"Udieresis",
			"aacute",
			"agrave",
			"acircumflex",
			"adieresis",
			"atilde",
			"aring",
			"ccedilla",
			"eacute",
			"egrave",
			"ecircumflex",
			"edieresis",
			"iacute",
			"igrave",
			"icircumflex",
			"idieresis",
			"ntilde",
			"oacute",
			"ograve",
			"ocircumflex",
			"odieresis",
			"otilde",
			"uacute",
			"ugrave",
			"ucircumflex",
			"udieresis",
			"dagger",
			"degree",
			"cent",
			"sterling",
			"section",
			"bullet",
			"paragraph",
			"germandbls",
			"registered",
			"copyright",
			"trademark",
			"acute",
			"dieresis",
			"notequal",
			"AE",
			"Oslash",
			"infinity",
			"plusminus",
			"lessequal",
			"greaterequal",
			"yen",
			"mu",
			"partialdiff",
			"summation",
			"product",
			"pi",
			"integral",
			"ordfeminine",
			"ordmasculine",
			"Omega",
			"ae",
			"oslash",
			"questiondown",
			"exclamdown",
			"logicalnot",
			"radical",
			"florin",
			"approxequal",
			"Delta",
			"guillemotleft",
			"guillemotright",
			"ellipsis",
			"nonbreakingspace",
			"Agrave",
			"Atilde",
			"Otilde",
			"OE",
			"oe",
			"endash",
			"emdash",
			"quotedblleft",
			"quotedblright",
			"quoteleft",
			"quoteright",
			"divide",
			"lozenge",
			"ydieresis",
			"Ydieresis",
			"fraction",
			"currency",
			"guilsinglleft",
			"guilsinglright",
			"fi",
			"fl",
			"daggerdbl",
			"periodcentered",
			"quotesinglbase",
			"quotedblbase",
			"perthousand",
			"Acircumflex",
			"Ecircumflex",
			"Aacute",
			"Edieresis",
			"Egrave",
			"Iacute",
			"Icircumflex",
			"Idieresis",
			"Igrave",
			"Oacute",
			"Ocircumflex",
			"apple",
			"Ograve",
			"Uacute",
			"Ucircumflex",
			"Ugrave",
			"dotlessi",
			"circumflex",
			"tilde",
			"macron",
			"breve",
			"dotaccent",
			"ring",
			"cedilla",
			"hungarumlaut",
			"ogonek",
			"caron",
			"Lslash",
			"lslash",
			"Scaron",
			"scaron",
			"Zcaron",
			"zcaron",
			"brokenbar",
			"Eth",
			"eth",
			"Yacute",
			"yacute",
			"Thorn",
			"thorn",
			"minus",
			"multiply",
			"onesuperior",
			"twosuperior",
			"threesuperior",
			"onehalf",
			"onequarter",
			"threequarters",
			"franc",
			"Gbreve",
			"gbreve",
			"Idotaccent",
			"Scedilla",
			"scedilla",
			"Cacute",
			"cacute",
			"Ccaron",
			"ccaron",
			"dcroat"
		];
	function kx(n) {
		this.font = n;
	}
	kx.prototype.charToGlyphIndex = function (n) {
		var e = n.codePointAt(0),
			t = this.font.glyphs;
		if (t) {
			for (var i = 0; i < t.length; i += 1) for (var r = t.get(i), s = 0; s < r.unicodes.length; s += 1) if (r.unicodes[s] === e) return i;
		}
		return null;
	};
	function Bx(n) {
		this.cmap = n;
	}
	Bx.prototype.charToGlyphIndex = function (n) {
		return this.cmap.glyphIndexMap[n.codePointAt(0)] || 0;
	};
	function ah(n, e) {
		(this.encoding = n), (this.charset = e);
	}
	ah.prototype.charToGlyphIndex = function (n) {
		var e = n.codePointAt(0),
			t = this.encoding[e];
		return this.charset.indexOf(t);
	};
	function lm(n) {
		switch (n.version) {
			case 1:
				this.names = la.slice();
				break;
			case 2:
				this.names = new Array(n.numberOfGlyphs);
				for (var e = 0; e < n.numberOfGlyphs; e++) n.glyphNameIndex[e] < la.length ? (this.names[e] = la[n.glyphNameIndex[e]]) : (this.names[e] = n.names[n.glyphNameIndex[e] - la.length]);
				break;
			case 2.5:
				this.names = new Array(n.numberOfGlyphs);
				for (var t = 0; t < n.numberOfGlyphs; t++) this.names[t] = la[t + n.glyphNameIndex[t]];
				break;
			case 3:
				this.names = [];
				break;
			default:
				this.names = [];
				break;
		}
	}
	lm.prototype.nameToGlyphIndex = function (n) {
		return this.names.indexOf(n);
	};
	lm.prototype.glyphIndexToName = function (n) {
		return this.names[n];
	};
	function lF(n) {
		for (var e, t = n.tables.cmap.glyphIndexMap, i = Object.keys(t), r = 0; r < i.length; r += 1) {
			var s = i[r],
				a = t[s];
			(e = n.glyphs.get(a)), e.addUnicode(parseInt(s));
		}
		for (var o = 0; o < n.glyphs.length; o += 1) (e = n.glyphs.get(o)), n.cffEncoding ? (n.isCIDFont ? (e.name = "gid" + o) : (e.name = n.cffEncoding.charset[o])) : n.glyphNames.names && (e.name = n.glyphNames.glyphIndexToName(o));
	}
	function cF(n) {
		n._IndexToUnicodeMap = {};
		for (var e = n.tables.cmap.glyphIndexMap, t = Object.keys(e), i = 0; i < t.length; i += 1) {
			var r = t[i],
				s = e[r];
			n._IndexToUnicodeMap[s] === void 0 ? (n._IndexToUnicodeMap[s] = { unicodes: [parseInt(r)] }) : n._IndexToUnicodeMap[s].unicodes.push(parseInt(r));
		}
	}
	function uF(n, e) {
		e.lowMemory ? cF(n) : lF(n);
	}
	function hF(n, e, t, i, r) {
		n.beginPath(), n.moveTo(e, t), n.lineTo(i, r), n.stroke();
	}
	var ea = { line: hF };
	function dF(n, e) {
		var t = e || new Tn();
		return {
			configurable: !0,
			get: function () {
				return typeof t == "function" && (t = t()), t;
			},
			set: function (i) {
				t = i;
			}
		};
	}
	function vi(n) {
		this.bindConstructorValues(n);
	}
	vi.prototype.bindConstructorValues = function (n) {
		(this.index = n.index || 0), (this.name = n.name || null), (this.unicode = n.unicode || void 0), (this.unicodes = n.unicodes || n.unicode !== void 0 ? [n.unicode] : []), "xMin" in n && (this.xMin = n.xMin), "yMin" in n && (this.yMin = n.yMin), "xMax" in n && (this.xMax = n.xMax), "yMax" in n && (this.yMax = n.yMax), "advanceWidth" in n && (this.advanceWidth = n.advanceWidth), Object.defineProperty(this, "path", dF(this, n.path));
	};
	vi.prototype.addUnicode = function (n) {
		this.unicodes.length === 0 && (this.unicode = n), this.unicodes.push(n);
	};
	vi.prototype.getBoundingBox = function () {
		return this.path.getBoundingBox();
	};
	vi.prototype.getPath = function (n, e, t, i, r) {
		(n = n !== void 0 ? n : 0), (e = e !== void 0 ? e : 0), (t = t !== void 0 ? t : 72);
		var s, a;
		i || (i = {});
		var o = i.xScale,
			l = i.yScale;
		if ((i.hinting && r && r.hinting && (a = this.path && r.hinting.exec(this, t)), a)) (s = r.hinting.getCommands(a)), (n = Math.round(n)), (e = Math.round(e)), (o = l = 1);
		else {
			s = this.path.commands;
			var c = (1 / (this.path.unitsPerEm || 1e3)) * t;
			o === void 0 && (o = c), l === void 0 && (l = c);
		}
		for (var u = new Tn(), h = 0; h < s.length; h += 1) {
			var d = s[h];
			d.type === "M" ? u.moveTo(n + d.x * o, e + -d.y * l) : d.type === "L" ? u.lineTo(n + d.x * o, e + -d.y * l) : d.type === "Q" ? u.quadraticCurveTo(n + d.x1 * o, e + -d.y1 * l, n + d.x * o, e + -d.y * l) : d.type === "C" ? u.curveTo(n + d.x1 * o, e + -d.y1 * l, n + d.x2 * o, e + -d.y2 * l, n + d.x * o, e + -d.y * l) : d.type === "Z" && u.closePath();
		}
		return u;
	};
	vi.prototype.getContours = function () {
		if (this.points === void 0) return [];
		for (var n = [], e = [], t = 0; t < this.points.length; t += 1) {
			var i = this.points[t];
			e.push(i), i.lastPointOfContour && (n.push(e), (e = []));
		}
		return tt.argument(e.length === 0, "There are still points left in the current contour."), n;
	};
	vi.prototype.getMetrics = function () {
		for (var n = this.path.commands, e = [], t = [], i = 0; i < n.length; i += 1) {
			var r = n[i];
			r.type !== "Z" && (e.push(r.x), t.push(r.y)), (r.type === "Q" || r.type === "C") && (e.push(r.x1), t.push(r.y1)), r.type === "C" && (e.push(r.x2), t.push(r.y2));
		}
		var s = { xMin: Math.min.apply(null, e), yMin: Math.min.apply(null, t), xMax: Math.max.apply(null, e), yMax: Math.max.apply(null, t), leftSideBearing: this.leftSideBearing };
		return isFinite(s.xMin) || (s.xMin = 0), isFinite(s.xMax) || (s.xMax = this.advanceWidth), isFinite(s.yMin) || (s.yMin = 0), isFinite(s.yMax) || (s.yMax = 0), (s.rightSideBearing = this.advanceWidth - s.leftSideBearing - (s.xMax - s.xMin)), s;
	};
	vi.prototype.draw = function (n, e, t, i, r) {
		this.getPath(e, t, i, r).draw(n);
	};
	vi.prototype.drawPoints = function (n, e, t, i) {
		function r(h, d, f, v) {
			n.beginPath();
			for (var _ = 0; _ < h.length; _ += 1) n.moveTo(d + h[_].x * v, f + h[_].y * v), n.arc(d + h[_].x * v, f + h[_].y * v, 2, 0, Math.PI * 2, !1);
			n.closePath(), n.fill();
		}
		(e = e !== void 0 ? e : 0), (t = t !== void 0 ? t : 0), (i = i !== void 0 ? i : 24);
		for (var s = (1 / this.path.unitsPerEm) * i, a = [], o = [], l = this.path, c = 0; c < l.commands.length; c += 1) {
			var u = l.commands[c];
			u.x !== void 0 && a.push({ x: u.x, y: -u.y }), u.x1 !== void 0 && o.push({ x: u.x1, y: -u.y1 }), u.x2 !== void 0 && o.push({ x: u.x2, y: -u.y2 });
		}
		(n.fillStyle = "blue"), r(a, e, t, s), (n.fillStyle = "red"), r(o, e, t, s);
	};
	vi.prototype.drawMetrics = function (n, e, t, i) {
		var r;
		(e = e !== void 0 ? e : 0), (t = t !== void 0 ? t : 0), (i = i !== void 0 ? i : 24), (r = (1 / this.path.unitsPerEm) * i), (n.lineWidth = 1), (n.strokeStyle = "black"), ea.line(n, e, -1e4, e, 1e4), ea.line(n, -1e4, t, 1e4, t);
		var s = this.xMin || 0,
			a = this.yMin || 0,
			o = this.xMax || 0,
			l = this.yMax || 0,
			c = this.advanceWidth || 0;
		(n.strokeStyle = "blue"), ea.line(n, e + s * r, -1e4, e + s * r, 1e4), ea.line(n, e + o * r, -1e4, e + o * r, 1e4), ea.line(n, -1e4, t + -a * r, 1e4, t + -a * r), ea.line(n, -1e4, t + -l * r, 1e4, t + -l * r), (n.strokeStyle = "green"), ea.line(n, e + c * r, -1e4, e + c * r, 1e4);
	};
	function _u(n, e, t) {
		Object.defineProperty(n, e, {
			get: function () {
				return n.path, n[t];
			},
			set: function (i) {
				n[t] = i;
			},
			enumerable: !0,
			configurable: !0
		});
	}
	function cm(n, e) {
		if (((this.font = n), (this.glyphs = {}), Array.isArray(e)))
			for (var t = 0; t < e.length; t++) {
				var i = e[t];
				(i.path.unitsPerEm = n.unitsPerEm), (this.glyphs[t] = i);
			}
		this.length = (e && e.length) || 0;
	}
	cm.prototype.get = function (n) {
		if (this.glyphs[n] === void 0) {
			this.font._push(n), typeof this.glyphs[n] == "function" && (this.glyphs[n] = this.glyphs[n]());
			var e = this.glyphs[n],
				t = this.font._IndexToUnicodeMap[n];
			if (t) for (var i = 0; i < t.unicodes.length; i++) e.addUnicode(t.unicodes[i]);
			this.font.cffEncoding ? (this.font.isCIDFont ? (e.name = "gid" + n) : (e.name = this.font.cffEncoding.charset[n])) : this.font.glyphNames.names && (e.name = this.font.glyphNames.glyphIndexToName(n)), (this.glyphs[n].advanceWidth = this.font._hmtxTableData[n].advanceWidth), (this.glyphs[n].leftSideBearing = this.font._hmtxTableData[n].leftSideBearing);
		} else typeof this.glyphs[n] == "function" && (this.glyphs[n] = this.glyphs[n]());
		return this.glyphs[n];
	};
	cm.prototype.push = function (n, e) {
		(this.glyphs[n] = e), this.length++;
	};
	function fF(n, e) {
		return new vi({ index: e, font: n });
	}
	function pF(n, e, t, i, r, s) {
		return function () {
			var a = new vi({ index: e, font: n });
			return (
				(a.path = function () {
					t(a, i, r);
					var o = s(n.glyphs, a);
					return (o.unitsPerEm = n.unitsPerEm), o;
				}),
				_u(a, "xMin", "_xMin"),
				_u(a, "xMax", "_xMax"),
				_u(a, "yMin", "_yMin"),
				_u(a, "yMax", "_yMax"),
				a
			);
		};
	}
	function mF(n, e, t, i) {
		return function () {
			var r = new vi({ index: e, font: n });
			return (
				(r.path = function () {
					var s = t(n, r, i);
					return (s.unitsPerEm = n.unitsPerEm), s;
				}),
				r
			);
		};
	}
	var xr = { GlyphSet: cm, glyphLoader: fF, ttfGlyphLoader: pF, cffGlyphLoader: mF };
	function zx(n, e) {
		if (n === e) return !0;
		if (Array.isArray(n) && Array.isArray(e)) {
			if (n.length !== e.length) return !1;
			for (var t = 0; t < n.length; t += 1) if (!zx(n[t], e[t])) return !1;
			return !0;
		} else return !1;
	}
	function up(n) {
		var e;
		return n.length < 1240 ? (e = 107) : n.length < 33900 ? (e = 1131) : (e = 32768), e;
	}
	function _s(n, e, t) {
		var i = [],
			r = [],
			s = Ze.getCard16(n, e),
			a,
			o;
		if (s !== 0) {
			var l = Ze.getByte(n, e + 2);
			a = e + (s + 1) * l + 2;
			for (var c = e + 3, u = 0; u < s + 1; u += 1) i.push(Ze.getOffset(n, c, l)), (c += l);
			o = a + i[s];
		} else o = e + 2;
		for (var h = 0; h < i.length - 1; h += 1) {
			var d = Ze.getBytes(n, a + i[h], a + i[h + 1]);
			t && (d = t(d)), r.push(d);
		}
		return { objects: r, startOffset: e, endOffset: o };
	}
	function gF(n, e) {
		var t = [],
			i = Ze.getCard16(n, e),
			r,
			s;
		if (i !== 0) {
			var a = Ze.getByte(n, e + 2);
			r = e + (i + 1) * a + 2;
			for (var o = e + 3, l = 0; l < i + 1; l += 1) t.push(Ze.getOffset(n, o, a)), (o += a);
			s = r + t[i];
		} else s = e + 2;
		return { offsets: t, startOffset: e, endOffset: s };
	}
	function vF(n, e, t, i, r) {
		var s = Ze.getCard16(t, i),
			a = 0;
		if (s !== 0) {
			var o = Ze.getByte(t, i + 2);
			a = i + (s + 1) * o + 2;
		}
		var l = Ze.getBytes(t, a + e[n], a + e[n + 1]);
		return l;
	}
	function _F(n) {
		for (var e = "", t = 15, i = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
			var r = n.parseByte(),
				s = r >> 4,
				a = r & 15;
			if (s === t || ((e += i[s]), a === t)) break;
			e += i[a];
		}
		return parseFloat(e);
	}
	function yF(n, e) {
		var t, i, r, s;
		if (e === 28) return (t = n.parseByte()), (i = n.parseByte()), (t << 8) | i;
		if (e === 29) return (t = n.parseByte()), (i = n.parseByte()), (r = n.parseByte()), (s = n.parseByte()), (t << 24) | (i << 16) | (r << 8) | s;
		if (e === 30) return _F(n);
		if (e >= 32 && e <= 246) return e - 139;
		if (e >= 247 && e <= 250) return (t = n.parseByte()), (e - 247) * 256 + t + 108;
		if (e >= 251 && e <= 254) return (t = n.parseByte()), -(e - 251) * 256 - t - 108;
		throw new Error("Invalid b0 " + e);
	}
	function xF(n) {
		for (var e = {}, t = 0; t < n.length; t += 1) {
			var i = n[t][0],
				r = n[t][1],
				s = void 0;
			if ((r.length === 1 ? (s = r[0]) : (s = r), e.hasOwnProperty(i) && !isNaN(e[i]))) throw new Error("Object " + e + " already has key " + i);
			e[i] = s;
		}
		return e;
	}
	function Hx(n, e, t) {
		e = e !== void 0 ? e : 0;
		var i = new Ze.Parser(n, e),
			r = [],
			s = [];
		for (t = t !== void 0 ? t : n.length; i.relativeOffset < t; ) {
			var a = i.parseByte();
			a <= 21 ? (a === 12 && (a = 1200 + i.parseByte()), r.push([a, s]), (s = [])) : s.push(yF(i, a));
		}
		return xF(r);
	}
	function Pl(n, e) {
		return e <= 390 ? (e = Uu[e]) : (e = n[e - 391]), e;
	}
	function Gx(n, e, t) {
		for (var i = {}, r, s = 0; s < e.length; s += 1) {
			var a = e[s];
			if (Array.isArray(a.type)) {
				var o = [];
				o.length = a.type.length;
				for (var l = 0; l < a.type.length; l++) (r = n[a.op] !== void 0 ? n[a.op][l] : void 0), r === void 0 && (r = a.value !== void 0 && a.value[l] !== void 0 ? a.value[l] : null), a.type[l] === "SID" && (r = Pl(t, r)), (o[l] = r);
				i[a.name] = o;
			} else (r = n[a.op]), r === void 0 && (r = a.value !== void 0 ? a.value : null), a.type === "SID" && (r = Pl(t, r)), (i[a.name] = r);
		}
		return i;
	}
	function bF(n, e) {
		var t = {};
		return (t.formatMajor = Ze.getCard8(n, e)), (t.formatMinor = Ze.getCard8(n, e + 1)), (t.size = Ze.getCard8(n, e + 2)), (t.offsetSize = Ze.getCard8(n, e + 3)), (t.startOffset = e), (t.endOffset = e + 4), t;
	}
	var Vx = [
			{ name: "version", op: 0, type: "SID" },
			{ name: "notice", op: 1, type: "SID" },
			{ name: "copyright", op: 1200, type: "SID" },
			{ name: "fullName", op: 2, type: "SID" },
			{ name: "familyName", op: 3, type: "SID" },
			{ name: "weight", op: 4, type: "SID" },
			{ name: "isFixedPitch", op: 1201, type: "number", value: 0 },
			{ name: "italicAngle", op: 1202, type: "number", value: 0 },
			{ name: "underlinePosition", op: 1203, type: "number", value: -100 },
			{ name: "underlineThickness", op: 1204, type: "number", value: 50 },
			{ name: "paintType", op: 1205, type: "number", value: 0 },
			{ name: "charstringType", op: 1206, type: "number", value: 2 },
			{ name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [0.001, 0, 0, 0.001, 0, 0] },
			{ name: "uniqueId", op: 13, type: "number" },
			{ name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
			{ name: "strokeWidth", op: 1208, type: "number", value: 0 },
			{ name: "xuid", op: 14, type: [], value: null },
			{ name: "charset", op: 15, type: "offset", value: 0 },
			{ name: "encoding", op: 16, type: "offset", value: 0 },
			{ name: "charStrings", op: 17, type: "offset", value: 0 },
			{ name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
			{ name: "ros", op: 1230, type: ["SID", "SID", "number"] },
			{ name: "cidFontVersion", op: 1231, type: "number", value: 0 },
			{ name: "cidFontRevision", op: 1232, type: "number", value: 0 },
			{ name: "cidFontType", op: 1233, type: "number", value: 0 },
			{ name: "cidCount", op: 1234, type: "number", value: 8720 },
			{ name: "uidBase", op: 1235, type: "number" },
			{ name: "fdArray", op: 1236, type: "offset" },
			{ name: "fdSelect", op: 1237, type: "offset" },
			{ name: "fontName", op: 1238, type: "SID" }
		],
		Wx = [
			{ name: "subrs", op: 19, type: "offset", value: 0 },
			{ name: "defaultWidthX", op: 20, type: "number", value: 0 },
			{ name: "nominalWidthX", op: 21, type: "number", value: 0 }
		];
	function SF(n, e) {
		var t = Hx(n, 0, n.byteLength);
		return Gx(t, Vx, e);
	}
	function Xx(n, e, t, i) {
		var r = Hx(n, e, t);
		return Gx(r, Wx, i);
	}
	function j0(n, e, t, i) {
		for (var r = [], s = 0; s < t.length; s += 1) {
			var a = new DataView(new Uint8Array(t[s]).buffer),
				o = SF(a, i);
			(o._subrs = []), (o._subrsBias = 0), (o._defaultWidthX = 0), (o._nominalWidthX = 0);
			var l = o.private[0],
				c = o.private[1];
			if (l !== 0 && c !== 0) {
				var u = Xx(n, c + e, l, i);
				if (((o._defaultWidthX = u.defaultWidthX), (o._nominalWidthX = u.nominalWidthX), u.subrs !== 0)) {
					var h = c + u.subrs,
						d = _s(n, h + e);
					(o._subrs = d.objects), (o._subrsBias = up(o._subrs));
				}
				o._privateDict = u;
			}
			r.push(o);
		}
		return r;
	}
	function EF(n, e, t, i) {
		var r,
			s,
			a = new Ze.Parser(n, e);
		t -= 1;
		var o = [".notdef"],
			l = a.parseCard8();
		if (l === 0) for (var c = 0; c < t; c += 1) (r = a.parseSID()), o.push(Pl(i, r));
		else if (l === 1)
			for (; o.length <= t; ) {
				(r = a.parseSID()), (s = a.parseCard8());
				for (var u = 0; u <= s; u += 1) o.push(Pl(i, r)), (r += 1);
			}
		else if (l === 2)
			for (; o.length <= t; ) {
				(r = a.parseSID()), (s = a.parseCard16());
				for (var h = 0; h <= s; h += 1) o.push(Pl(i, r)), (r += 1);
			}
		else throw new Error("Unknown charset format " + l);
		return o;
	}
	function wF(n, e, t) {
		var i,
			r = {},
			s = new Ze.Parser(n, e),
			a = s.parseCard8();
		if (a === 0) for (var o = s.parseCard8(), l = 0; l < o; l += 1) (i = s.parseCard8()), (r[i] = l);
		else if (a === 1) {
			var c = s.parseCard8();
			i = 1;
			for (var u = 0; u < c; u += 1) for (var h = s.parseCard8(), d = s.parseCard8(), f = h; f <= h + d; f += 1) (r[f] = i), (i += 1);
		} else throw new Error("Unknown encoding format " + a);
		return new ah(r, t);
	}
	function Y0(n, e, t) {
		var i,
			r,
			s,
			a,
			o = new Tn(),
			l = [],
			c = 0,
			u = !1,
			h = !1,
			d = 0,
			f = 0,
			v,
			_,
			p,
			g;
		if (n.isCIDFont) {
			var x = n.tables.cff.topDict._fdSelect[e.index],
				b = n.tables.cff.topDict._fdArray[x];
			(v = b._subrs), (_ = b._subrsBias), (p = b._defaultWidthX), (g = b._nominalWidthX);
		} else (v = n.tables.cff.topDict._subrs), (_ = n.tables.cff.topDict._subrsBias), (p = n.tables.cff.topDict._defaultWidthX), (g = n.tables.cff.topDict._nominalWidthX);
		var T = p;
		function P(w, y) {
			h && o.closePath(), o.moveTo(w, y), (h = !0);
		}
		function A() {
			var w;
			(w = l.length % 2 !== 0), w && !u && (T = l.shift() + g), (c += l.length >> 1), (l.length = 0), (u = !0);
		}
		function M(w) {
			for (var y, S, L, N, k, B, W, H, z, X, K, G, ue = 0; ue < w.length; ) {
				var ae = w[ue];
				switch (((ue += 1), ae)) {
					case 1:
						A();
						break;
					case 3:
						A();
						break;
					case 4:
						l.length > 1 && !u && ((T = l.shift() + g), (u = !0)), (f += l.pop()), P(d, f);
						break;
					case 5:
						for (; l.length > 0; ) (d += l.shift()), (f += l.shift()), o.lineTo(d, f);
						break;
					case 6:
						for (; l.length > 0 && ((d += l.shift()), o.lineTo(d, f), l.length !== 0); ) (f += l.shift()), o.lineTo(d, f);
						break;
					case 7:
						for (; l.length > 0 && ((f += l.shift()), o.lineTo(d, f), l.length !== 0); ) (d += l.shift()), o.lineTo(d, f);
						break;
					case 8:
						for (; l.length > 0; ) (i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a + l.shift()), o.curveTo(i, r, s, a, d, f);
						break;
					case 10:
						(k = l.pop() + _), (B = v[k]), B && M(B);
						break;
					case 11:
						return;
					case 12:
						switch (((ae = w[ue]), (ue += 1), ae)) {
							case 35:
								(i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (W = s + l.shift()), (H = a + l.shift()), (z = W + l.shift()), (X = H + l.shift()), (K = z + l.shift()), (G = X + l.shift()), (d = K + l.shift()), (f = G + l.shift()), l.shift(), o.curveTo(i, r, s, a, W, H), o.curveTo(z, X, K, G, d, f);
								break;
							case 34:
								(i = d + l.shift()), (r = f), (s = i + l.shift()), (a = r + l.shift()), (W = s + l.shift()), (H = a), (z = W + l.shift()), (X = a), (K = z + l.shift()), (G = f), (d = K + l.shift()), o.curveTo(i, r, s, a, W, H), o.curveTo(z, X, K, G, d, f);
								break;
							case 36:
								(i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (W = s + l.shift()), (H = a), (z = W + l.shift()), (X = a), (K = z + l.shift()), (G = X + l.shift()), (d = K + l.shift()), o.curveTo(i, r, s, a, W, H), o.curveTo(z, X, K, G, d, f);
								break;
							case 37:
								(i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (W = s + l.shift()), (H = a + l.shift()), (z = W + l.shift()), (X = H + l.shift()), (K = z + l.shift()), (G = X + l.shift()), Math.abs(K - d) > Math.abs(G - f) ? (d = K + l.shift()) : (f = G + l.shift()), o.curveTo(i, r, s, a, W, H), o.curveTo(z, X, K, G, d, f);
								break;
							default:
								console.log("Glyph " + e.index + ": unknown operator 1200" + ae), (l.length = 0);
						}
						break;
					case 14:
						l.length > 0 && !u && ((T = l.shift() + g), (u = !0)), h && (o.closePath(), (h = !1));
						break;
					case 18:
						A();
						break;
					case 19:
					case 20:
						A(), (ue += (c + 7) >> 3);
						break;
					case 21:
						l.length > 2 && !u && ((T = l.shift() + g), (u = !0)), (f += l.pop()), (d += l.pop()), P(d, f);
						break;
					case 22:
						l.length > 1 && !u && ((T = l.shift() + g), (u = !0)), (d += l.pop()), P(d, f);
						break;
					case 23:
						A();
						break;
					case 24:
						for (; l.length > 2; ) (i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a + l.shift()), o.curveTo(i, r, s, a, d, f);
						(d += l.shift()), (f += l.shift()), o.lineTo(d, f);
						break;
					case 25:
						for (; l.length > 6; ) (d += l.shift()), (f += l.shift()), o.lineTo(d, f);
						(i = d + l.shift()), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a + l.shift()), o.curveTo(i, r, s, a, d, f);
						break;
					case 26:
						for (l.length % 2 && (d += l.shift()); l.length > 0; ) (i = d), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s), (f = a + l.shift()), o.curveTo(i, r, s, a, d, f);
						break;
					case 27:
						for (l.length % 2 && (f += l.shift()); l.length > 0; ) (i = d + l.shift()), (r = f), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a), o.curveTo(i, r, s, a, d, f);
						break;
					case 28:
						(y = w[ue]), (S = w[ue + 1]), l.push(((y << 24) | (S << 16)) >> 16), (ue += 2);
						break;
					case 29:
						(k = l.pop() + n.gsubrsBias), (B = n.gsubrs[k]), B && M(B);
						break;
					case 30:
						for (; l.length > 0 && ((i = d), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a + (l.length === 1 ? l.shift() : 0)), o.curveTo(i, r, s, a, d, f), l.length !== 0); ) (i = d + l.shift()), (r = f), (s = i + l.shift()), (a = r + l.shift()), (f = a + l.shift()), (d = s + (l.length === 1 ? l.shift() : 0)), o.curveTo(i, r, s, a, d, f);
						break;
					case 31:
						for (; l.length > 0 && ((i = d + l.shift()), (r = f), (s = i + l.shift()), (a = r + l.shift()), (f = a + l.shift()), (d = s + (l.length === 1 ? l.shift() : 0)), o.curveTo(i, r, s, a, d, f), l.length !== 0); ) (i = d), (r = f + l.shift()), (s = i + l.shift()), (a = r + l.shift()), (d = s + l.shift()), (f = a + (l.length === 1 ? l.shift() : 0)), o.curveTo(i, r, s, a, d, f);
						break;
					default:
						ae < 32 ? console.log("Glyph " + e.index + ": unknown operator " + ae) : ae < 247 ? l.push(ae - 139) : ae < 251 ? ((y = w[ue]), (ue += 1), l.push((ae - 247) * 256 + y + 108)) : ae < 255 ? ((y = w[ue]), (ue += 1), l.push(-(ae - 251) * 256 - y - 108)) : ((y = w[ue]), (S = w[ue + 1]), (L = w[ue + 2]), (N = w[ue + 3]), (ue += 4), l.push(((y << 24) | (S << 16) | (L << 8) | N) / 65536));
				}
			}
		}
		return M(t), (e.advanceWidth = T), o;
	}
	function TF(n, e, t, i) {
		var r = [],
			s,
			a = new Ze.Parser(n, e),
			o = a.parseCard8();
		if (o === 0)
			for (var l = 0; l < t; l++) {
				if (((s = a.parseCard8()), s >= i)) throw new Error("CFF table CID Font FDSelect has bad FD index value " + s + " (FD count " + i + ")");
				r.push(s);
			}
		else if (o === 3) {
			var c = a.parseCard16(),
				u = a.parseCard16();
			if (u !== 0) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + u);
			for (var h, d = 0; d < c; d++) {
				if (((s = a.parseCard8()), (h = a.parseCard16()), s >= i)) throw new Error("CFF table CID Font FDSelect has bad FD index value " + s + " (FD count " + i + ")");
				if (h > t) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + h);
				for (; u < h; u++) r.push(s);
				u = h;
			}
			if (h !== t) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + h);
		} else throw new Error("CFF Table CID Font FDSelect table has unsupported format " + o);
		return r;
	}
	function MF(n, e, t, i) {
		t.tables.cff = {};
		var r = bF(n, e),
			s = _s(n, r.endOffset, Ze.bytesToString),
			a = _s(n, s.endOffset),
			o = _s(n, a.endOffset, Ze.bytesToString),
			l = _s(n, o.endOffset);
		(t.gsubrs = l.objects), (t.gsubrsBias = up(t.gsubrs));
		var c = j0(n, e, a.objects, o.objects);
		if (c.length !== 1) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + c.length);
		var u = c[0];
		if (((t.tables.cff.topDict = u), u._privateDict && ((t.defaultWidthX = u._privateDict.defaultWidthX), (t.nominalWidthX = u._privateDict.nominalWidthX)), u.ros[0] !== void 0 && u.ros[1] !== void 0 && (t.isCIDFont = !0), t.isCIDFont)) {
			var h = u.fdArray,
				d = u.fdSelect;
			if (h === 0 || d === 0) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
			h += e;
			var f = _s(n, h),
				v = j0(n, e, f.objects, o.objects);
			(u._fdArray = v), (d += e), (u._fdSelect = TF(n, d, t.numGlyphs, v.length));
		}
		var _ = e + u.private[1],
			p = Xx(n, _, u.private[0], o.objects);
		if (((t.defaultWidthX = p.defaultWidthX), (t.nominalWidthX = p.nominalWidthX), p.subrs !== 0)) {
			var g = _ + p.subrs,
				x = _s(n, g);
			(t.subrs = x.objects), (t.subrsBias = up(t.subrs));
		} else (t.subrs = []), (t.subrsBias = 0);
		var b;
		i.lowMemory ? ((b = gF(n, e + u.charStrings)), (t.nGlyphs = b.offsets.length)) : ((b = _s(n, e + u.charStrings)), (t.nGlyphs = b.objects.length));
		var T = EF(n, e + u.charset, t.nGlyphs, o.objects);
		if ((u.encoding === 0 ? (t.cffEncoding = new ah(aF, T)) : u.encoding === 1 ? (t.cffEncoding = new ah(oF, T)) : (t.cffEncoding = wF(n, e + u.encoding, T)), (t.encoding = t.encoding || t.cffEncoding), (t.glyphs = new xr.GlyphSet(t)), i.lowMemory))
			t._push = function (M) {
				var w = vF(M, b.offsets, n, e + u.charStrings);
				t.glyphs.push(M, xr.cffGlyphLoader(t, M, Y0, w));
			};
		else
			for (var P = 0; P < t.nGlyphs; P += 1) {
				var A = b.objects[P];
				t.glyphs.push(P, xr.cffGlyphLoader(t, P, Y0, A));
			}
	}
	function $x(n, e) {
		var t,
			i = Uu.indexOf(n);
		return i >= 0 && (t = i), (i = e.indexOf(n)), i >= 0 ? (t = i + Uu.length) : ((t = Uu.length + e.length), e.push(n)), t;
	}
	function AF() {
		return new Ve.Record("Header", [
			{ name: "major", type: "Card8", value: 1 },
			{ name: "minor", type: "Card8", value: 0 },
			{ name: "hdrSize", type: "Card8", value: 4 },
			{ name: "major", type: "Card8", value: 1 }
		]);
	}
	function CF(n) {
		var e = new Ve.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]);
		e.names = [];
		for (var t = 0; t < n.length; t += 1) e.names.push({ name: "name_" + t, type: "NAME", value: n[t] });
		return e;
	}
	function qx(n, e, t) {
		for (var i = {}, r = 0; r < n.length; r += 1) {
			var s = n[r],
				a = e[s.name];
			a !== void 0 && !zx(a, s.value) && (s.type === "SID" && (a = $x(a, t)), (i[s.op] = { name: s.name, type: s.type, value: a }));
		}
		return i;
	}
	function K0(n, e) {
		var t = new Ve.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]);
		return (t.dict = qx(Vx, n, e)), t;
	}
	function Z0(n) {
		var e = new Ve.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]);
		return (e.topDicts = [{ name: "topDict_0", type: "TABLE", value: n }]), e;
	}
	function LF(n) {
		var e = new Ve.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]);
		e.strings = [];
		for (var t = 0; t < n.length; t += 1) e.strings.push({ name: "string_" + t, type: "STRING", value: n[t] });
		return e;
	}
	function RF() {
		return new Ve.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]);
	}
	function PF(n, e) {
		for (var t = new Ve.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]), i = 0; i < n.length; i += 1) {
			var r = n[i],
				s = $x(r, e);
			t.fields.push({ name: "glyph_" + i, type: "SID", value: s });
		}
		return t;
	}
	function DF(n) {
		var e = [],
			t = n.path;
		e.push({ name: "width", type: "NUMBER", value: n.advanceWidth });
		for (var i = 0, r = 0, s = 0; s < t.commands.length; s += 1) {
			var a = void 0,
				o = void 0,
				l = t.commands[s];
			if (l.type === "Q") {
				var c = 0.3333333333333333,
					u = 2 / 3;
				l = { type: "C", x: l.x, y: l.y, x1: Math.round(c * i + u * l.x1), y1: Math.round(c * r + u * l.y1), x2: Math.round(c * l.x + u * l.x1), y2: Math.round(c * l.y + u * l.y1) };
			}
			if (l.type === "M") (a = Math.round(l.x - i)), (o = Math.round(l.y - r)), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rmoveto", type: "OP", value: 21 }), (i = Math.round(l.x)), (r = Math.round(l.y));
			else if (l.type === "L") (a = Math.round(l.x - i)), (o = Math.round(l.y - r)), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rlineto", type: "OP", value: 5 }), (i = Math.round(l.x)), (r = Math.round(l.y));
			else if (l.type === "C") {
				var h = Math.round(l.x1 - i),
					d = Math.round(l.y1 - r),
					f = Math.round(l.x2 - l.x1),
					v = Math.round(l.y2 - l.y1);
				(a = Math.round(l.x - l.x2)), (o = Math.round(l.y - l.y2)), e.push({ name: "dx1", type: "NUMBER", value: h }), e.push({ name: "dy1", type: "NUMBER", value: d }), e.push({ name: "dx2", type: "NUMBER", value: f }), e.push({ name: "dy2", type: "NUMBER", value: v }), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rrcurveto", type: "OP", value: 8 }), (i = Math.round(l.x)), (r = Math.round(l.y));
			}
		}
		return e.push({ name: "endchar", type: "OP", value: 14 }), e;
	}
	function OF(n) {
		for (var e = new Ve.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]), t = 0; t < n.length; t += 1) {
			var i = n.get(t),
				r = DF(i);
			e.charStrings.push({ name: i.name, type: "CHARSTRING", value: r });
		}
		return e;
	}
	function IF(n, e) {
		var t = new Ve.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }]);
		return (t.dict = qx(Wx, n, e)), t;
	}
	function FF(n, e) {
		for (
			var t = new Ve.Table("CFF ", [
					{ name: "header", type: "RECORD" },
					{ name: "nameIndex", type: "RECORD" },
					{ name: "topDictIndex", type: "RECORD" },
					{ name: "stringIndex", type: "RECORD" },
					{ name: "globalSubrIndex", type: "RECORD" },
					{ name: "charsets", type: "RECORD" },
					{ name: "charStringsIndex", type: "RECORD" },
					{ name: "privateDict", type: "RECORD" }
				]),
				i = 1 / e.unitsPerEm,
				r = { version: e.version, fullName: e.fullName, familyName: e.familyName, weight: e.weightName, fontBBox: e.fontBBox || [0, 0, 0, 0], fontMatrix: [i, 0, 0, i, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] },
				s = {},
				a = [],
				o,
				l = 1;
			l < n.length;
			l += 1
		)
			(o = n.get(l)), a.push(o.name);
		var c = [];
		(t.header = AF()), (t.nameIndex = CF([e.postScriptName]));
		var u = K0(r, c);
		(t.topDictIndex = Z0(u)), (t.globalSubrIndex = RF()), (t.charsets = PF(a, c)), (t.charStringsIndex = OF(n)), (t.privateDict = IF(s, c)), (t.stringIndex = LF(c));
		var h = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
		return (r.charset = h), (r.encoding = 0), (r.charStrings = r.charset + t.charsets.sizeOf()), (r.private[1] = r.charStrings + t.charStringsIndex.sizeOf()), (u = K0(r, c)), (t.topDictIndex = Z0(u)), t;
	}
	var jx = { parse: MF, make: FF };
	function NF(n, e) {
		var t = {},
			i = new Ze.Parser(n, e);
		return (
			(t.version = i.parseVersion()),
			(t.fontRevision = Math.round(i.parseFixed() * 1e3) / 1e3),
			(t.checkSumAdjustment = i.parseULong()),
			(t.magicNumber = i.parseULong()),
			tt.argument(t.magicNumber === 1594834165, "Font header has wrong magic number."),
			(t.flags = i.parseUShort()),
			(t.unitsPerEm = i.parseUShort()),
			(t.created = i.parseLongDateTime()),
			(t.modified = i.parseLongDateTime()),
			(t.xMin = i.parseShort()),
			(t.yMin = i.parseShort()),
			(t.xMax = i.parseShort()),
			(t.yMax = i.parseShort()),
			(t.macStyle = i.parseUShort()),
			(t.lowestRecPPEM = i.parseUShort()),
			(t.fontDirectionHint = i.parseShort()),
			(t.indexToLocFormat = i.parseShort()),
			(t.glyphDataFormat = i.parseShort()),
			t
		);
	}
	function UF(n) {
		var e = Math.round(new Date().getTime() / 1e3) + 2082844800,
			t = e;
		return (
			n.createdTimestamp && (t = n.createdTimestamp + 2082844800),
			new Ve.Table(
				"head",
				[
					{ name: "version", type: "FIXED", value: 65536 },
					{ name: "fontRevision", type: "FIXED", value: 65536 },
					{ name: "checkSumAdjustment", type: "ULONG", value: 0 },
					{ name: "magicNumber", type: "ULONG", value: 1594834165 },
					{ name: "flags", type: "USHORT", value: 0 },
					{ name: "unitsPerEm", type: "USHORT", value: 1e3 },
					{ name: "created", type: "LONGDATETIME", value: t },
					{ name: "modified", type: "LONGDATETIME", value: e },
					{ name: "xMin", type: "SHORT", value: 0 },
					{ name: "yMin", type: "SHORT", value: 0 },
					{ name: "xMax", type: "SHORT", value: 0 },
					{ name: "yMax", type: "SHORT", value: 0 },
					{ name: "macStyle", type: "USHORT", value: 0 },
					{ name: "lowestRecPPEM", type: "USHORT", value: 0 },
					{ name: "fontDirectionHint", type: "SHORT", value: 2 },
					{ name: "indexToLocFormat", type: "SHORT", value: 0 },
					{ name: "glyphDataFormat", type: "SHORT", value: 0 }
				],
				n
			)
		);
	}
	var Yx = { parse: NF, make: UF };
	function kF(n, e) {
		var t = {},
			i = new Ze.Parser(n, e);
		return (
			(t.version = i.parseVersion()),
			(t.ascender = i.parseShort()),
			(t.descender = i.parseShort()),
			(t.lineGap = i.parseShort()),
			(t.advanceWidthMax = i.parseUShort()),
			(t.minLeftSideBearing = i.parseShort()),
			(t.minRightSideBearing = i.parseShort()),
			(t.xMaxExtent = i.parseShort()),
			(t.caretSlopeRise = i.parseShort()),
			(t.caretSlopeRun = i.parseShort()),
			(t.caretOffset = i.parseShort()),
			(i.relativeOffset += 8),
			(t.metricDataFormat = i.parseShort()),
			(t.numberOfHMetrics = i.parseUShort()),
			t
		);
	}
	function BF(n) {
		return new Ve.Table(
			"hhea",
			[
				{ name: "version", type: "FIXED", value: 65536 },
				{ name: "ascender", type: "FWORD", value: 0 },
				{ name: "descender", type: "FWORD", value: 0 },
				{ name: "lineGap", type: "FWORD", value: 0 },
				{ name: "advanceWidthMax", type: "UFWORD", value: 0 },
				{ name: "minLeftSideBearing", type: "FWORD", value: 0 },
				{ name: "minRightSideBearing", type: "FWORD", value: 0 },
				{ name: "xMaxExtent", type: "FWORD", value: 0 },
				{ name: "caretSlopeRise", type: "SHORT", value: 1 },
				{ name: "caretSlopeRun", type: "SHORT", value: 0 },
				{ name: "caretOffset", type: "SHORT", value: 0 },
				{ name: "reserved1", type: "SHORT", value: 0 },
				{ name: "reserved2", type: "SHORT", value: 0 },
				{ name: "reserved3", type: "SHORT", value: 0 },
				{ name: "reserved4", type: "SHORT", value: 0 },
				{ name: "metricDataFormat", type: "SHORT", value: 0 },
				{ name: "numberOfHMetrics", type: "USHORT", value: 0 }
			],
			n
		);
	}
	var Kx = { parse: kF, make: BF };
	function zF(n, e, t, i, r) {
		for (var s, a, o = new Ze.Parser(n, e), l = 0; l < i; l += 1) {
			l < t && ((s = o.parseUShort()), (a = o.parseShort()));
			var c = r.get(l);
			(c.advanceWidth = s), (c.leftSideBearing = a);
		}
	}
	function HF(n, e, t, i, r) {
		n._hmtxTableData = {};
		for (var s, a, o = new Ze.Parser(e, t), l = 0; l < r; l += 1) l < i && ((s = o.parseUShort()), (a = o.parseShort())), (n._hmtxTableData[l] = { advanceWidth: s, leftSideBearing: a });
	}
	function GF(n, e, t, i, r, s, a) {
		a.lowMemory ? HF(n, e, t, i, r) : zF(e, t, i, r, s);
	}
	function VF(n) {
		for (var e = new Ve.Table("hmtx", []), t = 0; t < n.length; t += 1) {
			var i = n.get(t),
				r = i.advanceWidth || 0,
				s = i.leftSideBearing || 0;
			e.fields.push({ name: "advanceWidth_" + t, type: "USHORT", value: r }), e.fields.push({ name: "leftSideBearing_" + t, type: "SHORT", value: s });
		}
		return e;
	}
	var Zx = { parse: GF, make: VF };
	function WF(n) {
		for (
			var e = new Ve.Table("ltag", [
					{ name: "version", type: "ULONG", value: 1 },
					{ name: "flags", type: "ULONG", value: 0 },
					{ name: "numTags", type: "ULONG", value: n.length }
				]),
				t = "",
				i = 12 + n.length * 4,
				r = 0;
			r < n.length;
			++r
		) {
			var s = t.indexOf(n[r]);
			s < 0 && ((s = t.length), (t += n[r])), e.fields.push({ name: "offset " + r, type: "USHORT", value: i + s }), e.fields.push({ name: "length " + r, type: "USHORT", value: n[r].length });
		}
		return e.fields.push({ name: "stringPool", type: "CHARARRAY", value: t }), e;
	}
	function XF(n, e) {
		var t = new Ze.Parser(n, e),
			i = t.parseULong();
		tt.argument(i === 1, "Unsupported ltag table version."), t.skip("uLong", 1);
		for (var r = t.parseULong(), s = [], a = 0; a < r; a++) {
			for (var o = "", l = e + t.parseUShort(), c = t.parseUShort(), u = l; u < l + c; ++u) o += String.fromCharCode(n.getInt8(u));
			s.push(o);
		}
		return s;
	}
	var Jx = { make: WF, parse: XF };
	function $F(n, e) {
		var t = {},
			i = new Ze.Parser(n, e);
		return (
			(t.version = i.parseVersion()),
			(t.numGlyphs = i.parseUShort()),
			t.version === 1 &&
				((t.maxPoints = i.parseUShort()),
				(t.maxContours = i.parseUShort()),
				(t.maxCompositePoints = i.parseUShort()),
				(t.maxCompositeContours = i.parseUShort()),
				(t.maxZones = i.parseUShort()),
				(t.maxTwilightPoints = i.parseUShort()),
				(t.maxStorage = i.parseUShort()),
				(t.maxFunctionDefs = i.parseUShort()),
				(t.maxInstructionDefs = i.parseUShort()),
				(t.maxStackElements = i.parseUShort()),
				(t.maxSizeOfInstructions = i.parseUShort()),
				(t.maxComponentElements = i.parseUShort()),
				(t.maxComponentDepth = i.parseUShort())),
			t
		);
	}
	function qF(n) {
		return new Ve.Table("maxp", [
			{ name: "version", type: "FIXED", value: 20480 },
			{ name: "numGlyphs", type: "USHORT", value: n }
		]);
	}
	var Qx = { parse: $F, make: qF },
		eb = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"],
		tb = {
			0: "en",
			1: "fr",
			2: "de",
			3: "it",
			4: "nl",
			5: "sv",
			6: "es",
			7: "da",
			8: "pt",
			9: "no",
			10: "he",
			11: "ja",
			12: "ar",
			13: "fi",
			14: "el",
			15: "is",
			16: "mt",
			17: "tr",
			18: "hr",
			19: "zh-Hant",
			20: "ur",
			21: "hi",
			22: "th",
			23: "ko",
			24: "lt",
			25: "pl",
			26: "hu",
			27: "es",
			28: "lv",
			29: "se",
			30: "fo",
			31: "fa",
			32: "ru",
			33: "zh",
			34: "nl-BE",
			35: "ga",
			36: "sq",
			37: "ro",
			38: "cz",
			39: "sk",
			40: "si",
			41: "yi",
			42: "sr",
			43: "mk",
			44: "bg",
			45: "uk",
			46: "be",
			47: "uz",
			48: "kk",
			49: "az-Cyrl",
			50: "az-Arab",
			51: "hy",
			52: "ka",
			53: "mo",
			54: "ky",
			55: "tg",
			56: "tk",
			57: "mn-CN",
			58: "mn",
			59: "ps",
			60: "ks",
			61: "ku",
			62: "sd",
			63: "bo",
			64: "ne",
			65: "sa",
			66: "mr",
			67: "bn",
			68: "as",
			69: "gu",
			70: "pa",
			71: "or",
			72: "ml",
			73: "kn",
			74: "ta",
			75: "te",
			76: "si",
			77: "my",
			78: "km",
			79: "lo",
			80: "vi",
			81: "id",
			82: "tl",
			83: "ms",
			84: "ms-Arab",
			85: "am",
			86: "ti",
			87: "om",
			88: "so",
			89: "sw",
			90: "rw",
			91: "rn",
			92: "ny",
			93: "mg",
			94: "eo",
			128: "cy",
			129: "eu",
			130: "ca",
			131: "la",
			132: "qu",
			133: "gn",
			134: "ay",
			135: "tt",
			136: "ug",
			137: "dz",
			138: "jv",
			139: "su",
			140: "gl",
			141: "af",
			142: "br",
			143: "iu",
			144: "gd",
			145: "gv",
			146: "ga",
			147: "to",
			148: "el-polyton",
			149: "kl",
			150: "az",
			151: "nn"
		},
		jF = {
			0: 0,
			1: 0,
			2: 0,
			3: 0,
			4: 0,
			5: 0,
			6: 0,
			7: 0,
			8: 0,
			9: 0,
			10: 5,
			11: 1,
			12: 4,
			13: 0,
			14: 6,
			15: 0,
			16: 0,
			17: 0,
			18: 0,
			19: 2,
			20: 4,
			21: 9,
			22: 21,
			23: 3,
			24: 29,
			25: 29,
			26: 29,
			27: 29,
			28: 29,
			29: 0,
			30: 0,
			31: 4,
			32: 7,
			33: 25,
			34: 0,
			35: 0,
			36: 0,
			37: 0,
			38: 29,
			39: 29,
			40: 0,
			41: 5,
			42: 7,
			43: 7,
			44: 7,
			45: 7,
			46: 7,
			47: 7,
			48: 7,
			49: 7,
			50: 4,
			51: 24,
			52: 23,
			53: 7,
			54: 7,
			55: 7,
			56: 7,
			57: 27,
			58: 7,
			59: 4,
			60: 4,
			61: 4,
			62: 4,
			63: 26,
			64: 9,
			65: 9,
			66: 9,
			67: 13,
			68: 13,
			69: 11,
			70: 10,
			71: 12,
			72: 17,
			73: 16,
			74: 14,
			75: 15,
			76: 18,
			77: 19,
			78: 20,
			79: 22,
			80: 30,
			81: 0,
			82: 0,
			83: 0,
			84: 4,
			85: 28,
			86: 28,
			87: 28,
			88: 0,
			89: 0,
			90: 0,
			91: 0,
			92: 0,
			93: 0,
			94: 0,
			128: 0,
			129: 0,
			130: 0,
			131: 0,
			132: 0,
			133: 0,
			134: 0,
			135: 7,
			136: 4,
			137: 26,
			138: 0,
			139: 0,
			140: 0,
			141: 0,
			142: 0,
			143: 28,
			144: 0,
			145: 0,
			146: 0,
			147: 0,
			148: 6,
			149: 0,
			150: 0,
			151: 0
		},
		nb = {
			1078: "af",
			1052: "sq",
			1156: "gsw",
			1118: "am",
			5121: "ar-DZ",
			15361: "ar-BH",
			3073: "ar",
			2049: "ar-IQ",
			11265: "ar-JO",
			13313: "ar-KW",
			12289: "ar-LB",
			4097: "ar-LY",
			6145: "ary",
			8193: "ar-OM",
			16385: "ar-QA",
			1025: "ar-SA",
			10241: "ar-SY",
			7169: "aeb",
			14337: "ar-AE",
			9217: "ar-YE",
			1067: "hy",
			1101: "as",
			2092: "az-Cyrl",
			1068: "az",
			1133: "ba",
			1069: "eu",
			1059: "be",
			2117: "bn",
			1093: "bn-IN",
			8218: "bs-Cyrl",
			5146: "bs",
			1150: "br",
			1026: "bg",
			1027: "ca",
			3076: "zh-HK",
			5124: "zh-MO",
			2052: "zh",
			4100: "zh-SG",
			1028: "zh-TW",
			1155: "co",
			1050: "hr",
			4122: "hr-BA",
			1029: "cs",
			1030: "da",
			1164: "prs",
			1125: "dv",
			2067: "nl-BE",
			1043: "nl",
			3081: "en-AU",
			10249: "en-BZ",
			4105: "en-CA",
			9225: "en-029",
			16393: "en-IN",
			6153: "en-IE",
			8201: "en-JM",
			17417: "en-MY",
			5129: "en-NZ",
			13321: "en-PH",
			18441: "en-SG",
			7177: "en-ZA",
			11273: "en-TT",
			2057: "en-GB",
			1033: "en",
			12297: "en-ZW",
			1061: "et",
			1080: "fo",
			1124: "fil",
			1035: "fi",
			2060: "fr-BE",
			3084: "fr-CA",
			1036: "fr",
			5132: "fr-LU",
			6156: "fr-MC",
			4108: "fr-CH",
			1122: "fy",
			1110: "gl",
			1079: "ka",
			3079: "de-AT",
			1031: "de",
			5127: "de-LI",
			4103: "de-LU",
			2055: "de-CH",
			1032: "el",
			1135: "kl",
			1095: "gu",
			1128: "ha",
			1037: "he",
			1081: "hi",
			1038: "hu",
			1039: "is",
			1136: "ig",
			1057: "id",
			1117: "iu",
			2141: "iu-Latn",
			2108: "ga",
			1076: "xh",
			1077: "zu",
			1040: "it",
			2064: "it-CH",
			1041: "ja",
			1099: "kn",
			1087: "kk",
			1107: "km",
			1158: "quc",
			1159: "rw",
			1089: "sw",
			1111: "kok",
			1042: "ko",
			1088: "ky",
			1108: "lo",
			1062: "lv",
			1063: "lt",
			2094: "dsb",
			1134: "lb",
			1071: "mk",
			2110: "ms-BN",
			1086: "ms",
			1100: "ml",
			1082: "mt",
			1153: "mi",
			1146: "arn",
			1102: "mr",
			1148: "moh",
			1104: "mn",
			2128: "mn-CN",
			1121: "ne",
			1044: "nb",
			2068: "nn",
			1154: "oc",
			1096: "or",
			1123: "ps",
			1045: "pl",
			1046: "pt",
			2070: "pt-PT",
			1094: "pa",
			1131: "qu-BO",
			2155: "qu-EC",
			3179: "qu",
			1048: "ro",
			1047: "rm",
			1049: "ru",
			9275: "smn",
			4155: "smj-NO",
			5179: "smj",
			3131: "se-FI",
			1083: "se",
			2107: "se-SE",
			8251: "sms",
			6203: "sma-NO",
			7227: "sms",
			1103: "sa",
			7194: "sr-Cyrl-BA",
			3098: "sr",
			6170: "sr-Latn-BA",
			2074: "sr-Latn",
			1132: "nso",
			1074: "tn",
			1115: "si",
			1051: "sk",
			1060: "sl",
			11274: "es-AR",
			16394: "es-BO",
			13322: "es-CL",
			9226: "es-CO",
			5130: "es-CR",
			7178: "es-DO",
			12298: "es-EC",
			17418: "es-SV",
			4106: "es-GT",
			18442: "es-HN",
			2058: "es-MX",
			19466: "es-NI",
			6154: "es-PA",
			15370: "es-PY",
			10250: "es-PE",
			20490: "es-PR",
			3082: "es",
			1034: "es",
			21514: "es-US",
			14346: "es-UY",
			8202: "es-VE",
			2077: "sv-FI",
			1053: "sv",
			1114: "syr",
			1064: "tg",
			2143: "tzm",
			1097: "ta",
			1092: "tt",
			1098: "te",
			1054: "th",
			1105: "bo",
			1055: "tr",
			1090: "tk",
			1152: "ug",
			1058: "uk",
			1070: "hsb",
			1056: "ur",
			2115: "uz-Cyrl",
			1091: "uz",
			1066: "vi",
			1106: "cy",
			1160: "wo",
			1157: "sah",
			1144: "ii",
			1130: "yo"
		};
	function YF(n, e, t) {
		switch (n) {
			case 0:
				if (e === 65535) return "und";
				if (t) return t[e];
				break;
			case 1:
				return tb[e];
			case 3:
				return nb[e];
		}
	}
	var hp = "utf-16",
		KF = {
			0: "macintosh",
			1: "x-mac-japanese",
			2: "x-mac-chinesetrad",
			3: "x-mac-korean",
			6: "x-mac-greek",
			7: "x-mac-cyrillic",
			9: "x-mac-devanagai",
			10: "x-mac-gurmukhi",
			11: "x-mac-gujarati",
			12: "x-mac-oriya",
			13: "x-mac-bengali",
			14: "x-mac-tamil",
			15: "x-mac-telugu",
			16: "x-mac-kannada",
			17: "x-mac-malayalam",
			18: "x-mac-sinhalese",
			19: "x-mac-burmese",
			20: "x-mac-khmer",
			21: "x-mac-thai",
			22: "x-mac-lao",
			23: "x-mac-georgian",
			24: "x-mac-armenian",
			25: "x-mac-chinesesimp",
			26: "x-mac-tibetan",
			27: "x-mac-mongolian",
			28: "x-mac-ethiopic",
			29: "x-mac-ce",
			30: "x-mac-vietnamese",
			31: "x-mac-extarabic"
		},
		ZF = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
	function ib(n, e, t) {
		switch (n) {
			case 0:
				return hp;
			case 1:
				return ZF[t] || KF[e];
			case 3:
				if (e === 1 || e === 10) return hp;
				break;
		}
	}
	function JF(n, e, t) {
		for (var i = {}, r = new Ze.Parser(n, e), s = r.parseUShort(), a = r.parseUShort(), o = r.offset + r.parseUShort(), l = 0; l < a; l++) {
			var c = r.parseUShort(),
				u = r.parseUShort(),
				h = r.parseUShort(),
				d = r.parseUShort(),
				f = eb[d] || d,
				v = r.parseUShort(),
				_ = r.parseUShort(),
				p = YF(c, h, t),
				g = ib(c, u, h);
			if (g !== void 0 && p !== void 0) {
				var x = void 0;
				if ((g === hp ? (x = Ho.UTF16(n, o + _, v)) : (x = Ho.MACSTRING(n, o + _, v, g)), x)) {
					var b = i[f];
					b === void 0 && (b = i[f] = {}), (b[p] = x);
				}
			}
		}
		return s === 1 && r.parseUShort(), i;
	}
	function Zd(n) {
		var e = {};
		for (var t in n) e[n[t]] = parseInt(t);
		return e;
	}
	function J0(n, e, t, i, r, s) {
		return new Ve.Record("NameRecord", [
			{ name: "platformID", type: "USHORT", value: n },
			{ name: "encodingID", type: "USHORT", value: e },
			{ name: "languageID", type: "USHORT", value: t },
			{ name: "nameID", type: "USHORT", value: i },
			{ name: "length", type: "USHORT", value: r },
			{ name: "offset", type: "USHORT", value: s }
		]);
	}
	function QF(n, e) {
		var t = n.length,
			i = e.length - t + 1;
		e: for (var r = 0; r < i; r++)
			for (; r < i; r++) {
				for (var s = 0; s < t; s++) if (e[r + s] !== n[s]) continue e;
				return r;
			}
		return -1;
	}
	function Q0(n, e) {
		var t = QF(n, e);
		if (t < 0) {
			t = e.length;
			for (var i = 0, r = n.length; i < r; ++i) e.push(n[i]);
		}
		return t;
	}
	function eN(n, e) {
		var t,
			i = [],
			r = {},
			s = Zd(eb);
		for (var a in n) {
			var o = s[a];
			if ((o === void 0 && (o = a), (t = parseInt(o)), isNaN(t))) throw new Error('Name table entry "' + a + '" does not exist, see nameTableNames for complete list.');
			(r[t] = n[a]), i.push(t);
		}
		for (var l = Zd(tb), c = Zd(nb), u = [], h = [], d = 0; d < i.length; d++) {
			t = i[d];
			var f = r[t];
			for (var v in f) {
				var _ = f[v],
					p = 1,
					g = l[v],
					x = jF[g],
					b = ib(p, x, g),
					T = ze.MACSTRING(_, b);
				T === void 0 && ((p = 0), (g = e.indexOf(v)), g < 0 && ((g = e.length), e.push(v)), (x = 4), (T = ze.UTF16(_)));
				var P = Q0(T, h);
				u.push(J0(p, x, g, t, T.length, P));
				var A = c[v];
				if (A !== void 0) {
					var M = ze.UTF16(_),
						w = Q0(M, h);
					u.push(J0(3, 1, A, t, M.length, w));
				}
			}
		}
		u.sort(function (L, N) {
			return L.platformID - N.platformID || L.encodingID - N.encodingID || L.languageID - N.languageID || L.nameID - N.nameID;
		});
		for (
			var y = new Ve.Table("name", [
					{ name: "format", type: "USHORT", value: 0 },
					{ name: "count", type: "USHORT", value: u.length },
					{ name: "stringOffset", type: "USHORT", value: 6 + u.length * 12 }
				]),
				S = 0;
			S < u.length;
			S++
		)
			y.fields.push({ name: "record_" + S, type: "RECORD", value: u[S] });
		return y.fields.push({ name: "strings", type: "LITERAL", value: h }), y;
	}
	var rb = { parse: JF, make: eN },
		dp = [
			{ begin: 0, end: 127 },
			{ begin: 128, end: 255 },
			{ begin: 256, end: 383 },
			{ begin: 384, end: 591 },
			{ begin: 592, end: 687 },
			{ begin: 688, end: 767 },
			{ begin: 768, end: 879 },
			{ begin: 880, end: 1023 },
			{ begin: 11392, end: 11519 },
			{ begin: 1024, end: 1279 },
			{ begin: 1328, end: 1423 },
			{ begin: 1424, end: 1535 },
			{ begin: 42240, end: 42559 },
			{ begin: 1536, end: 1791 },
			{ begin: 1984, end: 2047 },
			{ begin: 2304, end: 2431 },
			{ begin: 2432, end: 2559 },
			{ begin: 2560, end: 2687 },
			{ begin: 2688, end: 2815 },
			{ begin: 2816, end: 2943 },
			{ begin: 2944, end: 3071 },
			{ begin: 3072, end: 3199 },
			{ begin: 3200, end: 3327 },
			{ begin: 3328, end: 3455 },
			{ begin: 3584, end: 3711 },
			{ begin: 3712, end: 3839 },
			{ begin: 4256, end: 4351 },
			{ begin: 6912, end: 7039 },
			{ begin: 4352, end: 4607 },
			{ begin: 7680, end: 7935 },
			{ begin: 7936, end: 8191 },
			{ begin: 8192, end: 8303 },
			{ begin: 8304, end: 8351 },
			{ begin: 8352, end: 8399 },
			{ begin: 8400, end: 8447 },
			{ begin: 8448, end: 8527 },
			{ begin: 8528, end: 8591 },
			{ begin: 8592, end: 8703 },
			{ begin: 8704, end: 8959 },
			{ begin: 8960, end: 9215 },
			{ begin: 9216, end: 9279 },
			{ begin: 9280, end: 9311 },
			{ begin: 9312, end: 9471 },
			{ begin: 9472, end: 9599 },
			{ begin: 9600, end: 9631 },
			{ begin: 9632, end: 9727 },
			{ begin: 9728, end: 9983 },
			{ begin: 9984, end: 10175 },
			{ begin: 12288, end: 12351 },
			{ begin: 12352, end: 12447 },
			{ begin: 12448, end: 12543 },
			{ begin: 12544, end: 12591 },
			{ begin: 12592, end: 12687 },
			{ begin: 43072, end: 43135 },
			{ begin: 12800, end: 13055 },
			{ begin: 13056, end: 13311 },
			{ begin: 44032, end: 55215 },
			{ begin: 55296, end: 57343 },
			{ begin: 67840, end: 67871 },
			{ begin: 19968, end: 40959 },
			{ begin: 57344, end: 63743 },
			{ begin: 12736, end: 12783 },
			{ begin: 64256, end: 64335 },
			{ begin: 64336, end: 65023 },
			{ begin: 65056, end: 65071 },
			{ begin: 65040, end: 65055 },
			{ begin: 65104, end: 65135 },
			{ begin: 65136, end: 65279 },
			{ begin: 65280, end: 65519 },
			{ begin: 65520, end: 65535 },
			{ begin: 3840, end: 4095 },
			{ begin: 1792, end: 1871 },
			{ begin: 1920, end: 1983 },
			{ begin: 3456, end: 3583 },
			{ begin: 4096, end: 4255 },
			{ begin: 4608, end: 4991 },
			{ begin: 5024, end: 5119 },
			{ begin: 5120, end: 5759 },
			{ begin: 5760, end: 5791 },
			{ begin: 5792, end: 5887 },
			{ begin: 6016, end: 6143 },
			{ begin: 6144, end: 6319 },
			{ begin: 10240, end: 10495 },
			{ begin: 40960, end: 42127 },
			{ begin: 5888, end: 5919 },
			{ begin: 66304, end: 66351 },
			{ begin: 66352, end: 66383 },
			{ begin: 66560, end: 66639 },
			{ begin: 118784, end: 119039 },
			{ begin: 119808, end: 120831 },
			{ begin: 1044480, end: 1048573 },
			{ begin: 65024, end: 65039 },
			{ begin: 917504, end: 917631 },
			{ begin: 6400, end: 6479 },
			{ begin: 6480, end: 6527 },
			{ begin: 6528, end: 6623 },
			{ begin: 6656, end: 6687 },
			{ begin: 11264, end: 11359 },
			{ begin: 11568, end: 11647 },
			{ begin: 19904, end: 19967 },
			{ begin: 43008, end: 43055 },
			{ begin: 65536, end: 65663 },
			{ begin: 65856, end: 65935 },
			{ begin: 66432, end: 66463 },
			{ begin: 66464, end: 66527 },
			{ begin: 66640, end: 66687 },
			{ begin: 66688, end: 66735 },
			{ begin: 67584, end: 67647 },
			{ begin: 68096, end: 68191 },
			{ begin: 119552, end: 119647 },
			{ begin: 73728, end: 74751 },
			{ begin: 119648, end: 119679 },
			{ begin: 7040, end: 7103 },
			{ begin: 7168, end: 7247 },
			{ begin: 7248, end: 7295 },
			{ begin: 43136, end: 43231 },
			{ begin: 43264, end: 43311 },
			{ begin: 43312, end: 43359 },
			{ begin: 43520, end: 43615 },
			{ begin: 65936, end: 65999 },
			{ begin: 66e3, end: 66047 },
			{ begin: 66208, end: 66271 },
			{ begin: 127024, end: 127135 }
		];
	function tN(n) {
		for (var e = 0; e < dp.length; e += 1) {
			var t = dp[e];
			if (n >= t.begin && n < t.end) return e;
		}
		return -1;
	}
	function nN(n, e) {
		var t = {},
			i = new Ze.Parser(n, e);
		(t.version = i.parseUShort()),
			(t.xAvgCharWidth = i.parseShort()),
			(t.usWeightClass = i.parseUShort()),
			(t.usWidthClass = i.parseUShort()),
			(t.fsType = i.parseUShort()),
			(t.ySubscriptXSize = i.parseShort()),
			(t.ySubscriptYSize = i.parseShort()),
			(t.ySubscriptXOffset = i.parseShort()),
			(t.ySubscriptYOffset = i.parseShort()),
			(t.ySuperscriptXSize = i.parseShort()),
			(t.ySuperscriptYSize = i.parseShort()),
			(t.ySuperscriptXOffset = i.parseShort()),
			(t.ySuperscriptYOffset = i.parseShort()),
			(t.yStrikeoutSize = i.parseShort()),
			(t.yStrikeoutPosition = i.parseShort()),
			(t.sFamilyClass = i.parseShort()),
			(t.panose = []);
		for (var r = 0; r < 10; r++) t.panose[r] = i.parseByte();
		return (
			(t.ulUnicodeRange1 = i.parseULong()),
			(t.ulUnicodeRange2 = i.parseULong()),
			(t.ulUnicodeRange3 = i.parseULong()),
			(t.ulUnicodeRange4 = i.parseULong()),
			(t.achVendID = String.fromCharCode(i.parseByte(), i.parseByte(), i.parseByte(), i.parseByte())),
			(t.fsSelection = i.parseUShort()),
			(t.usFirstCharIndex = i.parseUShort()),
			(t.usLastCharIndex = i.parseUShort()),
			(t.sTypoAscender = i.parseShort()),
			(t.sTypoDescender = i.parseShort()),
			(t.sTypoLineGap = i.parseShort()),
			(t.usWinAscent = i.parseUShort()),
			(t.usWinDescent = i.parseUShort()),
			t.version >= 1 && ((t.ulCodePageRange1 = i.parseULong()), (t.ulCodePageRange2 = i.parseULong())),
			t.version >= 2 && ((t.sxHeight = i.parseShort()), (t.sCapHeight = i.parseShort()), (t.usDefaultChar = i.parseUShort()), (t.usBreakChar = i.parseUShort()), (t.usMaxContent = i.parseUShort())),
			t
		);
	}
	function iN(n) {
		return new Ve.Table(
			"OS/2",
			[
				{ name: "version", type: "USHORT", value: 3 },
				{ name: "xAvgCharWidth", type: "SHORT", value: 0 },
				{ name: "usWeightClass", type: "USHORT", value: 0 },
				{ name: "usWidthClass", type: "USHORT", value: 0 },
				{ name: "fsType", type: "USHORT", value: 0 },
				{ name: "ySubscriptXSize", type: "SHORT", value: 650 },
				{ name: "ySubscriptYSize", type: "SHORT", value: 699 },
				{ name: "ySubscriptXOffset", type: "SHORT", value: 0 },
				{ name: "ySubscriptYOffset", type: "SHORT", value: 140 },
				{ name: "ySuperscriptXSize", type: "SHORT", value: 650 },
				{ name: "ySuperscriptYSize", type: "SHORT", value: 699 },
				{ name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
				{ name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
				{ name: "yStrikeoutSize", type: "SHORT", value: 49 },
				{ name: "yStrikeoutPosition", type: "SHORT", value: 258 },
				{ name: "sFamilyClass", type: "SHORT", value: 0 },
				{ name: "bFamilyType", type: "BYTE", value: 0 },
				{ name: "bSerifStyle", type: "BYTE", value: 0 },
				{ name: "bWeight", type: "BYTE", value: 0 },
				{ name: "bProportion", type: "BYTE", value: 0 },
				{ name: "bContrast", type: "BYTE", value: 0 },
				{ name: "bStrokeVariation", type: "BYTE", value: 0 },
				{ name: "bArmStyle", type: "BYTE", value: 0 },
				{ name: "bLetterform", type: "BYTE", value: 0 },
				{ name: "bMidline", type: "BYTE", value: 0 },
				{ name: "bXHeight", type: "BYTE", value: 0 },
				{ name: "ulUnicodeRange1", type: "ULONG", value: 0 },
				{ name: "ulUnicodeRange2", type: "ULONG", value: 0 },
				{ name: "ulUnicodeRange3", type: "ULONG", value: 0 },
				{ name: "ulUnicodeRange4", type: "ULONG", value: 0 },
				{ name: "achVendID", type: "CHARARRAY", value: "XXXX" },
				{ name: "fsSelection", type: "USHORT", value: 0 },
				{ name: "usFirstCharIndex", type: "USHORT", value: 0 },
				{ name: "usLastCharIndex", type: "USHORT", value: 0 },
				{ name: "sTypoAscender", type: "SHORT", value: 0 },
				{ name: "sTypoDescender", type: "SHORT", value: 0 },
				{ name: "sTypoLineGap", type: "SHORT", value: 0 },
				{ name: "usWinAscent", type: "USHORT", value: 0 },
				{ name: "usWinDescent", type: "USHORT", value: 0 },
				{ name: "ulCodePageRange1", type: "ULONG", value: 0 },
				{ name: "ulCodePageRange2", type: "ULONG", value: 0 },
				{ name: "sxHeight", type: "SHORT", value: 0 },
				{ name: "sCapHeight", type: "SHORT", value: 0 },
				{ name: "usDefaultChar", type: "USHORT", value: 0 },
				{ name: "usBreakChar", type: "USHORT", value: 0 },
				{ name: "usMaxContext", type: "USHORT", value: 0 }
			],
			n
		);
	}
	var fp = { parse: nN, make: iN, unicodeRanges: dp, getUnicodeRange: tN };
	function rN(n, e) {
		var t = {},
			i = new Ze.Parser(n, e);
		switch (((t.version = i.parseVersion()), (t.italicAngle = i.parseFixed()), (t.underlinePosition = i.parseShort()), (t.underlineThickness = i.parseShort()), (t.isFixedPitch = i.parseULong()), (t.minMemType42 = i.parseULong()), (t.maxMemType42 = i.parseULong()), (t.minMemType1 = i.parseULong()), (t.maxMemType1 = i.parseULong()), t.version)) {
			case 1:
				t.names = la.slice();
				break;
			case 2:
				(t.numberOfGlyphs = i.parseUShort()), (t.glyphNameIndex = new Array(t.numberOfGlyphs));
				for (var r = 0; r < t.numberOfGlyphs; r++) t.glyphNameIndex[r] = i.parseUShort();
				t.names = [];
				for (var s = 0; s < t.numberOfGlyphs; s++)
					if (t.glyphNameIndex[s] >= la.length) {
						var a = i.parseChar();
						t.names.push(i.parseString(a));
					}
				break;
			case 2.5:
				(t.numberOfGlyphs = i.parseUShort()), (t.offset = new Array(t.numberOfGlyphs));
				for (var o = 0; o < t.numberOfGlyphs; o++) t.offset[o] = i.parseChar();
				break;
		}
		return t;
	}
	function sN() {
		return new Ve.Table("post", [
			{ name: "version", type: "FIXED", value: 196608 },
			{ name: "italicAngle", type: "FIXED", value: 0 },
			{ name: "underlinePosition", type: "FWORD", value: 0 },
			{ name: "underlineThickness", type: "FWORD", value: 0 },
			{ name: "isFixedPitch", type: "ULONG", value: 0 },
			{ name: "minMemType42", type: "ULONG", value: 0 },
			{ name: "maxMemType42", type: "ULONG", value: 0 },
			{ name: "minMemType1", type: "ULONG", value: 0 },
			{ name: "maxMemType1", type: "ULONG", value: 0 }
		]);
	}
	var sb = { parse: rN, make: sN },
		ir = new Array(9);
	ir[1] = function () {
		var e = this.offset + this.relativeOffset,
			t = this.parseUShort();
		if (t === 1) return { substFormat: 1, coverage: this.parsePointer(ne.coverage), deltaGlyphId: this.parseUShort() };
		if (t === 2) return { substFormat: 2, coverage: this.parsePointer(ne.coverage), substitute: this.parseOffset16List() };
		tt.assert(!1, "0x" + e.toString(16) + ": lookup type 1 format must be 1 or 2.");
	};
	ir[2] = function () {
		var e = this.parseUShort();
		return tt.argument(e === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(ne.coverage), sequences: this.parseListOfLists() };
	};
	ir[3] = function () {
		var e = this.parseUShort();
		return tt.argument(e === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(ne.coverage), alternateSets: this.parseListOfLists() };
	};
	ir[4] = function () {
		var e = this.parseUShort();
		return (
			tt.argument(e === 1, "GSUB ligature table identifier-format must be 1"),
			{
				substFormat: e,
				coverage: this.parsePointer(ne.coverage),
				ligatureSets: this.parseListOfLists(function () {
					return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
				})
			}
		);
	};
	var Lo = { sequenceIndex: ne.uShort, lookupListIndex: ne.uShort };
	ir[5] = function () {
		var e = this.offset + this.relativeOffset,
			t = this.parseUShort();
		if (t === 1)
			return {
				substFormat: t,
				coverage: this.parsePointer(ne.coverage),
				ruleSets: this.parseListOfLists(function () {
					var s = this.parseUShort(),
						a = this.parseUShort();
					return { input: this.parseUShortList(s - 1), lookupRecords: this.parseRecordList(a, Lo) };
				})
			};
		if (t === 2)
			return {
				substFormat: t,
				coverage: this.parsePointer(ne.coverage),
				classDef: this.parsePointer(ne.classDef),
				classSets: this.parseListOfLists(function () {
					var s = this.parseUShort(),
						a = this.parseUShort();
					return { classes: this.parseUShortList(s - 1), lookupRecords: this.parseRecordList(a, Lo) };
				})
			};
		if (t === 3) {
			var i = this.parseUShort(),
				r = this.parseUShort();
			return { substFormat: t, coverages: this.parseList(i, ne.pointer(ne.coverage)), lookupRecords: this.parseRecordList(r, Lo) };
		}
		tt.assert(!1, "0x" + e.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
	};
	ir[6] = function () {
		var e = this.offset + this.relativeOffset,
			t = this.parseUShort();
		if (t === 1)
			return {
				substFormat: 1,
				coverage: this.parsePointer(ne.coverage),
				chainRuleSets: this.parseListOfLists(function () {
					return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(Lo) };
				})
			};
		if (t === 2)
			return {
				substFormat: 2,
				coverage: this.parsePointer(ne.coverage),
				backtrackClassDef: this.parsePointer(ne.classDef),
				inputClassDef: this.parsePointer(ne.classDef),
				lookaheadClassDef: this.parsePointer(ne.classDef),
				chainClassSet: this.parseListOfLists(function () {
					return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(Lo) };
				})
			};
		if (t === 3) return { substFormat: 3, backtrackCoverage: this.parseList(ne.pointer(ne.coverage)), inputCoverage: this.parseList(ne.pointer(ne.coverage)), lookaheadCoverage: this.parseList(ne.pointer(ne.coverage)), lookupRecords: this.parseRecordList(Lo) };
		tt.assert(!1, "0x" + e.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
	};
	ir[7] = function () {
		var e = this.parseUShort();
		tt.argument(e === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
		var t = this.parseUShort(),
			i = new ne(this.data, this.offset + this.parseULong());
		return { substFormat: 1, lookupType: t, extension: ir[t].call(i) };
	};
	ir[8] = function () {
		var e = this.parseUShort();
		return tt.argument(e === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(ne.coverage), backtrackCoverage: this.parseList(ne.pointer(ne.coverage)), lookaheadCoverage: this.parseList(ne.pointer(ne.coverage)), substitutes: this.parseUShortList() };
	};
	function aN(n, e) {
		e = e || 0;
		var t = new ne(n, e),
			i = t.parseVersion(1);
		return tt.argument(i === 1 || i === 1.1, "Unsupported GSUB table version."), i === 1 ? { version: i, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(ir) } : { version: i, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(ir), variations: t.parseFeatureVariationsList() };
	}
	var jo = new Array(9);
	jo[1] = function (e) {
		return e.substFormat === 1
			? new Ve.Table("substitutionTable", [
					{ name: "substFormat", type: "USHORT", value: 1 },
					{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) },
					{ name: "deltaGlyphID", type: "USHORT", value: e.deltaGlyphId }
			  ])
			: new Ve.Table(
					"substitutionTable",
					[
						{ name: "substFormat", type: "USHORT", value: 2 },
						{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) }
					].concat(Ve.ushortList("substitute", e.substitute))
			  );
	};
	jo[2] = function (e) {
		return (
			tt.assert(e.substFormat === 1, "Lookup type 2 substFormat must be 1."),
			new Ve.Table(
				"substitutionTable",
				[
					{ name: "substFormat", type: "USHORT", value: 1 },
					{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) }
				].concat(
					Ve.tableList("seqSet", e.sequences, function (t) {
						return new Ve.Table("sequenceSetTable", Ve.ushortList("sequence", t));
					})
				)
			)
		);
	};
	jo[3] = function (e) {
		return (
			tt.assert(e.substFormat === 1, "Lookup type 3 substFormat must be 1."),
			new Ve.Table(
				"substitutionTable",
				[
					{ name: "substFormat", type: "USHORT", value: 1 },
					{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) }
				].concat(
					Ve.tableList("altSet", e.alternateSets, function (t) {
						return new Ve.Table("alternateSetTable", Ve.ushortList("alternate", t));
					})
				)
			)
		);
	};
	jo[4] = function (e) {
		return (
			tt.assert(e.substFormat === 1, "Lookup type 4 substFormat must be 1."),
			new Ve.Table(
				"substitutionTable",
				[
					{ name: "substFormat", type: "USHORT", value: 1 },
					{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) }
				].concat(
					Ve.tableList("ligSet", e.ligatureSets, function (t) {
						return new Ve.Table(
							"ligatureSetTable",
							Ve.tableList("ligature", t, function (i) {
								return new Ve.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: i.ligGlyph }].concat(Ve.ushortList("component", i.components, i.components.length + 1)));
							})
						);
					})
				)
			)
		);
	};
	jo[6] = function (e) {
		if (e.substFormat === 1) {
			var t = new Ve.Table(
				"chainContextTable",
				[
					{ name: "substFormat", type: "USHORT", value: e.substFormat },
					{ name: "coverage", type: "TABLE", value: new Ve.Coverage(e.coverage) }
				].concat(
					Ve.tableList("chainRuleSet", e.chainRuleSets, function (s) {
						return new Ve.Table(
							"chainRuleSetTable",
							Ve.tableList("chainRule", s, function (a) {
								var o = Ve.ushortList("backtrackGlyph", a.backtrack, a.backtrack.length)
									.concat(Ve.ushortList("inputGlyph", a.input, a.input.length + 1))
									.concat(Ve.ushortList("lookaheadGlyph", a.lookahead, a.lookahead.length))
									.concat(Ve.ushortList("substitution", [], a.lookupRecords.length));
								return (
									a.lookupRecords.forEach(function (l, c) {
										o = o.concat({ name: "sequenceIndex" + c, type: "USHORT", value: l.sequenceIndex }).concat({ name: "lookupListIndex" + c, type: "USHORT", value: l.lookupListIndex });
									}),
									new Ve.Table("chainRuleTable", o)
								);
							})
						);
					})
				)
			);
			return t;
		} else if (e.substFormat === 2) tt.assert(!1, "lookup type 6 format 2 is not yet supported.");
		else if (e.substFormat === 3) {
			var i = [{ name: "substFormat", type: "USHORT", value: e.substFormat }];
			i.push({ name: "backtrackGlyphCount", type: "USHORT", value: e.backtrackCoverage.length }),
				e.backtrackCoverage.forEach(function (s, a) {
					i.push({ name: "backtrackCoverage" + a, type: "TABLE", value: new Ve.Coverage(s) });
				}),
				i.push({ name: "inputGlyphCount", type: "USHORT", value: e.inputCoverage.length }),
				e.inputCoverage.forEach(function (s, a) {
					i.push({ name: "inputCoverage" + a, type: "TABLE", value: new Ve.Coverage(s) });
				}),
				i.push({ name: "lookaheadGlyphCount", type: "USHORT", value: e.lookaheadCoverage.length }),
				e.lookaheadCoverage.forEach(function (s, a) {
					i.push({ name: "lookaheadCoverage" + a, type: "TABLE", value: new Ve.Coverage(s) });
				}),
				i.push({ name: "substitutionCount", type: "USHORT", value: e.lookupRecords.length }),
				e.lookupRecords.forEach(function (s, a) {
					i = i.concat({ name: "sequenceIndex" + a, type: "USHORT", value: s.sequenceIndex }).concat({ name: "lookupListIndex" + a, type: "USHORT", value: s.lookupListIndex });
				});
			var r = new Ve.Table("chainContextTable", i);
			return r;
		}
		tt.assert(!1, "lookup type 6 format must be 1, 2 or 3.");
	};
	function oN(n) {
		return new Ve.Table("GSUB", [
			{ name: "version", type: "ULONG", value: 65536 },
			{ name: "scripts", type: "TABLE", value: new Ve.ScriptList(n.scripts) },
			{ name: "features", type: "TABLE", value: new Ve.FeatureList(n.features) },
			{ name: "lookups", type: "TABLE", value: new Ve.LookupList(n.lookups, jo) }
		]);
	}
	var ab = { parse: aN, make: oN };
	function lN(n, e) {
		var t = new Ze.Parser(n, e),
			i = t.parseULong();
		tt.argument(i === 1, "Unsupported META table version."), t.parseULong(), t.parseULong();
		for (var r = t.parseULong(), s = {}, a = 0; a < r; a++) {
			var o = t.parseTag(),
				l = t.parseULong(),
				c = t.parseULong(),
				u = Ho.UTF8(n, e + l, c);
			s[o] = u;
		}
		return s;
	}
	function cN(n) {
		var e = Object.keys(n).length,
			t = "",
			i = 16 + e * 12,
			r = new Ve.Table("meta", [
				{ name: "version", type: "ULONG", value: 1 },
				{ name: "flags", type: "ULONG", value: 0 },
				{ name: "offset", type: "ULONG", value: i },
				{ name: "numTags", type: "ULONG", value: e }
			]);
		for (var s in n) {
			var a = t.length;
			(t += n[s]), r.fields.push({ name: "tag " + s, type: "TAG", value: s }), r.fields.push({ name: "offset " + s, type: "ULONG", value: i + a }), r.fields.push({ name: "length " + s, type: "ULONG", value: n[s].length });
		}
		return r.fields.push({ name: "stringPool", type: "CHARARRAY", value: t }), r;
	}
	var ob = { parse: lN, make: cN };
	function uN(n, e) {
		var t = new ne(n, e),
			i = t.parseUShort();
		tt.argument(i === 0, "Only COLRv0 supported.");
		var r = t.parseUShort(),
			s = t.parseOffset32(),
			a = t.parseOffset32(),
			o = t.parseUShort();
		t.relativeOffset = s;
		var l = t.parseRecordList(r, { glyphID: ne.uShort, firstLayerIndex: ne.uShort, numLayers: ne.uShort });
		t.relativeOffset = a;
		var c = t.parseRecordList(o, { glyphID: ne.uShort, paletteIndex: ne.uShort });
		return { version: i, baseGlyphRecords: l, layerRecords: c };
	}
	function hN(n) {
		var e = n.version;
		e === void 0 && (e = 0);
		var t = n.baseGlyphRecords;
		t === void 0 && (t = []);
		var i = n.layerRecords;
		i === void 0 && (i = []), tt.argument(e === 0, "Only COLRv0 supported.");
		var r = 14,
			s = r + t.length * 6;
		return new Ve.Table(
			"COLR",
			[
				{ name: "version", type: "USHORT", value: e },
				{ name: "numBaseGlyphRecords", type: "USHORT", value: t.length },
				{ name: "baseGlyphRecordsOffset", type: "ULONG", value: r },
				{ name: "layerRecordsOffset", type: "ULONG", value: s },
				{ name: "numLayerRecords", type: "USHORT", value: i.length }
			].concat(
				t
					.map(function (a, o) {
						return [
							{ name: "glyphID_" + o, type: "USHORT", value: a.glyphID },
							{ name: "firstLayerIndex_" + o, type: "USHORT", value: a.firstLayerIndex },
							{ name: "numLayers_" + o, type: "USHORT", value: a.numLayers }
						];
					})
					.flat(),
				i
					.map(function (a, o) {
						return [
							{ name: "LayerGlyphID_" + o, type: "USHORT", value: a.glyphID },
							{ name: "paletteIndex_" + o, type: "USHORT", value: a.paletteIndex }
						];
					})
					.flat()
			)
		);
	}
	var lb = { parse: uN, make: hN };
	function dN(n, e) {
		var t = new ne(n, e),
			i = t.parseShort(),
			r = t.parseShort(),
			s = t.parseShort(),
			a = t.parseShort(),
			o = t.parseOffset32(),
			l = t.parseUShortList(s);
		t.relativeOffset = o;
		var c = t.parseULongList(a);
		return { version: i, numPaletteEntries: r, colorRecords: c, colorRecordIndices: l };
	}
	function fN(n) {
		var e = n.version;
		e === void 0 && (e = 0);
		var t = n.numPaletteEntries;
		t === void 0 && (t = 0);
		var i = n.colorRecords;
		i === void 0 && (i = []);
		var r = n.colorRecordIndices;
		return (
			r === void 0 && (r = [0]),
			tt.argument(e === 0, "Only CPALv0 are supported."),
			tt.argument(i.length, "No colorRecords given."),
			tt.argument(r.length, "No colorRecordIndices given."),
			tt.argument(!t && r.length == 1, "Can't infer numPaletteEntries on multiple colorRecordIndices"),
			new Ve.Table(
				"CPAL",
				[
					{ name: "version", type: "USHORT", value: e },
					{ name: "numPaletteEntries", type: "USHORT", value: t || i.length },
					{ name: "numPalettes", type: "USHORT", value: r.length },
					{ name: "numColorRecords", type: "USHORT", value: i.length },
					{ name: "colorRecordsArrayOffset", type: "ULONG", value: 12 + 2 * r.length }
				].concat(
					r.map(function (s, a) {
						return { name: "colorRecordIndices_" + a, type: "USHORT", value: s };
					}),
					i.map(function (s, a) {
						return { name: "colorRecords_" + a, type: "ULONG", value: s };
					})
				)
			)
		);
	}
	var cb = { parse: dN, make: fN };
	function e_(n) {
		return (Math.log(n) / Math.log(2)) | 0;
	}
	function um(n) {
		for (; n.length % 4 !== 0; ) n.push(0);
		for (var e = 0, t = 0; t < n.length; t += 4) e += (n[t] << 24) + (n[t + 1] << 16) + (n[t + 2] << 8) + n[t + 3];
		return (e %= Math.pow(2, 32)), e;
	}
	function t_(n, e, t, i) {
		return new Ve.Record("Table Record", [
			{ name: "tag", type: "TAG", value: n !== void 0 ? n : "" },
			{ name: "checkSum", type: "ULONG", value: e !== void 0 ? e : 0 },
			{ name: "offset", type: "ULONG", value: t !== void 0 ? t : 0 },
			{ name: "length", type: "ULONG", value: i !== void 0 ? i : 0 }
		]);
	}
	function ub(n) {
		var e = new Ve.Table("sfnt", [
			{ name: "version", type: "TAG", value: "OTTO" },
			{ name: "numTables", type: "USHORT", value: 0 },
			{ name: "searchRange", type: "USHORT", value: 0 },
			{ name: "entrySelector", type: "USHORT", value: 0 },
			{ name: "rangeShift", type: "USHORT", value: 0 }
		]);
		(e.tables = n), (e.numTables = n.length);
		var t = Math.pow(2, e_(e.numTables));
		(e.searchRange = 16 * t), (e.entrySelector = e_(t)), (e.rangeShift = e.numTables * 16 - e.searchRange);
		for (var i = [], r = [], s = e.sizeOf() + t_().sizeOf() * e.numTables; s % 4 !== 0; ) (s += 1), r.push({ name: "padding", type: "BYTE", value: 0 });
		for (var a = 0; a < n.length; a += 1) {
			var o = n[a];
			tt.argument(o.tableName.length === 4, "Table name" + o.tableName + " is invalid.");
			var l = o.sizeOf(),
				c = t_(o.tableName, um(o.encode()), s, l);
			for (i.push({ name: c.tag + " Table Record", type: "RECORD", value: c }), r.push({ name: o.tableName + " table", type: "RECORD", value: o }), s += l, tt.argument(!isNaN(s), "Something went wrong calculating the offset."); s % 4 !== 0; ) (s += 1), r.push({ name: "padding", type: "BYTE", value: 0 });
		}
		return (
			i.sort(function (u, h) {
				return u.value.tag > h.value.tag ? 1 : -1;
			}),
			(e.fields = e.fields.concat(i)),
			(e.fields = e.fields.concat(r)),
			e
		);
	}
	function n_(n, e, t) {
		for (var i = 0; i < e.length; i += 1) {
			var r = n.charToGlyphIndex(e[i]);
			if (r > 0) {
				var s = n.glyphs.get(r);
				return s.getMetrics();
			}
		}
		return t;
	}
	function pN(n) {
		for (var e = 0, t = 0; t < n.length; t += 1) e += n[t];
		return e / n.length;
	}
	function mN(n) {
		for (var e = [], t = [], i = [], r = [], s = [], a = [], o = [], l, c = 0, u = 0, h = 0, d = 0, f = 0, v = 0; v < n.glyphs.length; v += 1) {
			var _ = n.glyphs.get(v),
				p = _.unicode | 0;
			if (isNaN(_.advanceWidth)) throw new Error("Glyph " + _.name + " (" + v + "): advanceWidth is not a number.");
			(l > p || l === void 0) && p > 0 && (l = p), c < p && (c = p);
			var g = fp.getUnicodeRange(p);
			if (g < 32) u |= 1 << g;
			else if (g < 64) h |= 1 << (g - 32);
			else if (g < 96) d |= 1 << (g - 64);
			else if (g < 123) f |= 1 << (g - 96);
			else throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
			if (_.name !== ".notdef") {
				var x = _.getMetrics();
				e.push(x.xMin), t.push(x.yMin), i.push(x.xMax), r.push(x.yMax), a.push(x.leftSideBearing), o.push(x.rightSideBearing), s.push(_.advanceWidth);
			}
		}
		var b = { xMin: Math.min.apply(null, e), yMin: Math.min.apply(null, t), xMax: Math.max.apply(null, i), yMax: Math.max.apply(null, r), advanceWidthMax: Math.max.apply(null, s), advanceWidthAvg: pN(s), minLeftSideBearing: Math.min.apply(null, a), maxLeftSideBearing: Math.max.apply(null, a), minRightSideBearing: Math.min.apply(null, o) };
		(b.ascender = n.ascender), (b.descender = n.descender);
		var T = Yx.make({ flags: 3, unitsPerEm: n.unitsPerEm, xMin: b.xMin, yMin: b.yMin, xMax: b.xMax, yMax: b.yMax, lowestRecPPEM: 3, createdTimestamp: n.createdTimestamp }),
			P = Kx.make({ ascender: b.ascender, descender: b.descender, advanceWidthMax: b.advanceWidthMax, minLeftSideBearing: b.minLeftSideBearing, minRightSideBearing: b.minRightSideBearing, xMaxExtent: b.maxLeftSideBearing + (b.xMax - b.xMin), numberOfHMetrics: n.glyphs.length }),
			A = Qx.make(n.glyphs.length),
			M = fp.make(
				Object.assign(
					{
						xAvgCharWidth: Math.round(b.advanceWidthAvg),
						usFirstCharIndex: l,
						usLastCharIndex: c,
						ulUnicodeRange1: u,
						ulUnicodeRange2: h,
						ulUnicodeRange3: d,
						ulUnicodeRange4: f,
						sTypoAscender: b.ascender,
						sTypoDescender: b.descender,
						sTypoLineGap: 0,
						usWinAscent: b.yMax,
						usWinDescent: Math.abs(b.yMin),
						ulCodePageRange1: 1,
						sxHeight: n_(n, "xyvw", { yMax: Math.round(b.ascender / 2) }).yMax,
						sCapHeight: n_(n, "HIKLEFJMNTZBDPRAGOQSUVWXY", b).yMax,
						usDefaultChar: n.hasChar(" ") ? 32 : 0,
						usBreakChar: n.hasChar(" ") ? 32 : 0
					},
					n.tables.os2
				)
			),
			w = Zx.make(n.glyphs),
			y = Ux.make(n.glyphs),
			S = n.getEnglishName("fontFamily"),
			L = n.getEnglishName("fontSubfamily"),
			N = S + " " + L,
			k = n.getEnglishName("postScriptName");
		k || (k = S.replace(/\s/g, "") + "-" + L);
		var B = {};
		for (var W in n.names) B[W] = n.names[W];
		B.uniqueID || (B.uniqueID = { en: n.getEnglishName("manufacturer") + ":" + N }), B.postScriptName || (B.postScriptName = { en: k }), B.preferredFamily || (B.preferredFamily = n.names.fontFamily), B.preferredSubfamily || (B.preferredSubfamily = n.names.fontSubfamily);
		var H = [],
			z = rb.make(B, H),
			X = H.length > 0 ? Jx.make(H) : void 0,
			K = sb.make(),
			G = jx.make(n.glyphs, { version: n.getEnglishName("version"), fullName: N, familyName: S, weightName: L, postScriptName: k, unitsPerEm: n.unitsPerEm, fontBBox: [0, b.yMin, b.ascender, b.advanceWidthMax] }),
			ue = n.metas && Object.keys(n.metas).length > 0 ? ob.make(n.metas) : void 0,
			ae = [T, P, A, M, z, y, K, G, w];
		X && ae.push(X), n.tables.gsub && ae.push(ab.make(n.tables.gsub)), n.tables.cpal && ae.push(cb.make(n.tables.cpal)), n.tables.colr && ae.push(lb.make(n.tables.colr)), ue && ae.push(ue);
		for (var Ue = ub(ae), Z = Ue.encode(), ie = um(Z), ge = Ue.fields, V = !1, j = 0; j < ge.length; j += 1)
			if (ge[j].name === "head table") {
				(ge[j].value.checkSumAdjustment = 2981146554 - ie), (V = !0);
				break;
			}
		if (!V) throw new Error("Could not find head table with checkSum to adjust.");
		return Ue;
	}
	var gN = { make: ub, fontToTable: mN, computeCheckSum: um };
	function Jd(n, e) {
		for (var t = 0, i = n.length - 1; t <= i; ) {
			var r = (t + i) >>> 1,
				s = n[r].tag;
			if (s === e) return r;
			s < e ? (t = r + 1) : (i = r - 1);
		}
		return -t - 1;
	}
	function i_(n, e) {
		for (var t = 0, i = n.length - 1; t <= i; ) {
			var r = (t + i) >>> 1,
				s = n[r];
			if (s === e) return r;
			s < e ? (t = r + 1) : (i = r - 1);
		}
		return -t - 1;
	}
	function r_(n, e) {
		for (var t, i = 0, r = n.length - 1; i <= r; ) {
			var s = (i + r) >>> 1;
			t = n[s];
			var a = t.start;
			if (a === e) return t;
			a < e ? (i = s + 1) : (r = s - 1);
		}
		if (i > 0) return (t = n[i - 1]), e > t.end ? 0 : t;
	}
	function tc(n, e) {
		(this.font = n), (this.tableName = e);
	}
	tc.prototype = {
		searchTag: Jd,
		binSearch: i_,
		getTable: function (n) {
			var e = this.font.tables[this.tableName];
			return !e && n && (e = this.font.tables[this.tableName] = this.createDefaultTable()), e;
		},
		getScriptNames: function () {
			var n = this.getTable();
			return n
				? n.scripts.map(function (e) {
						return e.tag;
				  })
				: [];
		},
		getDefaultScriptName: function () {
			var n = this.getTable();
			if (n) {
				for (var e = !1, t = 0; t < n.scripts.length; t++) {
					var i = n.scripts[t].tag;
					if (i === "DFLT") return i;
					i === "latn" && (e = !0);
				}
				if (e) return "latn";
			}
		},
		getScriptTable: function (n, e) {
			var t = this.getTable(e);
			if (t) {
				n = n || "DFLT";
				var i = t.scripts,
					r = Jd(t.scripts, n);
				if (r >= 0) return i[r].script;
				if (e) {
					var s = { tag: n, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } };
					return i.splice(-1 - r, 0, s), s.script;
				}
			}
		},
		getLangSysTable: function (n, e, t) {
			var i = this.getScriptTable(n, t);
			if (i) {
				if (!e || e === "dflt" || e === "DFLT") return i.defaultLangSys;
				var r = Jd(i.langSysRecords, e);
				if (r >= 0) return i.langSysRecords[r].langSys;
				if (t) {
					var s = { tag: e, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } };
					return i.langSysRecords.splice(-1 - r, 0, s), s.langSys;
				}
			}
		},
		getFeatureTable: function (n, e, t, i) {
			var r = this.getLangSysTable(n, e, i);
			if (r) {
				for (var s, a = r.featureIndexes, o = this.font.tables[this.tableName].features, l = 0; l < a.length; l++) if (((s = o[a[l]]), s.tag === t)) return s.feature;
				if (i) {
					var c = o.length;
					return tt.assert(c === 0 || t >= o[c - 1].tag, "Features must be added in alphabetical order."), (s = { tag: t, feature: { params: 0, lookupListIndexes: [] } }), o.push(s), a.push(c), s.feature;
				}
			}
		},
		getLookupTables: function (n, e, t, i, r) {
			var s = this.getFeatureTable(n, e, t, r),
				a = [];
			if (s) {
				for (var o, l = s.lookupListIndexes, c = this.font.tables[this.tableName].lookups, u = 0; u < l.length; u++) (o = c[l[u]]), o.lookupType === i && a.push(o);
				if (a.length === 0 && r) {
					o = { lookupType: i, lookupFlag: 0, subtables: [], markFilteringSet: void 0 };
					var h = c.length;
					return c.push(o), l.push(h), [o];
				}
			}
			return a;
		},
		getGlyphClass: function (n, e) {
			switch (n.format) {
				case 1:
					return n.startGlyph <= e && e < n.startGlyph + n.classes.length ? n.classes[e - n.startGlyph] : 0;
				case 2:
					var t = r_(n.ranges, e);
					return t ? t.classId : 0;
			}
		},
		getCoverageIndex: function (n, e) {
			switch (n.format) {
				case 1:
					var t = i_(n.glyphs, e);
					return t >= 0 ? t : -1;
				case 2:
					var i = r_(n.ranges, e);
					return i ? i.index + e - i.start : -1;
			}
		},
		expandCoverage: function (n) {
			if (n.format === 1) return n.glyphs;
			for (var e = [], t = n.ranges, i = 0; i < t.length; i++) for (var r = t[i], s = r.start, a = r.end, o = s; o <= a; o++) e.push(o);
			return e;
		}
	};
	function nc(n) {
		tc.call(this, n, "gpos");
	}
	nc.prototype = tc.prototype;
	nc.prototype.init = function () {
		var n = this.getDefaultScriptName();
		this.defaultKerningTables = this.getKerningTables(n);
	};
	nc.prototype.getKerningValue = function (n, e, t) {
		for (var i = 0; i < n.length; i++)
			for (var r = n[i].subtables, s = 0; s < r.length; s++) {
				var a = r[s],
					o = this.getCoverageIndex(a.coverage, e);
				if (!(o < 0))
					switch (a.posFormat) {
						case 1:
							for (var l = a.pairSets[o], c = 0; c < l.length; c++) {
								var u = l[c];
								if (u.secondGlyph === t) return (u.value1 && u.value1.xAdvance) || 0;
							}
							break;
						case 2:
							var h = this.getGlyphClass(a.classDef1, e),
								d = this.getGlyphClass(a.classDef2, t),
								f = a.classRecords[h][d];
							return (f.value1 && f.value1.xAdvance) || 0;
					}
			}
		return 0;
	};
	nc.prototype.getKerningTables = function (n, e) {
		if (this.font.tables.gpos) return this.getLookupTables(n, e, "kern", 2);
	};
	function _i(n) {
		tc.call(this, n, "gsub");
	}
	function vN(n, e) {
		var t = n.length;
		if (t !== e.length) return !1;
		for (var i = 0; i < t; i++) if (n[i] !== e[i]) return !1;
		return !0;
	}
	function hm(n, e, t) {
		for (var i = n.subtables, r = 0; r < i.length; r++) {
			var s = i[r];
			if (s.substFormat === e) return s;
		}
		if (t) return i.push(t), t;
	}
	_i.prototype = tc.prototype;
	_i.prototype.createDefaultTable = function () {
		return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
	};
	_i.prototype.getSingle = function (n, e, t) {
		for (var i = [], r = this.getLookupTables(e, t, n, 1), s = 0; s < r.length; s++)
			for (var a = r[s].subtables, o = 0; o < a.length; o++) {
				var l = a[o],
					c = this.expandCoverage(l.coverage),
					u = void 0;
				if (l.substFormat === 1) {
					var h = l.deltaGlyphId;
					for (u = 0; u < c.length; u++) {
						var d = c[u];
						i.push({ sub: d, by: d + h });
					}
				} else {
					var f = l.substitute;
					for (u = 0; u < c.length; u++) i.push({ sub: c[u], by: f[u] });
				}
			}
		return i;
	};
	_i.prototype.getMultiple = function (n, e, t) {
		for (var i = [], r = this.getLookupTables(e, t, n, 2), s = 0; s < r.length; s++)
			for (var a = r[s].subtables, o = 0; o < a.length; o++) {
				var l = a[o],
					c = this.expandCoverage(l.coverage),
					u = void 0;
				for (u = 0; u < c.length; u++) {
					var h = c[u],
						d = l.sequences[u];
					i.push({ sub: h, by: d });
				}
			}
		return i;
	};
	_i.prototype.getAlternates = function (n, e, t) {
		for (var i = [], r = this.getLookupTables(e, t, n, 3), s = 0; s < r.length; s++) for (var a = r[s].subtables, o = 0; o < a.length; o++) for (var l = a[o], c = this.expandCoverage(l.coverage), u = l.alternateSets, h = 0; h < c.length; h++) i.push({ sub: c[h], by: u[h] });
		return i;
	};
	_i.prototype.getLigatures = function (n, e, t) {
		for (var i = [], r = this.getLookupTables(e, t, n, 4), s = 0; s < r.length; s++)
			for (var a = r[s].subtables, o = 0; o < a.length; o++)
				for (var l = a[o], c = this.expandCoverage(l.coverage), u = l.ligatureSets, h = 0; h < c.length; h++)
					for (var d = c[h], f = u[h], v = 0; v < f.length; v++) {
						var _ = f[v];
						i.push({ sub: [d].concat(_.components), by: _.ligGlyph });
					}
		return i;
	};
	_i.prototype.addSingle = function (n, e, t, i) {
		var r = this.getLookupTables(t, i, n, 1, !0)[0],
			s = hm(r, 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] });
		tt.assert(s.coverage.format === 1, "Single: unable to modify coverage table format " + s.coverage.format);
		var a = e.sub,
			o = this.binSearch(s.coverage.glyphs, a);
		o < 0 && ((o = -1 - o), s.coverage.glyphs.splice(o, 0, a), s.substitute.splice(o, 0, 0)), (s.substitute[o] = e.by);
	};
	_i.prototype.addMultiple = function (n, e, t, i) {
		tt.assert(e.by instanceof Array && e.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
		var r = this.getLookupTables(t, i, n, 2, !0)[0],
			s = hm(r, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, sequences: [] });
		tt.assert(s.coverage.format === 1, "Multiple: unable to modify coverage table format " + s.coverage.format);
		var a = e.sub,
			o = this.binSearch(s.coverage.glyphs, a);
		o < 0 && ((o = -1 - o), s.coverage.glyphs.splice(o, 0, a), s.sequences.splice(o, 0, 0)), (s.sequences[o] = e.by);
	};
	_i.prototype.addAlternate = function (n, e, t, i) {
		var r = this.getLookupTables(t, i, n, 3, !0)[0],
			s = hm(r, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] });
		tt.assert(s.coverage.format === 1, "Alternate: unable to modify coverage table format " + s.coverage.format);
		var a = e.sub,
			o = this.binSearch(s.coverage.glyphs, a);
		o < 0 && ((o = -1 - o), s.coverage.glyphs.splice(o, 0, a), s.alternateSets.splice(o, 0, 0)), (s.alternateSets[o] = e.by);
	};
	_i.prototype.addLigature = function (n, e, t, i) {
		var r = this.getLookupTables(t, i, n, 4, !0)[0],
			s = r.subtables[0];
		s || ((s = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }), (r.subtables[0] = s)), tt.assert(s.coverage.format === 1, "Ligature: unable to modify coverage table format " + s.coverage.format);
		var a = e.sub[0],
			o = e.sub.slice(1),
			l = { ligGlyph: e.by, components: o },
			c = this.binSearch(s.coverage.glyphs, a);
		if (c >= 0) {
			for (var u = s.ligatureSets[c], h = 0; h < u.length; h++) if (vN(u[h].components, o)) return;
			u.push(l);
		} else (c = -1 - c), s.coverage.glyphs.splice(c, 0, a), s.ligatureSets.splice(c, 0, [l]);
	};
	_i.prototype.getFeature = function (n, e, t) {
		if (/ss\d\d/.test(n)) return this.getSingle(n, e, t);
		switch (n) {
			case "aalt":
			case "salt":
				return this.getSingle(n, e, t).concat(this.getAlternates(n, e, t));
			case "dlig":
			case "liga":
			case "rlig":
				return this.getLigatures(n, e, t);
			case "ccmp":
				return this.getMultiple(n, e, t).concat(this.getLigatures(n, e, t));
			case "stch":
				return this.getMultiple(n, e, t);
		}
	};
	_i.prototype.add = function (n, e, t, i) {
		if (/ss\d\d/.test(n)) return this.addSingle(n, e, t, i);
		switch (n) {
			case "aalt":
			case "salt":
				return typeof e.by == "number" ? this.addSingle(n, e, t, i) : this.addAlternate(n, e, t, i);
			case "dlig":
			case "liga":
			case "rlig":
				return this.addLigature(n, e, t, i);
			case "ccmp":
				return e.by instanceof Array ? this.addMultiple(n, e, t, i) : this.addLigature(n, e, t, i);
		}
	};
	function vl(n, e) {
		if (!n) throw e;
	}
	function s_(n, e, t, i, r) {
		var s;
		return (e & i) > 0 ? ((s = n.parseByte()), e & r || (s = -s), (s = t + s)) : (e & r) > 0 ? (s = t) : (s = t + n.parseShort()), s;
	}
	function hb(n, e, t) {
		var i = new Ze.Parser(e, t);
		(n.numberOfContours = i.parseShort()), (n._xMin = i.parseShort()), (n._yMin = i.parseShort()), (n._xMax = i.parseShort()), (n._yMax = i.parseShort());
		var r, s;
		if (n.numberOfContours > 0) {
			for (var a = (n.endPointIndices = []), o = 0; o < n.numberOfContours; o += 1) a.push(i.parseUShort());
			(n.instructionLength = i.parseUShort()), (n.instructions = []);
			for (var l = 0; l < n.instructionLength; l += 1) n.instructions.push(i.parseByte());
			var c = a[a.length - 1] + 1;
			r = [];
			for (var u = 0; u < c; u += 1) if (((s = i.parseByte()), r.push(s), (s & 8) > 0)) for (var h = i.parseByte(), d = 0; d < h; d += 1) r.push(s), (u += 1);
			if ((tt.argument(r.length === c, "Bad flags."), a.length > 0)) {
				var f = [],
					v;
				if (c > 0) {
					for (var _ = 0; _ < c; _ += 1) (s = r[_]), (v = {}), (v.onCurve = !!(s & 1)), (v.lastPointOfContour = a.indexOf(_) >= 0), f.push(v);
					for (var p = 0, g = 0; g < c; g += 1) (s = r[g]), (v = f[g]), (v.x = s_(i, s, p, 2, 16)), (p = v.x);
					for (var x = 0, b = 0; b < c; b += 1) (s = r[b]), (v = f[b]), (v.y = s_(i, s, x, 4, 32)), (x = v.y);
				}
				n.points = f;
			} else n.points = [];
		} else if (n.numberOfContours === 0) n.points = [];
		else {
			(n.isComposite = !0), (n.points = []), (n.components = []);
			for (var T = !0; T; ) {
				r = i.parseUShort();
				var P = { glyphIndex: i.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
				(r & 1) > 0 ? ((r & 2) > 0 ? ((P.dx = i.parseShort()), (P.dy = i.parseShort())) : (P.matchedPoints = [i.parseUShort(), i.parseUShort()])) : (r & 2) > 0 ? ((P.dx = i.parseChar()), (P.dy = i.parseChar())) : (P.matchedPoints = [i.parseByte(), i.parseByte()]),
					(r & 8) > 0 ? (P.xScale = P.yScale = i.parseF2Dot14()) : (r & 64) > 0 ? ((P.xScale = i.parseF2Dot14()), (P.yScale = i.parseF2Dot14())) : (r & 128) > 0 && ((P.xScale = i.parseF2Dot14()), (P.scale01 = i.parseF2Dot14()), (P.scale10 = i.parseF2Dot14()), (P.yScale = i.parseF2Dot14())),
					n.components.push(P),
					(T = !!(r & 32));
			}
			if (r & 256) {
				(n.instructionLength = i.parseUShort()), (n.instructions = []);
				for (var A = 0; A < n.instructionLength; A += 1) n.instructions.push(i.parseByte());
			}
		}
	}
	function Qd(n, e) {
		for (var t = [], i = 0; i < n.length; i += 1) {
			var r = n[i],
				s = { x: e.xScale * r.x + e.scale01 * r.y + e.dx, y: e.scale10 * r.x + e.yScale * r.y + e.dy, onCurve: r.onCurve, lastPointOfContour: r.lastPointOfContour };
			t.push(s);
		}
		return t;
	}
	function _N(n) {
		for (var e = [], t = [], i = 0; i < n.length; i += 1) {
			var r = n[i];
			t.push(r), r.lastPointOfContour && (e.push(t), (t = []));
		}
		return tt.argument(t.length === 0, "There are still points left in the current contour."), e;
	}
	function db(n) {
		var e = new Tn();
		if (!n) return e;
		for (var t = _N(n), i = 0; i < t.length; ++i) {
			var r = t[i],
				s = null,
				a = r[r.length - 1],
				o = r[0];
			if (a.onCurve) e.moveTo(a.x, a.y);
			else if (o.onCurve) e.moveTo(o.x, o.y);
			else {
				var l = { x: (a.x + o.x) * 0.5, y: (a.y + o.y) * 0.5 };
				e.moveTo(l.x, l.y);
			}
			for (var c = 0; c < r.length; ++c)
				if (((s = a), (a = o), (o = r[(c + 1) % r.length]), a.onCurve)) e.lineTo(a.x, a.y);
				else {
					var u = o;
					s.onCurve || ((a.x + s.x) * 0.5, (a.y + s.y) * 0.5), o.onCurve || (u = { x: (a.x + o.x) * 0.5, y: (a.y + o.y) * 0.5 }), e.quadraticCurveTo(a.x, a.y, u.x, u.y);
				}
			e.closePath();
		}
		return e;
	}
	function fb(n, e) {
		if (e.isComposite)
			for (var t = 0; t < e.components.length; t += 1) {
				var i = e.components[t],
					r = n.get(i.glyphIndex);
				if ((r.getPath(), r.points)) {
					var s = void 0;
					if (i.matchedPoints === void 0) s = Qd(r.points, i);
					else {
						if (i.matchedPoints[0] > e.points.length - 1 || i.matchedPoints[1] > r.points.length - 1) throw Error("Matched points out of range in " + e.name);
						var a = e.points[i.matchedPoints[0]],
							o = r.points[i.matchedPoints[1]],
							l = { xScale: i.xScale, scale01: i.scale01, scale10: i.scale10, yScale: i.yScale, dx: 0, dy: 0 };
						(o = Qd([o], l)[0]), (l.dx = a.x - o.x), (l.dy = a.y - o.y), (s = Qd(r.points, l));
					}
					e.points = e.points.concat(s);
				}
			}
		return db(e.points);
	}
	function yN(n, e, t, i) {
		for (var r = new xr.GlyphSet(i), s = 0; s < t.length - 1; s += 1) {
			var a = t[s],
				o = t[s + 1];
			a !== o ? r.push(s, xr.ttfGlyphLoader(i, s, hb, n, e + a, fb)) : r.push(s, xr.glyphLoader(i, s));
		}
		return r;
	}
	function xN(n, e, t, i) {
		var r = new xr.GlyphSet(i);
		return (
			(i._push = function (s) {
				var a = t[s],
					o = t[s + 1];
				a !== o ? r.push(s, xr.ttfGlyphLoader(i, s, hb, n, e + a, fb)) : r.push(s, xr.glyphLoader(i, s));
			}),
			r
		);
	}
	function bN(n, e, t, i, r) {
		return r.lowMemory ? xN(n, e, t, i) : yN(n, e, t, i);
	}
	var pb = { getPath: db, parse: bN },
		mb,
		Sa,
		gb,
		pp;
	function vb(n) {
		(this.font = n),
			(this.getCommands = function (e) {
				return pb.getPath(e).commands;
			}),
			(this._fpgmState = this._prepState = void 0),
			(this._errorState = 0);
	}
	function SN(n) {
		return n;
	}
	function _b(n) {
		return Math.sign(n) * Math.round(Math.abs(n));
	}
	function EN(n) {
		return (Math.sign(n) * Math.round(Math.abs(n * 2))) / 2;
	}
	function wN(n) {
		return Math.sign(n) * (Math.round(Math.abs(n) + 0.5) - 0.5);
	}
	function TN(n) {
		return Math.sign(n) * Math.ceil(Math.abs(n));
	}
	function MN(n) {
		return Math.sign(n) * Math.floor(Math.abs(n));
	}
	var yb = function (n) {
			var e = this.srPeriod,
				t = this.srPhase,
				i = this.srThreshold,
				r = 1;
			return n < 0 && ((n = -n), (r = -1)), (n += i - t), (n = Math.trunc(n / e) * e), (n += t), n < 0 ? t * r : n * r;
		},
		vr = {
			x: 1,
			y: 0,
			axis: "x",
			distance: function (n, e, t, i) {
				return (t ? n.xo : n.x) - (i ? e.xo : e.x);
			},
			interpolate: function (n, e, t, i) {
				var r, s, a, o, l, c, u;
				if (!i || i === this) {
					if (((r = n.xo - e.xo), (s = n.xo - t.xo), (l = e.x - e.xo), (c = t.x - t.xo), (a = Math.abs(r)), (o = Math.abs(s)), (u = a + o), u === 0)) {
						n.x = n.xo + (l + c) / 2;
						return;
					}
					n.x = n.xo + (l * o + c * a) / u;
					return;
				}
				if (((r = i.distance(n, e, !0, !0)), (s = i.distance(n, t, !0, !0)), (l = i.distance(e, e, !1, !0)), (c = i.distance(t, t, !1, !0)), (a = Math.abs(r)), (o = Math.abs(s)), (u = a + o), u === 0)) {
					vr.setRelative(n, n, (l + c) / 2, i, !0);
					return;
				}
				vr.setRelative(n, n, (l * o + c * a) / u, i, !0);
			},
			normalSlope: Number.NEGATIVE_INFINITY,
			setRelative: function (n, e, t, i, r) {
				if (!i || i === this) {
					n.x = (r ? e.xo : e.x) + t;
					return;
				}
				var s = r ? e.xo : e.x,
					a = r ? e.yo : e.y,
					o = s + t * i.x,
					l = a + t * i.y;
				n.x = o + (n.y - l) / i.normalSlope;
			},
			slope: 0,
			touch: function (n) {
				n.xTouched = !0;
			},
			touched: function (n) {
				return n.xTouched;
			},
			untouch: function (n) {
				n.xTouched = !1;
			}
		},
		Vr = {
			x: 0,
			y: 1,
			axis: "y",
			distance: function (n, e, t, i) {
				return (t ? n.yo : n.y) - (i ? e.yo : e.y);
			},
			interpolate: function (n, e, t, i) {
				var r, s, a, o, l, c, u;
				if (!i || i === this) {
					if (((r = n.yo - e.yo), (s = n.yo - t.yo), (l = e.y - e.yo), (c = t.y - t.yo), (a = Math.abs(r)), (o = Math.abs(s)), (u = a + o), u === 0)) {
						n.y = n.yo + (l + c) / 2;
						return;
					}
					n.y = n.yo + (l * o + c * a) / u;
					return;
				}
				if (((r = i.distance(n, e, !0, !0)), (s = i.distance(n, t, !0, !0)), (l = i.distance(e, e, !1, !0)), (c = i.distance(t, t, !1, !0)), (a = Math.abs(r)), (o = Math.abs(s)), (u = a + o), u === 0)) {
					Vr.setRelative(n, n, (l + c) / 2, i, !0);
					return;
				}
				Vr.setRelative(n, n, (l * o + c * a) / u, i, !0);
			},
			normalSlope: 0,
			setRelative: function (n, e, t, i, r) {
				if (!i || i === this) {
					n.y = (r ? e.yo : e.y) + t;
					return;
				}
				var s = r ? e.xo : e.x,
					a = r ? e.yo : e.y,
					o = s + t * i.x,
					l = a + t * i.y;
				n.y = l + i.normalSlope * (n.x - o);
			},
			slope: Number.POSITIVE_INFINITY,
			touch: function (n) {
				n.yTouched = !0;
			},
			touched: function (n) {
				return n.yTouched;
			},
			untouch: function (n) {
				n.yTouched = !1;
			}
		};
	Object.freeze(vr);
	Object.freeze(Vr);
	function ic(n, e) {
		(this.x = n), (this.y = e), (this.axis = void 0), (this.slope = e / n), (this.normalSlope = -n / e), Object.freeze(this);
	}
	ic.prototype.distance = function (n, e, t, i) {
		return this.x * vr.distance(n, e, t, i) + this.y * Vr.distance(n, e, t, i);
	};
	ic.prototype.interpolate = function (n, e, t, i) {
		var r, s, a, o, l, c, u;
		if (((a = i.distance(n, e, !0, !0)), (o = i.distance(n, t, !0, !0)), (r = i.distance(e, e, !1, !0)), (s = i.distance(t, t, !1, !0)), (l = Math.abs(a)), (c = Math.abs(o)), (u = l + c), u === 0)) {
			this.setRelative(n, n, (r + s) / 2, i, !0);
			return;
		}
		this.setRelative(n, n, (r * c + s * l) / u, i, !0);
	};
	ic.prototype.setRelative = function (n, e, t, i, r) {
		i = i || this;
		var s = r ? e.xo : e.x,
			a = r ? e.yo : e.y,
			o = s + t * i.x,
			l = a + t * i.y,
			c = i.normalSlope,
			u = this.slope,
			h = n.x,
			d = n.y;
		(n.x = (u * h - c * o + l - d) / (u - c)), (n.y = u * (n.x - h) + d);
	};
	ic.prototype.touch = function (n) {
		(n.xTouched = !0), (n.yTouched = !0);
	};
	function rc(n, e) {
		var t = Math.sqrt(n * n + e * e);
		return (n /= t), (e /= t), n === 1 && e === 0 ? vr : n === 0 && e === 1 ? Vr : new ic(n, e);
	}
	function $r(n, e, t, i) {
		(this.x = this.xo = Math.round(n * 64) / 64), (this.y = this.yo = Math.round(e * 64) / 64), (this.lastPointOfContour = t), (this.onCurve = i), (this.prevPointOnContour = void 0), (this.nextPointOnContour = void 0), (this.xTouched = !1), (this.yTouched = !1), Object.preventExtensions(this);
	}
	$r.prototype.nextTouched = function (n) {
		for (var e = this.nextPointOnContour; !n.touched(e) && e !== this; ) e = e.nextPointOnContour;
		return e;
	};
	$r.prototype.prevTouched = function (n) {
		for (var e = this.prevPointOnContour; !n.touched(e) && e !== this; ) e = e.prevPointOnContour;
		return e;
	};
	var Gl = Object.freeze(new $r(0, 0)),
		AN = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: !0 };
	function Ss(n, e) {
		switch (((this.env = n), (this.stack = []), (this.prog = e), n)) {
			case "glyf":
				(this.zp0 = this.zp1 = this.zp2 = 1), (this.rp0 = this.rp1 = this.rp2 = 0);
			case "prep":
				(this.fv = this.pv = this.dpv = vr), (this.round = _b);
		}
	}
	vb.prototype.exec = function (n, e) {
		if (typeof e != "number") throw new Error("Point size is not a number!");
		if (!(this._errorState > 2)) {
			var t = this.font,
				i = this._prepState;
			if (!i || i.ppem !== e) {
				var r = this._fpgmState;
				if (!r) {
					(Ss.prototype = AN), (r = this._fpgmState = new Ss("fpgm", t.tables.fpgm)), (r.funcs = []), (r.font = t), _e.DEBUG && (console.log("---EXEC FPGM---"), (r.step = -1));
					try {
						Sa(r);
					} catch (c) {
						console.log("Hinting error in FPGM:" + c), (this._errorState = 3);
						return;
					}
				}
				(Ss.prototype = r), (i = this._prepState = new Ss("prep", t.tables.prep)), (i.ppem = e);
				var s = t.tables.cvt;
				if (s) for (var a = (i.cvt = new Array(s.length)), o = e / t.unitsPerEm, l = 0; l < s.length; l++) a[l] = s[l] * o;
				else i.cvt = [];
				_e.DEBUG && (console.log("---EXEC PREP---"), (i.step = -1));
				try {
					Sa(i);
				} catch (c) {
					this._errorState < 2 && console.log("Hinting error in PREP:" + c), (this._errorState = 2);
				}
			}
			if (!(this._errorState > 1))
				try {
					return gb(n, i);
				} catch (c) {
					this._errorState < 1 && (console.log("Hinting error:" + c), console.log("Note: further hinting errors are silenced")), (this._errorState = 1);
					return;
				}
		}
	};
	gb = function (n, e) {
		var t = e.ppem / e.font.unitsPerEm,
			i = t,
			r = n.components,
			s,
			a,
			o;
		if (((Ss.prototype = e), !r)) (o = new Ss("glyf", n.instructions)), _e.DEBUG && (console.log("---EXEC GLYPH---"), (o.step = -1)), pp(n, o, t, i), (a = o.gZone);
		else {
			var l = e.font;
			(a = []), (s = []);
			for (var c = 0; c < r.length; c++) {
				var u = r[c],
					h = l.glyphs.get(u.glyphIndex);
				(o = new Ss("glyf", h.instructions)), _e.DEBUG && (console.log("---EXEC COMP " + c + "---"), (o.step = -1)), pp(h, o, t, i);
				for (var d = Math.round(u.dx * t), f = Math.round(u.dy * i), v = o.gZone, _ = o.contours, p = 0; p < v.length; p++) {
					var g = v[p];
					(g.xTouched = g.yTouched = !1), (g.xo = g.x = g.x + d), (g.yo = g.y = g.y + f);
				}
				var x = a.length;
				a.push.apply(a, v);
				for (var b = 0; b < _.length; b++) s.push(_[b] + x);
			}
			n.instructions && !o.inhibitGridFit && ((o = new Ss("glyf", n.instructions)), (o.gZone = o.z0 = o.z1 = o.z2 = a), (o.contours = s), a.push(new $r(0, 0), new $r(Math.round(n.advanceWidth * t), 0)), _e.DEBUG && (console.log("---EXEC COMPOSITE---"), (o.step = -1)), Sa(o), (a.length -= 2));
		}
		return a;
	};
	pp = function (n, e, t, i) {
		for (var r = n.points || [], s = r.length, a = (e.gZone = e.z0 = e.z1 = e.z2 = []), o = (e.contours = []), l, c = 0; c < s; c++) (l = r[c]), (a[c] = new $r(l.x * t, l.y * i, l.lastPointOfContour, l.onCurve));
		for (var u, h, d = 0; d < s; d++) (l = a[d]), u || ((u = l), o.push(d)), l.lastPointOfContour ? ((l.nextPointOnContour = u), (u.prevPointOnContour = l), (u = void 0)) : ((h = a[d + 1]), (l.nextPointOnContour = h), (h.prevPointOnContour = l));
		if (!e.inhibitGridFit) {
			if (_e.DEBUG) {
				console.log("PROCESSING GLYPH", e.stack);
				for (var f = 0; f < s; f++) console.log(f, a[f].x, a[f].y);
			}
			if ((a.push(new $r(0, 0), new $r(Math.round(n.advanceWidth * t), 0)), Sa(e), (a.length -= 2), _e.DEBUG)) {
				console.log("FINISHED GLYPH", e.stack);
				for (var v = 0; v < s; v++) console.log(v, a[v].x, a[v].y);
			}
		}
	};
	Sa = function (n) {
		var e = n.prog;
		if (e) {
			var t = e.length,
				i;
			for (n.ip = 0; n.ip < t; n.ip++) {
				if ((_e.DEBUG && n.step++, (i = mb[e[n.ip]]), !i)) throw new Error("unknown instruction: 0x" + Number(e[n.ip]).toString(16));
				i(n);
			}
		}
	};
	function bh(n) {
		for (var e = (n.tZone = new Array(n.gZone.length)), t = 0; t < e.length; t++) e[t] = new $r(0, 0);
	}
	function xb(n, e) {
		var t = n.prog,
			i = n.ip,
			r = 1,
			s;
		do
			if (((s = t[++i]), s === 88)) r++;
			else if (s === 89) r--;
			else if (s === 64) i += t[i + 1] + 1;
			else if (s === 65) i += 2 * t[i + 1] + 1;
			else if (s >= 176 && s <= 183) i += s - 176 + 1;
			else if (s >= 184 && s <= 191) i += (s - 184 + 1) * 2;
			else if (e && r === 1 && s === 27) break;
		while (r > 0);
		n.ip = i;
	}
	function a_(n, e) {
		_e.DEBUG && console.log(e.step, "SVTCA[" + n.axis + "]"), (e.fv = e.pv = e.dpv = n);
	}
	function o_(n, e) {
		_e.DEBUG && console.log(e.step, "SPVTCA[" + n.axis + "]"), (e.pv = e.dpv = n);
	}
	function l_(n, e) {
		_e.DEBUG && console.log(e.step, "SFVTCA[" + n.axis + "]"), (e.fv = n);
	}
	function c_(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = t.pop(),
			s = e.z2[i],
			a = e.z1[r];
		_e.DEBUG && console.log("SPVTL[" + n + "]", i, r);
		var o, l;
		n ? ((o = s.y - a.y), (l = a.x - s.x)) : ((o = a.x - s.x), (l = a.y - s.y)), (e.pv = e.dpv = rc(o, l));
	}
	function u_(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = t.pop(),
			s = e.z2[i],
			a = e.z1[r];
		_e.DEBUG && console.log("SFVTL[" + n + "]", i, r);
		var o, l;
		n ? ((o = s.y - a.y), (l = a.x - s.x)) : ((o = a.x - s.x), (l = a.y - s.y)), (e.fv = rc(o, l));
	}
	function CN(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "SPVFS[]", t, i), (n.pv = n.dpv = rc(i, t));
	}
	function LN(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "SPVFS[]", t, i), (n.fv = rc(i, t));
	}
	function RN(n) {
		var e = n.stack,
			t = n.pv;
		_e.DEBUG && console.log(n.step, "GPV[]"), e.push(t.x * 16384), e.push(t.y * 16384);
	}
	function PN(n) {
		var e = n.stack,
			t = n.fv;
		_e.DEBUG && console.log(n.step, "GFV[]"), e.push(t.x * 16384), e.push(t.y * 16384);
	}
	function DN(n) {
		(n.fv = n.pv), _e.DEBUG && console.log(n.step, "SFVTPV[]");
	}
	function ON(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop(),
			r = e.pop(),
			s = e.pop(),
			a = e.pop(),
			o = n.z0,
			l = n.z1,
			c = o[t],
			u = o[i],
			h = l[r],
			d = l[s],
			f = n.z2[a];
		_e.DEBUG && console.log("ISECT[], ", t, i, r, s, a);
		var v = c.x,
			_ = c.y,
			p = u.x,
			g = u.y,
			x = h.x,
			b = h.y,
			T = d.x,
			P = d.y,
			A = (v - p) * (b - P) - (_ - g) * (x - T),
			M = v * g - _ * p,
			w = x * P - b * T;
		(f.x = (M * (x - T) - w * (v - p)) / A), (f.y = (M * (b - P) - w * (_ - g)) / A);
	}
	function IN(n) {
		(n.rp0 = n.stack.pop()), _e.DEBUG && console.log(n.step, "SRP0[]", n.rp0);
	}
	function FN(n) {
		(n.rp1 = n.stack.pop()), _e.DEBUG && console.log(n.step, "SRP1[]", n.rp1);
	}
	function NN(n) {
		(n.rp2 = n.stack.pop()), _e.DEBUG && console.log(n.step, "SRP2[]", n.rp2);
	}
	function UN(n) {
		var e = n.stack.pop();
		switch ((_e.DEBUG && console.log(n.step, "SZP0[]", e), (n.zp0 = e), e)) {
			case 0:
				n.tZone || bh(n), (n.z0 = n.tZone);
				break;
			case 1:
				n.z0 = n.gZone;
				break;
			default:
				throw new Error("Invalid zone pointer");
		}
	}
	function kN(n) {
		var e = n.stack.pop();
		switch ((_e.DEBUG && console.log(n.step, "SZP1[]", e), (n.zp1 = e), e)) {
			case 0:
				n.tZone || bh(n), (n.z1 = n.tZone);
				break;
			case 1:
				n.z1 = n.gZone;
				break;
			default:
				throw new Error("Invalid zone pointer");
		}
	}
	function BN(n) {
		var e = n.stack.pop();
		switch ((_e.DEBUG && console.log(n.step, "SZP2[]", e), (n.zp2 = e), e)) {
			case 0:
				n.tZone || bh(n), (n.z2 = n.tZone);
				break;
			case 1:
				n.z2 = n.gZone;
				break;
			default:
				throw new Error("Invalid zone pointer");
		}
	}
	function zN(n) {
		var e = n.stack.pop();
		switch ((_e.DEBUG && console.log(n.step, "SZPS[]", e), (n.zp0 = n.zp1 = n.zp2 = e), e)) {
			case 0:
				n.tZone || bh(n), (n.z0 = n.z1 = n.z2 = n.tZone);
				break;
			case 1:
				n.z0 = n.z1 = n.z2 = n.gZone;
				break;
			default:
				throw new Error("Invalid zone pointer");
		}
	}
	function HN(n) {
		(n.loop = n.stack.pop()), _e.DEBUG && console.log(n.step, "SLOOP[]", n.loop);
	}
	function GN(n) {
		_e.DEBUG && console.log(n.step, "RTG[]"), (n.round = _b);
	}
	function VN(n) {
		_e.DEBUG && console.log(n.step, "RTHG[]"), (n.round = wN);
	}
	function WN(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "SMD[]", e), (n.minDis = e / 64);
	}
	function XN(n) {
		_e.DEBUG && console.log(n.step, "ELSE[]"), xb(n, !1);
	}
	function $N(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "JMPR[]", e), (n.ip += e - 1);
	}
	function qN(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "SCVTCI[]", e), (n.cvCutIn = e / 64);
	}
	function jN(n) {
		var e = n.stack;
		_e.DEBUG && console.log(n.step, "DUP[]"), e.push(e[e.length - 1]);
	}
	function ef(n) {
		_e.DEBUG && console.log(n.step, "POP[]"), n.stack.pop();
	}
	function YN(n) {
		_e.DEBUG && console.log(n.step, "CLEAR[]"), (n.stack.length = 0);
	}
	function KN(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "SWAP[]"), e.push(t), e.push(i);
	}
	function ZN(n) {
		var e = n.stack;
		_e.DEBUG && console.log(n.step, "DEPTH[]"), e.push(e.length);
	}
	function JN(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "LOOPCALL[]", t, i);
		var r = n.ip,
			s = n.prog;
		n.prog = n.funcs[t];
		for (var a = 0; a < i; a++) Sa(n), _e.DEBUG && console.log(++n.step, a + 1 < i ? "next loopcall" : "done loopcall", a);
		(n.ip = r), (n.prog = s);
	}
	function QN(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "CALL[]", e);
		var t = n.ip,
			i = n.prog;
		(n.prog = n.funcs[e]), Sa(n), (n.ip = t), (n.prog = i), _e.DEBUG && console.log(++n.step, "returning from", e);
	}
	function eU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "CINDEX[]", t), e.push(e[e.length - t]);
	}
	function tU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "MINDEX[]", t), e.push(e.splice(e.length - t, 1)[0]);
	}
	function nU(n) {
		if (n.env !== "fpgm") throw new Error("FDEF not allowed here");
		var e = n.stack,
			t = n.prog,
			i = n.ip,
			r = e.pop(),
			s = i;
		for (_e.DEBUG && console.log(n.step, "FDEF[]", r); t[++i] !== 45; );
		(n.ip = i), (n.funcs[r] = t.slice(s + 1, i));
	}
	function h_(n, e) {
		var t = e.stack.pop(),
			i = e.z0[t],
			r = e.fv,
			s = e.pv;
		_e.DEBUG && console.log(e.step, "MDAP[" + n + "]", t);
		var a = s.distance(i, Gl);
		n && (a = e.round(a)), r.setRelative(i, Gl, a, s), r.touch(i), (e.rp0 = e.rp1 = t);
	}
	function d_(n, e) {
		var t = e.z2,
			i = t.length - 2,
			r,
			s,
			a;
		_e.DEBUG && console.log(e.step, "IUP[" + n.axis + "]");
		for (var o = 0; o < i; o++) (r = t[o]), !n.touched(r) && ((s = r.prevTouched(n)), s !== r && ((a = r.nextTouched(n)), s === a && n.setRelative(r, r, n.distance(s, s, !1, !0), n, !0), n.interpolate(r, s, a, n)));
	}
	function f_(n, e) {
		for (var t = e.stack, i = n ? e.rp1 : e.rp2, r = (n ? e.z0 : e.z1)[i], s = e.fv, a = e.pv, o = e.loop, l = e.z2; o--; ) {
			var c = t.pop(),
				u = l[c],
				h = a.distance(r, r, !1, !0);
			s.setRelative(u, u, h, a), s.touch(u), _e.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - o) + ": " : "") + "SHP[" + (n ? "rp1" : "rp2") + "]", c);
		}
		e.loop = 1;
	}
	function p_(n, e) {
		var t = e.stack,
			i = n ? e.rp1 : e.rp2,
			r = (n ? e.z0 : e.z1)[i],
			s = e.fv,
			a = e.pv,
			o = t.pop(),
			l = e.z2[e.contours[o]],
			c = l;
		_e.DEBUG && console.log(e.step, "SHC[" + n + "]", o);
		var u = a.distance(r, r, !1, !0);
		do c !== r && s.setRelative(c, c, u, a), (c = c.nextPointOnContour);
		while (c !== l);
	}
	function m_(n, e) {
		var t = e.stack,
			i = n ? e.rp1 : e.rp2,
			r = (n ? e.z0 : e.z1)[i],
			s = e.fv,
			a = e.pv,
			o = t.pop();
		_e.DEBUG && console.log(e.step, "SHZ[" + n + "]", o);
		var l;
		switch (o) {
			case 0:
				l = e.tZone;
				break;
			case 1:
				l = e.gZone;
				break;
			default:
				throw new Error("Invalid zone");
		}
		for (var c, u = a.distance(r, r, !1, !0), h = l.length - 2, d = 0; d < h; d++) (c = l[d]), s.setRelative(c, c, u, a);
	}
	function iU(n) {
		for (var e = n.stack, t = n.loop, i = n.fv, r = e.pop() / 64, s = n.z2; t--; ) {
			var a = e.pop(),
				o = s[a];
			_e.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - t) + ": " : "") + "SHPIX[]", a, r), i.setRelative(o, o, r), i.touch(o);
		}
		n.loop = 1;
	}
	function rU(n) {
		for (var e = n.stack, t = n.rp1, i = n.rp2, r = n.loop, s = n.z0[t], a = n.z1[i], o = n.fv, l = n.dpv, c = n.z2; r--; ) {
			var u = e.pop(),
				h = c[u];
			_e.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - r) + ": " : "") + "IP[]", u, t, "<->", i), o.interpolate(h, s, a, l), o.touch(h);
		}
		n.loop = 1;
	}
	function g_(n, e) {
		var t = e.stack,
			i = t.pop() / 64,
			r = t.pop(),
			s = e.z1[r],
			a = e.z0[e.rp0],
			o = e.fv,
			l = e.pv;
		o.setRelative(s, a, i, l), o.touch(s), _e.DEBUG && console.log(e.step, "MSIRP[" + n + "]", i, r), (e.rp1 = e.rp0), (e.rp2 = r), n && (e.rp0 = r);
	}
	function sU(n) {
		for (var e = n.stack, t = n.rp0, i = n.z0[t], r = n.loop, s = n.fv, a = n.pv, o = n.z1; r--; ) {
			var l = e.pop(),
				c = o[l];
			_e.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - r) + ": " : "") + "ALIGNRP[]", l), s.setRelative(c, i, 0, a), s.touch(c);
		}
		n.loop = 1;
	}
	function aU(n) {
		_e.DEBUG && console.log(n.step, "RTDG[]"), (n.round = EN);
	}
	function v_(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = t.pop(),
			s = e.z0[r],
			a = e.fv,
			o = e.pv,
			l = e.cvt[i];
		_e.DEBUG && console.log(e.step, "MIAP[" + n + "]", i, "(", l, ")", r);
		var c = o.distance(s, Gl);
		n && (Math.abs(c - l) < e.cvCutIn && (c = l), (c = e.round(c))), a.setRelative(s, Gl, c, o), e.zp0 === 0 && ((s.xo = s.x), (s.yo = s.y)), a.touch(s), (e.rp0 = e.rp1 = r);
	}
	function oU(n) {
		var e = n.prog,
			t = n.ip,
			i = n.stack,
			r = e[++t];
		_e.DEBUG && console.log(n.step, "NPUSHB[]", r);
		for (var s = 0; s < r; s++) i.push(e[++t]);
		n.ip = t;
	}
	function lU(n) {
		var e = n.ip,
			t = n.prog,
			i = n.stack,
			r = t[++e];
		_e.DEBUG && console.log(n.step, "NPUSHW[]", r);
		for (var s = 0; s < r; s++) {
			var a = (t[++e] << 8) | t[++e];
			a & 32768 && (a = -((a ^ 65535) + 1)), i.push(a);
		}
		n.ip = e;
	}
	function cU(n) {
		var e = n.stack,
			t = n.store;
		t || (t = n.store = []);
		var i = e.pop(),
			r = e.pop();
		_e.DEBUG && console.log(n.step, "WS", i, r), (t[r] = i);
	}
	function uU(n) {
		var e = n.stack,
			t = n.store,
			i = e.pop();
		_e.DEBUG && console.log(n.step, "RS", i);
		var r = (t && t[i]) || 0;
		e.push(r);
	}
	function hU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "WCVTP", t, i), (n.cvt[i] = t / 64);
	}
	function dU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "RCVT", t), e.push(n.cvt[t] * 64);
	}
	function __(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = e.z2[i];
		_e.DEBUG && console.log(e.step, "GC[" + n + "]", i), t.push(e.dpv.distance(r, Gl, n, !1) * 64);
	}
	function y_(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = t.pop(),
			s = e.z1[i],
			a = e.z0[r],
			o = e.dpv.distance(a, s, n, n);
		_e.DEBUG && console.log(e.step, "MD[" + n + "]", i, r, "->", o), e.stack.push(Math.round(o * 64));
	}
	function fU(n) {
		_e.DEBUG && console.log(n.step, "MPPEM[]"), n.stack.push(n.ppem);
	}
	function pU(n) {
		_e.DEBUG && console.log(n.step, "FLIPON[]"), (n.autoFlip = !0);
	}
	function mU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "LT[]", t, i), e.push(i < t ? 1 : 0);
	}
	function gU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "LTEQ[]", t, i), e.push(i <= t ? 1 : 0);
	}
	function vU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "GT[]", t, i), e.push(i > t ? 1 : 0);
	}
	function _U(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "GTEQ[]", t, i), e.push(i >= t ? 1 : 0);
	}
	function yU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "EQ[]", t, i), e.push(t === i ? 1 : 0);
	}
	function xU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "NEQ[]", t, i), e.push(t !== i ? 1 : 0);
	}
	function bU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "ODD[]", t), e.push(Math.trunc(t) % 2 ? 1 : 0);
	}
	function SU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "EVEN[]", t), e.push(Math.trunc(t) % 2 ? 0 : 1);
	}
	function EU(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "IF[]", e), e || (xb(n, !0), _e.DEBUG && console.log(n.step, "EIF[]"));
	}
	function wU(n) {
		_e.DEBUG && console.log(n.step, "EIF[]");
	}
	function TU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "AND[]", t, i), e.push(t && i ? 1 : 0);
	}
	function MU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "OR[]", t, i), e.push(t || i ? 1 : 0);
	}
	function AU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "NOT[]", t), e.push(t ? 0 : 1);
	}
	function tf(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = e.fv,
			s = e.pv,
			a = e.ppem,
			o = e.deltaBase + (n - 1) * 16,
			l = e.deltaShift,
			c = e.z0;
		_e.DEBUG && console.log(e.step, "DELTAP[" + n + "]", i, t);
		for (var u = 0; u < i; u++) {
			var h = t.pop(),
				d = t.pop(),
				f = o + ((d & 240) >> 4);
			if (f === a) {
				var v = (d & 15) - 8;
				v >= 0 && v++, _e.DEBUG && console.log(e.step, "DELTAPFIX", h, "by", v * l);
				var _ = c[h];
				r.setRelative(_, _, v * l, s);
			}
		}
	}
	function CU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "SDB[]", t), (n.deltaBase = t);
	}
	function LU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "SDS[]", t), (n.deltaShift = Math.pow(0.5, t));
	}
	function RU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "ADD[]", t, i), e.push(i + t);
	}
	function PU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "SUB[]", t, i), e.push(i - t);
	}
	function DU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "DIV[]", t, i), e.push((i * 64) / t);
	}
	function OU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "MUL[]", t, i), e.push((i * t) / 64);
	}
	function IU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "ABS[]", t), e.push(Math.abs(t));
	}
	function FU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "NEG[]", t), e.push(-t);
	}
	function NU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "FLOOR[]", t), e.push(Math.floor(t / 64) * 64);
	}
	function UU(n) {
		var e = n.stack,
			t = e.pop();
		_e.DEBUG && console.log(n.step, "CEILING[]", t), e.push(Math.ceil(t / 64) * 64);
	}
	function yu(n, e) {
		var t = e.stack,
			i = t.pop();
		_e.DEBUG && console.log(e.step, "ROUND[]"), t.push(e.round(i / 64) * 64);
	}
	function kU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "WCVTF[]", t, i), (n.cvt[i] = (t * n.ppem) / n.font.unitsPerEm);
	}
	function nf(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = e.ppem,
			s = e.deltaBase + (n - 1) * 16,
			a = e.deltaShift;
		_e.DEBUG && console.log(e.step, "DELTAC[" + n + "]", i, t);
		for (var o = 0; o < i; o++) {
			var l = t.pop(),
				c = t.pop(),
				u = s + ((c & 240) >> 4);
			if (u === r) {
				var h = (c & 15) - 8;
				h >= 0 && h++;
				var d = h * a;
				_e.DEBUG && console.log(e.step, "DELTACFIX", l, "by", d), (e.cvt[l] += d);
			}
		}
	}
	function BU(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "SROUND[]", e), (n.round = yb);
		var t;
		switch (e & 192) {
			case 0:
				t = 0.5;
				break;
			case 64:
				t = 1;
				break;
			case 128:
				t = 2;
				break;
			default:
				throw new Error("invalid SROUND value");
		}
		switch (((n.srPeriod = t), e & 48)) {
			case 0:
				n.srPhase = 0;
				break;
			case 16:
				n.srPhase = 0.25 * t;
				break;
			case 32:
				n.srPhase = 0.5 * t;
				break;
			case 48:
				n.srPhase = 0.75 * t;
				break;
			default:
				throw new Error("invalid SROUND value");
		}
		(e &= 15), e === 0 ? (n.srThreshold = 0) : (n.srThreshold = (e / 8 - 0.5) * t);
	}
	function zU(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "S45ROUND[]", e), (n.round = yb);
		var t;
		switch (e & 192) {
			case 0:
				t = Math.sqrt(2) / 2;
				break;
			case 64:
				t = Math.sqrt(2);
				break;
			case 128:
				t = 2 * Math.sqrt(2);
				break;
			default:
				throw new Error("invalid S45ROUND value");
		}
		switch (((n.srPeriod = t), e & 48)) {
			case 0:
				n.srPhase = 0;
				break;
			case 16:
				n.srPhase = 0.25 * t;
				break;
			case 32:
				n.srPhase = 0.5 * t;
				break;
			case 48:
				n.srPhase = 0.75 * t;
				break;
			default:
				throw new Error("invalid S45ROUND value");
		}
		(e &= 15), e === 0 ? (n.srThreshold = 0) : (n.srThreshold = (e / 8 - 0.5) * t);
	}
	function HU(n) {
		_e.DEBUG && console.log(n.step, "ROFF[]"), (n.round = SN);
	}
	function GU(n) {
		_e.DEBUG && console.log(n.step, "RUTG[]"), (n.round = TN);
	}
	function VU(n) {
		_e.DEBUG && console.log(n.step, "RDTG[]"), (n.round = MN);
	}
	function WU(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "SCANCTRL[]", e);
	}
	function x_(n, e) {
		var t = e.stack,
			i = t.pop(),
			r = t.pop(),
			s = e.z2[i],
			a = e.z1[r];
		_e.DEBUG && console.log(e.step, "SDPVTL[" + n + "]", i, r);
		var o, l;
		n ? ((o = s.y - a.y), (l = a.x - s.x)) : ((o = a.x - s.x), (l = a.y - s.y)), (e.dpv = rc(o, l));
	}
	function XU(n) {
		var e = n.stack,
			t = e.pop(),
			i = 0;
		_e.DEBUG && console.log(n.step, "GETINFO[]", t), t & 1 && (i = 35), t & 32 && (i |= 4096), e.push(i);
	}
	function $U(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop(),
			r = e.pop();
		_e.DEBUG && console.log(n.step, "ROLL[]"), e.push(i), e.push(t), e.push(r);
	}
	function qU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "MAX[]", t, i), e.push(Math.max(i, t));
	}
	function jU(n) {
		var e = n.stack,
			t = e.pop(),
			i = e.pop();
		_e.DEBUG && console.log(n.step, "MIN[]", t, i), e.push(Math.min(i, t));
	}
	function YU(n) {
		var e = n.stack.pop();
		_e.DEBUG && console.log(n.step, "SCANTYPE[]", e);
	}
	function KU(n) {
		var e = n.stack.pop(),
			t = n.stack.pop();
		switch ((_e.DEBUG && console.log(n.step, "INSTCTRL[]", e, t), e)) {
			case 1:
				n.inhibitGridFit = !!t;
				return;
			case 2:
				n.ignoreCvt = !!t;
				return;
			default:
				throw new Error("invalid INSTCTRL[] selector");
		}
	}
	function ps(n, e) {
		var t = e.stack,
			i = e.prog,
			r = e.ip;
		_e.DEBUG && console.log(e.step, "PUSHB[" + n + "]");
		for (var s = 0; s < n; s++) t.push(i[++r]);
		e.ip = r;
	}
	function ms(n, e) {
		var t = e.ip,
			i = e.prog,
			r = e.stack;
		_e.DEBUG && console.log(e.ip, "PUSHW[" + n + "]");
		for (var s = 0; s < n; s++) {
			var a = (i[++t] << 8) | i[++t];
			a & 32768 && (a = -((a ^ 65535) + 1)), r.push(a);
		}
		e.ip = t;
	}
	function Ke(n, e, t, i, r, s) {
		var a = s.stack,
			o = n && a.pop(),
			l = a.pop(),
			c = s.rp0,
			u = s.z0[c],
			h = s.z1[l],
			d = s.minDis,
			f = s.fv,
			v = s.dpv,
			_,
			p,
			g,
			x;
		(p = _ = v.distance(h, u, !0, !0)),
			(g = p >= 0 ? 1 : -1),
			(p = Math.abs(p)),
			n && ((x = s.cvt[o]), i && Math.abs(p - x) < s.cvCutIn && (p = x)),
			t && p < d && (p = d),
			i && (p = s.round(p)),
			f.setRelative(h, u, g * p, v),
			f.touch(h),
			_e.DEBUG && console.log(s.step, (n ? "MIRP[" : "MDRP[") + (e ? "M" : "m") + (t ? ">" : "_") + (i ? "R" : "_") + (r === 0 ? "Gr" : r === 1 ? "Bl" : r === 2 ? "Wh" : "") + "]", n ? o + "(" + s.cvt[o] + "," + x + ")" : "", l, "(d =", _, "->", g * p, ")"),
			(s.rp1 = s.rp0),
			(s.rp2 = l),
			e && (s.rp0 = l);
	}
	mb = [
		a_.bind(void 0, Vr),
		a_.bind(void 0, vr),
		o_.bind(void 0, Vr),
		o_.bind(void 0, vr),
		l_.bind(void 0, Vr),
		l_.bind(void 0, vr),
		c_.bind(void 0, 0),
		c_.bind(void 0, 1),
		u_.bind(void 0, 0),
		u_.bind(void 0, 1),
		CN,
		LN,
		RN,
		PN,
		DN,
		ON,
		IN,
		FN,
		NN,
		UN,
		kN,
		BN,
		zN,
		HN,
		GN,
		VN,
		WN,
		XN,
		$N,
		qN,
		void 0,
		void 0,
		jN,
		ef,
		YN,
		KN,
		ZN,
		eU,
		tU,
		void 0,
		void 0,
		void 0,
		JN,
		QN,
		nU,
		void 0,
		h_.bind(void 0, 0),
		h_.bind(void 0, 1),
		d_.bind(void 0, Vr),
		d_.bind(void 0, vr),
		f_.bind(void 0, 0),
		f_.bind(void 0, 1),
		p_.bind(void 0, 0),
		p_.bind(void 0, 1),
		m_.bind(void 0, 0),
		m_.bind(void 0, 1),
		iU,
		rU,
		g_.bind(void 0, 0),
		g_.bind(void 0, 1),
		sU,
		aU,
		v_.bind(void 0, 0),
		v_.bind(void 0, 1),
		oU,
		lU,
		cU,
		uU,
		hU,
		dU,
		__.bind(void 0, 0),
		__.bind(void 0, 1),
		void 0,
		y_.bind(void 0, 0),
		y_.bind(void 0, 1),
		fU,
		void 0,
		pU,
		void 0,
		void 0,
		mU,
		gU,
		vU,
		_U,
		yU,
		xU,
		bU,
		SU,
		EU,
		wU,
		TU,
		MU,
		AU,
		tf.bind(void 0, 1),
		CU,
		LU,
		RU,
		PU,
		DU,
		OU,
		IU,
		FU,
		NU,
		UU,
		yu.bind(void 0, 0),
		yu.bind(void 0, 1),
		yu.bind(void 0, 2),
		yu.bind(void 0, 3),
		void 0,
		void 0,
		void 0,
		void 0,
		kU,
		tf.bind(void 0, 2),
		tf.bind(void 0, 3),
		nf.bind(void 0, 1),
		nf.bind(void 0, 2),
		nf.bind(void 0, 3),
		BU,
		zU,
		void 0,
		void 0,
		HU,
		void 0,
		GU,
		VU,
		ef,
		ef,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		WU,
		x_.bind(void 0, 0),
		x_.bind(void 0, 1),
		XU,
		void 0,
		$U,
		qU,
		jU,
		YU,
		KU,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		void 0,
		ps.bind(void 0, 1),
		ps.bind(void 0, 2),
		ps.bind(void 0, 3),
		ps.bind(void 0, 4),
		ps.bind(void 0, 5),
		ps.bind(void 0, 6),
		ps.bind(void 0, 7),
		ps.bind(void 0, 8),
		ms.bind(void 0, 1),
		ms.bind(void 0, 2),
		ms.bind(void 0, 3),
		ms.bind(void 0, 4),
		ms.bind(void 0, 5),
		ms.bind(void 0, 6),
		ms.bind(void 0, 7),
		ms.bind(void 0, 8),
		Ke.bind(void 0, 0, 0, 0, 0, 0),
		Ke.bind(void 0, 0, 0, 0, 0, 1),
		Ke.bind(void 0, 0, 0, 0, 0, 2),
		Ke.bind(void 0, 0, 0, 0, 0, 3),
		Ke.bind(void 0, 0, 0, 0, 1, 0),
		Ke.bind(void 0, 0, 0, 0, 1, 1),
		Ke.bind(void 0, 0, 0, 0, 1, 2),
		Ke.bind(void 0, 0, 0, 0, 1, 3),
		Ke.bind(void 0, 0, 0, 1, 0, 0),
		Ke.bind(void 0, 0, 0, 1, 0, 1),
		Ke.bind(void 0, 0, 0, 1, 0, 2),
		Ke.bind(void 0, 0, 0, 1, 0, 3),
		Ke.bind(void 0, 0, 0, 1, 1, 0),
		Ke.bind(void 0, 0, 0, 1, 1, 1),
		Ke.bind(void 0, 0, 0, 1, 1, 2),
		Ke.bind(void 0, 0, 0, 1, 1, 3),
		Ke.bind(void 0, 0, 1, 0, 0, 0),
		Ke.bind(void 0, 0, 1, 0, 0, 1),
		Ke.bind(void 0, 0, 1, 0, 0, 2),
		Ke.bind(void 0, 0, 1, 0, 0, 3),
		Ke.bind(void 0, 0, 1, 0, 1, 0),
		Ke.bind(void 0, 0, 1, 0, 1, 1),
		Ke.bind(void 0, 0, 1, 0, 1, 2),
		Ke.bind(void 0, 0, 1, 0, 1, 3),
		Ke.bind(void 0, 0, 1, 1, 0, 0),
		Ke.bind(void 0, 0, 1, 1, 0, 1),
		Ke.bind(void 0, 0, 1, 1, 0, 2),
		Ke.bind(void 0, 0, 1, 1, 0, 3),
		Ke.bind(void 0, 0, 1, 1, 1, 0),
		Ke.bind(void 0, 0, 1, 1, 1, 1),
		Ke.bind(void 0, 0, 1, 1, 1, 2),
		Ke.bind(void 0, 0, 1, 1, 1, 3),
		Ke.bind(void 0, 1, 0, 0, 0, 0),
		Ke.bind(void 0, 1, 0, 0, 0, 1),
		Ke.bind(void 0, 1, 0, 0, 0, 2),
		Ke.bind(void 0, 1, 0, 0, 0, 3),
		Ke.bind(void 0, 1, 0, 0, 1, 0),
		Ke.bind(void 0, 1, 0, 0, 1, 1),
		Ke.bind(void 0, 1, 0, 0, 1, 2),
		Ke.bind(void 0, 1, 0, 0, 1, 3),
		Ke.bind(void 0, 1, 0, 1, 0, 0),
		Ke.bind(void 0, 1, 0, 1, 0, 1),
		Ke.bind(void 0, 1, 0, 1, 0, 2),
		Ke.bind(void 0, 1, 0, 1, 0, 3),
		Ke.bind(void 0, 1, 0, 1, 1, 0),
		Ke.bind(void 0, 1, 0, 1, 1, 1),
		Ke.bind(void 0, 1, 0, 1, 1, 2),
		Ke.bind(void 0, 1, 0, 1, 1, 3),
		Ke.bind(void 0, 1, 1, 0, 0, 0),
		Ke.bind(void 0, 1, 1, 0, 0, 1),
		Ke.bind(void 0, 1, 1, 0, 0, 2),
		Ke.bind(void 0, 1, 1, 0, 0, 3),
		Ke.bind(void 0, 1, 1, 0, 1, 0),
		Ke.bind(void 0, 1, 1, 0, 1, 1),
		Ke.bind(void 0, 1, 1, 0, 1, 2),
		Ke.bind(void 0, 1, 1, 0, 1, 3),
		Ke.bind(void 0, 1, 1, 1, 0, 0),
		Ke.bind(void 0, 1, 1, 1, 0, 1),
		Ke.bind(void 0, 1, 1, 1, 0, 2),
		Ke.bind(void 0, 1, 1, 1, 0, 3),
		Ke.bind(void 0, 1, 1, 1, 1, 0),
		Ke.bind(void 0, 1, 1, 1, 1, 1),
		Ke.bind(void 0, 1, 1, 1, 1, 2),
		Ke.bind(void 0, 1, 1, 1, 1, 3)
	];
	function Yo(n) {
		(this.char = n), (this.state = {}), (this.activeState = null);
	}
	function dm(n, e, t) {
		(this.contextName = t), (this.startIndex = n), (this.endOffset = e);
	}
	function ZU(n, e, t) {
		(this.contextName = n), (this.openRange = null), (this.ranges = []), (this.checkStart = e), (this.checkEnd = t);
	}
	function rr(n, e) {
		(this.context = n), (this.index = e), (this.length = n.length), (this.current = n[e]), (this.backtrack = n.slice(0, e)), (this.lookahead = n.slice(e + 1));
	}
	function Sh(n) {
		(this.eventId = n), (this.subscribers = []);
	}
	function JU(n) {
		var e = this,
			t = ["start", "end", "next", "newToken", "contextStart", "contextEnd", "insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD", "updateContextsRanges"];
		t.forEach(function (r) {
			Object.defineProperty(e.events, r, { value: new Sh(r) });
		}),
			n &&
				t.forEach(function (r) {
					var s = n[r];
					typeof s == "function" && e.events[r].subscribe(s);
				});
		var i = ["insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD"];
		i.forEach(function (r) {
			e.events[r].subscribe(e.updateContextsRanges);
		});
	}
	function fn(n) {
		(this.tokens = []), (this.registeredContexts = {}), (this.contextCheckers = []), (this.events = {}), (this.registeredModifiers = []), JU.call(this, n);
	}
	Yo.prototype.setState = function (n, e) {
		return (this.state[n] = e), (this.activeState = { key: n, value: this.state[n] }), this.activeState;
	};
	Yo.prototype.getState = function (n) {
		return this.state[n] || null;
	};
	fn.prototype.inboundIndex = function (n) {
		return n >= 0 && n < this.tokens.length;
	};
	fn.prototype.composeRUD = function (n) {
		var e = this,
			t = !0,
			i = n.map(function (s) {
				return e[s[0]].apply(e, s.slice(1).concat(t));
			}),
			r = function (s) {
				return typeof s == "object" && s.hasOwnProperty("FAIL");
			};
		if (i.every(r)) return { FAIL: "composeRUD: one or more operations hasn't completed successfully", report: i.filter(r) };
		this.dispatch("composeRUD", [
			i.filter(function (s) {
				return !r(s);
			})
		]);
	};
	fn.prototype.replaceRange = function (n, e, t, i) {
		e = e !== null ? e : this.tokens.length;
		var r = t.every(function (a) {
			return a instanceof Yo;
		});
		if (!isNaN(n) && this.inboundIndex(n) && r) {
			var s = this.tokens.splice.apply(this.tokens, [n, e].concat(t));
			return i || this.dispatch("replaceToken", [n, e, t]), [s, t];
		} else return { FAIL: "replaceRange: invalid tokens or startIndex." };
	};
	fn.prototype.replaceToken = function (n, e, t) {
		if (!isNaN(n) && this.inboundIndex(n) && e instanceof Yo) {
			var i = this.tokens.splice(n, 1, e);
			return t || this.dispatch("replaceToken", [n, e]), [i[0], e];
		} else return { FAIL: "replaceToken: invalid token or index." };
	};
	fn.prototype.removeRange = function (n, e, t) {
		e = isNaN(e) ? this.tokens.length : e;
		var i = this.tokens.splice(n, e);
		return t || this.dispatch("removeRange", [i, n, e]), i;
	};
	fn.prototype.removeToken = function (n, e) {
		if (!isNaN(n) && this.inboundIndex(n)) {
			var t = this.tokens.splice(n, 1);
			return e || this.dispatch("removeToken", [t, n]), t;
		} else return { FAIL: "removeToken: invalid token index." };
	};
	fn.prototype.insertToken = function (n, e, t) {
		var i = n.every(function (r) {
			return r instanceof Yo;
		});
		return i ? (this.tokens.splice.apply(this.tokens, [e, 0].concat(n)), t || this.dispatch("insertToken", [n, e]), n) : { FAIL: "insertToken: invalid token(s)." };
	};
	fn.prototype.registerModifier = function (n, e, t) {
		this.events.newToken.subscribe(function (i, r) {
			var s = [i, r],
				a = e === null || e.apply(this, s) === !0,
				o = [i, r];
			if (a) {
				var l = t.apply(this, o);
				i.setState(n, l);
			}
		}),
			this.registeredModifiers.push(n);
	};
	Sh.prototype.subscribe = function (n) {
		return typeof n == "function" ? this.subscribers.push(n) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" };
	};
	Sh.prototype.unsubscribe = function (n) {
		this.subscribers.splice(n, 1);
	};
	rr.prototype.setCurrentIndex = function (n) {
		(this.index = n), (this.current = this.context[n]), (this.backtrack = this.context.slice(0, n)), (this.lookahead = this.context.slice(n + 1));
	};
	rr.prototype.get = function (n) {
		switch (!0) {
			case n === 0:
				return this.current;
			case n < 0 && Math.abs(n) <= this.backtrack.length:
				return this.backtrack.slice(n)[0];
			case n > 0 && n <= this.lookahead.length:
				return this.lookahead[n - 1];
			default:
				return null;
		}
	};
	fn.prototype.rangeToText = function (n) {
		if (n instanceof dm)
			return this.getRangeTokens(n)
				.map(function (e) {
					return e.char;
				})
				.join("");
	};
	fn.prototype.getText = function () {
		return this.tokens
			.map(function (n) {
				return n.char;
			})
			.join("");
	};
	fn.prototype.getContext = function (n) {
		var e = this.registeredContexts[n];
		return e || null;
	};
	fn.prototype.on = function (n, e) {
		var t = this.events[n];
		return t ? t.subscribe(e) : null;
	};
	fn.prototype.dispatch = function (n, e) {
		var t = this,
			i = this.events[n];
		i instanceof Sh &&
			i.subscribers.forEach(function (r) {
				r.apply(t, e || []);
			});
	};
	fn.prototype.registerContextChecker = function (n, e, t) {
		if (this.getContext(n)) return { FAIL: "context name '" + n + "' is already registered." };
		if (typeof e != "function") return { FAIL: "missing context start check." };
		if (typeof t != "function") return { FAIL: "missing context end check." };
		var i = new ZU(n, e, t);
		return (this.registeredContexts[n] = i), this.contextCheckers.push(i), i;
	};
	fn.prototype.getRangeTokens = function (n) {
		var e = n.startIndex + n.endOffset;
		return [].concat(this.tokens.slice(n.startIndex, e));
	};
	fn.prototype.getContextRanges = function (n) {
		var e = this.getContext(n);
		return e ? e.ranges : { FAIL: "context checker '" + n + "' is not registered." };
	};
	fn.prototype.resetContextsRanges = function () {
		var n = this.registeredContexts;
		for (var e in n)
			if (n.hasOwnProperty(e)) {
				var t = n[e];
				t.ranges = [];
			}
	};
	fn.prototype.updateContextsRanges = function () {
		this.resetContextsRanges();
		for (
			var n = this.tokens.map(function (i) {
					return i.char;
				}),
				e = 0;
			e < n.length;
			e++
		) {
			var t = new rr(n, e);
			this.runContextCheck(t);
		}
		this.dispatch("updateContextsRanges", [this.registeredContexts]);
	};
	fn.prototype.setEndOffset = function (n, e) {
		var t = this.getContext(e).openRange.startIndex,
			i = new dm(t, n, e),
			r = this.getContext(e).ranges;
		return (i.rangeId = e + "." + r.length), r.push(i), (this.getContext(e).openRange = null), i;
	};
	fn.prototype.runContextCheck = function (n) {
		var e = this,
			t = n.index;
		this.contextCheckers.forEach(function (i) {
			var r = i.contextName,
				s = e.getContext(r).openRange;
			if ((!s && i.checkStart(n) && ((s = new dm(t, null, r)), (e.getContext(r).openRange = s), e.dispatch("contextStart", [r, t])), s && i.checkEnd(n))) {
				var a = t - s.startIndex + 1,
					o = e.setEndOffset(a, r);
				e.dispatch("contextEnd", [r, o]);
			}
		});
	};
	fn.prototype.tokenize = function (n) {
		(this.tokens = []), this.resetContextsRanges();
		var e = Array.from(n);
		this.dispatch("start");
		for (var t = 0; t < e.length; t++) {
			var i = e[t],
				r = new rr(e, t);
			this.dispatch("next", [r]), this.runContextCheck(r);
			var s = new Yo(i);
			this.tokens.push(s), this.dispatch("newToken", [s, r]);
		}
		return this.dispatch("end", [this.tokens]), this.tokens;
	};
	function As(n) {
		return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(n);
	}
	function bb(n) {
		return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(n);
	}
	function Ps(n) {
		return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(n);
	}
	function ku(n) {
		return /[A-z]/.test(n);
	}
	function QU(n) {
		return /\s/.test(n);
	}
	function yi(n) {
		(this.font = n), (this.features = {});
	}
	function ca(n) {
		(this.id = n.id), (this.tag = n.tag), (this.substitution = n.substitution);
	}
	function sc(n, e) {
		if (!n) return -1;
		switch (e.format) {
			case 1:
				return e.glyphs.indexOf(n);
			case 2:
				for (var t = e.ranges, i = 0; i < t.length; i++) {
					var r = t[i];
					if (n >= r.start && n <= r.end) {
						var s = n - r.start;
						return r.index + s;
					}
				}
				break;
			default:
				return -1;
		}
		return -1;
	}
	function e3(n, e) {
		var t = sc(n, e.coverage);
		return t === -1 ? null : n + e.deltaGlyphId;
	}
	function t3(n, e) {
		var t = sc(n, e.coverage);
		return t === -1 ? null : e.substitute[t];
	}
	function rf(n, e) {
		for (var t = [], i = 0; i < n.length; i++) {
			var r = n[i],
				s = e.current;
			s = Array.isArray(s) ? s[0] : s;
			var a = sc(s, r);
			a !== -1 && t.push(a);
		}
		return t.length !== n.length ? -1 : t;
	}
	function n3(n, e) {
		var t = e.inputCoverage.length + e.lookaheadCoverage.length + e.backtrackCoverage.length;
		if (n.context.length < t) return [];
		var i = rf(e.inputCoverage, n);
		if (i === -1) return [];
		var r = e.inputCoverage.length - 1;
		if (n.lookahead.length < e.lookaheadCoverage.length) return [];
		for (var s = n.lookahead.slice(r); s.length && Ps(s[0].char); ) s.shift();
		var a = new rr(s, 0),
			o = rf(e.lookaheadCoverage, a),
			l = [].concat(n.backtrack);
		for (l.reverse(); l.length && Ps(l[0].char); ) l.shift();
		if (l.length < e.backtrackCoverage.length) return [];
		var c = new rr(l, 0),
			u = rf(e.backtrackCoverage, c),
			h = i.length === e.inputCoverage.length && o.length === e.lookaheadCoverage.length && u.length === e.backtrackCoverage.length,
			d = [];
		if (h)
			for (var f = 0; f < e.lookupRecords.length; f++)
				for (var v = e.lookupRecords[f], _ = v.lookupListIndex, p = this.getLookupByIndex(_), g = 0; g < p.subtables.length; g++) {
					var x = p.subtables[g],
						b = this.getLookupMethod(p, x),
						T = this.getSubstitutionType(p, x);
					if (T === "12")
						for (var P = 0; P < i.length; P++) {
							var A = n.get(P),
								M = b(A);
							M && d.push(M);
						}
				}
		return d;
	}
	function i3(n, e) {
		var t = n.current,
			i = sc(t, e.coverage);
		if (i === -1) return null;
		for (var r, s = e.ligatureSets[i], a = 0; a < s.length; a++) {
			r = s[a];
			for (var o = 0; o < r.components.length; o++) {
				var l = n.lookahead[o],
					c = r.components[o];
				if (l !== c) break;
				if (o === r.components.length - 1) return r;
			}
		}
		return null;
	}
	function r3(n, e) {
		var t = sc(n, e.coverage);
		return t === -1 ? null : e.sequences[t];
	}
	yi.prototype.getDefaultScriptFeaturesIndexes = function () {
		for (var n = this.font.tables.gsub.scripts, e = 0; e < n.length; e++) {
			var t = n[e];
			if (t.tag === "DFLT") return t.script.defaultLangSys.featureIndexes;
		}
		return [];
	};
	yi.prototype.getScriptFeaturesIndexes = function (n) {
		var e = this.font.tables;
		if (!e.gsub) return [];
		if (!n) return this.getDefaultScriptFeaturesIndexes();
		for (var t = this.font.tables.gsub.scripts, i = 0; i < t.length; i++) {
			var r = t[i];
			if (r.tag === n && r.script.defaultLangSys) return r.script.defaultLangSys.featureIndexes;
			var s = r.langSysRecords;
			if (s)
				for (var a = 0; a < s.length; a++) {
					var o = s[a];
					if (o.tag === n) {
						var l = o.langSys;
						return l.featureIndexes;
					}
				}
		}
		return this.getDefaultScriptFeaturesIndexes();
	};
	yi.prototype.mapTagsToFeatures = function (n, e) {
		for (var t = {}, i = 0; i < n.length; i++) {
			var r = n[i].tag,
				s = n[i].feature;
			t[r] = s;
		}
		this.features[e].tags = t;
	};
	yi.prototype.getScriptFeatures = function (n) {
		var e = this.features[n];
		if (this.features.hasOwnProperty(n)) return e;
		var t = this.getScriptFeaturesIndexes(n);
		if (!t) return null;
		var i = this.font.tables.gsub;
		return (
			(e = t.map(function (r) {
				return i.features[r];
			})),
			(this.features[n] = e),
			this.mapTagsToFeatures(e, n),
			e
		);
	};
	yi.prototype.getSubstitutionType = function (n, e) {
		var t = n.lookupType.toString(),
			i = e.substFormat.toString();
		return t + i;
	};
	yi.prototype.getLookupMethod = function (n, e) {
		var t = this,
			i = this.getSubstitutionType(n, e);
		switch (i) {
			case "11":
				return function (r) {
					return e3.apply(t, [r, e]);
				};
			case "12":
				return function (r) {
					return t3.apply(t, [r, e]);
				};
			case "63":
				return function (r) {
					return n3.apply(t, [r, e]);
				};
			case "41":
				return function (r) {
					return i3.apply(t, [r, e]);
				};
			case "21":
				return function (r) {
					return r3.apply(t, [r, e]);
				};
			default:
				throw new Error("lookupType: " + n.lookupType + " - substFormat: " + e.substFormat + " is not yet supported");
		}
	};
	yi.prototype.lookupFeature = function (n) {
		var e = n.contextParams,
			t = e.index,
			i = this.getFeature({ tag: n.tag, script: n.script });
		if (!i) return new Error("font '" + this.font.names.fullName.en + "' doesn't support feature '" + n.tag + "' for script '" + n.script + "'.");
		for (var r = this.getFeatureLookups(i), s = [].concat(e.context), a = 0; a < r.length; a++)
			for (var o = r[a], l = this.getLookupSubtables(o), c = 0; c < l.length; c++) {
				var u = l[c],
					h = this.getSubstitutionType(o, u),
					d = this.getLookupMethod(o, u),
					f = void 0;
				switch (h) {
					case "11":
						(f = d(e.current)), f && s.splice(t, 1, new ca({ id: 11, tag: n.tag, substitution: f }));
						break;
					case "12":
						(f = d(e.current)), f && s.splice(t, 1, new ca({ id: 12, tag: n.tag, substitution: f }));
						break;
					case "63":
						(f = d(e)), Array.isArray(f) && f.length && s.splice(t, 1, new ca({ id: 63, tag: n.tag, substitution: f }));
						break;
					case "41":
						(f = d(e)), f && s.splice(t, 1, new ca({ id: 41, tag: n.tag, substitution: f }));
						break;
					case "21":
						(f = d(e.current)), f && s.splice(t, 1, new ca({ id: 21, tag: n.tag, substitution: f }));
						break;
				}
				(e = new rr(s, t)), !(Array.isArray(f) && !f.length) && (f = null);
			}
		return s.length ? s : null;
	};
	yi.prototype.supports = function (n) {
		if (!n.script) return !1;
		this.getScriptFeatures(n.script);
		var e = this.features.hasOwnProperty(n.script);
		if (!n.tag) return e;
		var t = this.features[n.script].some(function (i) {
			return i.tag === n.tag;
		});
		return e && t;
	};
	yi.prototype.getLookupSubtables = function (n) {
		return n.subtables || null;
	};
	yi.prototype.getLookupByIndex = function (n) {
		var e = this.font.tables.gsub.lookups;
		return e[n] || null;
	};
	yi.prototype.getFeatureLookups = function (n) {
		return n.lookupListIndexes.map(this.getLookupByIndex.bind(this));
	};
	yi.prototype.getFeature = function (e) {
		if (!this.font) return { FAIL: "No font was found" };
		this.features.hasOwnProperty(e.script) || this.getScriptFeatures(e.script);
		var t = this.features[e.script];
		return t ? (t.tags[e.tag] ? this.features[e.script].tags[e.tag] : null) : { FAIL: "No feature for script " + e.script };
	};
	function s3(n) {
		var e = n.current,
			t = n.get(-1);
		return (t === null && As(e)) || (!As(t) && As(e));
	}
	function a3(n) {
		var e = n.get(1);
		return e === null || !As(e);
	}
	var o3 = { startCheck: s3, endCheck: a3 };
	function l3(n) {
		var e = n.current,
			t = n.get(-1);
		return (As(e) || Ps(e)) && !As(t);
	}
	function c3(n) {
		var e = n.get(1);
		switch (!0) {
			case e === null:
				return !0;
			case !As(e) && !Ps(e):
				var t = QU(e);
				if (!t) return !0;
				if (t) {
					var i = !1;
					if (
						((i = n.lookahead.some(function (r) {
							return As(r) || Ps(r);
						})),
						!i)
					)
						return !0;
				}
				break;
			default:
				return !1;
		}
	}
	var u3 = { startCheck: l3, endCheck: c3 };
	function h3(n, e, t) {
		e[t].setState(n.tag, n.substitution);
	}
	function d3(n, e, t) {
		e[t].setState(n.tag, n.substitution);
	}
	function f3(n, e, t) {
		n.substitution.forEach(function (i, r) {
			var s = e[t + r];
			s.setState(n.tag, i);
		});
	}
	function p3(n, e, t) {
		var i = e[t];
		i.setState(n.tag, n.substitution.ligGlyph);
		for (var r = n.substitution.components.length, s = 0; s < r; s++) (i = e[t + s + 1]), i.setState("deleted", !0);
	}
	var b_ = { 11: h3, 12: d3, 63: f3, 41: p3 };
	function fm(n, e, t) {
		n instanceof ca && b_[n.id] && b_[n.id](n, e, t);
	}
	function m3(n) {
		for (var e = [].concat(n.backtrack), t = e.length - 1; t >= 0; t--) {
			var i = e[t],
				r = bb(i),
				s = Ps(i);
			if (!r && !s) return !0;
			if (r) return !1;
		}
		return !1;
	}
	function g3(n) {
		if (bb(n.current)) return !1;
		for (var e = 0; e < n.lookahead.length; e++) {
			var t = n.lookahead[e],
				i = Ps(t);
			if (!i) return !0;
		}
		return !1;
	}
	function v3(n) {
		var e = this,
			t = "arab",
			i = this.featuresTags[t],
			r = this.tokenizer.getRangeTokens(n);
		if (r.length !== 1) {
			var s = new rr(
					r.map(function (o) {
						return o.getState("glyphIndex");
					}),
					0
				),
				a = new rr(
					r.map(function (o) {
						return o.char;
					}),
					0
				);
			r.forEach(function (o, l) {
				if (!Ps(o.char)) {
					s.setCurrentIndex(l), a.setCurrentIndex(l);
					var c = 0;
					m3(a) && (c |= 1), g3(a) && (c |= 2);
					var u;
					switch (c) {
						case 1:
							u = "fina";
							break;
						case 2:
							u = "init";
							break;
						case 3:
							u = "medi";
							break;
					}
					if (i.indexOf(u) !== -1) {
						var h = e.query.lookupFeature({ tag: u, script: t, contextParams: s });
						if (h instanceof Error) return console.info(h.message);
						h.forEach(function (d, f) {
							d instanceof ca && (fm(d, r, f), (s.context[f] = d.substitution));
						});
					}
				}
			});
		}
	}
	function S_(n, e) {
		var t = n.map(function (i) {
			return i.activeState.value;
		});
		return new rr(t, 0);
	}
	function _3(n) {
		var e = this,
			t = "arab",
			i = this.tokenizer.getRangeTokens(n),
			r = S_(i);
		r.context.forEach(function (s, a) {
			r.setCurrentIndex(a);
			var o = e.query.lookupFeature({ tag: "rlig", script: t, contextParams: r });
			o.length &&
				(o.forEach(function (l) {
					return fm(l, i, a);
				}),
				(r = S_(i)));
		});
	}
	function y3(n) {
		var e = n.current,
			t = n.get(-1);
		return (t === null && ku(e)) || (!ku(t) && ku(e));
	}
	function x3(n) {
		var e = n.get(1);
		return e === null || !ku(e);
	}
	var b3 = { startCheck: y3, endCheck: x3 };
	function E_(n, e) {
		var t = n.map(function (i) {
			return i.activeState.value;
		});
		return new rr(t, 0);
	}
	function S3(n) {
		var e = this,
			t = "latn",
			i = this.tokenizer.getRangeTokens(n),
			r = E_(i);
		r.context.forEach(function (s, a) {
			r.setCurrentIndex(a);
			var o = e.query.lookupFeature({ tag: "liga", script: t, contextParams: r });
			o.length &&
				(o.forEach(function (l) {
					return fm(l, i, a);
				}),
				(r = E_(i)));
		});
	}
	function lr(n) {
		(this.baseDir = n || "ltr"), (this.tokenizer = new fn()), (this.featuresTags = {});
	}
	lr.prototype.setText = function (n) {
		this.text = n;
	};
	lr.prototype.contextChecks = { latinWordCheck: b3, arabicWordCheck: o3, arabicSentenceCheck: u3 };
	function sf(n) {
		var e = this.contextChecks[n + "Check"];
		return this.tokenizer.registerContextChecker(n, e.startCheck, e.endCheck);
	}
	function E3() {
		return sf.call(this, "latinWord"), sf.call(this, "arabicWord"), sf.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text);
	}
	function w3() {
		var n = this,
			e = this.tokenizer.getContextRanges("arabicSentence");
		e.forEach(function (t) {
			var i = n.tokenizer.getRangeTokens(t);
			n.tokenizer.replaceRange(t.startIndex, t.endOffset, i.reverse());
		});
	}
	lr.prototype.registerFeatures = function (n, e) {
		var t = this,
			i = e.filter(function (r) {
				return t.query.supports({ script: n, tag: r });
			});
		this.featuresTags.hasOwnProperty(n) ? (this.featuresTags[n] = this.featuresTags[n].concat(i)) : (this.featuresTags[n] = i);
	};
	lr.prototype.applyFeatures = function (n, e) {
		if (!n) throw new Error("No valid font was provided to apply features");
		this.query || (this.query = new yi(n));
		for (var t = 0; t < e.length; t++) {
			var i = e[t];
			this.query.supports({ script: i.script }) && this.registerFeatures(i.script, i.tags);
		}
	};
	lr.prototype.registerModifier = function (n, e, t) {
		this.tokenizer.registerModifier(n, e, t);
	};
	function pm() {
		if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) throw new Error("glyphIndex modifier is required to apply arabic presentation features.");
	}
	function T3() {
		var n = this,
			e = "arab";
		if (this.featuresTags.hasOwnProperty(e)) {
			pm.call(this);
			var t = this.tokenizer.getContextRanges("arabicWord");
			t.forEach(function (i) {
				v3.call(n, i);
			});
		}
	}
	function M3() {
		var n = this,
			e = "arab";
		if (this.featuresTags.hasOwnProperty(e)) {
			var t = this.featuresTags[e];
			if (t.indexOf("rlig") !== -1) {
				pm.call(this);
				var i = this.tokenizer.getContextRanges("arabicWord");
				i.forEach(function (r) {
					_3.call(n, r);
				});
			}
		}
	}
	function A3() {
		var n = this,
			e = "latn";
		if (this.featuresTags.hasOwnProperty(e)) {
			var t = this.featuresTags[e];
			if (t.indexOf("liga") !== -1) {
				pm.call(this);
				var i = this.tokenizer.getContextRanges("latinWord");
				i.forEach(function (r) {
					S3.call(n, r);
				});
			}
		}
	}
	lr.prototype.checkContextReady = function (n) {
		return !!this.tokenizer.getContext(n);
	};
	lr.prototype.applyFeaturesToContexts = function () {
		this.checkContextReady("arabicWord") && (T3.call(this), M3.call(this)), this.checkContextReady("latinWord") && A3.call(this), this.checkContextReady("arabicSentence") && w3.call(this);
	};
	lr.prototype.processText = function (n) {
		(!this.text || this.text !== n) && (this.setText(n), E3.call(this), this.applyFeaturesToContexts());
	};
	lr.prototype.getBidiText = function (n) {
		return this.processText(n), this.tokenizer.getText();
	};
	lr.prototype.getTextGlyphs = function (n) {
		this.processText(n);
		for (var e = [], t = 0; t < this.tokenizer.tokens.length; t++) {
			var i = this.tokenizer.tokens[t];
			if (!i.state.deleted) {
				var r = i.activeState.value;
				e.push(Array.isArray(r) ? r[0] : r);
			}
		}
		return e;
	};
	function qt(n) {
		(n = n || {}),
			(n.tables = n.tables || {}),
			n.empty ||
				(vl(n.familyName, "When creating a new Font object, familyName is required."),
				vl(n.styleName, "When creating a new Font object, styleName is required."),
				vl(n.unitsPerEm, "When creating a new Font object, unitsPerEm is required."),
				vl(n.ascender, "When creating a new Font object, ascender is required."),
				vl(n.descender <= 0, "When creating a new Font object, negative descender value is required."),
				(this.names = {
					fontFamily: { en: n.familyName || " " },
					fontSubfamily: { en: n.styleName || " " },
					fullName: { en: n.fullName || n.familyName + " " + n.styleName },
					postScriptName: { en: n.postScriptName || (n.familyName + n.styleName).replace(/\s/g, "") },
					designer: { en: n.designer || " " },
					designerURL: { en: n.designerURL || " " },
					manufacturer: { en: n.manufacturer || " " },
					manufacturerURL: { en: n.manufacturerURL || " " },
					license: { en: n.license || " " },
					licenseURL: { en: n.licenseURL || " " },
					version: { en: n.version || "Version 0.1" },
					description: { en: n.description || " " },
					copyright: { en: n.copyright || " " },
					trademark: { en: n.trademark || " " }
				}),
				(this.unitsPerEm = n.unitsPerEm || 1e3),
				(this.ascender = n.ascender),
				(this.descender = n.descender),
				(this.createdTimestamp = n.createdTimestamp),
				(this.tables = Object.assign(n.tables, { os2: Object.assign({ usWeightClass: n.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: n.widthClass || this.usWidthClasses.MEDIUM, fsSelection: n.fsSelection || this.fsSelectionValues.REGULAR }, n.tables.os2) }))),
			(this.supported = !0),
			(this.glyphs = new xr.GlyphSet(this, n.glyphs || [])),
			(this.encoding = new kx(this)),
			(this.position = new nc(this)),
			(this.substitution = new _i(this)),
			(this.tables = this.tables || {}),
			(this._push = null),
			(this._hmtxTableData = {}),
			Object.defineProperty(this, "hinting", {
				get: function () {
					if (this._hinting) return this._hinting;
					if (this.outlinesFormat === "truetype") return (this._hinting = new vb(this));
				}
			});
	}
	qt.prototype.hasChar = function (n) {
		return this.encoding.charToGlyphIndex(n) !== null;
	};
	qt.prototype.charToGlyphIndex = function (n) {
		return this.encoding.charToGlyphIndex(n);
	};
	qt.prototype.charToGlyph = function (n) {
		var e = this.charToGlyphIndex(n),
			t = this.glyphs.get(e);
		return t || (t = this.glyphs.get(0)), t;
	};
	qt.prototype.updateFeatures = function (n) {
		return this.defaultRenderOptions.features.map(function (e) {
			return e.script === "latn"
				? {
						script: "latn",
						tags: e.tags.filter(function (t) {
							return n[t];
						})
				  }
				: e;
		});
	};
	qt.prototype.stringToGlyphs = function (n, e) {
		var t = this,
			i = new lr(),
			r = function (h) {
				return t.charToGlyphIndex(h.char);
			};
		i.registerModifier("glyphIndex", null, r);
		var s = e ? this.updateFeatures(e.features) : this.defaultRenderOptions.features;
		i.applyFeatures(this, s);
		for (var a = i.getTextGlyphs(n), o = a.length, l = new Array(o), c = this.glyphs.get(0), u = 0; u < o; u += 1) l[u] = this.glyphs.get(a[u]) || c;
		return l;
	};
	qt.prototype.nameToGlyphIndex = function (n) {
		return this.glyphNames.nameToGlyphIndex(n);
	};
	qt.prototype.nameToGlyph = function (n) {
		var e = this.nameToGlyphIndex(n),
			t = this.glyphs.get(e);
		return t || (t = this.glyphs.get(0)), t;
	};
	qt.prototype.glyphIndexToName = function (n) {
		return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(n) : "";
	};
	qt.prototype.getKerningValue = function (n, e) {
		(n = n.index || n), (e = e.index || e);
		var t = this.position.defaultKerningTables;
		return t ? this.position.getKerningValue(t, n, e) : this.kerningPairs[n + "," + e] || 0;
	};
	qt.prototype.defaultRenderOptions = {
		kerning: !0,
		features: [
			{ script: "arab", tags: ["init", "medi", "fina", "rlig"] },
			{ script: "latn", tags: ["liga", "rlig"] }
		]
	};
	qt.prototype.forEachGlyph = function (n, e, t, i, r, s) {
		(e = e !== void 0 ? e : 0), (t = t !== void 0 ? t : 0), (i = i !== void 0 ? i : 72), (r = Object.assign({}, this.defaultRenderOptions, r));
		var a = (1 / this.unitsPerEm) * i,
			o = this.stringToGlyphs(n, r),
			l;
		if (r.kerning) {
			var c = r.script || this.position.getDefaultScriptName();
			l = this.position.getKerningTables(c, r.language);
		}
		for (var u = 0; u < o.length; u += 1) {
			var h = o[u];
			if ((s.call(this, h, e, t, i, r), h.advanceWidth && (e += h.advanceWidth * a), r.kerning && u < o.length - 1)) {
				var d = l ? this.position.getKerningValue(l, h.index, o[u + 1].index) : this.getKerningValue(h, o[u + 1]);
				e += d * a;
			}
			r.letterSpacing ? (e += r.letterSpacing * i) : r.tracking && (e += (r.tracking / 1e3) * i);
		}
		return e;
	};
	qt.prototype.getPath = function (n, e, t, i, r) {
		var s = new Tn();
		return (
			this.forEachGlyph(n, e, t, i, r, function (a, o, l, c) {
				var u = a.getPath(o, l, c, r, this);
				s.extend(u);
			}),
			s
		);
	};
	qt.prototype.getPaths = function (n, e, t, i, r) {
		var s = [];
		return (
			this.forEachGlyph(n, e, t, i, r, function (a, o, l, c) {
				var u = a.getPath(o, l, c, r, this);
				s.push(u);
			}),
			s
		);
	};
	qt.prototype.getAdvanceWidth = function (n, e, t) {
		return this.forEachGlyph(n, 0, 0, e, t, function () {});
	};
	qt.prototype.draw = function (n, e, t, i, r, s) {
		this.getPath(e, t, i, r, s).draw(n);
	};
	qt.prototype.drawPoints = function (n, e, t, i, r, s) {
		this.forEachGlyph(e, t, i, r, s, function (a, o, l, c) {
			a.drawPoints(n, o, l, c);
		});
	};
	qt.prototype.drawMetrics = function (n, e, t, i, r, s) {
		this.forEachGlyph(e, t, i, r, s, function (a, o, l, c) {
			a.drawMetrics(n, o, l, c);
		});
	};
	qt.prototype.getEnglishName = function (n) {
		var e = this.names[n];
		if (e) return e.en;
	};
	qt.prototype.validate = function () {
		var n = this;
		function e(i, r) {}
		function t(i) {
			var r = n.getEnglishName(i);
			r && r.trim().length > 0;
		}
		t("fontFamily"), t("weightName"), t("manufacturer"), t("copyright"), t("version"), this.unitsPerEm > 0;
	};
	qt.prototype.toTables = function () {
		return gN.fontToTable(this);
	};
	qt.prototype.toBuffer = function () {
		return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
	};
	qt.prototype.toArrayBuffer = function () {
		for (var n = this.toTables(), e = n.encode(), t = new ArrayBuffer(e.length), i = new Uint8Array(t), r = 0; r < e.length; r++) i[r] = e[r];
		return t;
	};
	qt.prototype.download = function (n) {
		var e = this.getEnglishName("fontFamily"),
			t = this.getEnglishName("fontSubfamily");
		n = n || e.replace(/\s/g, "") + "-" + t + ".otf";
		var i = this.toArrayBuffer();
		if (((window.URL = window.URL || window.webkitURL), window.URL)) {
			var r = new DataView(i),
				s = new Blob([r], { type: "font/opentype" }),
				a = document.createElement("a");
			(a.href = window.URL.createObjectURL(s)), (a.download = n);
			var o = document.createEvent("MouseEvents");
			o.initEvent("click", !0, !1), a.dispatchEvent(o);
		} else console.warn("Font file could not be downloaded. Try using a different browser.");
	};
	qt.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 };
	qt.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 };
	qt.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
	function Sb(n, e) {
		var t = JSON.stringify(n),
			i = 256;
		for (var r in e) {
			var s = parseInt(r);
			if (!(!s || s < 256)) {
				if (JSON.stringify(e[r]) === t) return s;
				i <= s && (i = s + 1);
			}
		}
		return (e[i] = n), i;
	}
	function C3(n, e, t) {
		var i = Sb(e.name, t);
		return [
			{ name: "tag_" + n, type: "TAG", value: e.tag },
			{ name: "minValue_" + n, type: "FIXED", value: e.minValue << 16 },
			{ name: "defaultValue_" + n, type: "FIXED", value: e.defaultValue << 16 },
			{ name: "maxValue_" + n, type: "FIXED", value: e.maxValue << 16 },
			{ name: "flags_" + n, type: "USHORT", value: 0 },
			{ name: "nameID_" + n, type: "USHORT", value: i }
		];
	}
	function L3(n, e, t) {
		var i = {},
			r = new Ze.Parser(n, e);
		return (i.tag = r.parseTag()), (i.minValue = r.parseFixed()), (i.defaultValue = r.parseFixed()), (i.maxValue = r.parseFixed()), r.skip("uShort", 1), (i.name = t[r.parseUShort()] || {}), i;
	}
	function R3(n, e, t, i) {
		for (
			var r = Sb(e.name, i),
				s = [
					{ name: "nameID_" + n, type: "USHORT", value: r },
					{ name: "flags_" + n, type: "USHORT", value: 0 }
				],
				a = 0;
			a < t.length;
			++a
		) {
			var o = t[a].tag;
			s.push({ name: "axis_" + n + " " + o, type: "FIXED", value: e.coordinates[o] << 16 });
		}
		return s;
	}
	function P3(n, e, t, i) {
		var r = {},
			s = new Ze.Parser(n, e);
		(r.name = i[s.parseUShort()] || {}), s.skip("uShort", 1), (r.coordinates = {});
		for (var a = 0; a < t.length; ++a) r.coordinates[t[a].tag] = s.parseFixed();
		return r;
	}
	function D3(n, e) {
		var t = new Ve.Table("fvar", [
			{ name: "version", type: "ULONG", value: 65536 },
			{ name: "offsetToData", type: "USHORT", value: 0 },
			{ name: "countSizePairs", type: "USHORT", value: 2 },
			{ name: "axisCount", type: "USHORT", value: n.axes.length },
			{ name: "axisSize", type: "USHORT", value: 20 },
			{ name: "instanceCount", type: "USHORT", value: n.instances.length },
			{ name: "instanceSize", type: "USHORT", value: 4 + n.axes.length * 4 }
		]);
		t.offsetToData = t.sizeOf();
		for (var i = 0; i < n.axes.length; i++) t.fields = t.fields.concat(C3(i, n.axes[i], e));
		for (var r = 0; r < n.instances.length; r++) t.fields = t.fields.concat(R3(r, n.instances[r], n.axes, e));
		return t;
	}
	function O3(n, e, t) {
		var i = new Ze.Parser(n, e),
			r = i.parseULong();
		tt.argument(r === 65536, "Unsupported fvar table version.");
		var s = i.parseOffset16();
		i.skip("uShort", 1);
		for (var a = i.parseUShort(), o = i.parseUShort(), l = i.parseUShort(), c = i.parseUShort(), u = [], h = 0; h < a; h++) u.push(L3(n, e + s + h * o, t));
		for (var d = [], f = e + s + a * o, v = 0; v < l; v++) d.push(P3(n, f + v * c, u, t));
		return { axes: u, instances: d };
	}
	var I3 = { make: D3, parse: O3 },
		F3 = function () {
			return { coverage: this.parsePointer(ne.coverage), attachPoints: this.parseList(ne.pointer(ne.uShortList)) };
		},
		N3 = function () {
			var n = this.parseUShort();
			if ((tt.argument(n === 1 || n === 2 || n === 3, "Unsupported CaretValue table version."), n === 1)) return { coordinate: this.parseShort() };
			if (n === 2) return { pointindex: this.parseShort() };
			if (n === 3) return { coordinate: this.parseShort() };
		},
		U3 = function () {
			return this.parseList(ne.pointer(N3));
		},
		k3 = function () {
			return { coverage: this.parsePointer(ne.coverage), ligGlyphs: this.parseList(ne.pointer(U3)) };
		},
		B3 = function () {
			return this.parseUShort(), this.parseList(ne.pointer(ne.coverage));
		};
	function z3(n, e) {
		e = e || 0;
		var t = new ne(n, e),
			i = t.parseVersion(1);
		tt.argument(i === 1 || i === 1.2 || i === 1.3, "Unsupported GDEF table version.");
		var r = { version: i, classDef: t.parsePointer(ne.classDef), attachList: t.parsePointer(F3), ligCaretList: t.parsePointer(k3), markAttachClassDef: t.parsePointer(ne.classDef) };
		return i >= 1.2 && (r.markGlyphSets = t.parsePointer(B3)), r;
	}
	var H3 = { parse: z3 },
		sr = new Array(10);
	sr[1] = function () {
		var e = this.offset + this.relativeOffset,
			t = this.parseUShort();
		if (t === 1) return { posFormat: 1, coverage: this.parsePointer(ne.coverage), value: this.parseValueRecord() };
		if (t === 2) return { posFormat: 2, coverage: this.parsePointer(ne.coverage), values: this.parseValueRecordList() };
		tt.assert(!1, "0x" + e.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
	};
	sr[2] = function () {
		var e = this.offset + this.relativeOffset,
			t = this.parseUShort();
		tt.assert(t === 1 || t === 2, "0x" + e.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
		var i = this.parsePointer(ne.coverage),
			r = this.parseUShort(),
			s = this.parseUShort();
		if (t === 1)
			return {
				posFormat: t,
				coverage: i,
				valueFormat1: r,
				valueFormat2: s,
				pairSets: this.parseList(
					ne.pointer(
						ne.list(function () {
							return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(r), value2: this.parseValueRecord(s) };
						})
					)
				)
			};
		if (t === 2) {
			var a = this.parsePointer(ne.classDef),
				o = this.parsePointer(ne.classDef),
				l = this.parseUShort(),
				c = this.parseUShort();
			return {
				posFormat: t,
				coverage: i,
				valueFormat1: r,
				valueFormat2: s,
				classDef1: a,
				classDef2: o,
				class1Count: l,
				class2Count: c,
				classRecords: this.parseList(
					l,
					ne.list(c, function () {
						return { value1: this.parseValueRecord(r), value2: this.parseValueRecord(s) };
					})
				)
			};
		}
	};
	sr[3] = function () {
		return { error: "GPOS Lookup 3 not supported" };
	};
	sr[4] = function () {
		return { error: "GPOS Lookup 4 not supported" };
	};
	sr[5] = function () {
		return { error: "GPOS Lookup 5 not supported" };
	};
	sr[6] = function () {
		return { error: "GPOS Lookup 6 not supported" };
	};
	sr[7] = function () {
		return { error: "GPOS Lookup 7 not supported" };
	};
	sr[8] = function () {
		return { error: "GPOS Lookup 8 not supported" };
	};
	sr[9] = function () {
		return { error: "GPOS Lookup 9 not supported" };
	};
	function G3(n, e) {
		e = e || 0;
		var t = new ne(n, e),
			i = t.parseVersion(1);
		return tt.argument(i === 1 || i === 1.1, "Unsupported GPOS table version " + i), i === 1 ? { version: i, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(sr) } : { version: i, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(sr), variations: t.parseFeatureVariationsList() };
	}
	var V3 = new Array(10);
	function W3(n) {
		return new Ve.Table("GPOS", [
			{ name: "version", type: "ULONG", value: 65536 },
			{ name: "scripts", type: "TABLE", value: new Ve.ScriptList(n.scripts) },
			{ name: "features", type: "TABLE", value: new Ve.FeatureList(n.features) },
			{ name: "lookups", type: "TABLE", value: new Ve.LookupList(n.lookups, V3) }
		]);
	}
	var X3 = { parse: G3, make: W3 };
	function $3(n) {
		var e = {};
		n.skip("uShort");
		var t = n.parseUShort();
		tt.argument(t === 0, "Unsupported kern sub-table version."), n.skip("uShort", 2);
		var i = n.parseUShort();
		n.skip("uShort", 3);
		for (var r = 0; r < i; r += 1) {
			var s = n.parseUShort(),
				a = n.parseUShort(),
				o = n.parseShort();
			e[s + "," + a] = o;
		}
		return e;
	}
	function q3(n) {
		var e = {};
		n.skip("uShort");
		var t = n.parseULong();
		t > 1 && console.warn("Only the first kern subtable is supported."), n.skip("uLong");
		var i = n.parseUShort(),
			r = i & 255;
		if ((n.skip("uShort"), r === 0)) {
			var s = n.parseUShort();
			n.skip("uShort", 3);
			for (var a = 0; a < s; a += 1) {
				var o = n.parseUShort(),
					l = n.parseUShort(),
					c = n.parseShort();
				e[o + "," + l] = c;
			}
		}
		return e;
	}
	function j3(n, e) {
		var t = new Ze.Parser(n, e),
			i = t.parseUShort();
		if (i === 0) return $3(t);
		if (i === 1) return q3(t);
		throw new Error("Unsupported kern table version (" + i + ").");
	}
	var Y3 = { parse: j3 };
	function K3(n, e, t, i) {
		for (var r = new Ze.Parser(n, e), s = i ? r.parseUShort : r.parseULong, a = [], o = 0; o < t + 1; o += 1) {
			var l = s.call(r);
			i && (l *= 2), a.push(l);
		}
		return a;
	}
	var Z3 = { parse: K3 };
	function J3(n, e) {
		var t = new XMLHttpRequest();
		t.open("get", n, !0),
			(t.responseType = "arraybuffer"),
			(t.onload = function () {
				return t.response ? e(null, t.response) : e("Font could not be loaded: " + t.statusText);
			}),
			(t.onerror = function () {
				e("Font could not be loaded");
			}),
			t.send();
	}
	function w_(n, e) {
		for (var t = [], i = 12, r = 0; r < e; r += 1) {
			var s = Ze.getTag(n, i),
				a = Ze.getULong(n, i + 4),
				o = Ze.getULong(n, i + 8),
				l = Ze.getULong(n, i + 12);
			t.push({ tag: s, checksum: a, offset: o, length: l, compression: !1 }), (i += 16);
		}
		return t;
	}
	function Q3(n, e) {
		for (var t = [], i = 44, r = 0; r < e; r += 1) {
			var s = Ze.getTag(n, i),
				a = Ze.getULong(n, i + 4),
				o = Ze.getULong(n, i + 8),
				l = Ze.getULong(n, i + 12),
				c = void 0;
			o < l ? (c = "WOFF") : (c = !1), t.push({ tag: s, offset: a, compression: c, compressedLength: o, length: l }), (i += 20);
		}
		return t;
	}
	function ln(n, e) {
		if (e.compression === "WOFF") {
			var t = new Uint8Array(n.buffer, e.offset + 2, e.compressedLength - 2),
				i = new Uint8Array(e.length);
			if ((VI(t, i), i.byteLength !== e.length)) throw new Error("Decompression error: " + e.tag + " decompressed length doesn't match recorded length");
			var r = new DataView(i.buffer, 0);
			return { data: r, offset: 0 };
		} else return { data: n, offset: e.offset };
	}
	function Eb(n, e) {
		e = e ?? {};
		var t,
			i,
			r = new qt({ empty: !0 }),
			s = new DataView(n, 0),
			a,
			o = [],
			l = Ze.getTag(s, 0);
		if (l === "\0\0\0" || l === "true" || l === "typ1") (r.outlinesFormat = "truetype"), (a = Ze.getUShort(s, 4)), (o = w_(s, a));
		else if (l === "OTTO") (r.outlinesFormat = "cff"), (a = Ze.getUShort(s, 4)), (o = w_(s, a));
		else if (l === "wOFF") {
			var c = Ze.getTag(s, 4);
			if (c === "\0\0\0") r.outlinesFormat = "truetype";
			else if (c === "OTTO") r.outlinesFormat = "cff";
			else throw new Error("Unsupported OpenType flavor " + l);
			(a = Ze.getUShort(s, 12)), (o = Q3(s, a));
		} else throw new Error("Unsupported OpenType signature " + l);
		for (var u, h, d, f, v, _, p, g, x, b, T, P, A = 0; A < a; A += 1) {
			var M = o[A],
				w = void 0;
			switch (M.tag) {
				case "cmap":
					(w = ln(s, M)), (r.tables.cmap = Ux.parse(w.data, w.offset)), (r.encoding = new Bx(r.tables.cmap));
					break;
				case "cvt ":
					(w = ln(s, M)), (P = new Ze.Parser(w.data, w.offset)), (r.tables.cvt = P.parseShortList(M.length / 2));
					break;
				case "fvar":
					h = M;
					break;
				case "fpgm":
					(w = ln(s, M)), (P = new Ze.Parser(w.data, w.offset)), (r.tables.fpgm = P.parseByteList(M.length));
					break;
				case "head":
					(w = ln(s, M)), (r.tables.head = Yx.parse(w.data, w.offset)), (r.unitsPerEm = r.tables.head.unitsPerEm), (t = r.tables.head.indexToLocFormat);
					break;
				case "hhea":
					(w = ln(s, M)), (r.tables.hhea = Kx.parse(w.data, w.offset)), (r.ascender = r.tables.hhea.ascender), (r.descender = r.tables.hhea.descender), (r.numberOfHMetrics = r.tables.hhea.numberOfHMetrics);
					break;
				case "hmtx":
					p = M;
					break;
				case "ltag":
					(w = ln(s, M)), (i = Jx.parse(w.data, w.offset));
					break;
				case "COLR":
					(w = ln(s, M)), (r.tables.colr = lb.parse(w.data, w.offset));
					break;
				case "CPAL":
					(w = ln(s, M)), (r.tables.cpal = cb.parse(w.data, w.offset));
					break;
				case "maxp":
					(w = ln(s, M)), (r.tables.maxp = Qx.parse(w.data, w.offset)), (r.numGlyphs = r.tables.maxp.numGlyphs);
					break;
				case "name":
					b = M;
					break;
				case "OS/2":
					(w = ln(s, M)), (r.tables.os2 = fp.parse(w.data, w.offset));
					break;
				case "post":
					(w = ln(s, M)), (r.tables.post = sb.parse(w.data, w.offset)), (r.glyphNames = new lm(r.tables.post));
					break;
				case "prep":
					(w = ln(s, M)), (P = new Ze.Parser(w.data, w.offset)), (r.tables.prep = P.parseByteList(M.length));
					break;
				case "glyf":
					d = M;
					break;
				case "loca":
					x = M;
					break;
				case "CFF ":
					u = M;
					break;
				case "kern":
					g = M;
					break;
				case "GDEF":
					f = M;
					break;
				case "GPOS":
					v = M;
					break;
				case "GSUB":
					_ = M;
					break;
				case "meta":
					T = M;
					break;
			}
		}
		var y = ln(s, b);
		if (((r.tables.name = rb.parse(y.data, y.offset, i)), (r.names = r.tables.name), d && x)) {
			var S = t === 0,
				L = ln(s, x),
				N = Z3.parse(L.data, L.offset, r.numGlyphs, S),
				k = ln(s, d);
			r.glyphs = pb.parse(k.data, k.offset, N, r, e);
		} else if (u) {
			var B = ln(s, u);
			jx.parse(B.data, B.offset, r, e);
		} else throw new Error("Font doesn't contain TrueType or CFF outlines.");
		var W = ln(s, p);
		if ((Zx.parse(r, W.data, W.offset, r.numberOfHMetrics, r.numGlyphs, r.glyphs, e), uF(r, e), g)) {
			var H = ln(s, g);
			r.kerningPairs = Y3.parse(H.data, H.offset);
		} else r.kerningPairs = {};
		if (f) {
			var z = ln(s, f);
			r.tables.gdef = H3.parse(z.data, z.offset);
		}
		if (v) {
			var X = ln(s, v);
			(r.tables.gpos = X3.parse(X.data, X.offset)), r.position.init();
		}
		if (_) {
			var K = ln(s, _);
			r.tables.gsub = ab.parse(K.data, K.offset);
		}
		if (h) {
			var G = ln(s, h);
			r.tables.fvar = I3.parse(G.data, G.offset, r.names);
		}
		if (T) {
			var ue = ln(s, T);
			(r.tables.meta = ob.parse(ue.data, ue.offset)), (r.metas = r.tables.meta);
		}
		return r;
	}
	function ek(n, e, t) {
		return (
			(t = t ?? {}),
			new Promise(function (i, r) {
				J3(n, function (s, a) {
					if (s) {
						if (e) return e(s);
						r(s);
					}
					var o;
					try {
						o = Eb(a, t);
					} catch (l) {
						if (e) return e(l, null);
						r(l);
					}
					if (e) return e(null, o);
					i(o);
				});
			})
		);
	}
	var tk = Object.freeze({ __proto__: null, Font: qt, Glyph: vi, Path: Tn, BoundingBox: Qr, _parse: Ze, parse: Eb, load: ek });
	class nk extends Ma {
		constructor(e) {
			super(e), (this.reversed = !1);
		}
		load(e, t, i, r) {
			const s = this,
				a = new em(this.manager);
			a.setPath(this.path),
				a.setResponseType("arraybuffer"),
				a.setRequestHeader(this.requestHeader),
				a.setWithCredentials(this.withCredentials),
				a.load(
					e,
					function (o) {
						try {
							t(s.parse(o));
						} catch (l) {
							r ? r(l) : console.error(l), s.manager.itemError(e);
						}
					},
					i,
					r
				);
		}
		parse(e) {
			function t(r, s) {
				const a = Math.round,
					o = {},
					l = 1e5 / ((r.unitsPerEm || 2048) * 72),
					c = r.encoding.cmap.glyphIndexMap,
					u = Object.keys(c);
				for (let h = 0; h < u.length; h++) {
					const d = u[h],
						f = r.glyphs.glyphs[c[d]];
					if (d !== void 0) {
						const v = { ha: a(f.advanceWidth * l), x_min: a(f.xMin * l), x_max: a(f.xMax * l), o: "" };
						s && (f.path.commands = i(f.path.commands)),
							f.path.commands.forEach(function (_) {
								_.type.toLowerCase() === "c" && (_.type = "b"), (v.o += _.type.toLowerCase() + " "), _.x !== void 0 && _.y !== void 0 && (v.o += a(_.x * l) + " " + a(_.y * l) + " "), _.x1 !== void 0 && _.y1 !== void 0 && (v.o += a(_.x1 * l) + " " + a(_.y1 * l) + " "), _.x2 !== void 0 && _.y2 !== void 0 && (v.o += a(_.x2 * l) + " " + a(_.y2 * l) + " ");
							}),
							(o[String.fromCodePoint(f.unicode)] = v);
					}
				}
				return { glyphs: o, familyName: r.getEnglishName("fullName"), ascender: a(r.ascender * l), descender: a(r.descender * l), underlinePosition: r.tables.post.underlinePosition, underlineThickness: r.tables.post.underlineThickness, boundingBox: { xMin: r.tables.head.xMin, xMax: r.tables.head.xMax, yMin: r.tables.head.yMin, yMax: r.tables.head.yMax }, resolution: 1e3, original_font_information: r.tables.name };
			}
			function i(r) {
				const s = [];
				let a;
				r.forEach(function (l) {
					l.type.toLowerCase() === "m" ? ((a = [l]), s.push(a)) : l.type.toLowerCase() !== "z" && a.push(l);
				});
				const o = [];
				return (
					s.forEach(function (l) {
						const c = { type: "m", x: l[l.length - 1].x, y: l[l.length - 1].y };
						o.push(c);
						for (let u = l.length - 1; u > 0; u--) {
							const h = l[u],
								d = { type: h.type };
							h.x2 !== void 0 && h.y2 !== void 0 ? ((d.x1 = h.x2), (d.y1 = h.y2), (d.x2 = h.x1), (d.y2 = h.y1)) : h.x1 !== void 0 && h.y1 !== void 0 && ((d.x1 = h.x1), (d.y1 = h.y1)), (d.x = l[u - 1].x), (d.y = l[u - 1].y), o.push(d);
						}
					}),
					o
				);
			}
			return t(tk.parse(e), this.reversed);
		}
	}
	let Ki;
	function ik() {
		new nk().load("./assets/fonts/Roboto/Roboto-Regular.ttf", function (e) {
			Ki = new OI(e);
		});
	}
	function Pi(n, e, t, i, r, s) {
		e = e || "white";
		const a = t.pointID,
			o = t.blastName,
			l = t.uuid,
			c = new D(t.startXLocation, t.startYLocation, t.startZLocation),
			u = new D(t.endXLocation, t.endYLocation, t.endZLocation),
			h = r > 0 ? Bu(c, u, r) : r === 0 ? Bu(c, u, 1e-4) : r < 0 ? Bu(c, u, r) : u;
		console.log("drawHoles/intervalXYZ: ", h);
		const d = t.shapeType,
			v = i * 3,
			_ = 100;
		switch (d) {
			case "mesh-cube": {
				TI(n, e, "basic", l, o, a, c, h, u, v, r, 4), le.debugComments;
				break;
			}
			case "mesh-cylinder": {
				SI(n, e, "phong", l, o, a, c, h, u, v, r, 32), le.debugComments && console.log("BlastGroup: ", o, " AddingHole: ", a, " uuid:", l, " withSubdrill: ", r, " and Holelength: ", c.distanceTo(u));
				break;
			}
			case "mesh-cross": {
				bI(n, e, "basic", l, o, a, c, h, u, v, r, 4), le.debugComments;
				break;
			}
			case "mesh-circle": {
				k0(n, e, "basic", l, o, a, c, h, u, v, _, 4, 32, 2 * Math.PI), le.debugComments;
				break;
			}
			case "mesh-diamond": {
				EI(n, e, "basic", l, o, a, c, h, u, v, _, 4, 4, 2 * Math.PI, !1), le.debugComments;
				break;
			}
			case "mesh-square": {
				wI(n, e, "basic", l, o, a, c, h, u, v, _, 4, 4, 2 * Math.PI, !0), le.debugComments;
				break;
			}
			case "line-cross": {
				CI(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1), le.debugComments;
				break;
			}
			case "outline-circle": {
				B0(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1, !1), le.debugComments;
				break;
			}
			case "filled-circle": {
				B0(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1, !0), le.debugComments;
				break;
			}
			case "line-diamond": {
				RI(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1), le.debugComments;
				break;
			}
			case "line-square": {
				PI(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1), le.debugComments;
				break;
			}
			case "line-triangle": {
				DI(n, e, l, o, a, c, h, u, v, 2, !1, 0, 0, 1, !1), le.debugComments;
				break;
			}
			default: {
				k0(n, e, "basic", l, o, a, c, h, u, v, 100, 4, 32, 2 * Math.PI), le.debugComments;
				break;
			}
		}
		wb(n, e, t);
	}
	function wb(n, e, t) {
		e = e || "white";
		const i = t.pointID,
			r = t.uuid,
			s = t.blastName,
			a = new D(t.startXLocation, t.startYLocation, t.startZLocation),
			o = t.endXLocation && t.endYLocation && t.endZLocation ? new D(t.endXLocation, t.endYLocation, t.endZLocation) : null;
		t.endXLocation && t.endYLocation && t.endZLocation && t.subdrill > 0 && Bu(a, o, t.subdrill), t.diameter * 3;
		let c = 1,
			u = i.length;
		if ((le.holeNameDisplay && Ki && Nu(n, e, Ki, { x: a.x - u / 2, y: a.y + c / 2, z: a.z + 0.1 }, r, s, i, "holeNameText"), le.holeLengthDisplay && o && Ki)) {
			const h = a.distanceTo(o).toFixed(1);
			Nu(n, "#00aaFF", Ki, { x: a.x - u / 2, y: a.y - c, z: a.z + 0.1 }, r, s, h, "holeLengthText");
		}
		if (le.holeDiameterDisplay && t.diameter && Ki) {
			const h = t.diameter;
			Nu(n, "#33AA22", Ki, { x: a.x - u / 2, y: a.y - c, z: a.z + 0.1 }, r, s, h.toFixed(0), "holeDiameterText");
		}
		!le.holeNameDisplay && !le.holeLengthDisplay && le.holeDiameterDisplay;
	}
	function Tb(n, e, t) {
		const i = t.pointID,
			r = "basic",
			s = t.uuid,
			a = t.blastName,
			o = new D(t.startXLocation, t.startYLocation, t.startZLocation);
		xI(n, e, r, s, a, i, o, 100), le.debugComments, Ki && Nu(n, e, Ki, s, a, o, i);
	}
	function Bu(n, e, t) {
		const i = n instanceof D ? n : new D(n.x, n.y, n.z),
			r = e instanceof D ? e : new D(e.x, e.y, e.z),
			s = new D().subVectors(r, i),
			a = s.length();
		s.normalize();
		let o = t;
		return a < t && (o = a), new D().addVectors(r, s.multiplyScalar(-o));
	}
	const af = { type: "change" },
		of = { type: "start" },
		lf = { type: "end" };
	class rk extends Ns {
		constructor(e, t) {
			super();
			const i = this,
				r = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
			(this.object = e),
				(this.domElement = t),
				(this.domElement.style.touchAction = "none"),
				(this.enabled = !0),
				(this.screen = { left: 0, top: 0, width: 0, height: 0 }),
				(this.rotateSpeed = 1),
				(this.zoomSpeed = 1.2),
				(this.panSpeed = 0.3),
				(this.noRotate = !1),
				(this.noZoom = !1),
				(this.noPan = !1),
				(this.staticMoving = !1),
				(this.dynamicDampingFactor = 0.2),
				(this.minDistance = 0),
				(this.maxDistance = 1 / 0),
				(this.minZoom = 0),
				(this.maxZoom = 1 / 0),
				(this.keys = ["KeyA", "KeyS", "KeyD"]),
				(this.mouseButtons = { LEFT: hd.ROTATE, MIDDLE: hd.DOLLY, RIGHT: hd.PAN }),
				(this.target = new D());
			const s = 1e-6,
				a = new D();
			let o = 1,
				l = r.NONE,
				c = r.NONE,
				u = 0,
				h = 0,
				d = 0;
			const f = new D(),
				v = new Se(),
				_ = new Se(),
				p = new D(),
				g = new Se(),
				x = new Se(),
				b = new Se(),
				T = new Se(),
				P = [],
				A = {};
			(this.target0 = this.target.clone()),
				(this.position0 = this.object.position.clone()),
				(this.up0 = this.object.up.clone()),
				(this.zoom0 = this.object.zoom),
				(this.handleResize = function () {
					const V = i.domElement.getBoundingClientRect(),
						j = i.domElement.ownerDocument.documentElement;
					(i.screen.left = V.left + window.pageXOffset - j.clientLeft), (i.screen.top = V.top + window.pageYOffset - j.clientTop), (i.screen.width = V.width), (i.screen.height = V.height);
				});
			const M = (function () {
					const V = new Se();
					return function (he, xe) {
						return V.set((he - i.screen.left) / i.screen.width, (xe - i.screen.top) / i.screen.height), V;
					};
				})(),
				w = (function () {
					const V = new Se();
					return function (he, xe) {
						return V.set((he - i.screen.width * 0.5 - i.screen.left) / (i.screen.width * 0.5), (i.screen.height + 2 * (i.screen.top - xe)) / i.screen.width), V;
					};
				})();
			(this.rotateCamera = (function () {
				const V = new D(),
					j = new En(),
					he = new D(),
					xe = new D(),
					He = new D(),
					F = new D();
				return function () {
					F.set(_.x - v.x, _.y - v.y, 0);
					let pe = F.length();
					pe
						? (f.copy(i.object.position).sub(i.target), he.copy(f).normalize(), xe.copy(i.object.up).normalize(), He.crossVectors(xe, he).normalize(), xe.setLength(_.y - v.y), He.setLength(_.x - v.x), F.copy(xe.add(He)), V.crossVectors(F, f).normalize(), (pe *= i.rotateSpeed), j.setFromAxisAngle(V, pe), f.applyQuaternion(j), i.object.up.applyQuaternion(j), p.copy(V), (d = pe))
						: !i.staticMoving && d && ((d *= Math.sqrt(1 - i.dynamicDampingFactor)), f.copy(i.object.position).sub(i.target), j.setFromAxisAngle(p, d), f.applyQuaternion(j), i.object.up.applyQuaternion(j)),
						v.copy(_);
				};
			})()),
				(this.zoomCamera = function () {
					let V;
					l === r.TOUCH_ZOOM_PAN
						? ((V = u / h), (u = h), i.object.isPerspectiveCamera ? f.multiplyScalar(V) : i.object.isOrthographicCamera ? ((i.object.zoom = an.clamp(i.object.zoom / V, i.minZoom, i.maxZoom)), o !== i.object.zoom && i.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type"))
						: ((V = 1 + (x.y - g.y) * i.zoomSpeed), V !== 1 && V > 0 && (i.object.isPerspectiveCamera ? f.multiplyScalar(V) : i.object.isOrthographicCamera ? ((i.object.zoom = an.clamp(i.object.zoom / V, i.minZoom, i.maxZoom)), o !== i.object.zoom && i.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), i.staticMoving ? g.copy(x) : (g.y += (x.y - g.y) * this.dynamicDampingFactor));
				}),
				(this.panCamera = (function () {
					const V = new Se(),
						j = new D(),
						he = new D();
					return function () {
						if ((V.copy(T).sub(b), V.lengthSq())) {
							if (i.object.isOrthographicCamera) {
								const He = (i.object.right - i.object.left) / i.object.zoom / i.domElement.clientWidth,
									F = (i.object.top - i.object.bottom) / i.object.zoom / i.domElement.clientWidth;
								(V.x *= He), (V.y *= F);
							}
							V.multiplyScalar(f.length() * i.panSpeed), he.copy(f).cross(i.object.up).setLength(V.x), he.add(j.copy(i.object.up).setLength(V.y)), i.object.position.add(he), i.target.add(he), i.staticMoving ? b.copy(T) : b.add(V.subVectors(T, b).multiplyScalar(i.dynamicDampingFactor));
						}
					};
				})()),
				(this.checkDistances = function () {
					(!i.noZoom || !i.noPan) && (f.lengthSq() > i.maxDistance * i.maxDistance && (i.object.position.addVectors(i.target, f.setLength(i.maxDistance)), g.copy(x)), f.lengthSq() < i.minDistance * i.minDistance && (i.object.position.addVectors(i.target, f.setLength(i.minDistance)), g.copy(x)));
				}),
				(this.update = function () {
					f.subVectors(i.object.position, i.target),
						i.noRotate || i.rotateCamera(),
						i.noZoom || i.zoomCamera(),
						i.noPan || i.panCamera(),
						i.object.position.addVectors(i.target, f),
						i.object.isPerspectiveCamera ? (i.checkDistances(), i.object.lookAt(i.target), a.distanceToSquared(i.object.position) > s && (i.dispatchEvent(af), a.copy(i.object.position))) : i.object.isOrthographicCamera ? (i.object.lookAt(i.target), (a.distanceToSquared(i.object.position) > s || o !== i.object.zoom) && (i.dispatchEvent(af), a.copy(i.object.position), (o = i.object.zoom))) : console.warn("THREE.TrackballControls: Unsupported camera type");
				}),
				(this.reset = function () {
					(l = r.NONE), (c = r.NONE), i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.up.copy(i.up0), (i.object.zoom = i.zoom0), i.object.updateProjectionMatrix(), f.subVectors(i.object.position, i.target), i.object.lookAt(i.target), i.dispatchEvent(af), a.copy(i.object.position), (o = i.object.zoom);
				});
			function y(V) {
				i.enabled !== !1 && (P.length === 0 && (i.domElement.setPointerCapture(V.pointerId), i.domElement.addEventListener("pointermove", S), i.domElement.addEventListener("pointerup", L)), Ue(V), V.pointerType === "touch" ? K(V) : W(V));
			}
			function S(V) {
				i.enabled !== !1 && (V.pointerType === "touch" ? G(V) : H(V));
			}
			function L(V) {
				i.enabled !== !1 && (V.pointerType === "touch" ? ue(V) : z(), Z(V), P.length === 0 && (i.domElement.releasePointerCapture(V.pointerId), i.domElement.removeEventListener("pointermove", S), i.domElement.removeEventListener("pointerup", L)));
			}
			function N(V) {
				Z(V);
			}
			function k(V) {
				i.enabled !== !1 && (window.removeEventListener("keydown", k), c === r.NONE && (V.code === i.keys[r.ROTATE] && !i.noRotate ? (c = r.ROTATE) : V.code === i.keys[r.ZOOM] && !i.noZoom ? (c = r.ZOOM) : V.code === i.keys[r.PAN] && !i.noPan && (c = r.PAN)));
			}
			function B() {
				i.enabled !== !1 && ((c = r.NONE), window.addEventListener("keydown", k));
			}
			function W(V) {
				if (l === r.NONE)
					switch (V.button) {
						case i.mouseButtons.LEFT:
							l = r.ROTATE;
							break;
						case i.mouseButtons.MIDDLE:
							l = r.ZOOM;
							break;
						case i.mouseButtons.RIGHT:
							l = r.PAN;
							break;
					}
				const j = c !== r.NONE ? c : l;
				j === r.ROTATE && !i.noRotate ? (_.copy(w(V.pageX, V.pageY)), v.copy(_)) : j === r.ZOOM && !i.noZoom ? (g.copy(M(V.pageX, V.pageY)), x.copy(g)) : j === r.PAN && !i.noPan && (b.copy(M(V.pageX, V.pageY)), T.copy(b)), i.dispatchEvent(of);
			}
			function H(V) {
				const j = c !== r.NONE ? c : l;
				j === r.ROTATE && !i.noRotate ? (v.copy(_), _.copy(w(V.pageX, V.pageY))) : j === r.ZOOM && !i.noZoom ? x.copy(M(V.pageX, V.pageY)) : j === r.PAN && !i.noPan && T.copy(M(V.pageX, V.pageY));
			}
			function z() {
				(l = r.NONE), i.dispatchEvent(lf);
			}
			function X(V) {
				if (i.enabled !== !1 && i.noZoom !== !0) {
					switch ((V.preventDefault(), V.deltaMode)) {
						case 2:
							g.y -= V.deltaY * 0.025;
							break;
						case 1:
							g.y -= V.deltaY * 0.01;
							break;
						default:
							g.y -= V.deltaY * 25e-5;
							break;
					}
					i.dispatchEvent(of), i.dispatchEvent(lf);
				}
			}
			function K(V) {
				switch ((ie(V), P.length)) {
					case 1:
						(l = r.TOUCH_ROTATE), _.copy(w(P[0].pageX, P[0].pageY)), v.copy(_);
						break;
					default:
						l = r.TOUCH_ZOOM_PAN;
						const j = P[0].pageX - P[1].pageX,
							he = P[0].pageY - P[1].pageY;
						h = u = Math.sqrt(j * j + he * he);
						const xe = (P[0].pageX + P[1].pageX) / 2,
							He = (P[0].pageY + P[1].pageY) / 2;
						b.copy(M(xe, He)), T.copy(b);
						break;
				}
				i.dispatchEvent(of);
			}
			function G(V) {
				switch ((ie(V), P.length)) {
					case 1:
						v.copy(_), _.copy(w(V.pageX, V.pageY));
						break;
					default:
						const j = ge(V),
							he = V.pageX - j.x,
							xe = V.pageY - j.y;
						h = Math.sqrt(he * he + xe * xe);
						const He = (V.pageX + j.x) / 2,
							F = (V.pageY + j.y) / 2;
						T.copy(M(He, F));
						break;
				}
			}
			function ue(V) {
				switch (P.length) {
					case 0:
						l = r.NONE;
						break;
					case 1:
						(l = r.TOUCH_ROTATE), _.copy(w(V.pageX, V.pageY)), v.copy(_);
						break;
					case 2:
						l = r.TOUCH_ZOOM_PAN;
						for (let j = 0; j < P.length; j++)
							if (P[j].pointerId !== V.pointerId) {
								const he = A[P[j].pointerId];
								_.copy(w(he.x, he.y)), v.copy(_);
								break;
							}
						break;
				}
				i.dispatchEvent(lf);
			}
			function ae(V) {
				i.enabled !== !1 && V.preventDefault();
			}
			function Ue(V) {
				P.push(V);
			}
			function Z(V) {
				delete A[V.pointerId];
				for (let j = 0; j < P.length; j++)
					if (P[j].pointerId == V.pointerId) {
						P.splice(j, 1);
						return;
					}
			}
			function ie(V) {
				let j = A[V.pointerId];
				j === void 0 && ((j = new Se()), (A[V.pointerId] = j)), j.set(V.pageX, V.pageY);
			}
			function ge(V) {
				const j = V.pointerId === P[0].pointerId ? P[1] : P[0];
				return A[j.pointerId];
			}
			(this.dispose = function () {
				i.domElement.removeEventListener("contextmenu", ae), i.domElement.removeEventListener("pointerdown", y), i.domElement.removeEventListener("pointercancel", N), i.domElement.removeEventListener("wheel", X), i.domElement.removeEventListener("pointermove", S), i.domElement.removeEventListener("pointerup", L), window.removeEventListener("keydown", k), window.removeEventListener("keyup", B);
			}),
				this.domElement.addEventListener("contextmenu", ae),
				this.domElement.addEventListener("pointerdown", y),
				this.domElement.addEventListener("pointercancel", N),
				this.domElement.addEventListener("wheel", X, { passive: !1 }),
				window.addEventListener("keydown", k),
				window.addEventListener("keyup", B),
				this.handleResize(),
				this.update();
		}
	}
	const gs = {};
	function Cs() {
		gs.worldXCenter && gs.worldXCenter.updateDisplay(), gs.worldYCenter && gs.worldYCenter.updateDisplay(), gs.worldZCenter && gs.worldZCenter.updateDisplay(), gs.cameraDistance && gs.cameraDistance.updateDisplay(), localStorage.setItem("WorldOriginSettings", JSON.stringify(le));
	}
	const sk = () => {
		console.log("World Origin Settings Button Clicked"),
			document.getElementById("settings-world").addEventListener("click", function () {
				const n = document.createElement("div");
				(n.className = "modal fade"),
					(n.id = "world-origin-settings-modal"),
					(n.innerHTML = `
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">World Origin Settings</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form>
                            <div class="mb-3">
                                <label for="world-x" class="form-label">World X Center</label>
                                <input type="number" class="form-control" id="world-x" placeholder="Enter the world x center value" value="${le.worldXCenter}">
                            </div>
                            <div class="mb-3">
                                <label for="world-y" class="form-label">World Y Center</label>
                                <input type="number" class="form-control" id="world-y" placeholder="Enter the world y center value" value="${le.worldYCenter}">
                            </div>
							<!-- Hidden Z center input
                            <div class="mb-3">
                                <label for="world-z" class="form-label">World Z Center</label>
                                <input type="number" class="form-control" id="world-z" placeholder="Enter the world z center value" value="${le.worldZCenter}">
                            </div>
                            <div class="mb-3">
                                <label for="information">Z level data is not shifted, this only adjust the look-at-elevation.</label>
                            </div>
							--> 
                            <div class="mb-3">
                                <label for="camera-distance" class="form-label">Camera Distance</label>
                                <input type="number" class="form-control" id="camera-distance" placeholder="Enter the camera distance value" value="${le.cameraDistance}">
                        </form>
                    </div>
					
                    <div class="modal-footer">
						<button type="button" class="btn btn-danger" id="clear-world-origin-settings">Clear</button>
						<div class="col mx-3">
                			<!-- Horizontal spacer -->
            			</div>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" id="apply-world-origin-settings">Apply</button>
                        <button type="button" class="btn btn-success" id="save-world-origin-settings">Save</button>
                    </div>
                </div>
            </div>
        `),
					document.body.appendChild(n);
				const e = new window.bootstrap.Modal(n);
				e.show(),
					document.getElementById("clear-world-origin-settings").addEventListener("click", function () {
						alert(`Warning: Clearing the world origin settings
will reset the display origin and may cause display issues!`),
							(le.worldXCenter = 0),
							(le.worldYCenter = 0),
							(le.worldZCenter = 0),
							(document.getElementById("world-x").value = 0),
							(document.getElementById("world-y").value = 0),
							console.log("World Origin Settings Cleared: (x)", le.worldXCenter, " (y)", le.worldYCenter, " (z)", le.worldZCenter),
							Cs();
					}),
					document.getElementById("apply-world-origin-settings").addEventListener("click", function () {
						const t = document.getElementById("world-x").value,
							i = document.getElementById("world-y").value,
							r = document.getElementById("camera-distance").value,
							s = parseFloat(t),
							a = parseFloat(i),
							o = parseFloat(r);
						isNaN(s) || isNaN(a) || isNaN(o) ? alert("Invalid input. Please enter valid numbers.") : ((le.worldXCenter = s), (le.worldYCenter = a), (le.cameraDistance = o), console.log("World Origin Settings Applied: (x)", le.worldXCenter, " (y)", le.worldYCenter, " (z)", le.worldZCenter, " (camera distance)", le.cameraDistance), Cs());
					}),
					document.getElementById("save-world-origin-settings").addEventListener("click", function () {
						const t = document.getElementById("world-x").value,
							i = document.getElementById("world-y").value,
							r = document.getElementById("camera-distance").value,
							s = parseFloat(t),
							a = parseFloat(i),
							o = parseFloat(r);
						isNaN(s) || isNaN(a) || isNaN(o) ? alert("Invalid input. Please enter valid numbers.") : ((le.worldXCenter = s), (le.worldYCenter = a), (le.cameraDistance = o), console.log("World Origin Settings Saved: (x)", le.worldXCenter, " (y)", le.worldYCenter, " (z)", le.worldZCenter, " (camera distance)", le.cameraDistance), Cs(), e.hide(), n.remove());
					});
			});
	};
	let po = new Set(),
		oh = new Map(),
		rn = null;
	function Mb(n, e, t, i) {
		const r = document.createElement("div");
		if (((r.className = "tree-node"), (r.textContent = e.name || e.type), (r.dataset.objectId = e.id), e.children && e.children.length > 0)) {
			const s = document.createElement("span");
			(s.textContent = "►"),
				(s.style.cursor = "pointer"),
				(s.style.marginRight = "5px"),
				r.prepend(s),
				s.addEventListener("click", () => {
					const a = r.nextElementSibling;
					a.style.display === "none" ? ((a.style.display = "block"), (s.textContent = "▼")) : ((a.style.display = "none"), (s.textContent = "►"));
				});
		}
		if (
			(r.addEventListener("click", (s) => {
				ok(e, r, t, i, s);
			}),
			r.addEventListener("contextmenu", (s) => {
				s.preventDefault(), hk(s, e, i, t);
			}),
			n.appendChild(r),
			e.children && e.children.length > 0)
		) {
			const s = document.createElement("div");
			(s.className = "tree-children"), (s.style.display = "none"), n.appendChild(s), e.children.forEach((a) => Mb(s, a, t, i));
		}
	}
	function es(n, e) {
		const t = document.getElementById("objectPanel");
		(t.innerHTML = ""), n.children.forEach((i) => Mb(t, i, e, n));
	}
	function ak(n, e) {
		if (oh.has(n.uuid)) return;
		const t = new WO(n, 65280);
		t.update(), e.add(t), oh.set(n.uuid, t);
	}
	function mp(n, e) {
		const t = oh.get(n.uuid);
		t && (e.remove(t), t.geometry.dispose(), oh.delete(n.uuid));
	}
	function ok(n, e, t, i, r) {
		const s = r.shiftKey;
		if (po.has(n)) {
			mp(n, i), po.delete(n), e.classList.remove("selected");
			return;
		}
		s ||
			(po.forEach((o) => {
				mp(o, i);
				const l = `[data-object-id='${CSS.escape(o.id)}']`,
					c = document.querySelector(l);
				c && c.classList.remove("selected");
			}),
			po.clear()),
			ak(n, i),
			po.add(n),
			e.classList.add("selected");
	}
	const lk = { pointCloud: "CSV_PointCloudStore", k3dBlast: "K3D_BlastStore", csvBlast: "CSV_BlastStore", objMesh: "OBJ_MeshStore" };
	async function ck(n) {
		const e = await Zl();
		console.log("Attempting to find the store containing the object: " + n);
		for (const t of Object.values(lk))
			try {
				const i = await mh(e, t);
				for (const r of i) for (const s of r) if (s.uuid === n) return console.log("Match found in store: " + t), t;
			} catch (i) {
				console.warn("Error checking store " + t + ": " + i);
			}
		return console.warn("Object not found in any store."), null;
	}
	async function uk(n, e) {
		const t = n.userData.uuid,
			i = await ck(t);
		if (i)
			try {
				await AA("Kirra3D_Database", i, t), console.log("Object deleted from the database (Store: " + i + ").");
			} catch (r) {
				console.error("Failed to delete the object from the store (" + i + "): " + r), alert("Failed to delete the object from the database.");
			}
		else console.warn("Object not found in any store.");
	}
	let $i = !1;
	function hk(n, e, t, i) {
		rn && !$i && (rn.remove(), (rn = null)), ($i = !1), (rn = document.createElement("div")), (rn.style.position = "absolute"), (rn.style.left = `${n.pageX}px`), (rn.style.top = `${n.pageY}px`), (rn.style.backgroundColor = "#333"), (rn.style.color = "#fff"), (rn.style.padding = "10px"), (rn.style.borderRadius = "5px"), (rn.style.zIndex = 1e3);
		const r = document.createElement("div");
		(r.textContent = "Delete Object"),
			(r.style.cursor = "pointer"),
			r.addEventListener("click", async () => {
				rn && !$i && (($i = !0), await uk(e), await dk(e, t), rn.remove(), (rn = null), ($i = !1));
			}),
			rn.appendChild(r);
		const s = document.createElement("div");
		(s.textContent = "Look at Object"),
			(s.style.cursor = "pointer"),
			s.addEventListener("click", () => {
				rn && !$i && (($i = !0), i.lookAt(e.position), rn.remove(), (rn = null), ($i = !1));
			}),
			rn.appendChild(s),
			document.body.appendChild(rn),
			document.addEventListener(
				"click",
				() => {
					rn && !$i && (($i = !0), rn.remove(), (rn = null), ($i = !1));
				},
				{ once: !0 }
			);
	}
	function dk(n, e) {
		var i, r;
		mp(n, e), e.remove(n), (i = n.geometry) == null || i.dispose(), (r = n.material) == null || r.dispose(), po.delete(n);
		const t = document.querySelector(`[data-object-id='${CSS.escape(n.id)}']`);
		t && t.remove(), console.log("Object " + (n.name || n.type) + " deleted from the scene.");
	}
	let ys = [],
		_l = 0,
		yl = 0,
		ta = { x: 0, y: 0, z: 0 };
	function fk(n) {
		if (!n) return;
		const e = new FileReader();
		(e.onload = function (t) {
			const i = t.target.result;
			if (!n.name.toLowerCase().endsWith(".k3d")) return;
			const r = "K3D_BlastStore";
			ys.length = 0;
			const s = OA(i, r);
			if (
				(ys.push(...s),
				le.worldXCenter === 0 && le.worldYCenter === 0 ? ((_l = Rl(ys).x), (yl = Rl(ys).y), (le.worldXCenter = _l), (le.worldYCenter = yl), Cs()) : ((_l = le.worldXCenter || 0), (yl = le.worldYCenter || 0)),
				le.debugComments,
				i
					.split(
						`
`
					)[0]
					.split(",").length === 12)
			)
				for (const a of ys) {
					const o = { uuid: a.uuid, blastName: a.blastName, pointID: a.pointID, startXLocation: a.startXLocation - _l, startYLocation: a.startYLocation - yl, startZLocation: a.startZLocation, endXLocation: a.endXLocation - _l, endYLocation: a.endYLocation - yl, endZLocation: a.endZLocation, diameter: a.diameter, subdrill: a.subdrill, shapeType: a.shapeType, holeColour: a.holeColour };
					wb(Bt, o.holeColour, o), Pi(Bt, o.holeColour, o, o.diameter, o.subdrill, o.shapeType);
				}
			else
				alert(`Invalid file format

Check the columns in the file.
blastName,pointID,startXLocation,startYLocation,
startZLocation,endXLocation,endYLocation,
endZLocation,diameter,subdrill,
shapeType,holeColour`);
			le.debugComments,
				le.debugComments && (console.log("fileK3DUpload/handleFileUploadNoEvent/points: ", ys), console.log("Objects in scene: ", Bt.children)),
				(ta = Rl(ys)),
				cn.position.set(ta.x - le.worldXCenter, ta.y - le.worldYCenter, ta.z),
				ft.position.set(cn.position.x, cn.position.y, parseFloat(le.cameraDistance)),
				Ct.target.set(ta.x - le.worldXCenter, ta.y - le.worldYCenter, ta.z),
				ft.lookAt(cn.position),
				ft.updateProjectionMatrix(),
				Ct.update(),
				es(Bt, ft),
				le.debugComments && console.log("fileUpload/handleFileUploadNoEvent/controls.target", Ct.target),
				ft.updateMatrixWorld();
		}),
			e.readAsText(n);
	}
	const pk = /^[og]\s*(.+)?/,
		mk = /^mtllib /,
		gk = /^usemtl /,
		vk = /^usemap /,
		T_ = /\s+/,
		M_ = new D(),
		cf = new D(),
		A_ = new D(),
		C_ = new D(),
		Ci = new D(),
		xu = new rt();
	function _k() {
		const n = {
			objects: [],
			object: {},
			vertices: [],
			normals: [],
			colors: [],
			uvs: [],
			materials: {},
			materialLibraries: [],
			startObject: function (e, t) {
				if (this.object && this.object.fromDeclaration === !1) {
					(this.object.name = e), (this.object.fromDeclaration = t !== !1);
					return;
				}
				const i = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
				if (
					(this.object && typeof this.object._finalize == "function" && this.object._finalize(!0),
					(this.object = {
						name: e || "",
						fromDeclaration: t !== !1,
						geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: !1 },
						materials: [],
						smooth: !0,
						startMaterial: function (r, s) {
							const a = this._finalize(!1);
							a && (a.inherited || a.groupCount <= 0) && this.materials.splice(a.index, 1);
							const o = {
								index: this.materials.length,
								name: r || "",
								mtllib: Array.isArray(s) && s.length > 0 ? s[s.length - 1] : "",
								smooth: a !== void 0 ? a.smooth : this.smooth,
								groupStart: a !== void 0 ? a.groupEnd : 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: !1,
								clone: function (l) {
									const c = { index: typeof l == "number" ? l : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 };
									return (c.clone = this.clone.bind(c)), c;
								}
							};
							return this.materials.push(o), o;
						},
						currentMaterial: function () {
							if (this.materials.length > 0) return this.materials[this.materials.length - 1];
						},
						_finalize: function (r) {
							const s = this.currentMaterial();
							if ((s && s.groupEnd === -1 && ((s.groupEnd = this.geometry.vertices.length / 3), (s.groupCount = s.groupEnd - s.groupStart), (s.inherited = !1)), r && this.materials.length > 1)) for (let a = this.materials.length - 1; a >= 0; a--) this.materials[a].groupCount <= 0 && this.materials.splice(a, 1);
							return r && this.materials.length === 0 && this.materials.push({ name: "", smooth: this.smooth }), s;
						}
					}),
					i && i.name && typeof i.clone == "function")
				) {
					const r = i.clone(0);
					(r.inherited = !0), this.object.materials.push(r);
				}
				this.objects.push(this.object);
			},
			finalize: function () {
				this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
			},
			parseVertexIndex: function (e, t) {
				const i = parseInt(e, 10);
				return (i >= 0 ? i - 1 : i + t / 3) * 3;
			},
			parseNormalIndex: function (e, t) {
				const i = parseInt(e, 10);
				return (i >= 0 ? i - 1 : i + t / 3) * 3;
			},
			parseUVIndex: function (e, t) {
				const i = parseInt(e, 10);
				return (i >= 0 ? i - 1 : i + t / 2) * 2;
			},
			addVertex: function (e, t, i) {
				const r = this.vertices,
					s = this.object.geometry.vertices;
				s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2]);
			},
			addVertexPoint: function (e) {
				const t = this.vertices;
				this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
			},
			addVertexLine: function (e) {
				const t = this.vertices;
				this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
			},
			addNormal: function (e, t, i) {
				const r = this.normals,
					s = this.object.geometry.normals;
				s.push(r[e + 0], r[e + 1], r[e + 2]), s.push(r[t + 0], r[t + 1], r[t + 2]), s.push(r[i + 0], r[i + 1], r[i + 2]);
			},
			addFaceNormal: function (e, t, i) {
				const r = this.vertices,
					s = this.object.geometry.normals;
				M_.fromArray(r, e), cf.fromArray(r, t), A_.fromArray(r, i), Ci.subVectors(A_, cf), C_.subVectors(M_, cf), Ci.cross(C_), Ci.normalize(), s.push(Ci.x, Ci.y, Ci.z), s.push(Ci.x, Ci.y, Ci.z), s.push(Ci.x, Ci.y, Ci.z);
			},
			addColor: function (e, t, i) {
				const r = this.colors,
					s = this.object.geometry.colors;
				r[e] !== void 0 && s.push(r[e + 0], r[e + 1], r[e + 2]), r[t] !== void 0 && s.push(r[t + 0], r[t + 1], r[t + 2]), r[i] !== void 0 && s.push(r[i + 0], r[i + 1], r[i + 2]);
			},
			addUV: function (e, t, i) {
				const r = this.uvs,
					s = this.object.geometry.uvs;
				s.push(r[e + 0], r[e + 1]), s.push(r[t + 0], r[t + 1]), s.push(r[i + 0], r[i + 1]);
			},
			addDefaultUV: function () {
				const e = this.object.geometry.uvs;
				e.push(0, 0), e.push(0, 0), e.push(0, 0);
			},
			addUVLine: function (e) {
				const t = this.uvs;
				this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
			},
			addFace: function (e, t, i, r, s, a, o, l, c) {
				const u = this.vertices.length;
				let h = this.parseVertexIndex(e, u),
					d = this.parseVertexIndex(t, u),
					f = this.parseVertexIndex(i, u);
				if ((this.addVertex(h, d, f), this.addColor(h, d, f), o !== void 0 && o !== "")) {
					const v = this.normals.length;
					(h = this.parseNormalIndex(o, v)), (d = this.parseNormalIndex(l, v)), (f = this.parseNormalIndex(c, v)), this.addNormal(h, d, f);
				} else this.addFaceNormal(h, d, f);
				if (r !== void 0 && r !== "") {
					const v = this.uvs.length;
					(h = this.parseUVIndex(r, v)), (d = this.parseUVIndex(s, v)), (f = this.parseUVIndex(a, v)), this.addUV(h, d, f), (this.object.geometry.hasUVIndices = !0);
				} else this.addDefaultUV();
			},
			addPointGeometry: function (e) {
				this.object.geometry.type = "Points";
				const t = this.vertices.length;
				for (let i = 0, r = e.length; i < r; i++) {
					const s = this.parseVertexIndex(e[i], t);
					this.addVertexPoint(s), this.addColor(s);
				}
			},
			addLineGeometry: function (e, t) {
				this.object.geometry.type = "Line";
				const i = this.vertices.length,
					r = this.uvs.length;
				for (let s = 0, a = e.length; s < a; s++) this.addVertexLine(this.parseVertexIndex(e[s], i));
				for (let s = 0, a = t.length; s < a; s++) this.addUVLine(this.parseUVIndex(t[s], r));
			}
		};
		return n.startObject("", !1), n;
	}
	class yk extends Ma {
		constructor(e) {
			super(e), (this.materials = null);
		}
		load(e, t, i, r) {
			const s = this,
				a = new em(this.manager);
			a.setPath(this.path),
				a.setRequestHeader(this.requestHeader),
				a.setWithCredentials(this.withCredentials),
				a.load(
					e,
					function (o) {
						try {
							t(s.parse(o));
						} catch (l) {
							r ? r(l) : console.error(l), s.manager.itemError(e);
						}
					},
					i,
					r
				);
		}
		setMaterials(e) {
			return (this.materials = e), this;
		}
		parse(e) {
			const t = new _k();
			e.indexOf(`\r
`) !== -1 &&
				(e = e.replace(
					/\r\n/g,
					`
`
				)),
				e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
			const i = e.split(`
`);
			let r = [];
			for (let o = 0, l = i.length; o < l; o++) {
				const c = i[o].trimStart();
				if (c.length === 0) continue;
				const u = c.charAt(0);
				if (u !== "#")
					if (u === "v") {
						const h = c.split(T_);
						switch (h[0]) {
							case "v":
								t.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), h.length >= 7 ? (xu.setRGB(parseFloat(h[4]), parseFloat(h[5]), parseFloat(h[6])).convertSRGBToLinear(), t.colors.push(xu.r, xu.g, xu.b)) : t.colors.push(void 0, void 0, void 0);
								break;
							case "vn":
								t.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
								break;
							case "vt":
								t.uvs.push(parseFloat(h[1]), parseFloat(h[2]));
								break;
						}
					} else if (u === "f") {
						const d = c.slice(1).trim().split(T_),
							f = [];
						for (let _ = 0, p = d.length; _ < p; _++) {
							const g = d[_];
							if (g.length > 0) {
								const x = g.split("/");
								f.push(x);
							}
						}
						const v = f[0];
						for (let _ = 1, p = f.length - 1; _ < p; _++) {
							const g = f[_],
								x = f[_ + 1];
							t.addFace(v[0], g[0], x[0], v[1], g[1], x[1], v[2], g[2], x[2]);
						}
					} else if (u === "l") {
						const h = c.substring(1).trim().split(" ");
						let d = [];
						const f = [];
						if (c.indexOf("/") === -1) d = h;
						else
							for (let v = 0, _ = h.length; v < _; v++) {
								const p = h[v].split("/");
								p[0] !== "" && d.push(p[0]), p[1] !== "" && f.push(p[1]);
							}
						t.addLineGeometry(d, f);
					} else if (u === "p") {
						const d = c.slice(1).trim().split(" ");
						t.addPointGeometry(d);
					} else if ((r = pk.exec(c)) !== null) {
						const h = (" " + r[0].slice(1).trim()).slice(1);
						t.startObject(h);
					} else if (gk.test(c)) t.object.startMaterial(c.substring(7).trim(), t.materialLibraries);
					else if (mk.test(c)) t.materialLibraries.push(c.substring(7).trim());
					else if (vk.test(c)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
					else if (u === "s") {
						if (((r = c.split(" ")), r.length > 1)) {
							const d = r[1].trim().toLowerCase();
							t.object.smooth = d !== "0" && d !== "off";
						} else t.object.smooth = !0;
						const h = t.object.currentMaterial();
						h && (h.smooth = t.object.smooth);
					} else {
						if (c === "\0") continue;
						console.warn('THREE.OBJLoader: Unexpected line: "' + c + '"');
					}
			}
			t.finalize();
			const s = new Ot();
			if (((s.materialLibraries = [].concat(t.materialLibraries)), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0))
				for (let o = 0, l = t.objects.length; o < l; o++) {
					const c = t.objects[o],
						u = c.geometry,
						h = c.materials,
						d = u.type === "Line",
						f = u.type === "Points";
					let v = !1;
					if (u.vertices.length === 0) continue;
					const _ = new bt();
					_.setAttribute("position", new Tt(u.vertices, 3)), u.normals.length > 0 && _.setAttribute("normal", new Tt(u.normals, 3)), u.colors.length > 0 && ((v = !0), _.setAttribute("color", new Tt(u.colors, 3))), u.hasUVIndices === !0 && _.setAttribute("uv", new Tt(u.uvs, 2));
					const p = [];
					for (let x = 0, b = h.length; x < b; x++) {
						const T = h[x],
							P = T.name + "_" + T.smooth + "_" + v;
						let A = t.materials[P];
						if (this.materials !== null) {
							if (((A = this.materials.create(T.name)), d && A && !(A instanceof Fi))) {
								const M = new Fi();
								Er.prototype.copy.call(M, A), M.color.copy(A.color), (A = M);
							} else if (f && A && !(A instanceof vo)) {
								const M = new vo({ size: 10, sizeAttenuation: !1 });
								Er.prototype.copy.call(M, A), M.color.copy(A.color), (M.map = A.map), (A = M);
							}
						}
						A === void 0 && (d ? (A = new Fi()) : f ? (A = new vo({ size: 1, sizeAttenuation: !1 })) : (A = new nr()), (A.name = T.name), (A.flatShading = !T.smooth), (A.vertexColors = v), (t.materials[P] = A)), p.push(A);
					}
					let g;
					if (p.length > 1) {
						for (let x = 0, b = h.length; x < b; x++) {
							const T = h[x];
							_.addGroup(T.groupStart, T.groupCount, x);
						}
						d ? (g = new Fl(_, p)) : f ? (g = new bs(_, p)) : (g = new Re(_, p));
					} else d ? (g = new Fl(_, p[0])) : f ? (g = new bs(_, p[0])) : (g = new Re(_, p[0]));
					(g.name = c.name), s.add(g);
				}
			else if (t.vertices.length > 0) {
				const o = new vo({ size: 1, sizeAttenuation: !1 }),
					l = new bt();
				l.setAttribute("position", new Tt(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (l.setAttribute("color", new Tt(t.colors, 3)), (o.vertexColors = !0));
				const c = new bs(l, o);
				s.add(c);
			}
			return s;
		}
	}
	class xk extends Ma {
		constructor(e) {
			super(e);
		}
		load(e, t, i, r) {
			const s = this,
				a = this.path === "" ? HO.extractUrlBase(e) : this.path,
				o = new em(this.manager);
			o.setPath(this.path),
				o.setRequestHeader(this.requestHeader),
				o.setWithCredentials(this.withCredentials),
				o.load(
					e,
					function (l) {
						try {
							t(s.parse(l, a));
						} catch (c) {
							r ? r(c) : console.error(c), s.manager.itemError(e);
						}
					},
					i,
					r
				);
		}
		setMaterialOptions(e) {
			return (this.materialOptions = e), this;
		}
		parse(e, t) {
			const i = e.split(`
`);
			let r = {};
			const s = /\s+/,
				a = {};
			for (let l = 0; l < i.length; l++) {
				let c = i[l];
				if (((c = c.trim()), c.length === 0 || c.charAt(0) === "#")) continue;
				const u = c.indexOf(" ");
				let h = u >= 0 ? c.substring(0, u) : c;
				h = h.toLowerCase();
				let d = u >= 0 ? c.substring(u + 1) : "";
				if (((d = d.trim()), h === "newmtl")) (r = { name: d }), (a[d] = r);
				else if (h === "ka" || h === "kd" || h === "ks" || h === "ke") {
					const f = d.split(s, 3);
					r[h] = [parseFloat(f[0]), parseFloat(f[1]), parseFloat(f[2])];
				} else r[h] = d;
			}
			const o = new bk(this.resourcePath || t, this.materialOptions);
			return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(a), o;
		}
	}
	class bk {
		constructor(e = "", t = {}) {
			(this.baseUrl = e), (this.options = t), (this.materialsInfo = {}), (this.materials = {}), (this.materialsArray = []), (this.nameLookup = {}), (this.crossOrigin = "anonymous"), (this.side = this.options.side !== void 0 ? this.options.side : Kr), (this.wrap = this.options.wrap !== void 0 ? this.options.wrap : Xu);
		}
		setCrossOrigin(e) {
			return (this.crossOrigin = e), this;
		}
		setManager(e) {
			this.manager = e;
		}
		setMaterials(e) {
			(this.materialsInfo = this.convert(e)), (this.materials = {}), (this.materialsArray = []), (this.nameLookup = {});
		}
		convert(e) {
			if (!this.options) return e;
			const t = {};
			for (const i in e) {
				const r = e[i],
					s = {};
				t[i] = s;
				for (const a in r) {
					let o = !0,
						l = r[a];
					const c = a.toLowerCase();
					switch (c) {
						case "kd":
						case "ka":
						case "ks":
							this.options && this.options.normalizeRGB && (l = [l[0] / 255, l[1] / 255, l[2] / 255]), this.options && this.options.ignoreZeroRGBs && l[0] === 0 && l[1] === 0 && l[2] === 0 && (o = !1);
							break;
					}
					o && (s[c] = l);
				}
			}
			return t;
		}
		preload() {
			for (const e in this.materialsInfo) this.create(e);
		}
		getIndex(e) {
			return this.nameLookup[e];
		}
		getAsArray() {
			let e = 0;
			for (const t in this.materialsInfo) (this.materialsArray[e] = this.create(t)), (this.nameLookup[t] = e), e++;
			return this.materialsArray;
		}
		create(e) {
			return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
		}
		createMaterial_(e) {
			const t = this,
				i = this.materialsInfo[e],
				r = { name: e, side: this.side };
			function s(o, l) {
				return typeof l != "string" || l === "" ? "" : /^https?:\/\//i.test(l) ? l : o + l;
			}
			function a(o, l) {
				if (r[o]) return;
				const c = t.getTextureParams(l, r),
					u = t.loadTexture(s(t.baseUrl, c.url));
				u.repeat.copy(c.scale), u.offset.copy(c.offset), (u.wrapS = t.wrap), (u.wrapT = t.wrap), (o === "map" || o === "emissiveMap") && (u.colorSpace = ni), (r[o] = u);
			}
			for (const o in i) {
				const l = i[o];
				let c;
				if (l !== "")
					switch (o.toLowerCase()) {
						case "kd":
							r.color = new rt().fromArray(l).convertSRGBToLinear();
							break;
						case "ks":
							r.specular = new rt().fromArray(l).convertSRGBToLinear();
							break;
						case "ke":
							r.emissive = new rt().fromArray(l).convertSRGBToLinear();
							break;
						case "map_kd":
							a("map", l);
							break;
						case "map_ks":
							a("specularMap", l);
							break;
						case "map_ke":
							a("emissiveMap", l);
							break;
						case "norm":
							a("normalMap", l);
							break;
						case "map_bump":
						case "bump":
							a("bumpMap", l);
							break;
						case "map_d":
							a("alphaMap", l), (r.transparent = !0);
							break;
						case "ns":
							r.shininess = parseFloat(l);
							break;
						case "d":
							(c = parseFloat(l)), c < 1 && ((r.opacity = c), (r.transparent = !0));
							break;
						case "tr":
							(c = parseFloat(l)), this.options && this.options.invertTrProperty && (c = 1 - c), c > 0 && ((r.opacity = 1 - c), (r.transparent = !0));
							break;
					}
			}
			return (this.materials[e] = new nr(r)), this.materials[e];
		}
		getTextureParams(e, t) {
			const i = { scale: new Se(1, 1), offset: new Se(0, 0) },
				r = e.split(/\s+/);
			let s;
			return (s = r.indexOf("-bm")), s >= 0 && ((t.bumpScale = parseFloat(r[s + 1])), r.splice(s, 2)), (s = r.indexOf("-s")), s >= 0 && (i.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), (s = r.indexOf("-o")), s >= 0 && (i.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), (i.url = r.join(" ").trim()), i;
		}
		loadTexture(e, t, i, r, s) {
			const a = this.manager !== void 0 ? this.manager : Ex;
			let o = a.getHandler(e);
			o === null && (o = new wx(a)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
			const l = o.load(e, i, r, s);
			return t !== void 0 && (l.mapping = t), l;
		}
	}
	let Es, L_;
	function Sk(n, e) {
		console.clear();
		const t = n.find((s) => s.name.endsWith(".obj")),
			i = n.find((s) => s.name.endsWith(".mtl")),
			r = n.find((s) => s.name.endsWith(".jpg") || s.name.endsWith(".png"));
		if (!t) {
			console.error("00) OBJ file not found");
			return;
		}
		if ((t && console.log("00) OBJ file:", t.name), i && console.log("00) MTL file:", i.name), r && console.log("00) Texture file:", r.name), i)) {
			console.log("01) MTL File:", i);
			const s = i,
				a = new FileReader();
			(a.onload = function (o) {
				console.log("02) MTL Event Details:", o.target.result);
				const l = new xk(),
					c = o.target.result;
				if (((Es = l.parse(c)), Es.preload(), r)) {
					const u = new wx(),
						h = new FileReader();
					(h.onload = function (d) {
						console.log("03) Texture Event Details:", d.target.result);
						const f = u.load(d.target.result);
						Ek(f), uf(t, e);
					}),
						h.readAsDataURL(r);
				} else uf(t, e), alert("04) No texture file selected");
			}),
				a.readAsText(s);
		} else console.error("05) MTL file not found"), alert("06) No MTL file found"), uf(t, e);
		console.log("07) MTL:", i), console.log("08) OBJ:", t);
	}
	function Ek(n) {
		if (Es) for (let e of Object.values(Es.materials)) (n.colorSpace = ni), (n.brighness = 1), (n.contrast = 0.5), (n.anisotropy = 16), (e.colorSpace = ni), (e.side = An), (e.map = n), console.log("09) Applying Texture:", e.map), (e.needsUpdate = !0);
	}
	function uf(n, e) {
		console.log("10) OBJ File:", n);
		const t = n,
			i = new FileReader();
		(i.onload = function (r) {
			console.log("11) OBJ Event Details:", r.target.result);
			const s = new yk();
			Es && (console.log("12) Materials:", Es), s.setMaterials(Es));
			const a = r.target.result;
			(L_ = s.parse(a)), wk(L_, e, Es);
		}),
			i.readAsText(t);
	}
	function wk(n, e, t) {
		const i = new Tr().setFromObject(n),
			r = i.getCenter(new D());
		console.log("13) Bounding Box:", i);
		const s = le.worldXCenter !== 0 ? le.worldXCenter : r.x,
			a = le.worldYCenter !== 0 ? le.worldYCenter : r.y;
		(le.worldXCenter === 0 || le.worldYCenter === 0) && (console.log("14) World Center:", s, a), (le.worldXCenter = r.x), (le.worldYCenter = r.y), Cs()), console.log("15) Setting the Objects Center:", s, a), n.position.set(0, 0, 0), n.scale.set(1, 1, 1), (n.name = n.name);
		const o = new nr({ color: 11184810, side: An, flatShading: !0 });
		n.traverse(function (l) {
			if (l.isMesh) {
				const c = l.geometry.attributes.position;
				for (let u = 0; u < c.count; u++) c.setXYZ(u, c.getX(u) - s, c.getY(u) - a, c.getZ(u));
				l.geometry.computeVertexNormals(),
					(c.needsUpdate = !0),
					!l.material || !l.material.map ? (console.log("16) child.material", l.material), (l.material = o), (l.material.needsUpdate = !0)) : (console.log("17) child.material", l.material), (l.material.flatShading = !1), (l.material.side = An), (l.material.colorSpace = ni), (l.material.emissive = 0), (l.material.needsUpdate = !0)),
					l.geometry.computeBoundingBox(),
					l.geometry.computeBoundingSphere(),
					(l.userData = { name: n.name, isOBJMesh: !0, isTextured: !!t, originalMaterial: l.material, originalColour: l.material.color, offsetX: s, offsetY: a, offsetZ: 0, vertices: l.geometry.attributes.position.count, triangles: l.geometry.attributes.position.count / 3 }),
					e.scene.add(l),
					es(e.scene, e.camera);
			}
		});
	}
	function Ab(n) {
		const e = n.children.filter((i) => i.userData.entityType !== "camera" && i.userData.entityType !== "light"),
			t = new Tr();
		return (
			e.forEach((i) => {
				t.expandByObject(i);
			}),
			t
		);
	}
	function Tk() {
		(document.querySelector("#app").innerHTML = `
    <div id="scene-container">
	<!-- Three.js Canvas -->
	<div id="canvas"></div> 

    <!-- Vertical Nav Buttons -->
	<nav id="vertical-nav">
	    <img src="./assets/svg/kirralogo.svg" class="white-svg" alt="Kirra Logo" />
		<button id=open-holes title="File Open">
			<img src="./assets/tabler-icons-2.36.0/png/load-holes-k3d.png" alt="File Open Holes" />
		</button>
		<button id=import-holes title="File Import">
			<img src="./assets/tabler-icons-2.36.0/png/load-holes-csv.png" alt="File Import Holes" />
		</button>
	  	<button id=import-obj title="File OBJ Loader">
			<img src="./assets/tabler-icons-2.36.0/png/load-obj.png" alt="File Import OBJ" />
		</button>
		<button id=import-dxf title="File Import DXF">
			<img src="./assets/tabler-icons-2.36.0/png/load-dxf.png" alt="File Import DXF" />
		</button>
		<button id=import-pointcloud title="File Import Point Cloud CSV">
			<img src="./assets/tabler-icons-2.36.0/png/load-csv.png" alt="File Import Text Based Point Cloud" />
		</button>
		<button id=settings-world title="Settings World Origin">
			<img src="./assets/tabler-icons-2.36.0/png/world-cog.png" alt="World Origin Point" />
		</button>
		<button id=clear-local-storage title="Clear Local Storage" >
			<img src="./assets/tabler-icons-2.36.0/png/browser-x.png" alt="Clear Local Storage" />
		</button>
	</nav>

    <!-- Horizontal Nav Buttons -->    
    <nav id= horizontal-nav>
		<button id="reset" title="Reset" >
			<img src="./assets/tabler-icons-2.36.0/png/circle-letter-r.png" alt="Reset" />
		</button>
		<button id=swap-all-hole-visuals title="Swap Hole Visual" >
			<img src="./assets/tabler-icons-2.36.0/png/replace.png" alt="Swap Hole Visual" />
		</button>
		<button id=obj-display title="OBJ Display" >
			<img src="./assets/tabler-icons-2.36.0/png/hexagon-filled.png" alt="OBJ Display" />
		</button>
		<button id=hole-name-on-off title="Name On Off" >
			<img src="./assets/tabler-icons-2.36.0/png/holename.png" alt="Hole Name Display" />
		</button>
		<button id=hole-length-on-off title="Length On Off" >
			<img src="./assets/tabler-icons-2.36.0/png/holelength.png" alt="Hole Length Display" />
		</button>
		<button id=hole-diameter-on-off title="Diameter On Off">
			<img src="./assets/tabler-icons-2.36.0/png/holediam.png" alt="Hole Diameter Display" />
		</button>
		<button id=camera-mode title="Camera Mode" >
			<img src="./assets/tabler-icons-2.36.0/png/cube.png" alt="Perspective Mode" />
		</button>

		<label id="info-label" style="color: red;">Info Label</label>
	  <!-- Add more buttons as needed -->
	</nav>

     <!-- Right Panel (Initially hidden) -->
        <div id="right-panel" class="hidden">
            <button id="close-panel" title="Close Panel">&#x2715;</button>
            <br>
			<div id="objectPanel" class="panel tree-view">
				<!-- Dynamically generated content will go here -->
			</div>
        </div>

        <!-- Toggle Button (Initially visible) -->
        <button id="toggle-panel" class="panel-toggle-btn">
            <img src="./assets/tabler-icons-2.36.0/png/chevrons-left.png" alt="Open" />
        </button>
    </div>
    `),
			document.querySelector("#close-panel").addEventListener("click", function () {
				document.querySelector("#right-panel").classList.add("hidden"), (document.querySelector("#toggle-panel").style.display = "block");
			}),
			document.querySelector("#toggle-panel").addEventListener("click", function () {
				document.querySelector("#right-panel").classList.remove("hidden"), (document.querySelector("#toggle-panel").style.display = "none");
			});
	}
	const Mk = () => {
			document.getElementById("open-holes").addEventListener("click", function () {
				console.clear();
				const n = document.createElement("input");
				(n.type = "file"),
					(n.accept = ".k3d"),
					(n.style.display = "none"),
					(n.onchange = (e) => {
						e.target.files && e.target.files[0] && fk(e.target.files[0]);
					}),
					document.body.appendChild(n),
					n.click(),
					document.body.removeChild(n),
					le.debugComments && console.log("Load K3DFile button clicked");
			});
		},
		Ak = (n, e, t) => {
			if (!n) return console.error("Data is null or undefined"), [];
			let i = [];
			const r = parseInt(e.headerRows, 10) || 0;
			let s = -1;
			const a = Date.now();
			n.slice(r).forEach((l, c) => {
				const u = Fp(),
					h = l[Object.keys(l)[e.blastName - 1]] || `tempBlast_${a}`,
					d = String(l[Object.keys(l)[e.pointID - 1]] || s--),
					f = parseFloat(l[Object.keys(l)[e.startXLocation - 1]]),
					v = parseFloat(l[Object.keys(l)[e.startYLocation - 1]]),
					_ = parseFloat(l[Object.keys(l)[e.startZLocation - 1]]),
					p = parseFloat(l[Object.keys(l)[e.endXLocation - 1]]) || null,
					g = parseFloat(l[Object.keys(l)[e.endYLocation - 1]]) || null,
					x = parseFloat(l[Object.keys(l)[e.endZLocation - 1]]) || null,
					b = parseFloat(l[Object.keys(l)[e.diameter - 1]] * 1e3),
					T = parseFloat(l[Object.keys(l)[e.diameter - 1]]),
					P = parseFloat(e.diameter_unit === "mm" ? T || 0 : b || null),
					A = parseFloat(l[Object.keys(l)[e.subdrill - 1]] || null),
					M = l[Object.keys(l)[e.shapeType - 1]],
					w = l[Object.keys(l)[e.holeColour - 1]];
				!isNaN(f) && !isNaN(v) && !isNaN(_) && !isNaN(p) && !isNaN(g) && !isNaN(x) && i.push({ uuid: u, blastName: h, pointID: d, startXLocation: f, startYLocation: v, startZLocation: _, endXLocation: p, endYLocation: g, endZLocation: x, diameter: P, subdrill: A, shapeType: M, holeColour: w });
			});
			const o = "CSV_BlastStore";
			return (
				(async () => {
					try {
						const l = await Zl();
						console.log("Database opened successfully. Attempting to write data..."), await Ip(l, o, i), console.log("Data written successfully to " + o);
						const c = await mh(l, o);
						console.log("Data read back from the database:", c);
					} catch (l) {
						console.error("Failed to write or read data from the database:", l);
					}
				})(),
				i
			);
		},
		Ck = (n, e, t) => {
			console.log("Showing custom modal...");
			const i = `
        <div class="modal fade" id="csvModal" tabindex="-1" aria-labelledby="csvModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header custom-modal-header">
                        <h5 class="modal-title" id="csvModalLabel">Text File Import (.csv and .txt auto delimeter)</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form id="csvForm">
                            <div class="row">
                                <div class="col-md-6">
                                    ${R_(n, "left")}
                                </div>
                                <div class="col-md-6">
                                    ${R_(n, "right")}
                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-12">
                                    <div class="form-group">
                                        <label for="filePreviewTable">File Contents Preview (Set Order to refresh column view)</label>
                                        <div id="filePreviewTable" style="max-height: 200px; overflow-y: auto;"></div>
                                    </div>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-danger" id="clear-settings">Clear</button>
                        <div class="col mx-3"></div>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" id="set-order">Set Order</button>
                        <button type="button" class="btn btn-success" id="submit">Submit</button>
                    </div>
                </div>
            </div>
        </div>`,
				r = document.createElement("style");
			(r.innerHTML = `
        .custom-modal-header {
            background-color: #cccccc;
			font-size: 12px;
			height: 2.5em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9px;
        }
        th, td {
            padding: 1px;
            text-align: center;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-size: 11px;
        }
        .ignored-column {
            color: red;
            font-style: italic;
        }
		.modal-body label {
        	font-size: 12px; /* Adjust the font size of the labels */
        	height: 1.5em; /* Adjust the height of the labels */
    	}
    	.modal-body .form-control {
        	font-size: 12px; /* Adjust the font size of the input fields */
        	height: 2em; /* Adjust the height of the input fields */
        	padding: .25rem .5rem; /* Adjust the padding of the input fields */
		}
		.text-danger {
			font-size: 12px; /* Adjust the font size of the text-danger span */
			height: 2em; /* Adjust the height of the labels */
			align-items: center;
		}	
		.text-warning {
			font-size: 12px; /* Adjust the font size of the text-warning span */
			height: 2em; /* Adjust the height of the labels */
			align-items: center;
		}
    `),
				document.head.appendChild(r);
			const s = document.createElement("div");
			(s.innerHTML = i), document.body.appendChild(s);
			const a = new Sr(document.getElementById("csvModal"));
			a.show();
			const o = JSON.parse(localStorage.getItem("columnOrder"));
			if (o) {
				for (const [l, c] of Object.entries(o)) {
					const u = document.getElementById(l);
					u && (u.value = c);
				}
				o.diameter_unit ? (document.querySelector(`input[name="diameter_unit"][value="${o.diameter_unit}"]`).checked = !0) : (document.querySelector('input[name="diameter_unit"][value="mm"]').checked = !0);
			} else document.querySelector('input[name="diameter_unit"][value="mm"]').checked = !0;
			document.getElementById("clear-settings").addEventListener("click", function () {
				console.log("Clear settings clicked"),
					document.querySelectorAll("#csvForm input[type='number']").forEach((c) => {
						c.value = "";
					}),
					localStorage.removeItem("columnOrder"),
					bu(t);
			}),
				document.getElementById("set-order").addEventListener("click", function () {
					console.log("Set order clicked");
					const l = new FormData(document.getElementById("csvForm")),
						c = {};
					l.forEach((u, h) => {
						u && (c[h] = u);
					}),
						(c.diameter_unit = document.querySelector('input[name="diameter_unit"]:checked').value),
						localStorage.setItem("columnOrder", JSON.stringify(c)),
						console.log(c),
						alert("Column order has been set."),
						bu(t);
				}),
				document.getElementById("submit").addEventListener("click", function () {
					console.log("Submit clicked");
					const l = new FormData(document.getElementById("csvForm")),
						c = {};
					l.forEach((v, _) => {
						v && (c[_] = v);
					}),
						(c.diameter_unit = document.querySelector('input[name="diameter_unit"]:checked').value),
						console.log(c);
					const u = {};
					for (const [v, _] of Object.entries(c)) u[v] = _;
					(!u.startXLocation || !u.startYLocation || !u.startZLocation) && (alert("Please ensure that Start X, Start Y, and Start Z columns are selected."), console.error("Please ensure that Start X, Start Y, and Start Z columns are selected."));
					let h = Object.values(u),
						d = u.headerRows,
						f = h.filter((v, _) => v !== d && h.indexOf(v) !== _);
					f.length > 0 &&
						(console.log("Duplicates: ", f),
						alert(`Some columns are represented more than once.
Display may not be as intended.
Preferably a column is selected only once.
`)),
						u.startXLocation && u.startYLocation && u.startZLocation && (Pk(t, u), a.hide(), document.body.removeChild(s));
				}),
				document.getElementById("headerRows").addEventListener("input", () => bu(t)),
				bu(t);
		},
		R_ = (n, e) =>
			(e === "left"
				? [
						{ id: "headerRows", label: "Rows to Ignore", type: "number", placeholder: "# rows", required: !0, unused: !1 },
						{ id: "blastName", label: "Blast Name", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "pointID", label: "Hole Name", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "startXLocation", label: "Start X (Easting)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "startYLocation", label: "Start Y (Northing)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "startZLocation", label: "Start Z (Elevation)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "endXLocation", label: "End X (Easting)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "endYLocation", label: "End Y (Northing)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "endZLocation", label: "End Z (Elevation)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "diameter", label: "Diameter", placeholder: "Col #", type: "number", unit: !0, required: !1, unused: !1 }
				  ]
				: [
						{ id: "subdrill", label: "Subdrill", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "shapeType", label: "Shape Type", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "holeColour", label: "Hole Colour", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "holeLength", label: "Length", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "holeBearing", label: "Bearing", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "holeAngle", label: "Angle", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "holeBurden", label: "Burden", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "holeSpacing", label: "Spacing", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "fromHole", label: "From Hole", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "delay", label: "Delay", placeholder: "Col #", type: "number", required: !1, unused: !0 },
						{ id: "delayColour", label: "Delay Colour", placeholder: "Col #", type: "number", required: !1, unused: !0 }
				  ]
			)
				.map((s) =>
					s.required
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <div class="input-group">
                            <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}" required>
                            <div class="input-group-append">
                                <span class="input-group-text text-danger">needed</span>
                            </div>
                        </div>
                    </div>
                </div>`
						: s.unused
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <div class="input-group">
                            <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}" unused>
                            <div class="input-group-append">
                                <span class="input-group-text text-warning">unused</span>
                            </div>
                        </div>
                    </div>
                </div>`
						: s.unit
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}">
                        <div>
                            <input type="radio" id="${s.id}_mm" name="diameter_unit" value="mm">
                            <label for="${s.id}_mm">mm</label>
                            <input type="radio" id="${s.id}_m" name="diameter_unit" value="m">
                            <label for="${s.id}_m">m</label>
                        </div>
                    </div>
                </div>`
						: `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <input type="${s.type}" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}">
                    </div>
                </div>`
				)
				.join(""),
		bu = (n) => {
			const e = parseInt(document.getElementById("headerRows").value, 10) || 0,
				t = JSON.parse(localStorage.getItem("columnOrder") || "{}");
			if ((delete t.headerRows, n.length > 0)) {
				let i = '<table class="table table-striped"><thead><tr>';
				const r = {
						blastName: "Blast Name",
						pointID: "Hole Name",
						startXLocation: "Start X (Easting)",
						startYLocation: "Start Y (Northing)",
						startZLocation: "Start Z (Elevation)",
						endXLocation: "End X (Easting)",
						endYLocation: "End Y (Northing)",
						endZLocation: "End Z (Elevation)",
						diameter: `Diameter (${t.diameter_unit || "mm"})`,
						subdrill: "Subdrill",
						shapeType: "Shape Type",
						holeColour: "Hole Colour",
						holeLength: "Length",
						holeBearing: "Bearing",
						holeAzimuth: "Azimuth",
						holeBurden: "Burden",
						holeSpacing: "Spacing",
						fromHole: "From Hole",
						delay: "Delay",
						delayColour: "Delay Colour"
					},
					s = Object.keys(n[0]).length;
				for (let u = 0; u < s; u++) {
					const h = Object.keys(t).find((d) => t[d] == (u + 1).toString());
					h ? (i += `<th>${r[h]}</th>`) : (i += '<th class="ignored-column">ignored</th>');
				}
				i += "</tr></thead><tbody>";
				const a = n.slice(e),
					o = 10,
					l = a.slice(0, o),
					c = a.length > o;
				(i += l
					.map(
						(u) =>
							"<tr>" +
							Object.keys(u)
								.map((h, d) => (Object.keys(t).find((v) => t[v] == (d + 1).toString()) ? `<td>${u[h]}</td>` : `<td>${u[h]}</td>`))
								.join("") +
							"</tr>"
					)
					.join("")),
					c && (Object.keys(t).length, (i += "<tr><td><i>more rows in file...</i></td></tr>")),
					(i += "</tbody></table>"),
					console.log("Table content generated"),
					(document.getElementById("filePreviewTable").innerHTML = i);
			}
		};
	var Cb = { exports: {} };
	/* @license
Papa Parse
v5.4.1
https://github.com/mholt/PapaParse
License: MIT
*/ (function (n, e) {
		(function (t, i) {
			n.exports = i();
		})(gp, function t() {
			var i = typeof self < "u" ? self : typeof window < "u" ? window : i !== void 0 ? i : {},
				r = !i.document && !!i.postMessage,
				s = i.IS_PAPA_WORKER || !1,
				a = {},
				o = 0,
				l = {
					parse: function (w, y) {
						var S = (y = y || {}).dynamicTyping || !1;
						if ((M(S) && ((y.dynamicTypingFunction = S), (S = {})), (y.dynamicTyping = S), (y.transform = !!M(y.transform) && y.transform), y.worker && l.WORKERS_SUPPORTED)) {
							var L = (function () {
								if (!l.WORKERS_SUPPORTED) return !1;
								var k = ((W = i.URL || i.webkitURL || null), (H = t.toString()), l.BLOB_URL || (l.BLOB_URL = W.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", H, ")();"], { type: "text/javascript" })))),
									B = new i.Worker(k),
									W,
									H;
								return (B.onmessage = x), (B.id = o++), (a[B.id] = B);
							})();
							return (L.userStep = y.step), (L.userChunk = y.chunk), (L.userComplete = y.complete), (L.userError = y.error), (y.step = M(y.step)), (y.chunk = M(y.chunk)), (y.complete = M(y.complete)), (y.error = M(y.error)), delete y.worker, void L.postMessage({ input: w, config: y, workerId: L.id });
						}
						var N = null;
						return (
							l.NODE_STREAM_INPUT,
							typeof w == "string"
								? ((w = (function (k) {
										return k.charCodeAt(0) === 65279 ? k.slice(1) : k;
								  })(w)),
								  (N = y.download ? new h(y) : new f(y)))
								: w.readable === !0 && M(w.read) && M(w.on)
								? (N = new v(y))
								: ((i.File && w instanceof File) || w instanceof Object) && (N = new d(y)),
							N.stream(w)
						);
					},
					unparse: function (w, y) {
						var S = !1,
							L = !0,
							N = ",",
							k = `\r
`,
							B = '"',
							W = B + B,
							H = !1,
							z = null,
							X = !1;
						(function () {
							if (typeof y == "object") {
								if (
									(typeof y.delimiter != "string" ||
										l.BAD_DELIMITERS.filter(function (ae) {
											return y.delimiter.indexOf(ae) !== -1;
										}).length ||
										(N = y.delimiter),
									(typeof y.quotes == "boolean" || typeof y.quotes == "function" || Array.isArray(y.quotes)) && (S = y.quotes),
									(typeof y.skipEmptyLines != "boolean" && typeof y.skipEmptyLines != "string") || (H = y.skipEmptyLines),
									typeof y.newline == "string" && (k = y.newline),
									typeof y.quoteChar == "string" && (B = y.quoteChar),
									typeof y.header == "boolean" && (L = y.header),
									Array.isArray(y.columns))
								) {
									if (y.columns.length === 0) throw new Error("Option columns is empty");
									z = y.columns;
								}
								y.escapeChar !== void 0 && (W = y.escapeChar + B), (typeof y.escapeFormulae == "boolean" || y.escapeFormulae instanceof RegExp) && (X = y.escapeFormulae instanceof RegExp ? y.escapeFormulae : /^[=+\-@\t\r].*$/);
							}
						})();
						var K = new RegExp(p(B), "g");
						if ((typeof w == "string" && (w = JSON.parse(w)), Array.isArray(w))) {
							if (!w.length || Array.isArray(w[0])) return G(null, w, H);
							if (typeof w[0] == "object") return G(z || Object.keys(w[0]), w, H);
						} else if (typeof w == "object") return typeof w.data == "string" && (w.data = JSON.parse(w.data)), Array.isArray(w.data) && (w.fields || (w.fields = (w.meta && w.meta.fields) || z), w.fields || (w.fields = Array.isArray(w.data[0]) ? w.fields : typeof w.data[0] == "object" ? Object.keys(w.data[0]) : []), Array.isArray(w.data[0]) || typeof w.data[0] == "object" || (w.data = [w.data])), G(w.fields || [], w.data || [], H);
						throw new Error("Unable to serialize unrecognized input");
						function G(ae, Ue, Z) {
							var ie = "";
							typeof ae == "string" && (ae = JSON.parse(ae)), typeof Ue == "string" && (Ue = JSON.parse(Ue));
							var ge = Array.isArray(ae) && 0 < ae.length,
								V = !Array.isArray(Ue[0]);
							if (ge && L) {
								for (var j = 0; j < ae.length; j++) 0 < j && (ie += N), (ie += ue(ae[j], j));
								0 < Ue.length && (ie += k);
							}
							for (var he = 0; he < Ue.length; he++) {
								var xe = ge ? ae.length : Ue[he].length,
									He = !1,
									F = ge ? Object.keys(Ue[he]).length === 0 : Ue[he].length === 0;
								if ((Z && !ge && (He = Z === "greedy" ? Ue[he].join("").trim() === "" : Ue[he].length === 1 && Ue[he][0].length === 0), Z === "greedy" && ge)) {
									for (var fe = [], pe = 0; pe < xe; pe++) {
										var Ee = V ? ae[pe] : pe;
										fe.push(Ue[he][Ee]);
									}
									He = fe.join("").trim() === "";
								}
								if (!He) {
									for (var re = 0; re < xe; re++) {
										0 < re && !F && (ie += N);
										var We = ge && V ? ae[re] : re;
										ie += ue(Ue[he][We], re);
									}
									he < Ue.length - 1 && (!Z || (0 < xe && !F)) && (ie += k);
								}
							}
							return ie;
						}
						function ue(ae, Ue) {
							if (ae == null) return "";
							if (ae.constructor === Date) return JSON.stringify(ae).slice(1, 25);
							var Z = !1;
							X && typeof ae == "string" && X.test(ae) && ((ae = "'" + ae), (Z = !0));
							var ie = ae.toString().replace(K, W);
							return (Z =
								Z ||
								S === !0 ||
								(typeof S == "function" && S(ae, Ue)) ||
								(Array.isArray(S) && S[Ue]) ||
								(function (ge, V) {
									for (var j = 0; j < V.length; j++) if (-1 < ge.indexOf(V[j])) return !0;
									return !1;
								})(ie, l.BAD_DELIMITERS) ||
								-1 < ie.indexOf(N) ||
								ie.charAt(0) === " " ||
								ie.charAt(ie.length - 1) === " ")
								? B + ie + B
								: ie;
						}
					}
				};
			if (
				((l.RECORD_SEP = ""),
				(l.UNIT_SEP = ""),
				(l.BYTE_ORDER_MARK = "\uFEFF"),
				(l.BAD_DELIMITERS = [
					"\r",
					`
`,
					'"',
					l.BYTE_ORDER_MARK
				]),
				(l.WORKERS_SUPPORTED = !r && !!i.Worker),
				(l.NODE_STREAM_INPUT = 1),
				(l.LocalChunkSize = 10485760),
				(l.RemoteChunkSize = 5242880),
				(l.DefaultDelimiter = ","),
				(l.Parser = g),
				(l.ParserHandle = _),
				(l.NetworkStreamer = h),
				(l.FileStreamer = d),
				(l.StringStreamer = f),
				(l.ReadableStreamStreamer = v),
				i.jQuery)
			) {
				var c = i.jQuery;
				c.fn.parse = function (w) {
					var y = w.config || {},
						S = [];
					return (
						this.each(function (k) {
							if (!(c(this).prop("tagName").toUpperCase() === "INPUT" && c(this).attr("type").toLowerCase() === "file" && i.FileReader) || !this.files || this.files.length === 0) return !0;
							for (var B = 0; B < this.files.length; B++) S.push({ file: this.files[B], inputElem: this, instanceConfig: c.extend({}, y) });
						}),
						L(),
						this
					);
					function L() {
						if (S.length !== 0) {
							var k,
								B,
								W,
								H,
								z = S[0];
							if (M(w.before)) {
								var X = w.before(z.file, z.inputElem);
								if (typeof X == "object") {
									if (X.action === "abort") return (k = "AbortError"), (B = z.file), (W = z.inputElem), (H = X.reason), void (M(w.error) && w.error({ name: k }, B, W, H));
									if (X.action === "skip") return void N();
									typeof X.config == "object" && (z.instanceConfig = c.extend(z.instanceConfig, X.config));
								} else if (X === "skip") return void N();
							}
							var K = z.instanceConfig.complete;
							(z.instanceConfig.complete = function (G) {
								M(K) && K(G, z.file, z.inputElem), N();
							}),
								l.parse(z.file, z.instanceConfig);
						} else M(w.complete) && w.complete();
					}
					function N() {
						S.splice(0, 1), L();
					}
				};
			}
			function u(w) {
				(this._handle = null),
					(this._finished = !1),
					(this._completed = !1),
					(this._halted = !1),
					(this._input = null),
					(this._baseIndex = 0),
					(this._partialLine = ""),
					(this._rowCount = 0),
					(this._start = 0),
					(this._nextChunk = null),
					(this.isFirstChunk = !0),
					(this._completeResults = { data: [], errors: [], meta: {} }),
					function (y) {
						var S = P(y);
						(S.chunkSize = parseInt(S.chunkSize)), y.step || y.chunk || (S.chunkSize = null), (this._handle = new _(S)), ((this._handle.streamer = this)._config = S);
					}.call(this, w),
					(this.parseChunk = function (y, S) {
						if (this.isFirstChunk && M(this._config.beforeFirstChunk)) {
							var L = this._config.beforeFirstChunk(y);
							L !== void 0 && (y = L);
						}
						(this.isFirstChunk = !1), (this._halted = !1);
						var N = this._partialLine + y;
						this._partialLine = "";
						var k = this._handle.parse(N, this._baseIndex, !this._finished);
						if (!this._handle.paused() && !this._handle.aborted()) {
							var B = k.meta.cursor;
							this._finished || ((this._partialLine = N.substring(B - this._baseIndex)), (this._baseIndex = B)), k && k.data && (this._rowCount += k.data.length);
							var W = this._finished || (this._config.preview && this._rowCount >= this._config.preview);
							if (s) i.postMessage({ results: k, workerId: l.WORKER_ID, finished: W });
							else if (M(this._config.chunk) && !S) {
								if ((this._config.chunk(k, this._handle), this._handle.paused() || this._handle.aborted())) return void (this._halted = !0);
								(k = void 0), (this._completeResults = void 0);
							}
							return this._config.step || this._config.chunk || ((this._completeResults.data = this._completeResults.data.concat(k.data)), (this._completeResults.errors = this._completeResults.errors.concat(k.errors)), (this._completeResults.meta = k.meta)), this._completed || !W || !M(this._config.complete) || (k && k.meta.aborted) || (this._config.complete(this._completeResults, this._input), (this._completed = !0)), W || (k && k.meta.paused) || this._nextChunk(), k;
						}
						this._halted = !0;
					}),
					(this._sendError = function (y) {
						M(this._config.error) ? this._config.error(y) : s && this._config.error && i.postMessage({ workerId: l.WORKER_ID, error: y, finished: !1 });
					});
			}
			function h(w) {
				var y;
				(w = w || {}).chunkSize || (w.chunkSize = l.RemoteChunkSize),
					u.call(this, w),
					(this._nextChunk = r
						? function () {
								this._readChunk(), this._chunkLoaded();
						  }
						: function () {
								this._readChunk();
						  }),
					(this.stream = function (S) {
						(this._input = S), this._nextChunk();
					}),
					(this._readChunk = function () {
						if (this._finished) this._chunkLoaded();
						else {
							if (((y = new XMLHttpRequest()), this._config.withCredentials && (y.withCredentials = this._config.withCredentials), r || ((y.onload = A(this._chunkLoaded, this)), (y.onerror = A(this._chunkError, this))), y.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !r), this._config.downloadRequestHeaders)) {
								var S = this._config.downloadRequestHeaders;
								for (var L in S) y.setRequestHeader(L, S[L]);
							}
							if (this._config.chunkSize) {
								var N = this._start + this._config.chunkSize - 1;
								y.setRequestHeader("Range", "bytes=" + this._start + "-" + N);
							}
							try {
								y.send(this._config.downloadRequestBody);
							} catch (k) {
								this._chunkError(k.message);
							}
							r && y.status === 0 && this._chunkError();
						}
					}),
					(this._chunkLoaded = function () {
						y.readyState === 4 &&
							(y.status < 200 || 400 <= y.status
								? this._chunkError()
								: ((this._start += this._config.chunkSize ? this._config.chunkSize : y.responseText.length),
								  (this._finished =
										!this._config.chunkSize ||
										this._start >=
											(function (S) {
												var L = S.getResponseHeader("Content-Range");
												return L === null ? -1 : parseInt(L.substring(L.lastIndexOf("/") + 1));
											})(y)),
								  this.parseChunk(y.responseText)));
					}),
					(this._chunkError = function (S) {
						var L = y.statusText || S;
						this._sendError(new Error(L));
					});
			}
			function d(w) {
				var y, S;
				(w = w || {}).chunkSize || (w.chunkSize = l.LocalChunkSize), u.call(this, w);
				var L = typeof FileReader < "u";
				(this.stream = function (N) {
					(this._input = N), (S = N.slice || N.webkitSlice || N.mozSlice), L ? (((y = new FileReader()).onload = A(this._chunkLoaded, this)), (y.onerror = A(this._chunkError, this))) : (y = new FileReaderSync()), this._nextChunk();
				}),
					(this._nextChunk = function () {
						this._finished || (this._config.preview && !(this._rowCount < this._config.preview)) || this._readChunk();
					}),
					(this._readChunk = function () {
						var N = this._input;
						if (this._config.chunkSize) {
							var k = Math.min(this._start + this._config.chunkSize, this._input.size);
							N = S.call(N, this._start, k);
						}
						var B = y.readAsText(N, this._config.encoding);
						L || this._chunkLoaded({ target: { result: B } });
					}),
					(this._chunkLoaded = function (N) {
						(this._start += this._config.chunkSize), (this._finished = !this._config.chunkSize || this._start >= this._input.size), this.parseChunk(N.target.result);
					}),
					(this._chunkError = function () {
						this._sendError(y.error);
					});
			}
			function f(w) {
				var y;
				u.call(this, (w = w || {})),
					(this.stream = function (S) {
						return (y = S), this._nextChunk();
					}),
					(this._nextChunk = function () {
						if (!this._finished) {
							var S,
								L = this._config.chunkSize;
							return L ? ((S = y.substring(0, L)), (y = y.substring(L))) : ((S = y), (y = "")), (this._finished = !y), this.parseChunk(S);
						}
					});
			}
			function v(w) {
				u.call(this, (w = w || {}));
				var y = [],
					S = !0,
					L = !1;
				(this.pause = function () {
					u.prototype.pause.apply(this, arguments), this._input.pause();
				}),
					(this.resume = function () {
						u.prototype.resume.apply(this, arguments), this._input.resume();
					}),
					(this.stream = function (N) {
						(this._input = N), this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
					}),
					(this._checkIsFinished = function () {
						L && y.length === 1 && (this._finished = !0);
					}),
					(this._nextChunk = function () {
						this._checkIsFinished(), y.length ? this.parseChunk(y.shift()) : (S = !0);
					}),
					(this._streamData = A(function (N) {
						try {
							y.push(typeof N == "string" ? N : N.toString(this._config.encoding)), S && ((S = !1), this._checkIsFinished(), this.parseChunk(y.shift()));
						} catch (k) {
							this._streamError(k);
						}
					}, this)),
					(this._streamError = A(function (N) {
						this._streamCleanUp(), this._sendError(N);
					}, this)),
					(this._streamEnd = A(function () {
						this._streamCleanUp(), (L = !0), this._streamData("");
					}, this)),
					(this._streamCleanUp = A(function () {
						this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
					}, this));
			}
			function _(w) {
				var y,
					S,
					L,
					N = Math.pow(2, 53),
					k = -N,
					B = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,
					W = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,
					H = this,
					z = 0,
					X = 0,
					K = !1,
					G = !1,
					ue = [],
					ae = { data: [], errors: [], meta: {} };
				if (M(w.step)) {
					var Ue = w.step;
					w.step = function (he) {
						if (((ae = he), ge())) ie();
						else {
							if ((ie(), ae.data.length === 0)) return;
							(z += he.data.length), w.preview && z > w.preview ? S.abort() : ((ae.data = ae.data[0]), Ue(ae, H));
						}
					};
				}
				function Z(he) {
					return w.skipEmptyLines === "greedy" ? he.join("").trim() === "" : he.length === 1 && he[0].length === 0;
				}
				function ie() {
					return (
						ae && L && (j("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + l.DefaultDelimiter + "'"), (L = !1)),
						w.skipEmptyLines &&
							(ae.data = ae.data.filter(function (he) {
								return !Z(he);
							})),
						ge() &&
							(function () {
								if (!ae) return;
								function he(He, F) {
									M(w.transformHeader) && (He = w.transformHeader(He, F)), ue.push(He);
								}
								if (Array.isArray(ae.data[0])) {
									for (var xe = 0; ge() && xe < ae.data.length; xe++) ae.data[xe].forEach(he);
									ae.data.splice(0, 1);
								} else ae.data.forEach(he);
							})(),
						(function () {
							if (!ae || (!w.header && !w.dynamicTyping && !w.transform)) return ae;
							function he(He, F) {
								var fe,
									pe = w.header ? {} : [];
								for (fe = 0; fe < He.length; fe++) {
									var Ee = fe,
										re = He[fe];
									w.header && (Ee = fe >= ue.length ? "__parsed_extra" : ue[fe]), w.transform && (re = w.transform(re, Ee)), (re = V(Ee, re)), Ee === "__parsed_extra" ? ((pe[Ee] = pe[Ee] || []), pe[Ee].push(re)) : (pe[Ee] = re);
								}
								return w.header && (fe > ue.length ? j("FieldMismatch", "TooManyFields", "Too many fields: expected " + ue.length + " fields but parsed " + fe, X + F) : fe < ue.length && j("FieldMismatch", "TooFewFields", "Too few fields: expected " + ue.length + " fields but parsed " + fe, X + F)), pe;
							}
							var xe = 1;
							return !ae.data.length || Array.isArray(ae.data[0]) ? ((ae.data = ae.data.map(he)), (xe = ae.data.length)) : (ae.data = he(ae.data, 0)), w.header && ae.meta && (ae.meta.fields = ue), (X += xe), ae;
						})()
					);
				}
				function ge() {
					return w.header && ue.length === 0;
				}
				function V(he, xe) {
					return (
						(He = he),
						w.dynamicTypingFunction && w.dynamicTyping[He] === void 0 && (w.dynamicTyping[He] = w.dynamicTypingFunction(He)),
						(w.dynamicTyping[He] || w.dynamicTyping) === !0
							? xe === "true" ||
							  xe === "TRUE" ||
							  (xe !== "false" &&
									xe !== "FALSE" &&
									((function (F) {
										if (B.test(F)) {
											var fe = parseFloat(F);
											if (k < fe && fe < N) return !0;
										}
										return !1;
									})(xe)
										? parseFloat(xe)
										: W.test(xe)
										? new Date(xe)
										: xe === ""
										? null
										: xe))
							: xe
					);
					var He;
				}
				function j(he, xe, He, F) {
					var fe = { type: he, code: xe, message: He };
					F !== void 0 && (fe.row = F), ae.errors.push(fe);
				}
				(this.parse = function (he, xe, He) {
					var F = w.quoteChar || '"';
					if (
						(w.newline ||
							(w.newline = (function (Ee, re) {
								Ee = Ee.substring(0, 1048576);
								var We = new RegExp(p(re) + "([^]*?)" + p(re), "gm"),
									Ce = (Ee = Ee.replace(We, "")).split("\r"),
									Ie = Ee.split(`
`),
									U = 1 < Ie.length && Ie[0].length < Ce[0].length;
								if (Ce.length === 1 || U)
									return `
`;
								for (var R = 0, ee = 0; ee < Ce.length; ee++)
									Ce[ee][0] ===
										`
` && R++;
								return R >= Ce.length / 2
									? `\r
`
									: "\r";
							})(he, F)),
						(L = !1),
						w.delimiter)
					)
						M(w.delimiter) && ((w.delimiter = w.delimiter(he)), (ae.meta.delimiter = w.delimiter));
					else {
						var fe = (function (Ee, re, We, Ce, Ie) {
							var U, R, ee, de;
							Ie = Ie || [",", "	", "|", ";", l.RECORD_SEP, l.UNIT_SEP];
							for (var me = 0; me < Ie.length; me++) {
								var oe = Ie[me],
									Xe = 0,
									Me = 0,
									Pe = 0;
								ee = void 0;
								for (var Je = new g({ comments: Ce, delimiter: oe, newline: re, preview: 10 }).parse(Ee), we = 0; we < Je.data.length; we++)
									if (We && Z(Je.data[we])) Pe++;
									else {
										var Fe = Je.data[we].length;
										(Me += Fe), ee !== void 0 ? 0 < Fe && ((Xe += Math.abs(Fe - ee)), (ee = Fe)) : (ee = Fe);
									}
								0 < Je.data.length && (Me /= Je.data.length - Pe), (R === void 0 || Xe <= R) && (de === void 0 || de < Me) && 1.99 < Me && ((R = Xe), (U = oe), (de = Me));
							}
							return { successful: !!(w.delimiter = U), bestDelimiter: U };
						})(he, w.newline, w.skipEmptyLines, w.comments, w.delimitersToGuess);
						fe.successful ? (w.delimiter = fe.bestDelimiter) : ((L = !0), (w.delimiter = l.DefaultDelimiter)), (ae.meta.delimiter = w.delimiter);
					}
					var pe = P(w);
					return w.preview && w.header && pe.preview++, (y = he), (S = new g(pe)), (ae = S.parse(y, xe, He)), ie(), K ? { meta: { paused: !0 } } : ae || { meta: { paused: !1 } };
				}),
					(this.paused = function () {
						return K;
					}),
					(this.pause = function () {
						(K = !0), S.abort(), (y = M(w.chunk) ? "" : y.substring(S.getCharIndex()));
					}),
					(this.resume = function () {
						H.streamer._halted ? ((K = !1), H.streamer.parseChunk(y, !0)) : setTimeout(H.resume, 3);
					}),
					(this.aborted = function () {
						return G;
					}),
					(this.abort = function () {
						(G = !0), S.abort(), (ae.meta.aborted = !0), M(w.complete) && w.complete(ae), (y = "");
					});
			}
			function p(w) {
				return w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
			}
			function g(w) {
				var y,
					S = (w = w || {}).delimiter,
					L = w.newline,
					N = w.comments,
					k = w.step,
					B = w.preview,
					W = w.fastMode,
					H = (y = w.quoteChar === void 0 || w.quoteChar === null ? '"' : w.quoteChar);
				if ((w.escapeChar !== void 0 && (H = w.escapeChar), (typeof S != "string" || -1 < l.BAD_DELIMITERS.indexOf(S)) && (S = ","), N === S)) throw new Error("Comment character same as delimiter");
				N === !0 ? (N = "#") : (typeof N != "string" || -1 < l.BAD_DELIMITERS.indexOf(N)) && (N = !1),
					L !==
						`
` &&
						L !== "\r" &&
						L !==
							`\r
` &&
						(L = `
`);
				var z = 0,
					X = !1;
				(this.parse = function (K, G, ue) {
					if (typeof K != "string") throw new Error("Input must be a string");
					var ae = K.length,
						Ue = S.length,
						Z = L.length,
						ie = N.length,
						ge = M(k),
						V = [],
						j = [],
						he = [],
						xe = (z = 0);
					if (!K) return lt();
					if (w.header && !G) {
						var He = K.split(L)[0].split(S),
							F = [],
							fe = {},
							pe = !1;
						for (var Ee in He) {
							var re = He[Ee];
							M(w.transformHeader) && (re = w.transformHeader(re, Ee));
							var We = re,
								Ce = fe[re] || 0;
							for (0 < Ce && ((pe = !0), (We = re + "_" + Ce)), fe[re] = Ce + 1; F.includes(We); ) We = We + "_" + Ce;
							F.push(We);
						}
						if (pe) {
							var Ie = K.split(L);
							(Ie[0] = F.join(S)), (K = Ie.join(L));
						}
					}
					if (W || (W !== !1 && K.indexOf(y) === -1)) {
						for (var U = K.split(L), R = 0; R < U.length; R++) {
							if (((he = U[R]), (z += he.length), R !== U.length - 1)) z += L.length;
							else if (ue) return lt();
							if (!N || he.substring(0, ie) !== N) {
								if (ge) {
									if (((V = []), Pe(he.split(S)), ot(), X)) return lt();
								} else Pe(he.split(S));
								if (B && B <= R) return (V = V.slice(0, B)), lt(!0);
							}
						}
						return lt();
					}
					for (var ee = K.indexOf(S, z), de = K.indexOf(L, z), me = new RegExp(p(H) + p(y), "g"), oe = K.indexOf(y, z); ; )
						if (K[z] !== y)
							if (N && he.length === 0 && K.substring(z, z + ie) === N) {
								if (de === -1) return lt();
								(z = de + Z), (de = K.indexOf(L, z)), (ee = K.indexOf(S, z));
							} else if (ee !== -1 && (ee < de || de === -1)) he.push(K.substring(z, ee)), (z = ee + Ue), (ee = K.indexOf(S, z));
							else {
								if (de === -1) break;
								if ((he.push(K.substring(z, de)), Fe(de + Z), ge && (ot(), X))) return lt();
								if (B && V.length >= B) return lt(!0);
							}
						else
							for (oe = z, z++; ; ) {
								if ((oe = K.indexOf(y, oe + 1)) === -1) return ue || j.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: V.length, index: z }), we();
								if (oe === ae - 1) return we(K.substring(z, oe).replace(me, y));
								if (y !== H || K[oe + 1] !== H) {
									if (y === H || oe === 0 || K[oe - 1] !== H) {
										ee !== -1 && ee < oe + 1 && (ee = K.indexOf(S, oe + 1)), de !== -1 && de < oe + 1 && (de = K.indexOf(L, oe + 1));
										var Xe = Je(de === -1 ? ee : Math.min(ee, de));
										if (K.substr(oe + 1 + Xe, Ue) === S) {
											he.push(K.substring(z, oe).replace(me, y)), K[(z = oe + 1 + Xe + Ue)] !== y && (oe = K.indexOf(y, z)), (ee = K.indexOf(S, z)), (de = K.indexOf(L, z));
											break;
										}
										var Me = Je(de);
										if (K.substring(oe + 1 + Me, oe + 1 + Me + Z) === L) {
											if ((he.push(K.substring(z, oe).replace(me, y)), Fe(oe + 1 + Me + Z), (ee = K.indexOf(S, z)), (oe = K.indexOf(y, z)), ge && (ot(), X))) return lt();
											if (B && V.length >= B) return lt(!0);
											break;
										}
										j.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: V.length, index: z }), oe++;
									}
								} else oe++;
							}
					return we();
					function Pe(Ne) {
						V.push(Ne), (xe = z);
					}
					function Je(Ne) {
						var dt = 0;
						if (Ne !== -1) {
							var vt = K.substring(oe + 1, Ne);
							vt && vt.trim() === "" && (dt = vt.length);
						}
						return dt;
					}
					function we(Ne) {
						return ue || (Ne === void 0 && (Ne = K.substring(z)), he.push(Ne), (z = ae), Pe(he), ge && ot()), lt();
					}
					function Fe(Ne) {
						(z = Ne), Pe(he), (he = []), (de = K.indexOf(L, z));
					}
					function lt(Ne) {
						return { data: V, errors: j, meta: { delimiter: S, linebreak: L, aborted: X, truncated: !!Ne, cursor: xe + (G || 0) } };
					}
					function ot() {
						k(lt()), (V = []), (j = []);
					}
				}),
					(this.abort = function () {
						X = !0;
					}),
					(this.getCharIndex = function () {
						return z;
					});
			}
			function x(w) {
				var y = w.data,
					S = a[y.workerId],
					L = !1;
				if (y.error) S.userError(y.error, y.file);
				else if (y.results && y.results.data) {
					var N = {
						abort: function () {
							(L = !0), b(y.workerId, { data: [], errors: [], meta: { aborted: !0 } });
						},
						pause: T,
						resume: T
					};
					if (M(S.userStep)) {
						for (var k = 0; k < y.results.data.length && (S.userStep({ data: y.results.data[k], errors: y.results.errors, meta: y.results.meta }, N), !L); k++);
						delete y.results;
					} else M(S.userChunk) && (S.userChunk(y.results, N, y.file), delete y.results);
				}
				y.finished && !L && b(y.workerId, y.results);
			}
			function b(w, y) {
				var S = a[w];
				M(S.userComplete) && S.userComplete(y), S.terminate(), delete a[w];
			}
			function T() {
				throw new Error("Not implemented.");
			}
			function P(w) {
				if (typeof w != "object" || w === null) return w;
				var y = Array.isArray(w) ? [] : {};
				for (var S in w) y[S] = P(w[S]);
				return y;
			}
			function A(w, y) {
				return function () {
					w.apply(y, arguments);
				};
			}
			function M(w) {
				return typeof w == "function";
			}
			return (
				s &&
					(i.onmessage = function (w) {
						var y = w.data;
						if ((l.WORKER_ID === void 0 && y && (l.WORKER_ID = y.workerId), typeof y.input == "string")) i.postMessage({ workerId: l.WORKER_ID, results: l.parse(y.input, y.config), finished: !0 });
						else if ((i.File && y.input instanceof File) || y.input instanceof Object) {
							var S = l.parse(y.input, y.config);
							S && i.postMessage({ workerId: l.WORKER_ID, results: S, finished: !0 });
						}
					}),
				((h.prototype = Object.create(u.prototype)).constructor = h),
				((d.prototype = Object.create(u.prototype)).constructor = d),
				((f.prototype = Object.create(f.prototype)).constructor = f),
				((v.prototype = Object.create(u.prototype)).constructor = v),
				l
			);
		});
	})(Cb);
	var Lk = Cb.exports;
	const Lb = U_(Lk);
	let lo = [];
	const Rk = (n) => {
		Lb.parse(n, {
			header: !1,
			skipEmptyLines: !0,
			dynamicTyping: !0,
			complete: function (e) {
				const t = e.meta.fields,
					i = e.data,
					r = JSON.parse(localStorage.getItem("columnOrder") || "{}"),
					s = parseInt(r.headerRows) || 0;
				let a;
				s === 0
					? (a = [Object.keys(i[0]).join(","), ...i.map((o) => Object.values(o).join(","))].join(`
`))
					: (a = i.slice(s).map((o) => Object.values(o).join(",")).join(`
`)),
					Ck(t, a, i);
			}
		});
	};
	let qi = new D(0, 0, 0);
	const Pk = (n, e) => {
			try {
				const t = "csvBlastStore" + ch.csvFileCount,
					i = Ak(n, e, t);
				lo.push(...i), ch.csvFileCount++;
				let r,
					s,
					a,
					o = e.diameter_units || "mm";
				le.worldXCenter === 0 && le.worldYCenter === 0 ? ((qi = Rl(lo)), (r = qi.x), (s = qi.y), (a = qi.z), (le.worldXCenter = r), (le.worldYCenter = s), Cs()) : ((r = le.worldXCenter || 0), (s = le.worldYCenter || 0), (a = 0));
				const l = Date.now();
				let c = 0;
				for (const u of lo) {
					const h = {
						blastName: u.blastName,
						pointID: `${u.pointID}`,
						startXLocation: u.startXLocation - r,
						startYLocation: u.startYLocation - s,
						startZLocation: u.startZLocation,
						endXLocation: u.endXLocation !== null && u.endXLocation !== void 0 ? u.endXLocation - r : null,
						endYLocation: u.endYLocation !== null && u.endYLocation !== void 0 ? u.endYLocation - s : null,
						endZLocation: u.endZLocation !== null && u.endZLocation !== void 0 ? u.endZLocation : null,
						diameter: u.diameter || null,
						subdrill: u.subdrill || null,
						shapeType: u.shapeType || null,
						holeColour: u.holeColour || null
					};
					c++;
					const d = h.pointID !== null && h.pointID !== void 0,
						f = h.startXLocation !== null && h.startYLocation !== null && h.startZLocation !== null,
						v = h.endXLocation !== null && h.endYLocation !== null && h.endZLocation !== null,
						_ = h.diameter !== null && h.diameter !== void 0 && h.diameter > 0,
						p = h.subdrill !== null && h.subdrill !== void 0,
						g = h.shapeType !== null && h.shapeType !== void 0,
						x = h.holeColour !== null && h.holeColour !== void 0;
					if (!d || !f) {
						alert("Point ID and Start XYZ location are required");
						return;
					}
					h.blastName == null || h.blastName == null || h.blastName == "" || h.blastName == " " ? ((h.blastName = t), (u.blastName = t)) : (h.blastName = u.blastName),
						d && f && !v
							? ((h.diameter = null), (h.subdrill = null), (h.shapeType = "mesh-dummy"), (h.holeColour = u.holeColour || 16777215), Tb(Bt, h.holeColour, h), (u.diameter = null), (u.subdrill = null), (u.holeColour = u.holeColour || 16777215), (u.shapeType = "mesh-dummy"))
							: d && f && v && _ && p && g && x
							? Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType)
							: d && f && v && _ && p && g && !x
							? ((h.holeColour = 16777215), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.holeColour = 16777215))
							: d && f && v && _ && p && !g && x
							? ((h.shapeType = "mesh-cylinder"), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.shapeType = "mesh-cylinder"))
							: d && f && v && _ && !p && g && x
							? ((h.subdrill = 0), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.subdrill = 0))
							: d && f && v && _ && !p && !g && !x
							? ((h.subdrill = 0), (h.holeColour = 16777215), (h.shapeType = "mesh-cylinder"), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.subdrill = 0), (u.holeColour = 16777215), (u.shapeType = "mesh-cylinder"))
							: d && f && v && _ && p && !g && !x
							? ((h.holeColour = 16777215), (h.shapeType = "mesh-cylinder"), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.holeColour = 16777215), (u.shapeType = "mesh-cylinder"))
							: d && f && v && _ && !p && !g && x
							? ((h.subdrill = 0), (h.shapeType = "mesh-cylinder"), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.subdrill = 0), (u.shapeType = "mesh-cylinder"))
							: d && f && v && !_
							? ((h.diameter = 0), (h.subdrill = u.subdrill || 0), (h.holeColour = u.holeColour || 16777215), (h.shapeType = "mesh-cube"), Pi(Bt, h.holeColour, h, h.diameter, h.subdrill, h.shapeType), (u.diameter = 0), (u.shapeType = "mesh-cube"), (u.subdrill = u.subdrill || 0), (u.holeColour = u.holeColour || 16777215))
							: lo.length == c && (alert("Error: Invalid properties - Check Set Order or File"), console.log("Error: Invalid properties"));
				}
				le.debugComments && (console.log("fileCSVUpload/handleFileSubmit/points: ", lo), console.log("Objects in scene: ", Bt.children)),
					(qi = Rl(lo)),
					cn.position.set(qi.x - le.worldXCenter, qi.y - le.worldYCenter, qi.z),
					ft.position.set(cn.position.x, cn.position.y, parseFloat(le.cameraDistance)),
					Ct.target.set(qi.x - le.worldXCenter, qi.y - le.worldYCenter, qi.z),
					ft.lookAt(cn.position),
					ft.updateProjectionMatrix(),
					Ct.update(),
					es(Bt, ft),
					le.debugComments && console.log("fileUpload/handleFileSubmit/controls.target", Ct.target),
					ft.updateMatrixWorld();
			} catch (t) {
				console.error("Error in handleFileSubmit: ", t), alert("Error in handleFileSubmit: " + t);
			}
		},
		Dk = () => {
			document.getElementById("import-holes").addEventListener("click", function () {
				console.clear(), console.log("Import button clicked");
				const n = document.createElement("input");
				(n.type = "file"),
					(n.accept = ".csv , .txt"),
					(n.style.display = "none"),
					(n.onchange = (e) => {
						if ((console.log("File selected"), e.target.files && e.target.files[0])) {
							const t = e.target.files[0],
								i = new FileReader();
							(i.onload = (r) => {
								const s = r.target.result;
								Rk(s);
							}),
								i.readAsText(t);
						}
					}),
					document.body.appendChild(n),
					n.click(),
					document.body.removeChild(n),
					le.debugComments && (console.clear(), console.log("Load File button clicked"));
			});
		},
		Ok = (n) => {
			document.getElementById("import-obj").addEventListener("click", function () {
				const e = document.createElement("input");
				(e.type = "file"),
					(e.accept = ".obj,.mtl,image/*"),
					(e.multiple = !0),
					(e.style.display = "none"),
					(e.onchange = (t) => {
						if (t.target.files) {
							const i = Array.from(t.target.files);
							Sk(i, n);
						}
					}),
					document.body.appendChild(e),
					e.click(),
					document.body.removeChild(e),
					le.debugComments && console.log("Load OBJ button clicked"),
					(document.querySelector("#info-label").textContent =
						"Files selected: " +
						Array.from(e.files)
							.map((t) => t.name)
							.join(", "));
			});
		};
	class Ik {
		constructor(e) {
			(this._pointer = 0), (this._eof = !1), (this._data = e);
		}
		next() {
			if (!this.hasNext()) throw this._eof ? new Error("Cannot call 'next' after EOF group has been read") : new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
			const e = { code: parseInt(this._data[this._pointer]) };
			return this._pointer++, (e.value = P_(e.code, this._data[this._pointer].trim())), this._pointer++, e.code === 0 && e.value === "EOF" && (this._eof = !0), (this.lastReadGroup = e), e;
		}
		peek() {
			if (!this.hasNext()) throw this._eof ? new Error("Cannot call 'next' after EOF group has been read") : new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
			const e = { code: parseInt(this._data[this._pointer]) };
			return (e.value = P_(e.code, this._data[this._pointer + 1].trim())), e;
		}
		rewind(e = 1) {
			this._pointer = this._pointer - e * 2;
		}
		hasNext() {
			return !(this._eof || this._pointer > this._data.length - 2);
		}
		isEOF() {
			return this._eof;
		}
	}
	function P_(n, e) {
		return n <= 9
			? e
			: n >= 10 && n <= 59
			? parseFloat(e)
			: n >= 60 && n <= 99
			? parseInt(e)
			: n >= 100 && n <= 109
			? e
			: n >= 110 && n <= 149
			? parseFloat(e)
			: n >= 160 && n <= 179
			? parseInt(e)
			: n >= 210 && n <= 239
			? parseFloat(e)
			: n >= 270 && n <= 289
			? parseInt(e)
			: n >= 290 && n <= 299
			? Fk(e)
			: n >= 300 && n <= 369
			? e
			: n >= 370 && n <= 389
			? parseInt(e)
			: n >= 390 && n <= 399
			? e
			: n >= 400 && n <= 409
			? parseInt(e)
			: n >= 410 && n <= 419
			? e
			: n >= 420 && n <= 429
			? parseInt(e)
			: n >= 430 && n <= 439
			? e
			: n >= 440 && n <= 459
			? parseInt(e)
			: n >= 460 && n <= 469
			? parseFloat(e)
			: (n >= 470 && n <= 481) || n === 999 || (n >= 1e3 && n <= 1009)
			? e
			: n >= 1010 && n <= 1059
			? parseFloat(e)
			: n >= 1060 && n <= 1071
			? parseInt(e)
			: (console.log("WARNING: Group code does not have a defined type: %j", { code: n, value: e }), e);
	}
	function Fk(n) {
		if (n === "0") return !1;
		if (n === "1") return !0;
		throw TypeError("String '" + n + "' cannot be cast to Boolean type");
	}
	const Rb = [
		0, 16711680, 16776960, 65280, 65535, 255, 16711935, 16777215, 8421504, 12632256, 16711680, 16744319, 13369344, 13395558, 10027008, 10046540, 8323072, 8339263, 4980736, 4990502, 16727808, 16752511, 13382400, 13401958, 10036736, 10051404, 8331008, 8343359, 4985600, 4992806, 16744192, 16760703, 13395456, 13408614, 10046464, 10056268, 8339200, 8347455, 4990464, 4995366, 16760576, 16768895, 13408512, 13415014, 10056192, 10061132, 8347392, 8351551, 4995328, 4997670, 16776960, 16777087,
		13421568, 13421670, 10000384, 10000460, 8355584, 8355647, 5000192, 5000230, 12582656, 14679935, 10079232, 11717734, 7510016, 8755276, 6258432, 7307071, 3755008, 4344870, 8388352, 12582783, 6736896, 10079334, 5019648, 7510092, 4161280, 6258495, 2509824, 3755046, 4194048, 10485631, 3394560, 8375398, 2529280, 6264908, 2064128, 5209919, 1264640, 3099686, 65280, 8388479, 52224, 6736998, 38912, 5019724, 32512, 4161343, 19456, 2509862, 65343, 8388511, 52275, 6737023, 38950, 5019743, 32543,
		4161359, 19475, 2509871, 65407, 8388543, 52326, 6737049, 38988, 5019762, 32575, 4161375, 19494, 2509881, 65471, 8388575, 52377, 6737074, 39026, 5019781, 32607, 4161391, 19513, 2509890, 65535, 8388607, 52428, 6737100, 39064, 5019800, 32639, 4161407, 19532, 2509900, 49151, 8380415, 39372, 6730444, 29336, 5014936, 24447, 4157311, 14668, 2507340, 32767, 8372223, 26316, 6724044, 19608, 5010072, 16255, 4153215, 9804, 2505036, 16383, 8364031, 13260, 6717388, 9880, 5005208, 8063, 4149119, 4940,
		2502476, 255, 8355839, 204, 6710988, 152, 5000344, 127, 4145023, 76, 2500172, 4129023, 10452991, 3342540, 8349388, 2490520, 6245528, 2031743, 5193599, 1245260, 3089996, 8323327, 12550143, 6684876, 10053324, 4980888, 7490712, 4128895, 6242175, 2490444, 3745356, 12517631, 14647295, 10027212, 11691724, 7471256, 8735896, 6226047, 7290751, 3735628, 4335180, 16711935, 16744447, 13369548, 13395660, 9961624, 9981080, 8323199, 8339327, 4980812, 4990540, 16711871, 16744415, 13369497, 13395634,
		9961586, 9981061, 8323167, 8339311, 4980793, 4990530, 16711807, 16744383, 13369446, 13395609, 9961548, 9981042, 8323135, 8339295, 4980774, 4990521, 16711743, 16744351, 13369395, 13395583, 9961510, 9981023, 8323103, 8339279, 4980755, 4990511, 3355443, 5987163, 8684676, 11382189, 14079702, 16777215
	];
	function Nk(n) {
		return Rb[n];
	}
	function Dt(n) {
		const e = {};
		n.rewind();
		let t = n.next(),
			i = t.code;
		if (((e.x = t.value), (i += 10), (t = n.next()), t.code != i)) throw new Error("Expected code for point value to be " + i + " but got " + t.code + ".");
		return (e.y = t.value), (i += 10), (t = n.next()), t.code != i ? (n.rewind(), e) : ((e.z = t.value), e);
	}
	function kn(n, e, t) {
		switch (e.code) {
			case 0:
				n.type = e.value;
				break;
			case 5:
				n.handle = e.value;
				break;
			case 6:
				n.lineType = e.value;
				break;
			case 8:
				n.layer = e.value;
				break;
			case 48:
				n.lineTypeScale = e.value;
				break;
			case 60:
				n.visible = e.value === 0;
				break;
			case 62:
				(n.colorIndex = e.value), (n.color = Nk(Math.abs(e.value)));
				break;
			case 67:
				n.inPaperSpace = e.value !== 0;
				break;
			case 100:
				break;
			case 101:
				for (; e.code != 0; ) e = t.next();
				t.rewind();
				break;
			case 330:
				n.ownerHandle = e.value;
				break;
			case 347:
				n.materialObjectHandle = e.value;
				break;
			case 370:
				n.lineweight = e.value;
				break;
			case 420:
				n.color = e.value;
				break;
			case 1e3:
				(n.extendedData = n.extendedData || {}), (n.extendedData.customStrings = n.extendedData.customStrings || []), n.extendedData.customStrings.push(e.value);
				break;
			case 1001:
				(n.extendedData = n.extendedData || {}), (n.extendedData.applicationName = e.value);
				break;
			default:
				return !1;
		}
		return !0;
	}
	class Uk {
		constructor() {
			this.ForEntityName = "3DFACE";
		}
		parseEntity(e, t) {
			const i = { type: t.value, vertices: [] };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 70:
						(i.shape = (t.value & 1) === 1), (i.hasContinuousLinetypePattern = (t.value & 128) === 128);
						break;
					case 10:
						(i.vertices = kk(e, t)), (t = e.lastReadGroup);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	function kk(n, e) {
		var t = [],
			i = !1,
			r = !1,
			s = 4;
		for (let o = 0; o <= s; o++) {
			for (var a = {}; !n.isEOF() && !(e.code === 0 || r); ) {
				switch (e.code) {
					case 10:
					case 11:
					case 12:
					case 13:
						if (i) {
							r = !0;
							continue;
						}
						(a.x = e.value), (i = !0);
						break;
					case 20:
					case 21:
					case 22:
					case 23:
						a.y = e.value;
						break;
					case 30:
					case 31:
					case 32:
					case 33:
						a.z = e.value;
						break;
					default:
						return t;
				}
				e = n.next();
			}
			t.push(a), (i = !1), (r = !1);
		}
		return n.rewind(), t;
	}
	class Bk {
		constructor() {
			this.ForEntityName = "ARC";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.center = Dt(e);
						break;
					case 40:
						i.radius = t.value;
						break;
					case 50:
						i.startAngle = (Math.PI / 180) * t.value;
						break;
					case 51:
						(i.endAngle = (Math.PI / 180) * t.value), (i.angleLength = i.endAngle - i.startAngle);
						break;
					case 210:
						i.extrusionDirectionX = t.value;
						break;
					case 220:
						i.extrusionDirectionY = t.value;
						break;
					case 230:
						i.extrusionDirectionZ = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class zk {
		constructor() {
			this.ForEntityName = "ATTDEF";
		}
		parseEntity(e, t) {
			var i = { type: t.value, scale: 1, textStyle: "STANDARD" };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 1:
						i.text = t.value;
						break;
					case 2:
						i.tag = t.value;
						break;
					case 3:
						i.prompt = t.value;
						break;
					case 7:
						i.textStyle = t.value;
						break;
					case 10:
						i.startPoint = Dt(e);
						break;
					case 11:
						i.endPoint = Dt(e);
						break;
					case 39:
						i.thickness = t.value;
						break;
					case 40:
						i.textHeight = t.value;
						break;
					case 41:
						i.scale = t.value;
						break;
					case 50:
						i.rotation = t.value;
						break;
					case 51:
						i.obliqueAngle = t.value;
						break;
					case 70:
						(i.invisible = !!(t.value & 1)), (i.constant = !!(t.value & 2)), (i.verificationRequired = !!(t.value & 4)), (i.preset = !!(t.value & 8));
						break;
					case 71:
						(i.backwards = !!(t.value & 2)), (i.mirrored = !!(t.value & 4));
						break;
					case 72:
						i.horizontalJustification = t.value;
						break;
					case 73:
						i.fieldLength = t.value;
						break;
					case 74:
						i.verticalJustification = t.value;
						break;
					case 100:
						break;
					case 210:
						i.extrusionDirectionX = t.value;
						break;
					case 220:
						i.extrusionDirectionY = t.value;
						break;
					case 230:
						i.extrusionDirectionZ = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Hk {
		constructor() {
			this.ForEntityName = "CIRCLE";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.center = Dt(e);
						break;
					case 40:
						i.radius = t.value;
						break;
					case 50:
						i.startAngle = (Math.PI / 180) * t.value;
						break;
					case 51:
						const r = (Math.PI / 180) * t.value;
						r < i.startAngle ? (i.angleLength = r + 2 * Math.PI - i.startAngle) : (i.angleLength = r - i.startAngle), (i.endAngle = r);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Gk {
		constructor() {
			this.ForEntityName = "DIMENSION";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 2:
						i.block = t.value;
						break;
					case 10:
						i.anchorPoint = Dt(e);
						break;
					case 11:
						i.middleOfText = Dt(e);
						break;
					case 12:
						i.insertionPoint = Dt(e);
						break;
					case 13:
						i.linearOrAngularPoint1 = Dt(e);
						break;
					case 14:
						i.linearOrAngularPoint2 = Dt(e);
						break;
					case 15:
						i.diameterOrRadiusPoint = Dt(e);
						break;
					case 16:
						i.arcPoint = Dt(e);
						break;
					case 70:
						i.dimensionType = t.value;
						break;
					case 71:
						i.attachmentPoint = t.value;
						break;
					case 42:
						i.actualMeasurement = t.value;
						break;
					case 1:
						i.text = t.value;
						break;
					case 50:
						i.angle = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Vk {
		constructor() {
			this.ForEntityName = "ELLIPSE";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.center = Dt(e);
						break;
					case 11:
						i.majorAxisEndPoint = Dt(e);
						break;
					case 40:
						i.axisRatio = t.value;
						break;
					case 41:
						i.startAngle = t.value;
						break;
					case 42:
						i.endAngle = t.value;
						break;
					case 2:
						i.name = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Wk {
		constructor() {
			this.ForEntityName = "INSERT";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 2:
						i.name = t.value;
						break;
					case 41:
						i.xScale = t.value;
						break;
					case 42:
						i.yScale = t.value;
						break;
					case 43:
						i.zScale = t.value;
						break;
					case 10:
						i.position = Dt(e);
						break;
					case 50:
						i.rotation = t.value;
						break;
					case 70:
						i.columnCount = t.value;
						break;
					case 71:
						i.rowCount = t.value;
						break;
					case 44:
						i.columnSpacing = t.value;
						break;
					case 45:
						i.rowSpacing = t.value;
						break;
					case 210:
						i.extrusionDirection = Dt(e);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Xk {
		constructor() {
			this.ForEntityName = "LINE";
		}
		parseEntity(e, t) {
			const i = { type: t.value, vertices: [] };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.vertices.unshift(Dt(e));
						break;
					case 11:
						i.vertices.push(Dt(e));
						break;
					case 210:
						i.extrusionDirection = Dt(e);
						break;
					case 100:
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class $k {
		constructor() {
			this.ForEntityName = "LWPOLYLINE";
		}
		parseEntity(e, t) {
			const i = { type: t.value, vertices: [] };
			let r = 0;
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 38:
						i.elevation = t.value;
						break;
					case 39:
						i.depth = t.value;
						break;
					case 70:
						(i.shape = (t.value & 1) === 1), (i.hasContinuousLinetypePattern = (t.value & 128) === 128);
						break;
					case 90:
						r = t.value;
						break;
					case 10:
						i.vertices = qk(r, e);
						break;
					case 43:
						t.value !== 0 && (i.width = t.value);
						break;
					case 210:
						i.extrusionDirectionX = t.value;
						break;
					case 220:
						i.extrusionDirectionY = t.value;
						break;
					case 230:
						i.extrusionDirectionZ = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	function qk(n, e) {
		if (!n || n <= 0) throw Error("n must be greater than 0 verticies");
		const t = [];
		let i = !1,
			r = !1,
			s = e.lastReadGroup;
		for (let a = 0; a < n; a++) {
			const o = {};
			for (; !e.isEOF() && !(s.code === 0 || r); ) {
				switch (s.code) {
					case 10:
						if (i) {
							r = !0;
							continue;
						}
						(o.x = s.value), (i = !0);
						break;
					case 20:
						o.y = s.value;
						break;
					case 30:
						o.z = s.value;
						break;
					case 40:
						o.startWidth = s.value;
						break;
					case 41:
						o.endWidth = s.value;
						break;
					case 42:
						s.value != 0 && (o.bulge = s.value);
						break;
					default:
						return e.rewind(), i && t.push(o), e.rewind(), t;
				}
				s = e.next();
			}
			t.push(o), (i = !1), (r = !1);
		}
		return e.rewind(), t;
	}
	class jk {
		constructor() {
			this.ForEntityName = "MTEXT";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 3:
						i.text ? (i.text += t.value) : (i.text = t.value);
						break;
					case 1:
						i.text ? (i.text += t.value) : (i.text = t.value);
						break;
					case 10:
						i.position = Dt(e);
						break;
					case 11:
						i.directionVector = Dt(e);
						break;
					case 40:
						i.height = t.value;
						break;
					case 41:
						i.width = t.value;
						break;
					case 50:
						i.rotation = t.value;
						break;
					case 71:
						i.attachmentPoint = t.value;
						break;
					case 72:
						i.drawingDirection = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Yk {
		constructor() {
			this.ForEntityName = "POINT";
		}
		parseEntity(e, t) {
			const r = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						r.position = Dt(e);
						break;
					case 39:
						r.thickness = t.value;
						break;
					case 210:
						r.extrusionDirection = Dt(e);
						break;
					case 100:
						break;
					default:
						kn(r, t, e);
						break;
				}
				t = e.next();
			}
			return r;
		}
	}
	class Kk {
		constructor() {
			this.ForEntityName = "VERTEX";
		}
		parseEntity(e, t) {
			var i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.x = t.value;
						break;
					case 20:
						i.y = t.value;
						break;
					case 30:
						i.z = t.value;
						break;
					case 40:
						break;
					case 41:
						break;
					case 42:
						t.value != 0 && (i.bulge = t.value);
						break;
					case 70:
						(i.curveFittingVertex = (t.value & 1) !== 0), (i.curveFitTangent = (t.value & 2) !== 0), (i.splineVertex = (t.value & 8) !== 0), (i.splineControlPoint = (t.value & 16) !== 0), (i.threeDPolylineVertex = (t.value & 32) !== 0), (i.threeDPolylineMesh = (t.value & 64) !== 0), (i.polyfaceMeshVertex = (t.value & 128) !== 0);
						break;
					case 50:
						break;
					case 71:
						i.faceA = t.value;
						break;
					case 72:
						i.faceB = t.value;
						break;
					case 73:
						i.faceC = t.value;
						break;
					case 74:
						i.faceD = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class Zk {
		constructor() {
			this.ForEntityName = "POLYLINE";
		}
		parseEntity(e, t) {
			var i = { type: t.value, vertices: [] };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						break;
					case 20:
						break;
					case 30:
						break;
					case 39:
						i.thickness = t.value;
						break;
					case 40:
						break;
					case 41:
						break;
					case 70:
						(i.shape = (t.value & 1) !== 0), (i.includesCurveFitVertices = (t.value & 2) !== 0), (i.includesSplineFitVertices = (t.value & 4) !== 0), (i.is3dPolyline = (t.value & 8) !== 0), (i.is3dPolygonMesh = (t.value & 16) !== 0), (i.is3dPolygonMeshClosed = (t.value & 32) !== 0), (i.isPolyfaceMesh = (t.value & 64) !== 0), (i.hasContinuousLinetypePattern = (t.value & 128) !== 0);
						break;
					case 71:
						break;
					case 72:
						break;
					case 73:
						break;
					case 74:
						break;
					case 75:
						break;
					case 210:
						i.extrusionDirection = Dt(e);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return (i.vertices = Jk(e, t)), i;
		}
	}
	function Jk(n, e) {
		const t = new Kk(),
			i = [];
		for (; !n.isEOF(); )
			if (e.code === 0) {
				if (e.value === "VERTEX") i.push(t.parseEntity(n, e)), (e = n.lastReadGroup);
				else if (e.value === "SEQEND") {
					Qk(n, e);
					break;
				}
			}
		return i;
	}
	function Qk(n, e) {
		const t = { type: e.value };
		for (e = n.next(); !n.isEOF() && e.code != 0; ) kn(t, e, n), (e = n.next());
		return t;
	}
	class eB {
		constructor() {
			this.ForEntityName = "SOLID";
		}
		parseEntity(e, t) {
			const i = { type: t.value, points: [] };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.points[0] = Dt(e);
						break;
					case 11:
						i.points[1] = Dt(e);
						break;
					case 12:
						i.points[2] = Dt(e);
						break;
					case 13:
						i.points[3] = Dt(e);
						break;
					case 210:
						i.extrusionDirection = Dt(e);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class tB {
		constructor() {
			this.ForEntityName = "SPLINE";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.controlPoints || (i.controlPoints = []), i.controlPoints.push(Dt(e));
						break;
					case 11:
						i.fitPoints || (i.fitPoints = []), i.fitPoints.push(Dt(e));
						break;
					case 12:
						i.startTangent = Dt(e);
						break;
					case 13:
						i.endTangent = Dt(e);
						break;
					case 40:
						i.knotValues || (i.knotValues = []), i.knotValues.push(t.value);
						break;
					case 70:
						t.value & 1 && (i.closed = !0), t.value & 2 && (i.periodic = !0), t.value & 4 && (i.rational = !0), t.value & 8 && (i.planar = !0), t.value & 16 && ((i.planar = !0), (i.linear = !0));
						break;
					case 71:
						i.degreeOfSplineCurve = t.value;
						break;
					case 72:
						i.numberOfKnots = t.value;
						break;
					case 73:
						i.numberOfControlPoints = t.value;
						break;
					case 74:
						i.numberOfFitPoints = t.value;
						break;
					case 210:
						i.normalVector = Dt(e);
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	class nB {
		constructor() {
			this.ForEntityName = "TEXT";
		}
		parseEntity(e, t) {
			const i = { type: t.value };
			for (t = e.next(); !e.isEOF() && t.code !== 0; ) {
				switch (t.code) {
					case 10:
						i.startPoint = Dt(e);
						break;
					case 11:
						i.endPoint = Dt(e);
						break;
					case 40:
						i.textHeight = t.value;
						break;
					case 41:
						i.xScale = t.value;
						break;
					case 50:
						i.rotation = t.value;
						break;
					case 1:
						i.text = t.value;
						break;
					case 72:
						i.halign = t.value;
						break;
					case 73:
						i.valign = t.value;
						break;
					default:
						kn(i, t, e);
						break;
				}
				t = e.next();
			}
			return i;
		}
	}
	var Pb = { exports: {} };
	(function (n) {
		(function (e, t) {
			n.exports ? (n.exports = t()) : (e.log = t());
		})(gp, function () {
			var e = function () {},
				t = "undefined",
				i = typeof window !== t && typeof window.navigator !== t && /Trident\/|MSIE /.test(window.navigator.userAgent),
				r = ["trace", "debug", "info", "warn", "error"],
				s = {},
				a = null;
			function o(_, p) {
				var g = _[p];
				if (typeof g.bind == "function") return g.bind(_);
				try {
					return Function.prototype.bind.call(g, _);
				} catch {
					return function () {
						return Function.prototype.apply.apply(g, [_, arguments]);
					};
				}
			}
			function l() {
				console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
			}
			function c(_) {
				return _ === "debug" && (_ = "log"), typeof console === t ? !1 : _ === "trace" && i ? l : console[_] !== void 0 ? o(console, _) : console.log !== void 0 ? o(console, "log") : e;
			}
			function u() {
				for (var _ = this.getLevel(), p = 0; p < r.length; p++) {
					var g = r[p];
					this[g] = p < _ ? e : this.methodFactory(g, _, this.name);
				}
				if (((this.log = this.debug), typeof console === t && _ < this.levels.SILENT)) return "No console available for logging";
			}
			function h(_) {
				return function () {
					typeof console !== t && (u.call(this), this[_].apply(this, arguments));
				};
			}
			function d(_, p, g) {
				return c(_) || h.apply(this, arguments);
			}
			function f(_, p) {
				var g = this,
					x,
					b,
					T,
					P = "loglevel";
				typeof _ == "string" ? (P += ":" + _) : typeof _ == "symbol" && (P = void 0);
				function A(L) {
					var N = (r[L] || "silent").toUpperCase();
					if (!(typeof window === t || !P)) {
						try {
							window.localStorage[P] = N;
							return;
						} catch {}
						try {
							window.document.cookie = encodeURIComponent(P) + "=" + N + ";";
						} catch {}
					}
				}
				function M() {
					var L;
					if (!(typeof window === t || !P)) {
						try {
							L = window.localStorage[P];
						} catch {}
						if (typeof L === t)
							try {
								var N = window.document.cookie,
									k = encodeURIComponent(P),
									B = N.indexOf(k + "=");
								B !== -1 && (L = /^([^;]+)/.exec(N.slice(B + k.length + 1))[1]);
							} catch {}
						return g.levels[L] === void 0 && (L = void 0), L;
					}
				}
				function w() {
					if (!(typeof window === t || !P)) {
						try {
							window.localStorage.removeItem(P);
						} catch {}
						try {
							window.document.cookie = encodeURIComponent(P) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
						} catch {}
					}
				}
				function y(L) {
					var N = L;
					if ((typeof N == "string" && g.levels[N.toUpperCase()] !== void 0 && (N = g.levels[N.toUpperCase()]), typeof N == "number" && N >= 0 && N <= g.levels.SILENT)) return N;
					throw new TypeError("log.setLevel() called with invalid level: " + L);
				}
				(g.name = _),
					(g.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }),
					(g.methodFactory = p || d),
					(g.getLevel = function () {
						return T ?? b ?? x;
					}),
					(g.setLevel = function (L, N) {
						return (T = y(L)), N !== !1 && A(T), u.call(g);
					}),
					(g.setDefaultLevel = function (L) {
						(b = y(L)), M() || g.setLevel(L, !1);
					}),
					(g.resetLevel = function () {
						(T = null), w(), u.call(g);
					}),
					(g.enableAll = function (L) {
						g.setLevel(g.levels.TRACE, L);
					}),
					(g.disableAll = function (L) {
						g.setLevel(g.levels.SILENT, L);
					}),
					(g.rebuild = function () {
						if ((a !== g && (x = y(a.getLevel())), u.call(g), a === g)) for (var L in s) s[L].rebuild();
					}),
					(x = y(a ? a.getLevel() : "WARN"));
				var S = M();
				S != null && (T = y(S)), u.call(g);
			}
			(a = new f()),
				(a.getLogger = function (p) {
					if ((typeof p != "symbol" && typeof p != "string") || p === "") throw new TypeError("You must supply a name when creating a logger.");
					var g = s[p];
					return g || (g = s[p] = new f(p, a.methodFactory)), g;
				});
			var v = typeof window !== t ? window.log : void 0;
			return (
				(a.noConflict = function () {
					return typeof window !== t && window.log === a && (window.log = v), a;
				}),
				(a.getLoggers = function () {
					return s;
				}),
				(a.default = a),
				a
			);
		});
	})(Pb);
	var iB = Pb.exports;
	const Pt = U_(iB);
	Pt.setLevel("error");
	function rB(n) {
		n.registerEntityHandler(Uk), n.registerEntityHandler(Bk), n.registerEntityHandler(zk), n.registerEntityHandler(Hk), n.registerEntityHandler(Gk), n.registerEntityHandler(Vk), n.registerEntityHandler(Wk), n.registerEntityHandler(Xk), n.registerEntityHandler($k), n.registerEntityHandler(jk), n.registerEntityHandler(Yk), n.registerEntityHandler(Zk), n.registerEntityHandler(eB), n.registerEntityHandler(tB), n.registerEntityHandler(nB);
	}
	class sB {
		constructor() {
			(this._entityHandlers = {}), rB(this);
		}
		parse(e) {
			return typeof e == "string" ? this._parse(e) : (console.error("Cannot read dxf source of type `" + typeof e), null);
		}
		registerEntityHandler(e) {
			const t = new e();
			this._entityHandlers[t.ForEntityName] = t;
		}
		parseSync(e) {
			return this.parse(e);
		}
		parseStream(e) {
			let t = "";
			const i = this;
			return new Promise((r, s) => {
				e.on("data", (a) => {
					t += a;
				}),
					e.on("end", () => {
						try {
							r(i._parse(t));
						} catch (a) {
							s(a);
						}
					}),
					e.on("error", (a) => {
						s(a);
					});
			});
		}
		_parse(e) {
			const t = {};
			let i = 0;
			const r = e.split(/\r\n|\r|\n/g),
				s = new Ik(r);
			if (!s.hasNext()) throw Error("Empty file");
			const a = this;
			let o;
			function l() {
				for (o = s.next(); !s.isEOF(); )
					if (o.code === 0 && o.value === "SECTION") {
						if (((o = s.next()), o.code !== 2)) {
							console.error("Unexpected code %s after 0:SECTION", Db(o)), (o = s.next());
							continue;
						}
						o.value === "HEADER" ? (Pt.debug("> HEADER"), (t.header = c()), Pt.debug("<")) : o.value === "BLOCKS" ? (Pt.debug("> BLOCKS"), (t.blocks = u()), Pt.debug("<")) : o.value === "ENTITIES" ? (Pt.debug("> ENTITIES"), (t.entities = b(!1)), Pt.debug("<")) : o.value === "TABLES" ? (Pt.debug("> TABLES"), (t.tables = d()), Pt.debug("<")) : o.value === "EOF" ? Pt.debug("EOF") : Pt.warn("Skipping section '%s'", o.value);
					} else o = s.next();
			}
			function c() {
				let A = null,
					M = null;
				const w = {};
				for (o = s.next(); ; ) {
					if (pr(o, 0, "ENDSEC")) {
						A && (w[A] = M);
						break;
					} else o.code === 9 ? (A && (w[A] = M), (A = o.value)) : o.code === 10 ? (M = { x: o.value }) : o.code === 20 ? (M.y = o.value) : o.code === 30 ? (M.z = o.value) : (M = o.value);
					o = s.next();
				}
				return (o = s.next()), w;
			}
			function u() {
				const A = {};
				for (o = s.next(); o.value !== "EOF" && !pr(o, 0, "ENDSEC"); )
					if (pr(o, 0, "BLOCK")) {
						Pt.debug("block {");
						const M = h();
						Pt.debug("}"), P(M), M.name ? (A[M.name] = M) : Pt.error('block with handle "' + M.handle + '" is missing a name.');
					} else na(o), (o = s.next());
				return A;
			}
			function h() {
				const A = {};
				for (o = s.next(); o.value !== "EOF"; ) {
					switch (o.code) {
						case 1:
							(A.xrefPath = o.value), (o = s.next());
							break;
						case 2:
							(A.name = o.value), (o = s.next());
							break;
						case 3:
							(A.name2 = o.value), (o = s.next());
							break;
						case 5:
							(A.handle = o.value), (o = s.next());
							break;
						case 8:
							(A.layer = o.value), (o = s.next());
							break;
						case 10:
							(A.position = T(o)), (o = s.next());
							break;
						case 67:
							(A.paperSpace = !!(o.value && o.value == 1)), (o = s.next());
							break;
						case 70:
							o.value != 0 && (A.type = o.value), (o = s.next());
							break;
						case 100:
							o = s.next();
							break;
						case 330:
							(A.ownerHandle = o.value), (o = s.next());
							break;
						case 0:
							if (o.value == "ENDBLK") break;
							A.entities = b(!0);
							break;
						default:
							na(o), (o = s.next());
					}
					if (pr(o, 0, "ENDBLK")) {
						o = s.next();
						break;
					}
				}
				return A;
			}
			function d() {
				const A = {};
				for (o = s.next(); o.value !== "EOF" && !pr(o, 0, "ENDSEC"); ) pr(o, 0, "TABLE") ? ((o = s.next()), x[o.value] ? (Pt.debug(o.value + " Table {"), (A[x[o.value].tableName] = v(o)), Pt.debug("}")) : Pt.debug("Unhandled Table " + o.value)) : (o = s.next());
				return (o = s.next()), A;
			}
			const f = "ENDTAB";
			function v(A) {
				const M = x[A.value],
					w = {};
				let y = 0;
				for (o = s.next(); !pr(o, 0, f); )
					switch (o.code) {
						case 5:
							(w.handle = o.value), (o = s.next());
							break;
						case 330:
							(w.ownerHandle = o.value), (o = s.next());
							break;
						case 100:
							o.value === "AcDbSymbolTable" || na(o), (o = s.next());
							break;
						case 70:
							(y = o.value), (o = s.next());
							break;
						case 0:
							o.value === M.dxfSymbolName ? (w[M.tableRecordsProperty] = M.parseTableRecords()) : (na(o), (o = s.next()));
							break;
						default:
							na(o), (o = s.next());
					}
				const S = w[M.tableRecordsProperty];
				if (S) {
					let L = (() => {
						if (S.constructor === Array) return S.length;
						if (typeof S == "object") return Object.keys(S).length;
					})();
					y !== L && Pt.warn("Parsed " + L + " " + M.dxfSymbolName + "'s but expected " + y);
				}
				return (o = s.next()), w;
			}
			function _() {
				const A = [];
				let M = {};
				for (Pt.debug("ViewPort {"), o = s.next(); !pr(o, 0, f); )
					switch (o.code) {
						case 2:
							(M.name = o.value), (o = s.next());
							break;
						case 10:
							(M.lowerLeftCorner = T(o)), (o = s.next());
							break;
						case 11:
							(M.upperRightCorner = T(o)), (o = s.next());
							break;
						case 12:
							(M.center = T(o)), (o = s.next());
							break;
						case 13:
							(M.snapBasePoint = T(o)), (o = s.next());
							break;
						case 14:
							(M.snapSpacing = T(o)), (o = s.next());
							break;
						case 15:
							(M.gridSpacing = T(o)), (o = s.next());
							break;
						case 16:
							(M.viewDirectionFromTarget = T(o)), (o = s.next());
							break;
						case 17:
							(M.viewTarget = T(o)), (o = s.next());
							break;
						case 42:
							(M.lensLength = o.value), (o = s.next());
							break;
						case 43:
							(M.frontClippingPlane = o.value), (o = s.next());
							break;
						case 44:
							(M.backClippingPlane = o.value), (o = s.next());
							break;
						case 45:
							(M.viewHeight = o.value), (o = s.next());
							break;
						case 50:
							(M.snapRotationAngle = o.value), (o = s.next());
							break;
						case 51:
							(M.viewTwistAngle = o.value), (o = s.next());
							break;
						case 79:
							(M.orthographicType = o.value), (o = s.next());
							break;
						case 110:
							(M.ucsOrigin = T(o)), (o = s.next());
							break;
						case 111:
							(M.ucsXAxis = T(o)), (o = s.next());
							break;
						case 112:
							(M.ucsYAxis = T(o)), (o = s.next());
							break;
						case 110:
							(M.ucsOrigin = T(o)), (o = s.next());
							break;
						case 281:
							(M.renderMode = o.value), (o = s.next());
							break;
						case 281:
							(M.defaultLightingType = o.value), (o = s.next());
							break;
						case 292:
							(M.defaultLightingOn = o.value), (o = s.next());
							break;
						case 330:
							(M.ownerHandle = o.value), (o = s.next());
							break;
						case 63:
						case 421:
						case 431:
							(M.ambientColor = o.value), (o = s.next());
							break;
						case 0:
							o.value === "VPORT" && (Pt.debug("}"), A.push(M), Pt.debug("ViewPort {"), (M = {}), (o = s.next()));
							break;
						default:
							na(o), (o = s.next());
							break;
					}
				return Pt.debug("}"), A.push(M), A;
			}
			function p() {
				const A = {};
				let M = {},
					w = 0,
					y;
				for (Pt.debug("LType {"), o = s.next(); !pr(o, 0, "ENDTAB"); )
					switch (o.code) {
						case 2:
							(M.name = o.value), (y = o.value), (o = s.next());
							break;
						case 3:
							(M.description = o.value), (o = s.next());
							break;
						case 73:
							(w = o.value), w > 0 && (M.pattern = []), (o = s.next());
							break;
						case 40:
							(M.patternLength = o.value), (o = s.next());
							break;
						case 49:
							M.pattern.push(o.value), (o = s.next());
							break;
						case 0:
							Pt.debug("}"), w > 0 && w !== M.pattern.length && Pt.warn("lengths do not match on LTYPE pattern"), (A[y] = M), (M = {}), Pt.debug("LType {"), (o = s.next());
							break;
						default:
							o = s.next();
					}
				return Pt.debug("}"), (A[y] = M), A;
			}
			function g() {
				const A = {};
				let M = {},
					w;
				for (Pt.debug("Layer {"), o = s.next(); !pr(o, 0, "ENDTAB"); )
					switch (o.code) {
						case 2:
							(M.name = o.value), (w = o.value), (o = s.next());
							break;
						case 62:
							(M.visible = o.value >= 0), (M.colorIndex = Math.abs(o.value)), (M.color = aB(M.colorIndex)), (o = s.next());
							break;
						case 70:
							(M.frozen = (o.value & 1) != 0 || (o.value & 2) != 0), (o = s.next());
							break;
						case 0:
							o.value === "LAYER" && (Pt.debug("}"), (A[w] = M), Pt.debug("Layer {"), (M = {}), (w = void 0), (o = s.next()));
							break;
						default:
							na(o), (o = s.next());
							break;
					}
				return Pt.debug("}"), (A[w] = M), A;
			}
			const x = { VPORT: { tableRecordsProperty: "viewPorts", tableName: "viewPort", dxfSymbolName: "VPORT", parseTableRecords: _ }, LTYPE: { tableRecordsProperty: "lineTypes", tableName: "lineType", dxfSymbolName: "LTYPE", parseTableRecords: p }, LAYER: { tableRecordsProperty: "layers", tableName: "layer", dxfSymbolName: "LAYER", parseTableRecords: g } };
			function b(A) {
				const M = [],
					w = A ? "ENDBLK" : "ENDSEC";
				for (A || (o = s.next()); ; )
					if (o.code === 0) {
						if (o.value === w) break;
						const y = a._entityHandlers[o.value];
						if (y != null) {
							Pt.debug(o.value + " {");
							const S = y.parseEntity(s, o);
							(o = s.lastReadGroup), Pt.debug("}"), P(S), M.push(S);
						} else {
							Pt.warn("Unhandled entity " + o.value), (o = s.next());
							continue;
						}
					} else o = s.next();
				return w == "ENDSEC" && (o = s.next()), M;
			}
			function T(A) {
				const M = {};
				let w = A.code;
				if (((M.x = A.value), (w += 10), (A = s.next()), A.code != w)) throw new Error("Expected code for point value to be " + w + " but got " + A.code + ".");
				return (M.y = A.value), (w += 10), (A = s.next()), A.code != w ? (s.rewind(), M) : ((M.z = A.value), M);
			}
			function P(A) {
				if (!A) throw new TypeError("entity cannot be undefined or null");
				A.handle || (A.handle = i++);
			}
			return l(), t;
		}
	}
	function pr(n, e, t) {
		return n.code === e && n.value === t;
	}
	function na(n) {
		Pt.debug("unhandled group " + Db(n));
	}
	function Db(n) {
		return n.code + ":" + n.value;
	}
	function aB(n) {
		return Rb[n];
	}
	function oB(n, e) {
		if (!n) return;
		const t = new FileReader();
		(t.onload = function (i) {
			const r = i.target.result,
				a = new sB().parseSync(r);
			console.log("DXF:", a), new Fi({ color: 16759552 });
			const o = new Ot();
			new D(le.worldXCenter, le.worldYCenter, le.worldZCenter),
				a.entities.forEach((l) => {
					const u = new Tr().setFromObject(o).getCenter(new D()),
						h = le.worldXCenter !== 0 ? le.worldXCenter : u.x,
						d = le.worldYCenter !== 0 ? le.worldYCenter : u.y;
					if (((le.worldXCenter === 0 || le.worldYCenter === 0) && ((le.worldXCenter = u.x), (le.worldYCenter = u.y), Cs()), l.type === "LINE")) {
						const f = new bt().setFromPoints([new D(l.vertices[0].x - h, l.vertices[0].y - d, l.vertices[0].z), new D(l.vertices[1].x - h, l.vertices[1].y - d, l.vertices[1].z)]);
						let v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v });
						const p = new Sn(f, _);
						console.log("DXF LINE:", p), o.add(p);
					}
					if (l.type === "POLYLINE" || l.type === "LWPOLYLINE") {
						let f = l.vertices.map((x) => new D(x.x - h, x.y - d, x.z));
						l.shape && f.push(f[0]);
						let v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new bt().setFromPoints(f),
							g = new Sn(p, _);
						console.log("DXF POLYLINE:", g), o.add(g);
					}
					if (l.type === "CIRCLE") {
						let f = new xa(l.radius, 32),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new Sn(f, _);
						p.position.set(l.center.x - h, l.center.y - d, l.center.z), console.log("DXF CIRCLE:", p), o.add(p);
					}
					if (l.type === "ARC") {
						let f = new xa(l.radius, 32, l.startAngle, l.endAngle),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new Sn(f, _);
						p.position.set(l.center.x - h, l.center.y - d, l.center.z), console.log("DXF ARC:", p), o.add(p);
					}
					if (l.type === "SPLINE") {
						let f = l.controlPoints.map((b) => new D(b.x - h, b.y - d, b.z)),
							v = new mx(f),
							_ = new bt().setFromPoints(v.getPoints(50)),
							p = l.color ? l.color : 16777215,
							g = new Kt({ color: p }),
							x = new Sn(_, g);
						console.log("DXF SPLINE:", x), o.add(x);
					}
					if (l.type === "ELLIPSE") {
						let v = new Ms(l.x - h, l.y - d, l.xRadius, l.yRadius, l.startAngle, l.endAngle, l.clockwise, l.rotation).getPoints(50),
							_ = new bt().setFromPoints(v),
							p = l.color ? l.color : 16777215,
							g = new Kt({ color: p }),
							x = new Sn(_, g);
						console.log("DXF ELLIPSE:", x), o.add(x);
					}
					if (l.type === "TEXT") {
						let f = new sp(l.text, { font: Ki, size: l.textHeight, depth: 0.01, curveSegments: 6, bevelEnabled: !0, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 1 }),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new Re(f, _);
						p.position.set(l.startPoint.x - h, l.startPoint.y - d, l.startPoint.z), (p.dxfType = l.type), console.log("DXF TEXT:", p), o.add(p);
					}
					if (l.type === "MTEXT") {
						let f = new sp(l.text, { font: Ki, size: l.height, depth: 0.01, curveSegments: 6, bevelEnabled: !0, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 1 }),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new Re(f, _);
						p.position.set(l.startPoint.x - h, l.startPoint.y - d, l.startPoint.z), (p.dxfType = l.type), console.log("DXF MTEXT:", p), o.add(p);
					}
					if (l.type === "DIMENSION") {
						let f = l.points.map((x) => new D(x.x - h, x.y - d, x.z)),
							v = new bt().setFromPoints(f),
							_ = l.color ? l.color : 16777215,
							p = new Kt({ color: _ }),
							g = new Sn(v, p);
						console.log("DXF DIMENSION:", g), o.add(g);
					}
					if (l.type === "POINT") {
						let f = new bt().setFromPoints([new D(l.position.x - h, l.position.y - d, l.position.z)]),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new bs(f, _);
						console.log("DXF POINT:", p), o.add(p);
					}
					if (l.type === "INSERT") {
						let f = new bt().setFromPoints([new D(l.position.x - h, l.position.y - d, l.position.z)]),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new bs(f, _);
						console.log("DXF INSERT:", p), o.add(p);
					}
					if (l.type === "BLOCK") {
						let f = new bt().setFromPoints([new D(l.position.x - h, l.position.y - d, l.position.z)]),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new bs(f, _);
						console.log("DXF BLOCK:", p), o.add(p);
					}
					if (l.type === "HATCH") {
						let f = new bt().setFromPoints([new D(l.position.x - h, l.position.y - d, l.position.z)]),
							v = l.color ? l.color : 16777215,
							_ = new Kt({ color: v }),
							p = new bs(f, _);
						console.log("DXF HATCH:", p), o.add(p);
					}
				}),
				(o.name = n.name),
				Bt.add(o),
				es(Bt, ft),
				console.log("Object position after load:", o.position),
				console.log("Object rotation after load:", o.rotation),
				console.log("Object scale after load:", o.scale),
				le.debugComments && (console.log("Loaded DXF position:", o.position), console.log("Loaded DXF rotation:", o.rotation), console.log("Loaded DXF scale:", o.scale));
		}),
			(t.onerror = function (i) {
				console.log("Error reading the DXF file:", i);
			}),
			t.readAsText(n);
	}
	const lB = (n) => {
			document.getElementById("import-dxf").addEventListener("click", function () {
				const e = document.createElement("input");
				(e.type = "file"),
					(e.accept = ".dxf"),
					(e.style.display = "none"),
					(e.onchange = (t) => {
						t.target.files && t.target.files[0] && oB(t.target.files[0]);
					}),
					document.body.appendChild(e),
					e.click(),
					document.body.removeChild(e),
					le.debugComments && console.log("Load DXF button clicked"),
					(document.querySelector("#info-label").textContent = "File DXF Loaded: " + e.name);
			});
		},
		cB = (n, e, t) => {
			if (!n) return console.error("Data is null or undefined"), [];
			let i = [];
			const r = parseInt(e.headerRows, 10) || 0;
			let s = -1;
			n.slice(r).forEach((o) => {
				const l = Fp(),
					c = String(o[Object.keys(o)[e.pointID - 1]] || s--),
					u = parseFloat(o[Object.keys(o)[e.pointX - 1]]),
					h = parseFloat(o[Object.keys(o)[e.pointY - 1]]),
					d = parseFloat(o[Object.keys(o)[e.pointZ - 1]]),
					f = parseFloat(o[Object.keys(o)[e.pointR - 1]]),
					v = parseFloat(o[Object.keys(o)[e.pointG - 1]]),
					_ = parseFloat(o[Object.keys(o)[e.pointB - 1]]),
					p = parseFloat(o[Object.keys(o)[e.pointA - 1]]);
				!isNaN(u) && !isNaN(h) && !isNaN(d) && i.push({ uuid: l, pointID: c, pointX: u, pointY: h, pointZ: d, pointR: f, pointG: v, pointB: _, pointA: p });
			});
			const a = "CSV_PointCloudStore";
			return (
				(async () => {
					try {
						const o = await Zl();
						console.log("Database opened successfully. Attempting to write data..."), console.log("Data to write:", i), await Ip(o, a, i), console.log("Data written successfully to CSV_PointCloudStore");
						const l = await mh(o, a);
						console.log("Data read back from the database:", l);
					} catch (o) {
						console.error("Failed to write or read data from the database:", o);
					}
				})(),
				i
			);
		};
	function Ob(n) {
		const e = new rt(n);
		return { r: e.r, g: e.g, b: e.b };
	}
	const uB = (n, e, t) => {
			console.log("Showing custom modal...");
			const i = `
        <div class="modal fade" id="csvModal" tabindex="-1" aria-labelledby="csvModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header custom-modal-header">
                        <h5 class="modal-title" id="csvModalLabel">XYZ Point Cloud Import (.xyz .csv .txt auto-delimeter)</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form id="csvForm">
                            <div class="row">
                                <div class="col-md-6">
                                    ${D_(n, "left")}
                                </div>
                                <div class="col-md-6">
                                    ${D_(n, "right")}
                                    <div class="row mb-1">
                                        <label for="maxEdgeLength" class="col-sm-5 col-form-label">Max Edge Length (m)</label>
                                        <div class="col-sm-6">
                                            <input type="number" class="form-control" id="maxEdgeLength" name="maxEdgeLength" value="10" min="0">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-12">
                                    <div class="form-group">
                                        <label for="filePreviewTable">File Contents Preview (Set Order to refresh column view)</label>
                                        <div id="filePreviewTable" style="max-height: 300px; overflow-y: auto;"></div>
                                    </div>
                                    <div class="form-group">
                                        <input type="checkbox" id="createMesh" name="createMesh">
                                        <label for="createMesh">Create Mesh</label>
                                    </div>
                                    <div class="form-group d-flex align-items-center">
                                        <label for="pointColor">Mesh/Point Colour</label>
                                        <input type="color" class="form-control form-control-color mx-2" id="pointColor" value="#ffAA00" title="Choose your colour">
                                        <div id="colorPalette" class="d-flex flex-wrap">
                                            <!-- Palette colors will be added here dynamically -->
                                        </div>
                                    </div>
                                </div>                   
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-danger" id="clear-settings">Clear</button>
                        <div class="col mx-3"></div>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" id="set-order">Set Order</button>
                        <button type="button" class="btn btn-success" id="submit">Submit</button>
                    </div>
                </div>
            </div>
        </div>`,
				r = document.createElement("style");
			(r.innerHTML = `
        .custom-modal-header {
            background-color: #cccccc;
			font-size: 12px;
			height: 2.5em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9px;
        }
        th, td {
            padding: 1px;
            text-align: center;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-size: 11px;
        }
        .ignored-column {
            color: red;
            font-style: italic;
        }
		.modal-body label {
        	font-size: 12px; /* Adjust the font size of the labels */
        	height: 1.5em; /* Adjust the height of the labels */
    	}
    	.modal-body .form-control {
        	font-size: 12px; /* Adjust the font size of the input fields */
        	height: 2em; /* Adjust the height of the input fields */
        	padding: .25rem .5rem; /* Adjust the padding of the input fields */
		}
		.text-danger {
			font-size: 12px; /* Adjust the font size of the text-danger span */
			height: 2em; /* Adjust the height of the labels */
			align-items: center;
		}	
		.text-warning {
			font-size: 12px; /* Adjust the font size of the text-warning span */
			height: 2em; /* Adjust the height of the labels */
			align-items: center;
		}
		#colorPalette .color-swatch {
			width: 24px;
			height: 24px;
			margin: 2px;
			border: 1px solid #ddd;
			cursor: pointer;
		}
    `),
				document.head.appendChild(r);
			const s = document.createElement("div");
			(s.innerHTML = i), document.body.appendChild(s);
			const a = new Sr(document.getElementById("csvModal"));
			a.show();
			const o = JSON.parse(localStorage.getItem("pointCloudOrder"));
			if (o)
				for (const [d, f] of Object.entries(o)) {
					const v = document.getElementById(d);
					v && (v.value = f);
				}
			const l = JSON.parse(localStorage.getItem("createMeshState"));
			l !== null && (document.getElementById("createMesh").checked = l);
			const c = localStorage.getItem("maxEdgeLength");
			c !== null && (document.getElementById("maxEdgeLength").value = c),
				document.getElementById("createMesh").addEventListener("change", function () {
					localStorage.setItem("createMeshState", JSON.stringify(this.checked));
				}),
				document.getElementById("maxEdgeLength").addEventListener("input", function () {
					localStorage.setItem("maxEdgeLength", this.value);
				}),
				document.getElementById("clear-settings").addEventListener("click", function () {
					console.log("Clear settings clicked"),
						document.querySelectorAll("#csvForm input[type='number']").forEach((f) => {
							f.value = "";
						}),
						localStorage.removeItem("pointCloudOrder"),
						localStorage.removeItem("createMeshState"),
						localStorage.removeItem("maxEdgeLength"),
						(document.getElementById("createMesh").checked = !1),
						(document.getElementById("maxEdgeLength").value = 10),
						Su(t);
				}),
				document.getElementById("set-order").addEventListener("click", function () {
					console.log("Set order clicked");
					const d = new FormData(document.getElementById("csvForm")),
						f = {};
					d.forEach((v, _) => {
						v && (f[_] = v);
					}),
						localStorage.setItem("pointCloudOrder", JSON.stringify(f)),
						console.log("Set pointColumnOrder is: ", f),
						alert("Column order has been set."),
						Su(t);
				}),
				document.getElementById("submit").addEventListener("click", function () {
					console.log("Submit clicked");
					const d = new FormData(document.getElementById("csvForm")),
						f = {};
					d.forEach((w, y) => {
						w && (f[y] = w);
					}),
						console.log(f);
					const v = {};
					for (const [w, y] of Object.entries(f)) v[w] = y;
					if (!v.pointX || !v.pointY || !v.pointZ) {
						alert("Please ensure that Point X, Point Y, and Point Z columns are selected."), console.error("Please ensure that Point X, Point Y, and Point Z columns are selected.");
						return;
					}
					let _ = Object.values(v),
						p = v.headerRows,
						g = _.filter((w, y) => w !== p && w !== "maxEdgeLength" && _.indexOf(w) !== y);
					if (g.length > 0) {
						console.log("Duplicates: ", g),
							alert(`Some columns are represented more than once.
Display may not be as intended.
Preferably a column is selected only once.
`);
						return;
					}
					const x = document.getElementById("pointColor").value,
						b = Ob(x),
						T = b.r,
						P = b.g,
						A = b.b,
						M = parseFloat(document.getElementById("maxEdgeLength").value);
					console.log("Red:", T), console.log("Green:", P), console.log("Blue:", A), console.log("Max Edge Length:", M), v.pointX && v.pointY && v.pointZ && (CB(t, v, x, M), a.hide(), document.body.removeChild(s));
				}),
				document.getElementById("headerRows").addEventListener("input", () => Su(t)),
				Su(t);
			const u = ["#990000", "#FF0000", "#FFAA00", "#CCCC00", "#FFF000", "#00ff00", "#00bb00", "#00bbff", "#0055FF", "#aa00ff", "#F1F1F1", "#E3E3E3", "#C6C6C6", "#7F7F7F", "#555555", "#393939", "#1C1C1C", "#00FFFF", "#006699", "#FF00FF"],
				h = document.getElementById("colorPalette");
			u.forEach((d) => {
				const f = document.createElement("div");
				(f.className = "color-swatch"),
					(f.style.backgroundColor = d),
					f.addEventListener("click", () => {
						document.getElementById("pointColor").value = d;
					}),
					h.appendChild(f);
			});
		},
		D_ = (n, e) =>
			(e === "left"
				? [
						{ id: "headerRows", label: "Rows to Ignore", type: "number", placeholder: "# rows", required: !0, unused: !1 },
						{ id: "pointID", label: "Point ID (col#)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "pointX", label: "Point X (col#)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "pointY", label: "Point Y (col#)", type: "number", placeholder: "Col #", required: !0, unused: !1 },
						{ id: "pointZ", label: "Point Z (col#)", type: "number", placeholder: "Col #", required: !0, unused: !1 }
				  ]
				: [
						{ id: "pointR", label: "Point Red (col#)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "pointG", label: "Point Green (col#)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "pointB", label: "Point Blue (col#)", placeholder: "Col #", type: "number", required: !1, unused: !1 },
						{ id: "pointA", label: "Point Alpha (col#)", placeholder: "Col #", type: "number", required: !1, unused: !1 }
				  ]
			)
				.map((s) =>
					s.required
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <div class="input-group">
                            <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}" required>
                            <div class="input-group-append">
                                <span class="input-group-text text-danger">needed</span>
                            </div>
                        </div>
                    </div>
                </div>`
						: s.unused
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <div class="input-group">
                            <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}" unused>
                            <div class="input-group-append">
                                <span class="input-group-text text-warning">unused</span>
                            </div>
                        </div>
                    </div>
                </div>`
						: s.unit
						? `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <input type="number" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}">
                        <div>
                            <input type="radio" id="${s.id}_mm" name="diameter_unit" value="mm">
                            <label for="${s.id}_mm">mm</label>
                            <input type="radio" id="${s.id}_m" name="diameter_unit" value="m">
                            <label for="${s.id}_m">m</label>
                        </div>
                    </div>
                </div>`
						: `
                <div class="row mb-1">
                    <label for="${s.id}" class="col-sm-5 col-form-label">${s.label}</label>
                    <div class="col-sm-6">
                        <input type="${s.type}" class="form-control" id="${s.id}" name="${s.id}" placeholder="${s.placeholder}">
                    </div>
                </div>`
				)
				.join(""),
		Su = (n) => {
			const e = parseInt(document.getElementById("headerRows").value, 10) || 0,
				t = JSON.parse(localStorage.getItem("pointCloudOrder") || "{}");
			if ((delete t.headerRows, n.length > 0)) {
				let i = '<table class="table table-striped"><thead><tr>';
				const r = { pointID: "Point ID", pointX: "Point X", pointY: "Point Y", pointZ: "Point Z", pointR: "Point Red", pointG: "Point Green", pointB: "Point Blue", pointA: "Point Alpha" },
					s = Object.keys(n[0]).length;
				for (let u = 0; u < s; u++) {
					const h = Object.keys(t).find((d) => t[d] == (u + 1).toString());
					h ? (i += `<th>${r[h]}</th>`) : (i += '<th class="ignored-column">ignored</th>');
				}
				i += "</tr></thead><tbody>";
				const a = n.slice(e),
					o = 10,
					l = a.slice(0, o),
					c = a.length > o;
				(i += l
					.map(
						(u) =>
							"<tr>" +
							Object.keys(u)
								.map((h, d) => (Object.keys(t).find((v) => t[v] == (d + 1).toString()) ? `<td>${u[h]}</td>` : `<td>${u[h]}</td>`))
								.join("") +
							"</tr>"
					)
					.join("")),
					c && (Object.keys(t).length, (i += "<tr><td><i>more rows in file...</i></td></tr>")),
					(i += "</tbody></table>"),
					console.log("Table content generated"),
					(document.getElementById("filePreviewTable").innerHTML = i);
			}
		},
		qr = 11102230246251565e-32,
		$n = 134217729,
		hB = (3 + 8 * qr) * qr;
	function hf(n, e, t, i, r) {
		let s,
			a,
			o,
			l,
			c = e[0],
			u = i[0],
			h = 0,
			d = 0;
		u > c == u > -c ? ((s = c), (c = e[++h])) : ((s = u), (u = i[++d]));
		let f = 0;
		if (h < n && d < t) for (u > c == u > -c ? ((a = c + s), (o = s - (a - c)), (c = e[++h])) : ((a = u + s), (o = s - (a - u)), (u = i[++d])), s = a, o !== 0 && (r[f++] = o); h < n && d < t; ) u > c == u > -c ? ((a = s + c), (l = a - s), (o = s - (a - l) + (c - l)), (c = e[++h])) : ((a = s + u), (l = a - s), (o = s - (a - l) + (u - l)), (u = i[++d])), (s = a), o !== 0 && (r[f++] = o);
		for (; h < n; ) (a = s + c), (l = a - s), (o = s - (a - l) + (c - l)), (c = e[++h]), (s = a), o !== 0 && (r[f++] = o);
		for (; d < t; ) (a = s + u), (l = a - s), (o = s - (a - l) + (u - l)), (u = i[++d]), (s = a), o !== 0 && (r[f++] = o);
		return (s !== 0 || f === 0) && (r[f++] = s), f;
	}
	function dB(n, e) {
		let t = e[0];
		for (let i = 1; i < n; i++) t += e[i];
		return t;
	}
	function ac(n) {
		return new Float64Array(n);
	}
	const fB = (3 + 16 * qr) * qr,
		pB = (2 + 12 * qr) * qr,
		mB = (9 + 64 * qr) * qr * qr,
		co = ac(4),
		O_ = ac(8),
		I_ = ac(12),
		F_ = ac(16),
		Qn = ac(4);
	function gB(n, e, t, i, r, s, a) {
		let o, l, c, u, h, d, f, v, _, p, g, x, b, T, P, A, M, w;
		const y = n - r,
			S = t - r,
			L = e - s,
			N = i - s;
		(T = y * N),
			(d = $n * y),
			(f = d - (d - y)),
			(v = y - f),
			(d = $n * N),
			(_ = d - (d - N)),
			(p = N - _),
			(P = v * p - (T - f * _ - v * _ - f * p)),
			(A = L * S),
			(d = $n * L),
			(f = d - (d - L)),
			(v = L - f),
			(d = $n * S),
			(_ = d - (d - S)),
			(p = S - _),
			(M = v * p - (A - f * _ - v * _ - f * p)),
			(g = P - M),
			(h = P - g),
			(co[0] = P - (g + h) + (h - M)),
			(x = T + g),
			(h = x - T),
			(b = T - (x - h) + (g - h)),
			(g = b - A),
			(h = b - g),
			(co[1] = b - (g + h) + (h - A)),
			(w = x + g),
			(h = w - x),
			(co[2] = x - (w - h) + (g - h)),
			(co[3] = w);
		let k = dB(4, co),
			B = pB * a;
		if (k >= B || -k >= B || ((h = n - y), (o = n - (y + h) + (h - r)), (h = t - S), (c = t - (S + h) + (h - r)), (h = e - L), (l = e - (L + h) + (h - s)), (h = i - N), (u = i - (N + h) + (h - s)), o === 0 && l === 0 && c === 0 && u === 0) || ((B = mB * a + hB * Math.abs(k)), (k += y * u + N * o - (L * c + S * l)), k >= B || -k >= B)) return k;
		(T = o * N),
			(d = $n * o),
			(f = d - (d - o)),
			(v = o - f),
			(d = $n * N),
			(_ = d - (d - N)),
			(p = N - _),
			(P = v * p - (T - f * _ - v * _ - f * p)),
			(A = l * S),
			(d = $n * l),
			(f = d - (d - l)),
			(v = l - f),
			(d = $n * S),
			(_ = d - (d - S)),
			(p = S - _),
			(M = v * p - (A - f * _ - v * _ - f * p)),
			(g = P - M),
			(h = P - g),
			(Qn[0] = P - (g + h) + (h - M)),
			(x = T + g),
			(h = x - T),
			(b = T - (x - h) + (g - h)),
			(g = b - A),
			(h = b - g),
			(Qn[1] = b - (g + h) + (h - A)),
			(w = x + g),
			(h = w - x),
			(Qn[2] = x - (w - h) + (g - h)),
			(Qn[3] = w);
		const W = hf(4, co, 4, Qn, O_);
		(T = y * u),
			(d = $n * y),
			(f = d - (d - y)),
			(v = y - f),
			(d = $n * u),
			(_ = d - (d - u)),
			(p = u - _),
			(P = v * p - (T - f * _ - v * _ - f * p)),
			(A = L * c),
			(d = $n * L),
			(f = d - (d - L)),
			(v = L - f),
			(d = $n * c),
			(_ = d - (d - c)),
			(p = c - _),
			(M = v * p - (A - f * _ - v * _ - f * p)),
			(g = P - M),
			(h = P - g),
			(Qn[0] = P - (g + h) + (h - M)),
			(x = T + g),
			(h = x - T),
			(b = T - (x - h) + (g - h)),
			(g = b - A),
			(h = b - g),
			(Qn[1] = b - (g + h) + (h - A)),
			(w = x + g),
			(h = w - x),
			(Qn[2] = x - (w - h) + (g - h)),
			(Qn[3] = w);
		const H = hf(W, O_, 4, Qn, I_);
		(T = o * u),
			(d = $n * o),
			(f = d - (d - o)),
			(v = o - f),
			(d = $n * u),
			(_ = d - (d - u)),
			(p = u - _),
			(P = v * p - (T - f * _ - v * _ - f * p)),
			(A = l * c),
			(d = $n * l),
			(f = d - (d - l)),
			(v = l - f),
			(d = $n * c),
			(_ = d - (d - c)),
			(p = c - _),
			(M = v * p - (A - f * _ - v * _ - f * p)),
			(g = P - M),
			(h = P - g),
			(Qn[0] = P - (g + h) + (h - M)),
			(x = T + g),
			(h = x - T),
			(b = T - (x - h) + (g - h)),
			(g = b - A),
			(h = b - g),
			(Qn[1] = b - (g + h) + (h - A)),
			(w = x + g),
			(h = w - x),
			(Qn[2] = x - (w - h) + (g - h)),
			(Qn[3] = w);
		const z = hf(H, I_, 4, Qn, F_);
		return F_[z - 1];
	}
	function Eu(n, e, t, i, r, s) {
		const a = (e - s) * (t - r),
			o = (n - r) * (i - s),
			l = a - o,
			c = Math.abs(a + o);
		return Math.abs(l) >= fB * c ? l : -gB(n, e, t, i, r, s, c);
	}
	const N_ = Math.pow(2, -52),
		wu = new Uint32Array(512);
	class mm {
		static from(e, t = bB, i = SB) {
			const r = e.length,
				s = new Float64Array(r * 2);
			for (let a = 0; a < r; a++) {
				const o = e[a];
				(s[2 * a] = t(o)), (s[2 * a + 1] = i(o));
			}
			return new mm(s);
		}
		constructor(e) {
			const t = e.length >> 1;
			if (t > 0 && typeof e[0] != "number") throw new Error("Expected coords to contain numbers.");
			this.coords = e;
			const i = Math.max(2 * t - 5, 0);
			(this._triangles = new Uint32Array(i * 3)), (this._halfedges = new Int32Array(i * 3)), (this._hashSize = Math.ceil(Math.sqrt(t))), (this._hullPrev = new Uint32Array(t)), (this._hullNext = new Uint32Array(t)), (this._hullTri = new Uint32Array(t)), (this._hullHash = new Int32Array(this._hashSize)), (this._ids = new Uint32Array(t)), (this._dists = new Float64Array(t)), this.update();
		}
		update() {
			const { coords: e, _hullPrev: t, _hullNext: i, _hullTri: r, _hullHash: s } = this,
				a = e.length >> 1;
			let o = 1 / 0,
				l = 1 / 0,
				c = -1 / 0,
				u = -1 / 0;
			for (let y = 0; y < a; y++) {
				const S = e[2 * y],
					L = e[2 * y + 1];
				S < o && (o = S), L < l && (l = L), S > c && (c = S), L > u && (u = L), (this._ids[y] = y);
			}
			const h = (o + c) / 2,
				d = (l + u) / 2;
			let f, v, _;
			for (let y = 0, S = 1 / 0; y < a; y++) {
				const L = df(h, d, e[2 * y], e[2 * y + 1]);
				L < S && ((f = y), (S = L));
			}
			const p = e[2 * f],
				g = e[2 * f + 1];
			for (let y = 0, S = 1 / 0; y < a; y++) {
				if (y === f) continue;
				const L = df(p, g, e[2 * y], e[2 * y + 1]);
				L < S && L > 0 && ((v = y), (S = L));
			}
			let x = e[2 * v],
				b = e[2 * v + 1],
				T = 1 / 0;
			for (let y = 0; y < a; y++) {
				if (y === f || y === v) continue;
				const S = yB(p, g, x, b, e[2 * y], e[2 * y + 1]);
				S < T && ((_ = y), (T = S));
			}
			let P = e[2 * _],
				A = e[2 * _ + 1];
			if (T === 1 / 0) {
				for (let L = 0; L < a; L++) this._dists[L] = e[2 * L] - e[0] || e[2 * L + 1] - e[1];
				xo(this._ids, this._dists, 0, a - 1);
				const y = new Uint32Array(a);
				let S = 0;
				for (let L = 0, N = -1 / 0; L < a; L++) {
					const k = this._ids[L],
						B = this._dists[k];
					B > N && ((y[S++] = k), (N = B));
				}
				(this.hull = y.subarray(0, S)), (this.triangles = new Uint32Array(0)), (this.halfedges = new Uint32Array(0));
				return;
			}
			if (Eu(p, g, x, b, P, A) < 0) {
				const y = v,
					S = x,
					L = b;
				(v = _), (x = P), (b = A), (_ = y), (P = S), (A = L);
			}
			const M = xB(p, g, x, b, P, A);
			(this._cx = M.x), (this._cy = M.y);
			for (let y = 0; y < a; y++) this._dists[y] = df(e[2 * y], e[2 * y + 1], M.x, M.y);
			xo(this._ids, this._dists, 0, a - 1), (this._hullStart = f);
			let w = 3;
			(i[f] = t[_] = v), (i[v] = t[f] = _), (i[_] = t[v] = f), (r[f] = 0), (r[v] = 1), (r[_] = 2), s.fill(-1), (s[this._hashKey(p, g)] = f), (s[this._hashKey(x, b)] = v), (s[this._hashKey(P, A)] = _), (this.trianglesLen = 0), this._addTriangle(f, v, _, -1, -1, -1);
			for (let y = 0, S, L; y < this._ids.length; y++) {
				const N = this._ids[y],
					k = e[2 * N],
					B = e[2 * N + 1];
				if ((y > 0 && Math.abs(k - S) <= N_ && Math.abs(B - L) <= N_) || ((S = k), (L = B), N === f || N === v || N === _)) continue;
				let W = 0;
				for (let G = 0, ue = this._hashKey(k, B); G < this._hashSize && ((W = s[(ue + G) % this._hashSize]), !(W !== -1 && W !== i[W])); G++);
				W = t[W];
				let H = W,
					z;
				for (; (z = i[H]), Eu(k, B, e[2 * H], e[2 * H + 1], e[2 * z], e[2 * z + 1]) >= 0; )
					if (((H = z), H === W)) {
						H = -1;
						break;
					}
				if (H === -1) continue;
				let X = this._addTriangle(H, N, i[H], -1, -1, r[H]);
				(r[N] = this._legalize(X + 2)), (r[H] = X), w++;
				let K = i[H];
				for (; (z = i[K]), Eu(k, B, e[2 * K], e[2 * K + 1], e[2 * z], e[2 * z + 1]) < 0; ) (X = this._addTriangle(K, N, z, r[N], -1, r[K])), (r[N] = this._legalize(X + 2)), (i[K] = K), w--, (K = z);
				if (H === W) for (; (z = t[H]), Eu(k, B, e[2 * z], e[2 * z + 1], e[2 * H], e[2 * H + 1]) < 0; ) (X = this._addTriangle(z, N, H, -1, r[H], r[z])), this._legalize(X + 2), (r[z] = X), (i[H] = H), w--, (H = z);
				(this._hullStart = t[N] = H), (i[H] = t[K] = N), (i[N] = K), (s[this._hashKey(k, B)] = N), (s[this._hashKey(e[2 * H], e[2 * H + 1])] = H);
			}
			this.hull = new Uint32Array(w);
			for (let y = 0, S = this._hullStart; y < w; y++) (this.hull[y] = S), (S = i[S]);
			(this.triangles = this._triangles.subarray(0, this.trianglesLen)), (this.halfedges = this._halfedges.subarray(0, this.trianglesLen));
		}
		_hashKey(e, t) {
			return Math.floor(vB(e - this._cx, t - this._cy) * this._hashSize) % this._hashSize;
		}
		_legalize(e) {
			const { _triangles: t, _halfedges: i, coords: r } = this;
			let s = 0,
				a = 0;
			for (;;) {
				const o = i[e],
					l = e - (e % 3);
				if (((a = l + ((e + 2) % 3)), o === -1)) {
					if (s === 0) break;
					e = wu[--s];
					continue;
				}
				const c = o - (o % 3),
					u = l + ((e + 1) % 3),
					h = c + ((o + 2) % 3),
					d = t[a],
					f = t[e],
					v = t[u],
					_ = t[h];
				if (_B(r[2 * d], r[2 * d + 1], r[2 * f], r[2 * f + 1], r[2 * v], r[2 * v + 1], r[2 * _], r[2 * _ + 1])) {
					(t[e] = _), (t[o] = d);
					const g = i[h];
					if (g === -1) {
						let b = this._hullStart;
						do {
							if (this._hullTri[b] === h) {
								this._hullTri[b] = e;
								break;
							}
							b = this._hullPrev[b];
						} while (b !== this._hullStart);
					}
					this._link(e, g), this._link(o, i[a]), this._link(a, h);
					const x = c + ((o + 1) % 3);
					s < wu.length && (wu[s++] = x);
				} else {
					if (s === 0) break;
					e = wu[--s];
				}
			}
			return a;
		}
		_link(e, t) {
			(this._halfedges[e] = t), t !== -1 && (this._halfedges[t] = e);
		}
		_addTriangle(e, t, i, r, s, a) {
			const o = this.trianglesLen;
			return (this._triangles[o] = e), (this._triangles[o + 1] = t), (this._triangles[o + 2] = i), this._link(o, r), this._link(o + 1, s), this._link(o + 2, a), (this.trianglesLen += 3), o;
		}
	}
	function vB(n, e) {
		const t = n / (Math.abs(n) + Math.abs(e));
		return (e > 0 ? 3 - t : 1 + t) / 4;
	}
	function df(n, e, t, i) {
		const r = n - t,
			s = e - i;
		return r * r + s * s;
	}
	function _B(n, e, t, i, r, s, a, o) {
		const l = n - a,
			c = e - o,
			u = t - a,
			h = i - o,
			d = r - a,
			f = s - o,
			v = l * l + c * c,
			_ = u * u + h * h,
			p = d * d + f * f;
		return l * (h * p - _ * f) - c * (u * p - _ * d) + v * (u * f - h * d) < 0;
	}
	function yB(n, e, t, i, r, s) {
		const a = t - n,
			o = i - e,
			l = r - n,
			c = s - e,
			u = a * a + o * o,
			h = l * l + c * c,
			d = 0.5 / (a * c - o * l),
			f = (c * u - o * h) * d,
			v = (a * h - l * u) * d;
		return f * f + v * v;
	}
	function xB(n, e, t, i, r, s) {
		const a = t - n,
			o = i - e,
			l = r - n,
			c = s - e,
			u = a * a + o * o,
			h = l * l + c * c,
			d = 0.5 / (a * c - o * l),
			f = n + (c * u - o * h) * d,
			v = e + (a * h - l * u) * d;
		return { x: f, y: v };
	}
	function xo(n, e, t, i) {
		if (i - t <= 20)
			for (let r = t + 1; r <= i; r++) {
				const s = n[r],
					a = e[s];
				let o = r - 1;
				for (; o >= t && e[n[o]] > a; ) n[o + 1] = n[o--];
				n[o + 1] = s;
			}
		else {
			const r = (t + i) >> 1;
			let s = t + 1,
				a = i;
			xl(n, r, s), e[n[t]] > e[n[i]] && xl(n, t, i), e[n[s]] > e[n[i]] && xl(n, s, i), e[n[t]] > e[n[s]] && xl(n, t, s);
			const o = n[s],
				l = e[o];
			for (;;) {
				do s++;
				while (e[n[s]] < l);
				do a--;
				while (e[n[a]] > l);
				if (a < s) break;
				xl(n, s, a);
			}
			(n[t + 1] = n[a]), (n[a] = o), i - s + 1 >= a - t ? (xo(n, e, s, i), xo(n, e, t, a - 1)) : (xo(n, e, t, a - 1), xo(n, e, s, i));
		}
	}
	function xl(n, e, t) {
		const i = n[e];
		(n[e] = n[t]), (n[t] = i);
	}
	function bB(n) {
		return n[0];
	}
	function SB(n) {
		return n[1];
	}
	function EB(n, e) {
		try {
			let l = function (u, h) {
					const d = u[0] - h[0],
						f = u[1] - h[1];
					return d * d + f * f;
				},
				c = function (u) {
					const [h, d, f] = u,
						v = l(h, d),
						_ = l(d, f),
						p = l(f, h);
					return v < Number.EPSILON || _ < Number.EPSILON || p < Number.EPSILON;
				};
			var t = l,
				i = c;
			let r = [];
			const s = (u) => parseFloat(u.x),
				a = (u) => parseFloat(u.y),
				o = mm.from(n, s, a);
			for (let u = 0; u < o.triangles.length; u += 3) {
				const h = o.triangles[u],
					d = o.triangles[u + 1],
					f = o.triangles[u + 2],
					v = n[h],
					_ = n[d],
					p = n[f],
					g = l([s(v), a(v)], [s(_), a(_)]),
					x = l([s(_), a(_)], [s(p), a(p)]),
					b = l([s(p), a(p)], [s(v), a(v)]);
				if (g <= e ** 2 && x <= e ** 2 && b <= e ** 2) {
					const T = [
						[s(v), a(v), v.z],
						[s(_), a(_), _.z],
						[s(p), a(p), p.z]
					];
					c(T) || r.push(T);
				}
			}
			return console.log("Delaunay Triangles:", r), r;
		} catch (r) {
			console.log(r);
		}
	}
	function wB(n) {
		const e = {};
		function t(r, s) {
			const a = r < s ? r + "," + s : s + "," + r;
			e[a] ? e[a]++ : (e[a] = 1);
		}
		for (const r of n) t(r[0].join(","), r[1].join(",")), t(r[1].join(","), r[2].join(",")), t(r[2].join(","), r[0].join(","));
		const i = [];
		for (const r in e) e[r] > 2 && i.push(r);
		return console.log("Overlapping Edges:", i), i.length > 0;
	}
	function TB(n) {
		const e = new D();
		for (const t of n) e.add(t);
		return e.divideScalar(n.length), e;
	}
	function MB(n, e, t) {
		const i = EB(n, e);
		console.log(i), wB(i) && console.warn("Overlapping triangles detected.");
		const r = [],
			s = [];
		for (let u = 0; u < i.length; u++) {
			const h = i[u];
			for (let d = 0; d < 3; d++) {
				const f = h[d];
				r.push(f[0], f[1], f[2]), s.push(u * 3 + d);
			}
		}
		const a = new bt();
		a.setAttribute("position", new Tt(r, 3)), a.setIndex(s), a.computeVertexNormals();
		const o = new nr({ color: t, side: An, wireframe: !1 }),
			l = new Re(a, o),
			c = TB(n.map((u) => new D(u.x, u.y, u.z)));
		return (l.userData = { name: "tempPointCloudName", isTXTMesh: !0, vertices: n.length, triangles: i.length, meshCenter: c, originalMaterial: o }), console.log("pointCloudMesh", l.userData), l;
	}
	let vs = [];
	const AB = (n) => {
		Lb.parse(n, {
			header: !1,
			skipEmptyLines: !0,
			dynamicTyping: !1,
			complete: function (e) {
				const t = e.meta.fields,
					i = e.data,
					r = JSON.parse(localStorage.getItem("pointCloudOrder") || "{}"),
					s = parseInt(r.headerRows) || 0;
				let a;
				s === 0
					? (a = [Object.keys(i[0]).join(","), ...i.map((o) => Object.values(o).join(","))].join(`
`))
					: (a = i.slice(s).map((o) => Object.values(o).join(",")).join(`
`)),
					uB(t, a, i);
			}
		});
	};
	let ji = new D(0, 0, 0);
	const CB = (n, e, t, i) => {
			vs = [];
			try {
				ch.cloudPointFileCount++;
				const r = "point-cloud" + ch.cloudPointFileCount,
					s = cB(n, e, r);
				vs.push(...s), console.log("cloudPoints: ", vs);
				let a, o, l;
				le.worldXCenter === 0 && le.worldYCenter === 0 ? ((ji = U0(vs)), (a = ji.x), (o = ji.y), (l = ji.z), (le.worldXCenter = a), (le.worldYCenter = o), Cs()) : ((a = le.worldXCenter || 0), (o = le.worldYCenter || 0), (l = 0));
				const c = Date.now(),
					u = new bt(),
					h = [],
					d = [],
					f = Ob(t),
					v = 1;
				console.log("default colour: ", f.r, ":", f.g, ":", f.b);
				let _ = (p) => (p > 1 ? p / 255 : p);
				for (const p of vs) {
					const g = { pointID: p.pointID, pointX: parseFloat(p.pointX - a), pointY: parseFloat(p.pointY - o), pointZ: parseFloat(p.pointZ - l), pointR: isNaN(_(parseFloat(p.pointR))) ? f.r : _(parseFloat(p.pointR)), pointG: isNaN(_(parseFloat(p.pointG))) ? f.g : _(parseFloat(p.pointG)), pointB: isNaN(_(parseFloat(p.pointB))) ? f.b : _(parseFloat(p.pointB)), pointA: isNaN(parseFloat(p.pointA), 1) };
					h.push(g.pointX, g.pointY, g.pointZ), g.pointR !== null && g.pointG !== null && g.pointB !== null ? d.push(g.pointR, g.pointG, g.pointB) : d.push(1, 1, 1);
				}
				if ((console.log("vertices count: ", h.length / 3), console.log("vertices: ", h), document.getElementById("createMesh").checked)) {
					const p = [];
					for (let x = 0; x < h.length; x += 3) p.push({ x: h[x], y: h[x + 1], z: h[x + 2] });
					i = i || 15;
					const g = MB(p, i, t);
					(g.userData = { name: r, points: vs, isTXTMesh: !0, creationTime: c }), Bt.add(g);
				} else {
					const p = new bt();
					p.setAttribute("position", new Tt(h, 3)), p.setAttribute("color", new Tt(d, 3));
					const g = new vo({ size: 2, vertexColors: !0 }),
						x = new bs(p, g);
					(x.name = r), (x.userData = { name: r, points: vs, isTXTMesh: !1, creationTime: c }), Bt.add(x);
				}
				ft.position.set(0, 0, parseFloat(le.cameraDistance)), (ji = U0(vs)), cn.position.set(ji.x - le.worldXCenter, ji.y - le.worldYCenter, ji.z), Ct.target.set(ji.x - le.worldXCenter, ji.y - le.worldYCenter, ji.z), ft.lookAt(cn.position), ft.updateProjectionMatrix(), Ct.update(), es(Bt, ft);
			} catch (r) {
				console.error("Error in handleFileSubmit: ", r);
			}
		},
		LB = () => {
			document.getElementById("import-pointcloud").addEventListener("click", function () {
				console.clear(), console.log("Import button clicked");
				const n = document.createElement("input");
				(n.type = "file"),
					(n.accept = ".csv , .xyz, .txt"),
					(n.style.display = "none"),
					(n.onchange = (e) => {
						if ((console.log("File selected"), e.target.files && e.target.files[0])) {
							const t = e.target.files[0],
								i = new FileReader();
							(i.onload = (r) => {
								const s = r.target.result;
								AB(s);
							}),
								i.readAsText(t);
						}
					}),
					document.body.appendChild(n),
					n.click(),
					document.body.removeChild(n),
					le.debugComments && (console.clear(), console.log("Load File button clicked"));
			});
		};
	function RB() {
		const n = `<!-- Modal -->
    <div class="modal fade" id="clearLocalStorageModal" tabindex="-1" aria-labelledby="clearLocalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="custom-modal-header">
            <h5 class="modal-title" id="clearLocalLabel">Clear Local Storage</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            Clear the Kirra3D local storage in the browser? Doing this will clear all settings and data. 
          </div>
          <div class="modal-footer">
            <button type="button" id="cancel" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" id="clear" class="btn btn-danger">Clear Memory</button>
            <button type="button" id="clearDB" class="btn btn-danger">Clear Database</button>
          </div>
        </div>
      </div>
    </div>`,
			e = document.createElement("style");
		(e.innerHTML = `
    .custom-modal-header {
        background-color: #cccccc;
        font-size: 10px;
        height: 3em;
    }
    .modal-body label {
        font-size: 12px; /* Adjust the font size of the labels */
        height: 1.5em; /* Adjust the height of the labels */
    }
    .modal-body .form-control {
        font-size: 12px; /* Adjust the font size of the input fields */
        height: 2em; /* Adjust the height of the input fields */
        padding: .25rem .5rem; /* Adjust the padding of the input fields */
    }
    .text-danger {
        font-size: 12px; /* Adjust the font size of the text-danger span */
        height: 2em; /* Adjust the height of the labels */
        align-items: center;
    }	
    .text-warning {
        font-size: 12px; /* Adjust the font size of the text-warning span */
        height: 2em; /* Adjust the height of the labels */
        align-items: center;
    }
`),
			document.head.appendChild(e);
		const t = document.createElement("div");
		(t.innerHTML = n), document.body.appendChild(t);
		const i = new Sr(document.getElementById("clearLocalStorageModal"));
		i.show(),
			document.getElementById("clear").addEventListener("click", function () {
				localStorage.clear(), (le.worldXCenter = 0), (le.worldYCenter = 0), (le.worldZCenter = 0), localStorage.setItem("WorldOriginSettings", JSON.stringify(le)), alert("Local storage has been cleared."), i.hide();
			});
		const r = { pointCloud: "CSV_PointCloudStore", k3dBlast: "K3D_BlastStore", csvBlast: "CSV_BlastStore", objMesh: "OBJ_MeshStore" };
		document.getElementById("clearDB").addEventListener("click", async function () {
			try {
				for (const s in r) await CA("Kirra3D_Database", r[s]);
				alert("Database has been cleared.");
			} catch (s) {
				console.error("Failed to clear database:", s);
			} finally {
				i.hide();
			}
		});
	}
	const PB = () => {
		document.getElementById("clear-local-storage").addEventListener("click", function () {
			RB();
		});
	};
	function DB(n, e, t, i) {
		document.querySelector("#reset").addEventListener("click", function () {
			console.log("Camera Type Before Reset: ", n.isPerspectiveCamera ? "Perspective" : "Orthographic");
			const r = Ab(t).getCenter(new D());
			console.log("Box Centre: ", r.x, r.y, r.z), n.up.set(0, 1, 0);
			const s = parseFloat(i.cameraDistance) * 0.5,
				a = new D(r.x, r.y, r.z + s);
			e instanceof rk && (console.log("Trackball Controls"), n.position.set(a.x, a.y, a.z), n.lookAt(r.x, r.y, r.z), e.target.set(r.x, r.y, r.z), console.log("Target set to: ", r.x, r.y, r.z)),
				e instanceof nm && (console.log("Arcball Controls"), n.position.set(a.x, a.y, a.z), n.lookAt(r.x, r.y, r.z), e.target.set(r.x, r.y, r.z), console.log("Target set to: ", r.x, r.y, r.z)),
				n.updateProjectionMatrix(),
				i.debugComments && console.log("View Reset"),
				(document.querySelector("#info-label").textContent = "View Reset");
		});
	}
	function OB(n, e) {
		document.querySelector("#obj-display").addEventListener("click", () => {
			(e.wireframeSolidTransparentTexture = e.wireframeSolidTransparentTexture === "Texture" ? "Solid" : e.wireframeSolidTransparentTexture === "Solid" ? "Transparent" : e.wireframeSolidTransparentTexture === "Transparent" ? "Wireframe" : e.wireframeSolidTransparentTexture === "Wireframe" ? "Invisible" : "Texture"),
				n.traverse(function (t) {
					(t.userData.isOBJMesh || t.userData.isTXTMesh) &&
						(e.wireframeSolidTransparentTexture === "Texture"
							? ((document.querySelector("#info-label").textContent = "Texture On"),
							  (document.querySelector("#obj-display").innerHTML = '<img src="./assets/tabler-icons-2.36.0/png/cube-material.png" alt="Texture Display" />'),
							  (t.material = t.userData.originalMaterial || t.material),
							  n.traverse(function (i) {
									i instanceof eh && (i.intensity = 0.6);
							  }))
							: e.wireframeSolidTransparentTexture === "Solid"
							? ((document.querySelector("#info-label").textContent = "Solid On"),
							  (document.querySelector("#obj-display").innerHTML = '<img src="./assets/tabler-icons-2.36.0/png/hexagon-filled.png" alt="Solid Display" />'),
							  (t.material = new nr({ color: t.material.color, flatShading: !1, side: An })),
							  n.traverse(function (i) {
									i instanceof eh && (i.intensity = 0.6);
							  }))
							: e.wireframeSolidTransparentTexture === "Transparent"
							? ((document.querySelector("#info-label").textContent = "Transparent On"), (document.querySelector("#obj-display").innerHTML = '<img src="./assets/tabler-icons-2.36.0/png/cube-transparent.png" alt="Transparent Display" />'), (t.material = new nr({ color: t.material.color, flatShading: !0, side: An, transparent: !0, opacity: 0.5 })))
							: e.wireframeSolidTransparentTexture === "Wireframe"
							? ((document.querySelector("#info-label").textContent = "Wireframe On"), (document.querySelector("#obj-display").innerHTML = '<img src="./assets/tabler-icons-2.36.0/png/cube-wireframe.png" alt="Wireframe Display" />'), (t.material = new Kt({ color: t.material.color, wireframe: !0 })))
							: e.wireframeSolidTransparentTexture === "Invisible" && ((document.querySelector("#info-label").textContent = "Invisible On"), (document.querySelector("#obj-display").innerHTML = '<img src="./assets/tabler-icons-2.36.0/png/hexagon-letter-x.png" alt="Invisible Display" />'), (t.material = new Kt({ color: t.material.color, visible: !1 }))),
						(t.material.needsUpdate = !0));
				});
		});
	}
	function IB(n, e, t, i) {
		document.querySelector("#camera-mode").addEventListener("click", () => {
			(i.usePerspectiveCam = !i.usePerspectiveCam), console.log("Switching Camera Mode to: ", i.usePerspectiveCam ? "Perspective" : "Orthographic");
			let r = Ab(n).getCenter(new D());
			vI(r.x, r.y, r.z),
				e.position.set(r.x, r.y, r.z + parseFloat(i.cameraDistance) * 0.5),
				e.lookAt(r.x, r.y, r.z),
				t.target.set(r.x, r.y, r.z),
				e.updateProjectionMatrix(),
				(document.querySelector("#camera-mode").innerHTML = i.usePerspectiveCam ? '<img src="./assets/tabler-icons-2.36.0/png/cube-perspective.png" alt="Perspective Mode" />' : '<img src="./assets/tabler-icons-2.36.0/png/cube.png" alt="Orthographic Mode" />'),
				console.log("Camera Type After Change: ", e.isPerspectiveCamera ? "Perspective" : "Orthographic"),
				console.log("Camera Position After Change: ", e.position.x, e.position.y, e.position.z),
				console.log("boxCentre after change: ", r.x, r.y, r.z);
		});
	}
	function FB(n, e, t) {
		document.querySelector("#hole-name-on-off").addEventListener("click", () => {
			(n.holeNameDisplay = !n.holeNameDisplay), gm(), n.holeNameDisplay ? (document.querySelector("#info-label").textContent = "Hole Name Display On") : (document.querySelector("#info-label").textContent = "Hole Name Display Off"), es(t, e);
		});
	}
	function NB(n) {
		document.querySelector("#hole-length-on-off").addEventListener("click", () => {
			(n.holeLengthDisplay = !n.holeLengthDisplay), gm(), n.holeLengthDisplay ? (document.querySelector("#info-label").textContent = "Hole Length Display On") : (document.querySelector("#info-label").textContent = "Hole Length Display Off"), es(scene, camera);
		});
	}
	function UB(n) {
		document.querySelector("#hole-diameter-on-off").addEventListener("click", () => {
			(n.holeDiameterDisplay = !n.holeDiameterDisplay), gm(), n.holeDiameterDisplay ? (document.querySelector("#info-label").textContent = "Hole Diameter Display On") : (document.querySelector("#info-label").textContent = "Hole Diameter Display Off"), es(scene, camera);
		});
	}
	window.bootstrap = TA;
	Tk();
	const Ib = _I(ys),
		{ scene: bn, camera: Ko, renderer: lh } = Ib;
	ik();
	es(bn, Ko);
	const ch = { cloudPointFileCount: 0, csvFileCount: 0, k3DFileCount: 0, objFileCount: 0 };
	Mk();
	Dk();
	Ok(Ib);
	lB();
	LB();
	sk();
	PB();
	DB(Ko, Ct, bn, le);
	OB(bn, le);
	IB(bn, Ko, Ct, le);
	FB(le, Ko, bn);
	NB(le);
	UB(le);
	document.addEventListener("DOMContentLoaded", async () => {
		try {
			const n = await Zl();
			console.log("Kirra3D database initialized");
		} catch (n) {
			console.error("Error initializing Kirra3D IndexedDB:", n);
		}
	});
	function Fb() {
		const n = [];
		for (let e = 0; e < localStorage.length; e++)
			if (localStorage.key(e).includes("k3DBlastStore") || localStorage.key(e).includes("csvBlastStore")) {
				const t = JSON.parse(localStorage.getItem(localStorage.key(e)));
				n.push(...t);
			}
		return n;
	}
	function kB() {
		const n = Fb();
		document.querySelector("#info-label").textContent = "Holes in Scene: " + n.length + " - Current Test Display: " + le.holeDisplay;
		const e = ["mesh-cross", "mesh-circle", "mesh-diamond", "mesh-square", "mesh-cylinder", "mesh-cube", "line-cross", "outline-circle", "filled-circle", "line-diamond", "line-square", "line-triangle"],
			t = le.holeDisplay,
			r = (1 + e.indexOf(t)) % e.length;
		le.holeDisplay = e[r];
		const s = [];
		bn.traverse(function (c) {
			c.userData.entityType === "hole" && c.userData.entityType !== "dummy" && s.push(c);
		});
		for (const c of s) bn.remove(c);
		let a, o, l;
		le.worldXCenter === 0 && le.worldYCenter === 0 && le.worldZCenter === 0 ? ((a = 0), (o = 0), (l = 0)) : ((a = le.worldXCenter || 0), (o = le.worldYCenter || 0), (l = 0)),
			n.length > 0
				? n.forEach((c) => {
						const u = {
							pointID: c.pointID,
							startXLocation: c.startXLocation - a,
							startYLocation: c.startYLocation - o,
							startZLocation: c.startZLocation - l,
							endXLocation: isNaN(c.endXLocation) ? null : c.endXLocation - a,
							endYLocation: isNaN(c.endYLocation) ? null : c.endYLocation - o,
							endZLocation: isNaN(c.endZLocation) ? null : c.endZLocation - l,
							diameter: c.diameter,
							subdrill: c.subdrill,
							shapeType: c.endXLocation != null || c.endYLocation != null || c.endZLocation != null ? le.holeDisplay : "mesh-dummy",
							holeColour: c.holeColour
						};
						u.diameter > 0 ? (Pi(bn, u.holeColour, u, u.diameter, u.subdrill, le.holeDisplay), console.log("diameter is greater then 0")) : isNaN(u.diameter) ? ((shapeType = "mesh-cube"), Pi(bn, u.holeColour, u, u.diameter, u.subdrill, shapeType), console.log("diameter is not a number")) : (endXLocation != null || endYLocation != null || endZLocation != null) && (Tb(bn, "cyan", u), console.log("of type dummy")),
							(document.querySelector("#info-label").textContent = "Current Hole Display: " + le.holeDisplay);
				  })
				: console.log("Not enough points to draw holes - no end points"),
			lh ? (console.log("Rendering scene with updated hole display"), lh.render(bn, Ko)) : console.error("Renderer is not initialized.");
	}
	function gm() {
		const n = Fb();
		(document.querySelector("#info-label").textContent = "Holes in Scene: " + n.length),
			console.clear(),
			console.log(
				`Objects in scene BEFORE updateScene():
`,
				bn.children
			);
		const e = [],
			t = [],
			i = [],
			r = [];
		bn.traverse(function (l) {
			l.userData.entityType === "hole" && e.push(l), l.userData.entityType === "holeNameText" && t.push(l), l.userData.entityType === "holeLengthText" && i.push(l), l.userData.entityType === "holeDiameterText" && r.push(l);
		});
		for (const l of e) bn.remove(l);
		for (const l of t) bn.remove(l);
		for (const l of i) bn.remove(l);
		for (const l of r) bn.remove(l);
		let s, a, o;
		le.worldXCenter === 0 && le.worldYCenter === 0 && le.worldZCenter === 0 ? ((s = 0), (a = 0), (o = 0)) : ((s = le.worldXCenter || 0), (a = le.worldYCenter || 0), (o = 0)),
			n.length > 0
				? n.forEach((l) => {
						const c = { pointID: l.pointID, startXLocation: l.startXLocation - s, startYLocation: l.startYLocation - a, startZLocation: l.startZLocation - o, endXLocation: isNaN(l.endXLocation) ? null : l.endXLocation - s, endYLocation: isNaN(l.endYLocation) ? null : l.endYLocation - a, endZLocation: isNaN(l.endZLocation) ? null : l.endZLocation - o, diameter: l.diameter, subdrill: l.subdrill, shapeType: l.shapeType, holeColour: l.holeColour };
						console.log("Inside updateScene drawing holes"), l.endXLocation !== null && l.endYLocation !== null && l.endZLocation !== null && l.diameter !== null && Pi(bn, c.holeColour, c, c.diameter, c.subdrill, c.shapeType);
				  })
				: console.log("Not enough points to draw holes - no end points"),
			lh ? (console.log("Rendering scene with updated parameters"), lh.render(bn, Ko)) : console.error("Renderer is not initialized."),
			console.log(
				`Objects in scene AFTER updateScene():
`,
				bn.children
			);
	}
	document.querySelector("#swap-all-hole-visuals").addEventListener("click", kB);
});
export default BB();
